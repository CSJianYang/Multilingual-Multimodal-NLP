[
    {
        "title": "Jump Game",
        "question_content": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 20917,
                "title": "linear-and-simple-solution-in-c",
                "content": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "solutionTags": [],
                "code": "I just iterate and update the maximal index that I can reach\\n\\n    bool canJump(int A[], int n) {\\n        int i = 0;\\n        for (int reach = 0; i < n && i <= reach; ++i)\\n            reach = max(i + A[i], reach);\\n        return i == n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20900,
                "title": "simplest-o-n-solution-with-constant-space",
                "content": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "solutionTags": [],
                "code": "Idea is to work backwards from the last index. Keep track of the smallest index that can \"jump\" to the last index. Check whether the current index can jump to this smallest index.\\n\\n    bool canJump(int A[], int n) {\\n        int last=n-1,i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(i+A[i]>=last)last=i;\\n        }\\n        return last<=0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20907,
                "title": "1-6-lines-o-n-time-o-1-space",
                "content": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1**\\n\\nGoing forwards. `m` tells the maximum index we can reach so far.\\n\\n    def canJump(self, nums):\\n        m = 0\\n        for i, n in enumerate(nums):\\n            if i > m:\\n                return False\\n            m = max(m, i+n)\\n        return True\\n\\n**Solution 2**\\n\\nOne-liner version:\\n\\n    def canJump(self, nums):\\n        return reduce(lambda m, (i, n): max(m, i+n) * (i <= m), enumerate(nums, 1), 1) > 0\\n\\n**Solution 3**\\n\\nGoing backwards, most people seem to do that, here's my version.\\n\\n    def canJump(self, nums):\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]:\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n\\n**Solution 4**\\n\\nC version.\\n\\n    bool canJump(int* nums, int n) {\\n        int goal=n-1, i;\\n        for (i=n; i--;)\\n            if (i+nums[i] >= goal)\\n                goal=i;\\n        return !goal;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 596454,
                "title": "python-simple-solution-with-thinking-process-runtime-o-n",
                "content": "When I first see this problem, two things pop up in my mind:\\n* Maybe I can do some sort of DFS, BFS (with backtracking?) but there will be a lot of redundancies\\n* Then this begs for Dynamic Programming!\\n\\nBut my gut feeling was saying that this problem has to have a simpler approach.\\n\\nSo, here is my thinking process:\\n* Base case: last index can trivially reach to last index.\\n* **Q1**: How can I reach to the last index (I will call it `last_position`) from a preceding index?\\n\\t* If I have a preceding index `idx` in `nums` which has jump count `jump` which satisfies `idx+jump >= last_position`, I know that this `idx` is good enough to be treated as the last index because all I need to do now is to get to that `idx`. I am going to treat this new `idx` as a new `last_position`.\\n* I ask **Q1** again.\\n\\nSo now, here are two important things:\\n* If we have indices which are like **sinkholes**, those with 0 as jump and every other preceding index can only jump to that sinkhole, our `last_position` will not be updated anymore because `idx+jump >= last_position` will not be satisfied at that sinkhole and every other preceding index cannot satisfy the `idx+jump >= last_position` condition since their jumps are not big enough.\\nE.g. ```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\\n* If we have **barriers**, those indices with 0 as jump, but the preceding indices contain jumps which can go beyond those barriers, `idx+jump >= last_position` will be satisfied and `last_position` will be updated.\\nE.g. ```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\\n\\nFinally ask this question when we have finished looping\\n* Is the last position index of 0? (i.e, have we reached to the beginning while doing the process of jumping and updating the `last_position`?)\\n* If we have sinkholes in `nums`, our `last_position` will not be 0. Thus, `False` will be retured.\\n\\nThat\\'s all!\\n\\nThis is what I have in mind when I was thinking of this approach :D\\n![image](https://assets.leetcode.com/users/arkaung/image_1587809403.png)\\n\\n## Python\\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```\\n\\nBut in the interview, this approach may not be apparent or maybe the interviewer is looking for something. \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums=[3,2,1,0,4] # Here 0 is a sinkhole becuase all preceding indices can only jump to the sinkhole```\n```nums=[3,2,2,0,4] # Here 0 is just a barrier since the index before that 0 can jump *over* that barrier```\n``` python\\n1. class Solution:\\n2.    def canJump(self, nums: List[int]) -> bool:\\n3.        last_position = len(nums)-1\\n4.        \\n5.        for i in range(len(nums)-2,-1,-1): # Iterate backwards from second to last item until the first item\\n6.            if (i + nums[i]) >= last_position: # If this index has jump count which can reach to or beyond the last position\\n7.                last_position = i # Since we just need to reach to this new index\\n8.        return last_position == 0\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20932,
                "title": "6-line-java-solution-in-o-n",
                "content": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n    public boolean canJump(int[] nums) {\\n        int reachable = 0;\\n        for (int i=0; i<nums.length; ++i) {\\n            if (i > reachable) return false;\\n            reachable = Math.max(reachable, i + nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 520481,
                "title": "c-easy-o-n-solution-with-detailed-explanation",
                "content": "The idea is to iterate backwards, i.e., right to left, and keep track of the minimum jump length required, i.e., `minjump`, at a position. \\n\\nFor the last index, the minimum jump length required would be zero because you have reached the last index. For each index or position that we go backwards(since we are iterating right to left), the minimum jump length required increases by 1. \\n\\nWe start from the second last index and increase `minjump` by 1 for each position. If at a particular index, the maximum jump length at that position is greater than or equal to the minimum jump length required, i.e., `nums[i]>=minjump`, then we can say that we can reach the last index from that position. Thus, we reduce the minimum jump length required to zero if the condition is satisfied so that for the next position when iterating backwards the minimum jump length required is 1 after incrementation. \\n\\nOur objective now is to check if the minimum jump length required, i.e., value of `minjump`, after iterating through the entire array is zero which would indicate that the last index can be reached from the first index of the array. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```\\n\\n#### Complexity Analysis\\n\\n* Time complexity : O(n).   \\nWe are iterating through the *nums* array only once. The length of *nums* array is *n*. Thus, time complexity = *O(n)*.\\n\\n* Space complexity : O(1). \\nWe are not using any extra memory. Thus, space complexity = *O(1).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i, minjump = 0;\\n        for(i = nums.size()-2; i >= 0; i--){\\n            minjump++;\\n            if(nums[i] >= minjump)\\n\\t\\t\\t    minjump = 0;\\n        }\\n        if(minjump == 0) \\n\\t\\t    return true;\\n        else \\n\\t\\t    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375320,
                "title": "interview-scenario-recursion-memoization-dp-greedy",
                "content": "Suppose you get this question during an interview, let\\'s do a walk-through.\\nInterviewer : Quotes the question...\\n\\n***let\\'s get started***\\nAsk clarifying questions,  examples, and scenarios. The more you ask, interviewer gets more and more intrigued, for good.\\n\\numm, at every index starting from the 0th, you can make jumps ranging from 1 till nums[index]. Greedily making a choice of jump won\\'t work in subtle cases, for example, if from 0th index I take a jump to the index with maximum jump value, it might lead me to a postion with value of jumps equal to 0, and I\\'ll be stuck.\\nAs I\\'ve got a lot of options to make a jump, I\\'d love to the explore the recurring idea behind this question(i.e. I can make a jump ranging from index(idx) to postions ranging from : (idx + 1 *till* idx + nums[idx]), and the same thing can be done from all these indexes. \\nIf by following any route I reach last index, I\\'ll return true. Otherwise if none of the index can lead me to last index, I\\'ll return a false. \\n\\nWhile solving the problem, think out loud and let the interviewer know what you are thinking.\\nrecursion approach : \\ntc : O(N^N) ~ exponential\\nsc : O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\\n\\nThere\\'s no chance that this question will not give a T.L.E,  it\\'s exponential,  it\\'ll have many overlapping subproblems, and hence I can memoize it using a 1d dp array.\\n\\nmemoized : \\ntc : O(N* N) -> for each  index, I can have at max N jumps, hence O(N* N).\\nsc : O(N) + O(N) -> stack space plus dp array size.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\\n\\n*I\\'m not a huge fan of that extra stack space, let me just convert this whole soution into a dp(tabulation)  solution, so that extra O(N) space can be chucked  out.*\\n\\ntc : O(N* N)\\nsc : O(N) -> dp array size\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\\n\\n\\n**Bonus**, I can also think of a solution that kinda resembles Kadane\\'s algorithm. For every index, I\\'m checking the max reach  I can have till that element, if that reach is less than the value of my index, that means I can never reach this particular index and my  answer should be false. \\n\\ntc : O(N)\\nsc : O(1)\\n\\nThe comments that I\\'ve made show my entire thought process that I\\'d be delivering to the interviewer.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```\\n\\n\\nThank you, if you enjoyed this approach of writing soutions do give me an upvote, and please feel free to add suggestions. Viva - La - Vida.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        return create(nums, 0); \\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx) {\\n        if(idx == nums.size() -1) return true;  //if I reach the last index, I should return true;\\n        if(nums[idx] == 0) return false; //if at any  point I reach an index with jump value = 0\\n\\t\\t//,I\\'ll get stuck and hence will return a false.\\n        \\n        int reach = idx + nums[idx]; //the max jump that I can make\\n\\t\\t//I can make jumps ranging from idx + 1, till reach, and hence will run a loop\\n\\t\\t//to cover all those possbile jumps\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n\\t\\t//if true, it means taking this jump led me to the last index.\\n            if(jump < nums.size() && create(nums, jump)) \\n                return  true; \\n        }\\n\\t\\t\\t\\n\\t\\t//if I reach  here,  it means none of the jumps led  me to the  last index \\n\\t\\t//and hence returning, false.\\n        return  false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return create(nums, 0, dp);\\n    }\\nprivate:\\n    bool create(vector<int>& nums, int idx, vector<int>& dp) {\\n        if(idx == nums.size() -1) return true;\\n        if(nums[idx] == 0) return false;\\n        \\n        if(dp[idx] != -1) return dp[idx]; //overlapping subproblems\\n        int reach = idx + nums[idx];\\n        for(int jump=idx + 1; jump <= reach; jump++) {\\n            if(jump < nums.size() && create(nums, jump, dp)) \\n                return dp[idx] = true; //memoizing for particular index.\\n        }\\n        \\n        return dp[idx] = false; //memoizing for particular index.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        dp[n-1] = 1; //base case;\\n        \\n        for(int idx = n-2; idx >= 0; idx--) {\\n            if(nums[idx] == 0) {\\n                dp[idx] = false;\\n                continue;   \\n            }\\n            \\n            int flag = 0;\\n            int reach = idx + nums[idx];\\n            for(int jump=idx + 1; jump <= reach; jump++) {\\n                if(jump < nums.size() && dp[jump]) {\\n                    dp[idx] = true;\\n                    flag = 1;  \\n                    break;\\n                }\\n            }\\n            if(flag == 1) \\n                continue;\\n           \\n            dp[idx] = false;\\n\\t\\t\\t\\n        }\\n        return dp[0]; \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        //it shows at max what index can I reach.\\n        //initially I can only reach index 0, hence reach = 0\\n        int reach = 0; \\n    \\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            //at every index I\\'ll check if my reach was atleast able to \\n            //reach that particular index.\\n            \\n            //reach >= idx -> great, carry on. Otherwise, \\n            if(reach < idx) return false;\\n            \\n            //now as you can reach this index, it\\'s time to update your reach\\n            //as at every index, you\\'re getting a new jump length.\\n            reach = max(reach, idx + nums[idx]);\\n        }\\n        \\n        //this means that you reached till the end of the array, wohooo!! \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20923,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] A) {\\n        int max = 0;\\n        for(int i=0;i<A.length;i++){\\n            if(i>max) {return false;}\\n            max = Math.max(A[i]+i,max);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3758301,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int reachable = 0;\\n       for(int i = 0; i < nums.length; i ++) {\\n           if(i > reachable) return false;\\n           reachable = Math.max(reachable, i + nums[i]);\\n       } \\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150021,
                "title": "c-solutions-greedy-recursive-dp",
                "content": "1. Linear\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\n2. Recursive\\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\\n3. Recursive+Memoization\\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\\n4. DP (Updated)\\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int reachable=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>reachable) return false;\\n            reachable=max(reachable,i+nums[i]);\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n    bool canJump(vector<int>& nums) {\\n              return solve(0,nums); \\n    }\\n    bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n                  if(solve(k,nums)){\\n                return true;\\n            }      \\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n     public:\\n     bool canJump(vector<int>& nums) {\\n          memo.assign(nums.size(),-1);\\n          return solve(0,nums);   \\n     }\\n     bool solve(int i,vector<int> nums){\\n        \\n        if(i==nums.size()-1) return true;\\n        if(memo[i]!=-1) return memo[i];\\n        int reachable=i+nums[i];\\n        \\n        for(int k=i+1;k<=reachable;k++){\\n             if(solve(k,nums)){\\n                return memo[i]=true;\\n             } \\n        }\\n        return memo[i]=false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> memo;\\n    public:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,0);\\n        dp[0]=true;\\n        \\n        for(int i=1;i<n;i++){\\n             for(int j=i-1;j>=0;j--){\\n                 if(dp[j] && j+nums[j]>=i){\\n                     dp[i]=true;\\n                     break;\\n                 }       \\n             }           \\n        }\\n        return dp[n-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21121,
                "title": "c-elegant-solution-o-n-time",
                "content": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    bool canJump(vector<int>& nums) {\\n        int size=nums.size();\\n        int step=nums[0];\\n        for(int i=1;i<size;++i){\\n            step--;\\n            if(step<0)\\n               return false;\\n            if(nums[i]>step)\\n               step=nums[i];\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1443541,
                "title": "python-3-approaches-top-down-dp-bottom-up-dp-max-pos-so-far-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP (Sometime TLE)**\\n- Let `dp(i)` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp(0)` is our result.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top down DP**\\n- Let `dp[i]` denote the possibility if we can reach the `last index` if we are at index `i`.\\n- Then `dp[0]` is our result.\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Max Pos So Far**\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1:\\n                return True\\n            \\n            for j in range(i+1, min(i+nums[i], n-1) + 1):\\n                if dp(j):\\n                    return True\\n            return False\\n        \\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = [False] * n\\n        dp[n-1] = True\\n        for i in range(n-2, -1, -1):\\n            for j in range(i+1, min(n, i+nums[i]+1)):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        maxPos = 0\\n        i = 0\\n        while i <= maxPos:\\n            maxPos = max(maxPos, i + nums[i])\\n            if maxPos >= n - 1: return True\\n            i += 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336291,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\\n\\n# **C Language:**\\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        // Take curr variable to keep the current maximum jump...\\n        int curr = 0;\\n        // Traverse all the elements through loop...\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            // It means there is no way to jump to current index...\\n            // so we should return false...\\n            if (i > curr) {\\n                return false;\\n            }\\n            // Update the current maximum jump...\\n            curr = Math.max(curr, i + nums[i]);     // It\\u2019s possible to reach the end of the array...\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int idx = 0;\\n        //check what is the maximum index we can reach from that index...\\n        for (int maximum = 0; idx < nums.size() && idx <= maximum; ++idx)\\n            maximum = max(idx + nums[idx], maximum);       //if the maximum index reached is the last index of the array...\\n        return idx == nums.size();\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```\n```\\nvar canJump = function(nums) {\\n    // Base condition...\\n    if(nums.length <= 1)\\n        return true;\\n    // To keep the maximum index that can be reached...\\n    let maximum = nums[0];\\n    // Traverse all the elements through loop...\\n    for(let i = 0; i < nums.length; i++){\\n        //if there is no way to jump to next...\\n        // so we should return false...\\n        if(maximum <= i && nums[i] == 0) \\n            return false;\\n        //update the maximum jump...    \\n        if(i + nums[i] > maximum){\\n            maximum = i + nums[i];\\n        }\\n        //maximum is enough to reach the end...\\n        if(maximum >= nums.length-1) \\n            return true;\\n    }\\n    return false;   \\n};\\n```\n```\\nbool canJump(int* nums, int numsSize){\\n    int jump = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (jump < i) {\\n            break;\\n        }\\n        if (jump < i + nums[i]) {\\n            jump = i + nums[i];\\n        }\\n        if (jump >= numsSize - 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        # Take curr variable to keep the current maximum jump...\\n        curr = nums[0]\\n        # Traverse all the elements through loop...\\n        for i in range(1,len(nums)):\\n            # If the current index \\'i\\' is less than current maximum jump \\'curr\\'...\\n            # It means there is no way to jump to current index...\\n            # so we should return false...\\n            if curr == 0:\\n                return False\\n            curr -= 1\\n            # Update the current maximum jump...\\n            curr = max(curr, nums[i])       # It\\u2019s possible to reach the end of the array...\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273641,
                "title": "javascript-simple-o-n-greedy-solution",
                "content": "**Explaination**\\n\\nIt\\'s a typical problem that can be solved by ***Greedy*** algorithm, which is an algorithm **makes the optimal choice at each step** as going forward.\\n\\nYou will need to iterate over the `nums` starting from 0 to the last, and **keep updating** `max` to record how far you can jump so far.\\n` max = Math.max(max, idx + nums[idx]);`\\nAnd check if the `max` is greater or equal to the `target` at each step.\\n\\nThat\\'s pretty much it!\\n\\nBut we still can add a bit of **optimization** by checking an early exit condition when there is no way to move forward. \\nIf a current value is 0, you cannot jump to the next. But there might be a way to jump farther from the previous step. How can we check that? `max` again!\\n`max > idx` then we can conclude we can go further from the previous step. Otherwise, it\\'s impossible.\\n\\nSo the early exit condition is \\n`if (max <= idx && nums[idx] === 0) { return false; }`\\n\\n\\n**Code**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n  let idx = 0;\\n  let max = 0;\\n  let target = nums.length - 1;\\n\\n  while(idx < nums.length) {\\n    max = Math.max(max, idx + nums[idx]);\\n    \\n    if (max >= target) {\\n      return true;\\n    }\\n    \\n    if (max <= idx && nums[idx] === 0) {\\n      return false;\\n    }\\n    \\n    idx++;\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452807,
                "title": "python-dp-o-n-with-explanation",
                "content": "- DP definition: The farthest index we can reach given allowed steps from 0 to `i`\\n- DP decision & relationship: It\\'s either the `dp[i - 1]` or `i + nums[i]` whichever one is larger\\n- DP condition:\\n\\t- If at any moment, dp[i] = 0, that means there is no way it can reach any further, return `False` immediately.\\n\\t- If at any moment, dp[i] >= last index, that means it can already reach the end of the array given the steps allowed from 0 to `i`, return `True` immediately.\\n\\n\\n```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        length = len(nums)\\n        dp = [0] * length\\n        \\n        dp[0] = nums[0]\\n        \\n        for i in range(1, length - 1):\\n            \\n            if dp[i - 1] < i:\\n                return False\\n            \\n            dp[i] = max(i + nums[i], dp[i - 1])\\n            \\n            if dp[i] >= length - 1:\\n                return True\\n        \\n        return dp[length - 2] >= length - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20944,
                "title": "java-98-percentile-solution",
                "content": "The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. \\n\\n    public class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean canJump(int[] nums) {\\n           if(nums.length < 2) return true;\\n           \\n           for(int curr = nums.length-2; curr>=0;curr--){\\n               if(nums[curr] == 0){\\n                   int neededJumps = 1;\\n                   while(neededJumps > nums[curr]){\\n                       neededJumps++;\\n                       curr--;\\n                       if(curr < 0) return false;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 2951773,
                "title": "java-easy-time-o-n-space-o-1",
                "content": "# Code\\n#100% faster.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\\n#Another Approach\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\\n#Alternate Solution but gives TLE.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n     int boundary = 0;\\n     for(int i =0;i<=boundary;i++){\\n         boundary = Math.max(boundary,i+nums[i]);\\n         if(boundary >=nums.length-1)\\n         return true;\\n     } \\n     return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        dp[n-1]=0;\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] == 0) {\\n\\t\\t\\t\\tdp[i] = Integer.MAX_VALUE;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[i] > 0) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int j = 1; j <= nums[i] ;j++) {\\n\\t\\t\\t\\t\\tif (i + j < dp.length) {\\n\\t\\t\\t\\t\\t\\tif (dp[i + j] != Integer.MAX_VALUE)\\n                            min = Math.min(min, dp[i + j]);\\n\\t\\t\\t\\t\\t\\telse \\n                            dp[i]=Integer.MAX_VALUE;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}else{\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min != Integer.MAX_VALUE)dp[i]=min+1;\\n            }\\n        }\\n         return dp[0]!=Integer.MAX_VALUE;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        boolean [] dp = new boolean[len];\\n        dp[len-1] = true;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j = 1; j<=nums[i]; j++){\\n                System.out.println(j+\"||\"+i);\\n                dp[i]=(i+j<len-1)?dp[i+j]: true;\\n                if(dp[i])break;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       return helper(nums,0);\\n    }\\n    public boolean helper(int []nums,int currIndex){\\n        int len = nums.length-1;\\n        if(currIndex>=len)return true;\\n        boolean ans = false;\\n        for(int i = nums[currIndex]; i>=1;i--){\\n            System.out.println(i+\"||\"+currIndex);\\n           ans = helper(nums,currIndex+i);\\n           if(ans)break;\\n        }\\n            System.out.println(\"||\"+currIndex);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21064,
                "title": "5-line-python-solution",
                "content": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def canJump(self, nums):\\n        max_reach, n = 0, len(nums)\\n        for i, x in enumerate(nums):\\n            if max_reach < i: return False\\n            if max_reach >= n - 1: return True\\n            max_reach = max(max_reach, i + x)",
                "codeTag": "Python3"
            },
            {
                "id": 20974,
                "title": "3ms-simple-java-solution",
                "content": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean canJump(int[] nums) {\\n        int maxIndex = nums.length-1;\\n        int maxJump  = nums[0];\\n        for(int i = 0; i <= maxJump; i++){\\n            maxJump=Math.max(maxJump,i+nums[i]);\\n            if(maxJump>=maxIndex) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3592600,
                "title": "most-easy-c-code",
                "content": "# Approach \\n For each element, it checks if the current index i is greater than maxReach. If it is, then it means that it is not possible to reach the current index from any of the previous indices, so the function returns false. Otherwise, it updates maxReach to be the maximum of its current value and i + nums[i], which represents the maximum index that can be reached from the current index.\\n\\nAfter iterating over all elements, if no false value has been returned, then it means that it is possible to reach the last index, so the function returns true.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxReach = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194131,
                "title": "java-simple-and-easy-greedy-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        //last index from where we can reach to end cell\\n        //As from last index (n - 1) itself reach to  end cell,  \\n        int lastIndex = n - 1;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(i + nums[i] >= lastIndex){\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        //check from 0 reach to end cell\\n        return lastIndex == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500445,
                "title": "don-t-make-question-difficult-using-dp-t-c-o-n-s-c-o-1-c-greedy-code-with-explanation",
                "content": "easy to approach:\\n1. if any time your nums value becomes zero then it will not be able to take next step then your expected ans should be wrong .\\n2. you don\\'t have to check for thn exact last index if you cross thn last index thn obiously you can end at last index .\\n\\nIt does\\'t need dynamic programming  always try to approach which is easy to understand.\\n\\n**T.C->O(N)**\\n**S.C.->0(1)**\\n\\n**DO UP VOTE PLESE IF YOU LIKED THE CONCEPT **\\n\\nHAPPY CODING \\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        int n=nums.size()-1;\\n        int reach=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            reach=max(reach,i+nums[i]);\\n            if(reach==i)\\n                return false;\\n            else\\n            {\\n                if(reach>=n)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500227,
                "title": "python-2-lines-greedy-o-n-solution-explained",
                "content": "There are two algorithms: one is dp with complexity O(n^2), where dp(i) is the minimum number of steps to reach position i and on each step we need to check potentially O(n) jumps.\\n\\nHowever there is a solution with better complexity, using greedy idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then we check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\nWe can look at our process like this: what is the biggest index we can reach after say i jumps. Then if we have new index to traverse we update our range. For example for nums = [2, 3, 0, 1, 4] we have t = [2, 4, 4, 4, 8] and after 1 jump we can reach index 2 and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything. In this problem we do not need number of steps, but this idea can be used in problem **0045 Jump game II**.\\n\\n#### Complexity\\nTime and space complexity is O(n).\\n\\n#### Code\\n```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774588,
                "title": "python-easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly. If we reach the maxium reachable index we get out of loop.\\n3. At last, if maxium reachable index is greater than or equal to last index of the array, means we can reach the last element else return false.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reachableIndex = 0\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n            if curr == reachableIndex:\\n                break\\n                \\n        return reachableIndex >= len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591224,
                "title": "recursive-memoizaton-tabulation-o-n-solution-with-constant-space",
                "content": "# Recursive\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\\n\\n# Memoization\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\\n\\n# Tabulation\\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n\\t}\\n\\n\\tbool f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return true;\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums);\\n        \\n        return check;\\n\\t}\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tbool f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind];\\n        bool check = false;\\n        for(int i = ind+1; i <= min(n-1, ind+jump); i++)\\n            check = check || f(i, n, nums, dp);\\n        \\n        return dp[ind] = check;\\n    }\\n```\n```\\n\\tbool canJump(vector<int>& nums) {\\n        int i = 0, n = nums.size();\\n        for(int reach = 0; i < n && i <= reach; i++)\\n            reach = max(reach, nums[i] + i);\\n        return i == n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435741,
                "title": "simple-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I was confused with this question since it is considered to be a DP problem, but I found that the DP solution was not very intuitive. For me it was much simpler and faster to solve this using greedy.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each position of the array, we are given a choice of either taking the steps from that point, or continuing with the steps we took previously. \\n\\nAt the start, we know we have nums[0] steps, and hence our steps left should = nums[0].\\n\\nAs we traverse through the array, we update our steps left to be the maximum of (nums[index], stepsleft - 1), ensuring that we always have the most possible steps left. If we reach the last index, we know that we can reach the end and return true.\\n\\nIf we ever run out of steps, then we know we can\\'t reach the last index and thus stop the loop and return false.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums.length <= 1){\\n            return true;\\n        }\\n        int stepsleft = nums[0];\\n        int index = 1;\\n        while(stepsleft > 0){\\n            if (index == nums.length-1){\\n                return true;\\n            }\\n            stepsleft = Math.max(stepsleft-1, nums[index]);\\n            index++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271858,
                "title": "python-greedy",
                "content": "We can use a pointer ```j``` to indicate the farthest index we can reach. \\nAs any index within ```j``` can be chosen to jump from, we can use a heuristic that for each index ```i``` whose jump length is ```x```, ```j = max(j, i+x)```. If ```i+x > j```, we just jump from ```i``` to increase our jump range from ```j``` to ```i+x```.\\nBut we should ensure that ```i``` is reachable. So if ```j<i```, it\\'s not reachable even with our best effort. We return ```False```.\\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```j```\n```j```\n```i```\n```x```\n```j = max(j, i+x)```\n```i+x > j```\n```i```\n```j```\n```i+x```\n```i```\n```j<i```\n```False```\n```\\ndef canJump(nums):\\n\\tj = 0\\n\\tfor i, x in enumerate(nums):\\n\\t\\tif j < i: return False \\n\\t\\tj = max(j, i+x)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 21193,
                "title": "how-about-my-solution",
                "content": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] A) {\\n       if(A.length==0) return true;\\n       int maxcan=0;// the farthest position it can jump\\n       for(int i=0;i<A.length;i++){\\n           if(maxcan>=A.length-1) return true; //if the farthest postion have passed the end or reached the end\\n           maxcan=Math.max(maxcan,A[i]+i);// update the farthest position\\n           if(maxcan==i) return false; // return false when you cannot move any further..\\n       }\\n       return true;//not necessary, just a return type...\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158292,
                "title": "c-easiest-beginner-friendly-sol-greedy-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a variable reach to 0, which represents the farthest index that can be reached so far.\\n2. Loop through the array nums and for each index i, do the following:\\n    - a. If i is greater than reach or reach is greater than or equal to nums.length - 1, break the loop as it means reaching the last index is not possible.\\n    - b. Update the value of reach as the maximum of reach and i + nums[i].\\n1. Return reach >= nums.length - 1, which means that the last index can be reached or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the array nums. This is because we are looping through the entire nums array once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are using a single integer variable reach.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int reach = 0;\\n        for (int i = 0; i < n; i++) {\\n            // (i > reach) will cover [1,1,0,1,2] or [0,0,0....]\\n            if(i > reach || reach >= n-1)\\n                break;\\n            //this reach will store upto which index we can jump from that ith index\\n            reach = max(reach, i + nums[i]);\\n        }\\n        if (reach >= n-1)\\n            return true;\\n        //this \"return false\" means definitely (i > reach) at any point\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > reach || reach >= nums.length - 1) break;\\n            reach = Math.max(reach, i + nums[i]);\\n        }\\n        return reach >= nums.length - 1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reach = 0\\n        for i in range(len(nums)):\\n            if i > reach or reach >= len(nums) - 1:\\n                break\\n            reach = max(reach, i + nums[i])\\n        return reach >= len(nums) - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755056,
                "title": "o-n-greedy-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int reach = 0;\\n        for(int i=0;i<=reach;i++){\\n            reach= Math.max(reach , i+nums[i]);\\n            if(reach>=nums.length-1){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21146,
                "title": "c-smiple-and-easy-to-understand-o-n-time-4-lines",
                "content": "    class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool canJump(vector<int>& nums) {\\n    \\t\\tint truepos=nums.size()-1;//the lowest starting point that you can reach the end \\n    \\t\\tfor(int i=nums.size()-2;i>=0;i--)\\n    \\t\\t\\ttruepos=(i+nums[i])>=truepos?i:truepos;\\n    \\t\\treturn(truepos==0);\\t\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 21185,
                "title": "another-way-of-looking-at-the-problem",
                "content": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "solutionTags": [],
                "code": "0 is like a **trap**. \\nAnytime you fall-in 0, you can't jump no more (except the last one which you are already at target).\\n\\nSo first, find those traps from start. After we find one, we have to go back to test if this trap is leap-able. This is not efficient.\\n\\nIf we search from back, whenever a trap is found, we can conveniently convert **searching for trap** problem to **searching for leap-able** problem. No need to go back. So one scan, O(n).\\n\\npartial code:\\n\\n    \\tfor(int i = A.length - 2; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tif(A[i] == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\t//start search\\n\\t\\t\\t\\tint zeroIndex = i;\\n\\t\\t\\t\\tfor(i = i - 1; i >=0; i--)  //keep using same i to continue searching!\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(A[i] > zeroIndex - i)   //we can overcome this trap!\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(i == -1) //searched to end and no possible leap\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2060972,
                "title": "c-easy-explanation-dp-tabulation-bottoms-up",
                "content": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```\\nIf you like the above explanation do upvote \\uD83D\\uDC4Dand if there is any scope of improvement or query do comment\\uD83D\\uDE01.\\n\\n**Thank You For Reading!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool canJump(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    vector<bool> dp(n, false);\\n    dp[0] = true;\\n     // Only One Element , so we do not have to jump anywhere\\n    for (int i = 1; i < n; i++)\\n    {\\n        for (int j = i - 1; j >= 0; j--)\\n        // Here we are traversing backward\\n        // We are checking for every position from last that whether we\\n        // can reach that ith index with current position and jump or not\\n        {\\n            if (dp[j] && j + nums[j] >= i)\\n            // Here we are checking dp[j] to make sure that previously if we could reach the\\n            // jth index or not , means that if we were not be able to reach the jth index\\n            // then how can we jump from that index , so there will be no use\\n            // of jumping from that index\\n            {\\n                dp[i] = true;\\n            //Yes!,we can reach the ith position from present jth position\\n                break;\\n            //If we can jump from the present jth position then no need of checking previous\\n            //indexes as by checking dp[j] we have already made sure that we can reach the jth position\\n\\t\\t\\t//easily and from there the ith position\\n            }\\n        }\\n    }\\n    return dp[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912523,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var reach = 0\\n        var i = 0\\n\\n        while i <= reach {\\n            reach = max(reach, i + nums[i])\\n            i += 1\\n            if reach >= nums.count - 1 { return true }\\n        }\\n\\n        return false\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321112,
                "title": "java-solution-1ms-runtime-greedy-approach",
                "content": "**Problem Link :** https://leetcode.com/problems/jump-game/?envType=study-plan&id=algorithm-ii\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm traverse from the end upto 0. Initially we set the last index as our `goal` then if we can reach the goal from  `i`th index , then we set our goal index to `i`th index.\\nEventually if goal reaches to `0` then we know we can reach the last index from starting point (`0`th index).\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```\\n\\nThank You\\n\\nPlease Do Upvote!!!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length-1;\\n       for(int i = goal-1; i >= 0; i--){\\n           if(nums[i]+i >= goal){\\n               goal = i;\\n           }\\n       }\\n       return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285632,
                "title": "golang-o-n-o-1-solution-with-images",
                "content": "The idea of this solution is pretty simple once you understand it. \\n\\nThe idea of this solution is:\\n\\n* We get the maximum index we can go up to by getting the maximum of `i + nums[i]` and `max`.\\n* Then, if `i` has surpassed the maximum index, we can return `false`.\\n* Otherwise return `true`.\\n\\nIf you don\\'t understand why this works, look at the following example:\\n\\ninput: `[3, 2, 1, 0, 4]`\\nexpected output: `false`\\n\\n![image](https://assets.leetcode.com/users/images/2aa23e13-7f07-44ef-bd8f-2b50ed3305b2_1624199132.427165.jpeg)\\n\\n\\n**The Code:**\\n\\n``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc canJump(nums []int) bool {\\n    max := 0\\n    for i := 0; i < len(nums); i++ {\\n        if i > max {\\n            return false\\n        }\\n        if i + nums[i] > max {\\n            max = i + nums[i]\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656772,
                "title": "solution-swift-jump-game-test-cases",
                "content": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b>  Executed 2 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func canJump(_ nums: [Int]) -> Bool {\\n        var indexMax = nums[0]\\n        for (i, v) in nums.enumerated() {\\n            if i > indexMax{ return false }\\n            indexMax = max(indexMax, i + v)\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n    func test0() {\\n        let value = solution.canJump([2,3,1,1,4])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    /// You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\\n    func test1() {\\n        let value = solution.canJump([3,2,1,0,4])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300303,
                "title": "efficient-logic-in-c",
                "content": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We will take steps equal to max of element of array and steps and decrement it by 1 after each iteration. If our steps reaches less than zero, we will then return false.\\nOnce we reach the last index and steps do not become 0, we will have achieved our goal.(return true)\\n\\n    bool canJump(vector<int>& nums) \\n    {\\n        int steps = 0;\\n        int size = nums.size();  //taking size\\n        \\n        for(int i = 0;i < size; i++)\\n        {\\n            if (steps  <  0)\\n                return false;\\n    \\n            steps = max(steps, nums[i]) - 1;  // as we are moving further from the element\\n        }    \\n        return true;\\n    }\\n\\t\\n\\t\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 349913,
                "title": "simple-python-solution",
                "content": "Solution 1: dynamic programing from the end to the start\\nTime complexity: O(n^2) (Time Limit Exceeded, 74 / 75 test cases passed)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\\n\\nSolution 2: time complexity O(n)\\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        dp = n * [False]\\n        dp[n-1] = True\\n        for i in range(n - 2, -1, -1):\\n            for j in range(1, nums[i] + 1):\\n                if i + j < n and dp[i+j]:\\n                    dp[i] = True\\n                    break\\n        return dp[0]\\n```\n```\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        # dp = n * [False]\\n        # dp[n-1] = True\\n        right_most = n - 1\\n        for i in range(n - 2, -1, -1):\\n            if i + nums[i] >= right_most:\\n                # dp[i] = True\\n                right_most = i\\n        return right_most == 0   # or dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133302,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction canJump(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (max < i) return false;  // max steps cannot reach position i\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20963,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion**https://discuss.leetcode.com/topic/80174/python-solution-with-detailed-explanation\\n\\n**Jump Game** https://leetcode.com/problems/jump-game/?tab=Description\\n\\n**Memoization Solution**\\n* Draw the recursion tree. Notice we can have stack overflow for an exremely large input. MLE\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\\n\\n**Dynamic Programming Solution**\\n* Complexity is order n^2. We have an issue here - TLE.\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n**Linear - Ladders and Stairs Solution**\\n* Linear complexity\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\\n\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        return self.can_jump_memoization(0, nums, {})\\n\\n    def can_jump_memoization(self, i, array, cache):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if i >= len(array):\\n            return False\\n        elif i == len(array)-1:\\n            return True\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = False\\n            for j in range(1, array[i]+1):\\n                if self.can_jump_memoization(j+i, array, cache):\\n                    cache[i] = True\\n                    return True\\n            return cache[i]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        dp = [False]*len(nums)\\n        dp[0] = True\\n        for i in range(1,len(nums)):\\n            for j in range(i-1,-1,-1):\\n                if dp[j] == True and nums[j] + j >= i:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach = nums[0]\\n        end_index = len(nums)-1\\n        if max_reach >= end_index:\\n            return True\\n        for i in range(1, len(nums)):\\n            if i > max_reach:\\n                return False\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= end_index:\\n                return True            \\n        return False \\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        max_reach, i, N = 0, 0, len(nums)\\n        while i < N and max_reach >= i:\\n            max_reach = max(max_reach, i+nums[i])\\n            if max_reach >= N-1:\\n                return True\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953864,
                "title": "easy-explanation-which-beats-98-c-users-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust assume we are standing on the last index\\nAim: to somehow reach 0th index as **if we can reach last to zero we can reach zero to last index also**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.just maintain a (last_pos) variable that **keeps a track of your last position** you were able to travell from last index.\\n\\n2.if current position(i) + value of current position(nums[i]) is grater then our last position(last_pos) that means we can reach to our last position(last_pos) from our current(i) position\\n\\n3.And now if ***i + nums[i] >= curr_pos our curr_pos becomes i*** this means we can travell till i from the last index or we can successfully travell to last index from that position(i).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are iterating every element only once time complexity is O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe have just used 2 extra variables n and last_pos that is constant which makes tc = O(1)\\n\\n# hope this brings a smile on your face.......\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last_pos = n-1;\\n        for(int i = n-1 ; i > -1 ; i--)\\n        {\\n            if(nums[i]+i >= last_pos) last_pos = i;\\n        }\\n        if(last_pos==0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887273,
                "title": "beats-98-mind-blowing-intuition-explained",
                "content": "# Intuition\\nChange the destination point backwards. \\n# Approach\\nInitially, first destination point is last index. Change destination point to index of first previous element that can jump to current goal. That way we can, tecnically, consider this new goal as destination point cause once we can reach to it we can automatically get to original goal as well. In the end, if last updated goal happens to be very first element or zero index then it means that we can get to the original last index destination point from zero index.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #original destination is last index\\n        goal = len(nums)-1\\n\\n        #check backwards\\n        for i in range(len(nums)-2,-1,-1):\\n            #if we can jump then update\\n            if i+nums[i] >= goal:\\n                goal = i\\n\\n        #check if we can reach from first index\\n        return True if goal == 0 else False #return goal == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987629,
                "title": "c-solution-very-simple-to-understand-o-n-time-o-1-space",
                "content": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CanJump(int[] nums) {\\n \\n        // The end of the array is true, since that means we are at the solution.\\n        int nearestTrue = nums.Length - 1;\\n        \\n        // Working backwards through the array we want to check if our current num can jump us to the nearest \\'TRUE\\'.\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            // If we can jump to the nearest true, we become the nearest true.\\n            if(i + nums[i] >= nearestTrue)\\n            {\\n                nearestTrue = i;\\n            }\\n        }\\n        \\n        // If the nearest true is the start, the entire solution is jumpable.\\n        return nearestTrue == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493351,
                "title": "java-memoization-solution",
                "content": "I initially wrote the solution using a hashmap as memoization object but was getting TLE. So changed it to dp array.\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return canJump(nums, 0, dp);\\n    }\\n    \\n    public boolean canJump(int[] nums, int index, int[] dp) {\\n        if (index >= nums.length-1) {\\n            return true;\\n        } \\n        \\n        if (nums[index] == 0) {\\n            dp[index] = 0;\\n            return false;\\n        }\\n        \\n        if (dp[index] != -1){\\n            return dp[index] == 1;\\n        } \\n        \\n        int jumps = nums[index];\\n        for (int i = 1; i <= jumps; i++) {\\n            if (canJump(nums, index+i, dp)) {\\n                dp[index] = 1;\\n                return true;\\n            }\\n        }\\n        \\n        dp[index] = 0;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21080,
                "title": "greedy-14ms-o-n-o-1-easy-c-solution-easy-understanding",
                "content": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    bool canJump(int A[], int n) { // Greedy\\n        \\n        n==1?({return true;}):({;});  // Return true if already reach the end\\n        \\n        int max_index_can_jump = 0; // So far the current max index we can jump to.\\n        \\n        for (int i = 0; i <= max_index_can_jump; ++i )\\n        {\\n            if( (A[i]+i) > max_index_can_jump ) // check if need to update the current max index we can jump to\\n            {\\n                if((A[i]+i) >= (n - 1)) // check if we can jump to the last index (end)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    max_index_can_jump = A[i]+i; // Then update\\n                }\\n            }\\n        }\\n        \\n        //return max_index_can_jump == (n-1); // First line is only one of the case\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2225627,
                "title": "python-3-brute-force-dp-greedy",
                "content": "**Brute Force Approach (TLE)**\\n\\\\\\nThe brute-force approach is to visit all possible paths (which can be achieved by using the DFS algorithm). The idea is to create a recursive function that accepts one parameter: `i`. It keeps track of the current index we\\'re in.\\n\\\\\\nWe\\'ll need to handle the following scenarios explicitly:\\n\\u2022 When `nums[i] == 0`\\n\\u2022\\xA0When `i == N - 1`\\n\\\\\\nIf `nums[i] == 0`, this implies we can no longer move forward b/c we have 0 jump - hence we\\'ll return false. If `i == N - 1`, this implies we\\'ve found a path that reaches the final element - hence we\\'ll return true.\\n\\nIt seems like there are `nums[i]` choices we can make per recursive function. We can jump from `i` to `i + 1` ~ `i + nums[i] `inclusive. We can use a for-loop to attempt all the possible jumps. *FYI: Its lowerbound is `i + 1` & its upperbound is `min(i + nums[i], N - 1) + 1`. This allows us to reduce the total # of iterations.*\\n\\\\\\nFor each iteration:\\n1) we\\'ll make a recursive call: `dfs(j)` (where `j` is an index of the for-loop)\\n2) If `dfs(j) == True` , then it implies the current element leads to the final element. Hence, we\\'ll immediately return true.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^N) b/c we must jump at most N times per recursive function. \\nThe space complexity is O(N) b/c we must store a reference of N recursive-calls in a call-stack.\\n\\n---\\n\\\\\\n**Top-down DP (Memoization) (TLE)**\\n\\\\\\nThe above solution seems to be inefficient b/c we\\'re visiting the same sub-paths on multiple occasions. To remedy this issue, we can store a precomputed value of the visited sub-paths into a dictionary or a list. *FYI: I\\'ll be using a dictionary for this example.*\\n\\nThe idea is to add an additional parameter, that stores a reference of the dictionary, in a recursive function. After the existing base cases, we\\'ll add a new conditional statement that checks whether the key: `i` already exists in the dictionary. If that\\'s the case, then it implies we\\'ve already visited the current path. Hence, we\\'ll return its precomputed value as an answer.\\n\\nOtherwise, we\\'ll compute the current path\\'s answer and store it in the dictionary.\\n\\\\\\n*Implementation w/ a dictionary*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\\n\\\\\\n*implementation w/ a list*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\\n\\\\\\n*implementation w/ the lru_cache decorator*\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we still need to jump at most N times per recursive function. However, we won\\'t need to visit the same path again b/c we\\'re storing the precomputed value (of the paths) in a dictionary (or a list). \\n\\nThe space complexity is O(N) b/c we must store N key-value pairs into the dictionary. *FYI: If we\\'re using a list, then we must allocate N additional space to initialize an N-sized list.*\\n\\n---\\n\\n\\\\\\n**Bottom-up DP (Iterative DP) (occasionally passes but TLE for the most part)**\\n\\\\\\nWe can convert the top-down DP into its iterative alternative. First, we\\'ll initialize an N-sized list and we\\'ll set the final element as true. Next, we\\'ll use a nested for-loop to visit all the paths - where the outer-loop iterates N times and an inner-loop iterates at most N times.\\n\\nBefore we execute the inner-loop, we\\'ll check whether `nums[i] == 0`. If that\\'s the case, then it implies we have 0 jump - which prevents us from moving any further. Hence, we\\'ll immediately skip to the next iteration.\\n\\nFor each iteration of the inner-loop, we\\'ll check whether `dp[j]` (where` j` is an index of the inner-loop) equals true. If that\\'s the case, then it implies the path reaches to the last element. Hence, we\\'ll assign true to `dp[i]` and break the inner-loop.\\n\\nAfter we finish executing the nested for-loop, we\\'ll return `dp[0] `as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\\n\\\\\\nThe time complexity is O(N^2) b/c we must execute a nested for-loop where an outer-loop iterates N times. For each iteration of the outer-loop, we must execute an inner-loop that iterates at most N times.\\n\\nThe space complexity is O(N) b/c we must initialize an N-sized list.\\n\\n---\\n\\\\\\n**Greedy Approach**\\n\\\\\\nIf we look closely at the problem, we don\\'t necessarily have to visit all the paths to verify whether a valid path exists. As long as we can jump to the element t*hat ultimately leads to the final element,* then we should be able to verify whether the valid path exists.\\n\\nThe idea is to iterate through `nums` from right to left, and for each iteration, we\\'ll check whether `i + nums[i]` >= index of the element that leads to the final element (I\\'ll call it `valid_idx` for brevity\\'s sake). If that\\'s true, then it implies the current element leads to the final element. Hence, we\\'ll update `valid_idx` to store `i`. \\n\\nAfter we finish iterating through `nums`, we\\'ll check whether `valid_idx == 0`. If that\\'s true, then it implies the first element leads to the final element. Therefore, we\\'ll return true as an answer. Otherwise, we\\'ll return false as an answer.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```\\n\\\\\\nThe time complexity is O(N) b/c we must iterate through `nums` once.\\nThe space complexity is O(1) b/c we\\'re only initializing few variables throughout the implementation.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n            \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if i in memo:\\n                return memo[i]\\n            \\n            is_valid = False    \\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, {})\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n    \\n        def dfs(i, memo):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            if memo[i] != None:\\n                return memo[i]\\n            \\n            is_valid = False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j, memo):\\n                    is_valid = True\\n                    break\\n            \\n            memo[i] = is_valid\\n            return memo[i]\\n        \\n        return dfs(0, [None] * N)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        \\n        @lru_cache(N)\\n        def dfs(i):\\n            if i == N - 1:\\n                return True\\n            \\n            if nums[i] == 0:\\n                return False\\n            \\n            for j in range(i + 1, min(i + nums[i], N - 1) + 1):\\n                if dfs(j):\\n                    return True\\n                    \\n            return False\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        dp = [False] * N\\n        dp[-1] = True\\n        \\n        for i in range(N - 1, -1, -1):\\n            if nums[i] == 0:\\n                continue\\n            \\n            lowerbound = i + 1\\n            upperbound = min(i + nums[i], N - 1) + 1\\n            \\n            for j in range(lowerbound, upperbound):\\n                if dp[j]:\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        N = len(nums)\\n        valid_idx = N - 1\\n        \\n        for i in range(N - 2, -1, -1):\\n            if i + nums[i] >= valid_idx:\\n                valid_idx = i\\n        \\n        return valid_idx == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723975,
                "title": "jump-game-building-to-jump-game-2-c-solutions",
                "content": "(1) Jump Game 1\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n(2) Jump Game 2\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        \\n        int maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(maxreach<i)\\n                return false;\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=1) return 0;\\n        \\n        int jumps=0, currreach=0, maxreach=0;\\n        for(int i=0; i<n; i++){\\n            if(currreach<i){\\n                jumps++;\\n                currreach=maxreach;\\n            }\\n            maxreach=max(maxreach, i + nums[i]);\\n        }\\n        return jumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21010,
                "title": "this-can-be-solved-by-using-car-and-fuel-tank-analogy",
                "content": "Lets rephrase the question, \\nWe want to reach the end of the road(end of the array), the numbers in the Array are fuelTanks one the road.\\nFor tarvelling to the next fuelTank(number) we will lose a fuel unit in your current tank.\\n\\nAns:\\nAt each number(fuel tank), we pick up whichever is highest our current fuelTank in the car OR the fuel tank that is in the road\\n\\n```\\npublic class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }\\n        //there is no need for the fuel at the end- this just messes with my code, so making it zero\\n        fuelRoad[fuelRoad.length-1]=0;\\n        //lets initilize the car with the firstfuel tank in the road\\n        int carPosition=1, fuelTank=fuelRoad[0]-1;\\n        while(carPosition<fuelRoad.length && \\n            //there has to be fuel to travel\\n            fuelTank>=0){\\n            //this is just small optimization,checks whether we will have enough fuel to reach the end\\n            if(carPosition+fuelTank >= fuelRoad.length-1){\\n                return true;\\n            }\\n            //check which is bigger the fuel in the road or our tank\\n            if(fuelRoad[carPosition]>fuelTank){\\n                fuelTank=fuelRoad[carPosition];\\n            }\\n            carPosition++;\\n            fuelTank--;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] fuelRoad) {\\n        if(fuelRoad.length<=1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21156,
                "title": "simple-python-solution-o-n-1-55ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def canJump(self, nums):\\n            stepsLeft = nums[0]\\n    \\n            if not stepsLeft and len(nums) > 1:\\n                return False\\n    \\n            for num in nums[1:-1]:\\n                stepsLeft = max(stepsLeft - 1, num)\\n                if not stepsLeft:\\n                    return False\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3144678,
                "title": "c-easy-to-understand-dynamic-programming-tabulation-method-o-n-runtime",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic Programming using Tabulation Method.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) {Extra space for DP array}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n\\n        // DP Tabulation method\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            //Check if that place is reachabale or not.\\n            if(dp[i-1]>0){\\n                //Counting the steps and updating the values after each iteration\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        //If that step is reachable, return true.\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952469,
                "title": "brute-dp-o-n-greedy-w-images-explained",
                "content": "# Intuition & Approach [BRUTE]\\nFor Brute:\\nSo this part is pretty simple brute force approach. We recursively try to jump at every location we can starting from the first and see if we ever get at the target position which is `length of nums -1` or `len(nums)-1` as seen in python.\\n\\n\\nHere is a brute force code for the same.\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\\nAbove Code Explanation:\\n- Our dfs function is recursive.\\n- It returns `True` if current index, `ind` in code is `greater than or equal to our target_index` because it means we can reach it.\\n- It returns `False` if steps at cur index is 0, which means we cannot go any further.\\n- Lastly, we use dictionary/hashmap named `memo` to cache/memoize the path. Basic `caching/memoization`.\\n\\n# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n# Approach [Greedy]\\n\\nOkay so here we basically traverse reverse and keep shifting our Goal like so:\\n- if we can reach our current Goal from our current position then, we can shift our goal to current position because we no longer need to check if we can get to previous Goal because if we can get to the current position we can get to goal as well hence we can overall shift the goal itself.\\nWish I could say it better. LOL\\n\\n\\n# Code Explanation:\\nSo we start with Goal as `len(nums)-1`.\\n\\nConsider this pic:\\n - Goal marked with Green BOX.\\n - Indeces writeen with blue.\\n![jump1.PNG](https://assets.leetcode.com/users/images/3950dc19-e9c7-477f-849b-56bef24c6fa4_1672037205.3182197.png)\\n- So here we start with goal at INDEX 5.\\n- We Traverse from index 4 to 0.\\n- At Index 4 we see, Oh we can get to goal INDEX 5 from here so we set our new goal to Index 4.\\n![jump2.PNG](https://assets.leetcode.com/users/images/3323373d-d0c5-43b0-8b34-08959c72f096_1672037320.1121492.png)\\n- Again we check at Index 3, Oh we ca get to goal Index 4 from here, so we set our goal to Index 3.\\n![jump3.PNG](https://assets.leetcode.com/users/images/a4b46cd5-7b0f-4593-bb5f-ab9a5597a0bb_1672037373.798035.png)\\nAnd we keep moving on till the end of our traversal.\\nIf we end with Goal at 0, then we know oh yes we can actually reach the end. If not then NO.\\n\\n\\nConsider Example 2 of Example Testcases and we will see that we cannot reach the Goal and so our Goal does end at 0. Hence False.\\n\\nAlso, to check if we can get to a Goal or not we just check if the maximum number of steps from current position will lead us to position greater than or equal to our goal or not.\\nwritten in PYTHON as:\\n`if nums[ind]+ind >= goal:\\n    goal = ind`\\nBasically just shifting our GOAL if max capacity of cu rindex takes us on or farther than our GOAL.\\n\\n\\n# Code Python and JS\\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```\\n\\n# Time complexity:\\nBRUTE:\\n- O(n^2) after memoization O(a^n) before memo if a is avg of all elements in nums\\n\\nGreedy:\\n- O(n)\\n\\n# Space complexity:\\nIDK, O(1) for Greedy cause no extra space used, NOT SURE LOL!!\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(ind, memo):\\n            if ind in memo:\\n                return memo[ind]\\n            if ind >= len(nums)-1:\\n                return True \\n            if nums[ind] == 0:\\n                return False\\n            for steps in range(nums[ind], 0, -1):\\n                goTo = ind + steps\\n                if dfs(goTo, memo):\\n                    memo[ind] = True\\n                    return True\\n            memo[ind] = False\\n            return False\\n        return dfs(0, {})\\n\\n```\n```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        goal = len(nums)-1\\n        for ind in range(len(nums)-1, -1, -1):\\n            if (nums[ind] + ind) >= goal:\\n                goal = ind\\n        if goal == 0:\\n            return True\\n        return False\\n               \\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    var goal = nums.length - 1;\\n    for (var i = (nums.length-1); i>=0; i--)\\n    {\\n        if (nums[i]+i >= goal)\\n            goal = i;\\n    }\\n\\n    if (goal == 0)\\n        return true;\\n    return false;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833942,
                "title": "python-a-walrus-approved-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** One-liner with walrus operator `:=` used to update state.\\n```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\\n\\n**Python #2.** The same logic, but using imperative style.\\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums, m = 0):\\n        return all(i <= m and 1+(m:=max(m,i+n)) for i,n in enumerate(nums))\\n```\n```\\nclass Solution:\\n    def canJump_(self, nums: List[int]) -> bool:\\n        m = 0\\n        for i,n in enumerate(nums):\\n            if i > m : return False\\n            m = max(m,i+n)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045294,
                "title": "every-possible-simple-c-solution-additional-python-and-java-solutions-as-well",
                "content": "### Approach 1 : Brute Force\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K^N) where k is the max value in the array\\nSpace Complexity - O(N) - Recursive Stack Space\\n\\n### Approach 2 : Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N + N) - Recursive Stack Space + Memoization table\\n\\n### Approach 3 : Tabulation\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(K*N) where k is the max value in the array\\nSpace Complexity - O(N) - Dp Table\\n\\n### Approach 4 : Greedy\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N) \\nSpace Complexity - O(1)\\n\\n## **Java And Python Solutions**\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1) return true;\\n     \\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums);\\n        }\\n        return val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1) return true;\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        bool val = false;\\n        for(int i=1; i<=nums[inx]; i++){\\n            val = val || helper(inx + i, nums, dp);\\n        }\\n        return dp[inx] = val;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[nums.size()-1] = 1;\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            bool val = false;\\n            for(int i=1; i<=nums[inx]; i++){\\n               if(inx + i < nums.size()) val = val || dp[inx + i];\\n            }\\n            dp[inx] = val;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size(), canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int canReach = n-1;\\n        for(int curPos = n-1; curPos >= 0; curPos--){\\n            if(curPos + nums[curPos] >= canReach){\\n                canReach = Math.min(curPos, canReach);\\n            }\\n        }\\n        return canReach == 0;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        canReach = n-1\\n        for curPos in range(n-1, -1, -1):\\n            if curPos + nums[curPos] >= canReach:\\n                canReach = min(curPos, canReach)\\n                \\n        return canReach == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732617,
                "title": "very-simple-and-fast-greedy-solution-with-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can found many Recursion with dp and tabulation solutions. But here we will discuss an ***very simple greedy solution that does not require any dynamic programming*** you just need a simple observation.\\n\\n---\\n\\n- Observation\\nfor any index ***i*** in the given array, if i know the nearest index value (*let it be **x***) from where i can reach to my destination then the only thing i need to check now is that\\nCan i reach at index ***x*** from my current position (that is index ***i***)?.\\n->this question can easily answered by checking a condition is ***(i+nums[i]>=x)*** true?\\n{\\nhere ***i+nums[i]*** -> the maximum distance(index value) that you can reach from ***i***th index. \\n}\\n- if the above condition is true -> then we can easily reach to x from our current index i and so on our destination.\\n- if the above condition is false -> then we can\\'t reach on our destination from our current index i.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nn=size of the given vector nums\\nOur destination is ***n-1***th index.\\n- Basic Fact -> we can always reach at ***n-1***th index from ***n-1***th index itself irrespective of value in ***nums[n-1]***\\n\\n- **Steps** :-\\n\\n1) We will maintain a variable (***x***) that stores the value of nearest index from which we can reach at n-1th index and initialize it with ***n-1***.\\n2) We will also maintain a *bool variable* (***ans***) that stores the truth value that can we reach at our destination from the current index? (initialize ans with value 0).\\n2) Now We will start a for loop from ***i=n-1*** to ***i=0*** and for each i we do :\\n    - if we can reach at ***x*** from ***i*** then we assign ***ans=1*** and update value of x as ***x=i***\\n    - else assign ***ans=0***\\n\\n\\n4. Finally return the ans.\\n\\n# Complexity\\n- Time complexity:\\n***O(n)***\\nAs we are Running a for loop from i=n-1 to i=0 So time complexity = O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n***Any Query/Suggestions are welcome***\\n\\n***\\uD83D\\uDC4D Upvote if you like***\\n\\n*for getting this code in other programming language you can comment here i will provide that ASAP.*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* Time coplexity = O(n) || Space complexity = O(1). */\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n-1; //nearest variable from where we can reach (n-1)th index.(Greedy approach)\\n        bool ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+nums[i]>=x) //condition that can we reach to x from i.\\n            {\\n                ans=1;\\n                x=i; // update the value of x as we got a nearer point.\\n            }\\n            else ans=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703697,
                "title": "c-solution-with-full-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- It passes **151 test cases** but ***Gives WRONG ANSWER!***\\n- This was the first approach that came to my mind.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- We took a variable temp to store the max jump possible.\\n- If at any point temp became equal to the current index ***i*** that means we can\\u2019t go to next position from here, simply return false.\\n- Any point if temp crosses the size of the given array, then simply return true.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i]>=n-i-1) return true; \\n            if(nums[i]==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n= nums.size();\\n        if(n==1) return true;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            temp = max(temp, i+nums[i]);\\n            if(temp == i) return false;\\n            if(temp >= n-1) return true;\\n        }\\n        return false;\\n    }\\n    \\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545232,
                "title": "java-easy-to-understand-jump-game",
                "content": "Key for this problem **Think it from last index**, like we want to reach at last we can start from last and if reach at 0 or -ve index that means we find solution\\n\\n\\n```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canJump(int[] nums) {\\n        int last = nums.length - 1; // last index/ position to reach \\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (i+nums[i] >= last) { // check if i+nums[i] >= last means we can reach to that index \\n\\t\\t\\t//with curr value and from current index and if yes then \\n\\t\\t\\t//change last to current index\\n                last = i;\\n            }\\n        }\\n        return last <= 0; // if last <= 0  then that means we can reach to solution if we start from begining also return true else false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500036,
                "title": "being-greedy-is-rewarding-sometimes-easy-to-understand-concise",
                "content": "## Approach 1:\\nThese type of problem can be solved using segmented bfs taking maximum element from a range it can go. Here my approach is to go as far as possible and once our index crosses the farthest then we return False as its not possible to reach the end.\\n\\n### Code\\n``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\\n\\n## Approach 2:\\nSimilar to problem 0045 Jump Game II, but here we need to check if we can reach the end. As in problem 0045 we can create cumulative maximum of i + nums[i] and check if for some element we have i == t[i]: if we have such place, we stuck and we can not reach the last cell, if not, we can reach.\\n\\n### Code:\\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\\nCerdits : [@Dmitry](https://leetcode.com/DBabichev/) \\n\\n## Approach 3:\\nI found it while searching for other answers and found it interesting \\nIdea:\\nConsider nums[i] to be the amount of fuel in the tank sitting at i that we can switch to. As moving from left to right, we lose 1 unit of fuel per step. At each index, we switch to the new tank if it has more fuel than what we have left. If the amount of fuel goes to zero somewhere in the middle, return False.\\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```\\n\\nCredits :- [Link Of Solution](https://leetcode.com/problems/jump-game/discuss/1500014/Python-O(N)-time-O(1)-space.-Switch-to-the-new-tank-whenever-you-can-gain-fuel.) \\n[Profile](https://leetcode.com/hkwu6013)\\n\\n## Complexity Analysis:\\nTime Complexity For Both is O(N)\\nSpace Complexity For approach 1 is O(1) and for Approach 2 is O(N)\\n\\n## Note:\\nIf You have any other answer in a different approach feel free to comment it down , I will add it and like you profile or page to the answer . **Hope you find it help full . If yes please Upvote it if no , feel free to place it down in the comment section.**",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "``` Python\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        farthest = 0\\n\\n        for index, value in enumerate(nums):\\n            if index > farthest:\\n                return False\\n            farthest = max(farthest, index+value)\\n        return True\\n```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        return all(i != t[i] for i in range(len(t) - 1))\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: list[int]) -> bool:\\n        fuel = 0\\n        for i in range(len(nums)-1):\\n            fuel = max(fuel, nums[i])\\n            if fuel == 0:\\n                return False\\n            fuel -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208231,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        int jump=nums[0];\\n        if(jump == 0) return false;\\n        \\n         for(int i=1; i<n; i++) \\n         {\\n             jump--;\\n             if(i==n-1) return true;\\n             jump = max(jump, nums[i]);\\n             if(jump==0) return false;\\n         }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541554,
                "title": "dp-and-greedy",
                "content": "### DP\\n**state(i)** as whether we can jump to i.\\n**state(i) is true if any state(j) is true for j can jump to i.**\\nGoal state is **state(nums.length - 1)**.\\n```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump to the furthest place able to reach.\\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        boolean[] state = new boolean[nums.length];\\n        state[0] = true;\\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (state[j] && (j + nums[j] >= i)) { // from j, we can jump to i\\n                    state[i] = true;\\n                }\\n            }\\n        }\\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canJump(int[] nums) {\\n        if (nums.length <= 1) {\\n            return true;\\n        }\\n        \\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > maxReach[i - 1]) {\\n                return false;\\n            }\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n            if (maxReach[i] >= nums.length - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153033,
                "title": "3-approaches-in-python-explained-clean",
                "content": "1) DP Recursive \\nResult: Ran out of stack space for this case\\n              [1,1,1,1,1,1,1...................................................................,1,1]\\nIdea is that from any given index say \\'idx\\' we can move to a next index in the range(1,nums[idx]+1) so we try all of them for all idx and check whether we can reach the last index. Since we may arrive at the same index  more than once, we memoize.\\n```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\\n2) BFS\\nResult: Time Limist Exceeded (71/75 test cases passed)\\nIt is tempting to see that this just a search problem in an implicit graph. The nodes being indexes and edges connect one node to the next candidate neighboring (or) \"can jump to\" indexes. So we just perform a BFS carefully by not repeating ourselves, there is no need to construct the graph.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\\n 3) Key observation that it is okay to overshoot in jumping process since we can easily choose to jump less. The only way you do not reach the end is when you do not have sufficient jumping capability or \\'jumpingPower\\' and that\\'s exactly what we check for.\\nResult: Accepted, beats 58%\\n ```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import wraps\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        def memo(func):\\n            cache = {}\\n            @wraps(func)\\n            def wrap(*args):\\n                if args not in cache:\\n                    cache[args]=func(*args)\\n                return cache[args]\\n            return wrap\\n        @memo\\n        def solve(idx):\\n            if idx == len(nums)-1: \\n                return True\\n            if idx >= len(nums):\\n                return False\\n            return any([solve(idx+jumpDist) for jumpDist in range(1,nums[idx]+1)])\\n        \\n        return solve(0)\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums: return True\\n        fringe = deque([0])\\n        seen = set()\\n        canReachLast = False\\n        while fringe:\\n            idx = fringe.popleft()\\n            if idx == len(nums)-1: canReachLast = True\\n            seen.add(idx)\\n            for nextJump in range(1,nums[idx]+1):\\n                if idx+nextJump not in seen and idx+nextJump < len(nums):\\n                    fringe.append(idx+nextJump)\\n        return canReachLast\\n```\n```\\n class Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # In general two cases arise when  we cannot reach the last index\\n        # 1) we overshoot as we can jump too far 2) we do not have enough jumping power to get there\\n        # 1) is not a possibility here as we can simply choose to jump less and get there\\n        # so we just have to check for 2)\\n        jumpingPower = 0\\n        for idx in range(len(nums)):\\n            # we reached an index that\\'s beyond the furthest we can reach\\n            # this is 2) we break out\\n            if idx > jumpingPower: break\\n            # update how far we can jump\\n            jumpingPower = max(nums[idx]+idx,jumpingPower)\\n        return jumpingPower >= len(nums)-1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20894,
                "title": "c-simple-greedy-and-optimized",
                "content": "This one was fun.  I went from an O(N^2) algorithm to O(N) and learned how to be \"greedy\" :-)\\n\\nHere the difference from the other posts is that in for loop, the condition is optimized.  If we are going to check two conditions in the for loop, why not make sure those are optimal?  I believe the code is still readable but now the loop condition is optimized.\\n***\\n    /// <summary>\\n    /// Given an array of non-negative integers, you are initially positioned at \\n    /// the first index of the array. Each element in the array represents your \\n    /// maximum jump length at that position. Determine if you are able to reach\\n    /// the last index.\\n    /// </summary>\\n    /// <example>\\n    /// A = [2,3,1,1,4], return true.\\n    /// A = [3,2,1,0,4], return false.\\n    /// </example>\\n    public class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }\\n            }\\n\\n            return maxJump >= lenMinus1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public bool CanJump(int[] nums)\\n        {\\n            int maxJump = 0, lenMinus1 = nums.Length - 1;\\n\\n            for (int i=0; maxJump>=i && maxJump < lenMinus1; i++)\\n            {              \\n                if (i + nums[i] > maxJump)\\n                {\\n                    maxJump = i + nums[i];//if Ai=0, maxJump = i\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 21093,
                "title": "one-pass-solution-java",
                "content": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "     public boolean canJump(int[] nums) {\\n            int max =0;\\n            for(int i=0;i<nums.length; i++){\\n                if(max<i) return false;\\n                max=Math.max(max, i+nums[i]);\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 21096,
                "title": "c-o-n-solution-with-comments",
                "content": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "        \\n    bool canJump(vector<int>& nums) {\\n        unsigned int maxReach = 0;\\n        for (unsigned int i = 0; i < nums.size(); i++) {\\n            if (maxReach < i)  // cannot reach i \\n                return false;\\n            if (maxReach >= nums.size()-1)\\n                return true;  //early return \\n            maxReach = max(maxReach, i+nums[i]);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3573168,
                "title": "python-simple-solution-beats-81-14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI can start from the finish line and problems only appear when there is a zero\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a greedy approach to iterate from the last index `j` towards the first index. It starts with `j` set to the last index of `nums`.\\n\\nIn each iteration, it checks if the element at index `j-1` is greater than 0. If it is, it means we can jump from index `j-1` to index `j`. In this case, it decrements `j` by 1 and continues to the next iteration.\\n\\nIf the element at index `j-1` is 0, it means we cannot jump from index `j-1` to index `j`. In this case, it enters a nested loop starting from index `i` set to `j-1` and iterates towards the first index (`i <= 0`).\\n\\nWithin the nested loop, it checks if the value at index `i` (`nums[i]`) is less than the distance between `j` and `i` (`j-i`). If it is, it means it is not possible to jump from index `i` to index `j` based on the value at index `i`. In this case, it decrements `i` by 1 and continues to check the previous indices.\\n\\nIf the nested loop reaches the first index (`i <= 0`) without finding a suitable index to jump from, it means it is not possible to reach the last index of `nums`. In this case, the code returns `False`.\\n\\nIf the outer loop completes and exits without encountering any issues, it means it is possible to reach the last index of `nums` based on the given jump values. The code then returns `True`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        j=len(nums)-1\\n\\n        while j>0:\\n            if nums[j-1]>0:\\n                j-=1\\n            else:\\n                i=j-1\\n                while nums[i]<j-i:\\n                    if i<=0:\\n                        return False\\n                    i-=1\\n                j=i\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817477,
                "title": "c-5-lines-code-4-approaches-dp-easy-analysis-100",
                "content": "# Approach: Recursion\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n^10e5) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Recursion with DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [TLE]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + space of Call Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\\n\\n# Approach: Iterative DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 18%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n# Approach: Same concept no DP\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n) [Accepted, better than 100%]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        \\n        bool res=false;\\n        for(int i=1; i<=nums[n]; i++){\\n            res= res||fn(nums, n+i);\\n        }\\n        return res;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    bool fn(vector<int> nums, int n){\\n        if(n==nums.size()-1) return true;\\n        if(n>=nums.size()) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1; i<=nums[n] and n+i < nums.size(); i++){\\n            if(fn(nums, n+i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        dp=vector<int>(nums.size()+1,-1);\\n        return fn(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> dp(n+1, false);\\n        dp[n-1] = true;\\n        for(int i = n-2; i >= 0; i--){\\n            for(int j=1; j<=nums[i] and i+j < n; j++){\\n                if(dp[i+j]){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = n-1;\\n        for(int i = n-2; i >= 0; i--){\\n            if(i+nums[i] >= last) last = i;\\n        }\\n        return last == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310838,
                "title": "python3-solution-with-detailed-explanation-o-n-o-1",
                "content": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "***Please upvote if this helps!***\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        # TC = O(n) ; SC = O(1) no extra space needed;\\n        # Greedy solution\\n        \\n        destination = len(nums) - 1\\n        for i in range(destination-1, -1 , -1):\\n            # start from the second last position of nums \\n            if i + nums[i] >= destination:\\n                # if from ith index, we can reach destination\\n                # update our destination to ith index\\n                destination = i\\n        # if destination reaches 0 meaning that we can reach end from first index\\n        # otherwise we can\\'t\\n        return destination == 0\\n        \\n        # Explanation:\\n        # Greedy approach:\\n        # We start at the last index of the array and work our way backwards\\n        # for eg: nums = [2,3,1,1,4]\\n        # so we start from our destination i.e. 4, and work our way towards it \\n        # meaning if we can reach 4 from its neighbour i.e. 1 , then it means \\n        # all we need to make sure is that we can reach 1;\\n        # because if we reach 1 we can obviously reach 4\\n        # similarly if we can reach first occurr of 1 from 3 then all we need to do is \\n\\t\\t# reach 3, because if we can, then we can reach 4 and so on.\\n        # NOTE: we dont want to minimize the number of steps to reach\\n        #       we just want to check if we can or cannot reach\\n        #       Thats why, this approach works.\\n",
                "codeTag": "Java"
            },
            {
                "id": 1255164,
                "title": "c-4-solutions-recursion-top-down-dp-bottom-up-dp-optimised-bottom-up-dp",
                "content": "**Solution 1 : Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 : Top Down DP**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 3 : Bottom Up Way 1**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 4 : Bottom Up Dp Way 2**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        return canJump(nums, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector <int> nums, int curr, vector <bool> dp) {\\n        if (curr == nums.size() - 1) {\\n            return true;\\n        }\\n        if (dp[curr]) {\\n            return dp[curr];\\n        }\\n        for (int i = nums[curr]; i > 0; i--) {\\n            if (canJump(nums, curr + i, dp)) {\\n                dp[curr] = true;\\n                return dp[curr];\\n            }\\n        }\\n        dp[curr] = false;\\n        return dp[curr];\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        vector <bool> dp(nums.size(), false);\\n        return canJump(nums, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <bool> dp(n, false);\\n        dp[n - 1] = true;\\n        \\n        for (int curr = n - 2; curr >= 0; curr--) {    \\n            int last = min(n - 1, curr + nums[curr]);\\n            \\n            for (int next = curr + 1; next <= last; next++) {\\n                if (dp[next]) {\\n                    dp[curr] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int target = n - 1;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            if (i + nums[i] >= target) {\\n                target = i;\\n            }\\n        }\\n        \\n        return target == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596403,
                "title": "python-really-kiss-solution",
                "content": "I started thinking of Dynamic Programming solution but in this case after re-reading the problem, I noticed that three interesting bits: \\n1. **non-negative integers** and \\n2. **Each element represents your maximum jump.** and \\n3. I only had to return **if I am able to find *a* solution** to the problem.\\n\\nThat means that I don\\'t really care about those values if they provide me enough *credit* to jump to the next cell.\\nGoing backwards, I always increment the `debit` of my cost to jump.\\nAs soon as I have a value that offsets my debit, I don\\'t really care of it\\'s value, and I can keep going.\\nOtherwise means that that cell doesn\\'t provide me enough `credits` to offset the `debit`, so I treat it as a `0 credit`: it\\'s a dead end.\\nIf I don\\'t have debit when I reach my first position, I know that there is A path.\\n\\nIf the problem wanted for example to count how many paths, then I was forced to do something more complex but we need to remember to KISS.\\nDynamic Programming is very powerful but also we shouldn\\'t immediately reach the most powerful tool for the job.\\n\\n-sorry, end of my preaching-\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        debit = 0\\n        for i in reversed(nums[:-1]):\\n            debit += 1\\n            if i - debit >= 0:\\n                debit = 0\\n        return debit <= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182034,
                "title": "difference-between-dp-and-greedy",
                "content": "### Dynamic Programming\\nLooking from the end and at each point ahead checking the best possible way to reach the end\\n```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\\n\\n\\n### Greedy\\n[Reference](leetcode.com/problems/jump-game/discuss/20900/Simplest-O(N)-solution-with-constant-space/20948)\\nLooking from the start and selecting the locally optimum in the hope of reaching global optimum\\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```\\n\\n\\n\\n\\n\\n\\n## Example\\n\\n\\t\\n![image](https://assets.leetcode.com/users/sohammehta/image_1539664091.png)\\n\\nIf we have a Greedy Approach here then we will take the path 1+99+1 as we select local optimum from the beggining\\n\\nBut if we take DP Approach then we start from back and find the cost of `reaching end` from `that specific node`. So when we reach the first node we will have two options\\n1. 99+1 path\\n2. 5+1 path\\nNow we simply have to decide between (1+(99+1)) and (20+(5+1)) path\\n\\n",
                "solutionTags": [],
                "code": "```\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> jump(n,false);\\n        jump[n-1]=true;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=nums[i] && j<n;j++)\\n            {\\n                if(jump[i+j]==true) \\n                {\\n                    jump[i]=true; \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return jump[0];\\n    }\\n```\n```\\n    bool canJump(vector<int>& nums) {\\n      int n = nums.size(), farest = 0;\\n      for(int i = 0;i < n; i++)\\n      {\\n        if(farest < i) return false;\\n        farest = max(i + nums[i], farest);\\n      }\\n      \\n      return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20897,
                "title": "recursive-and-non-recursive-solution-in-python-faster-than-100-python-solutions",
                "content": "At first I came up with this recursive solution, it is not difficult to think\\n```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\\nIt is like every time you look from the tail to see whether current index can get you into the last index and if we can reach last index from the current index, then current index becomes a new last index, we do the check again. \\n\\nThen I think it is not difficult to come up with the Non-recursive version evolved from the above solution:\\n\\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "solutionTags": [],
                "code": "```\\nif len(nums) == 1: return True\\nfor i in reversed(range(len(nums)-1)):\\n       if i + nums[i] >= len(nums) - 1:\\n           return self.canJump(nums[0:i+1])\\nreturn False\\n```\n```\\n        last_index = len(nums) - 1\\n        for i in reversed(range(last_index)):\\n            if i + nums[i] >= last_index:\\n                last_index = i\\n        return last_index == 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21165,
                "title": "easy-java-code-accepted-with-comments-for-understanding",
                "content": "just for record\\n\\n    public class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }\\n        //loop finished, the last grid can be reached\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canJump(int[] A) {\\n        int len=A.length;\\n        int ability=A[0];//the farmost grid index that can be reached\\n        for(int i=1;i<len;i++)\\n        {\\n            if(ability<i)//cannot reach beyond current grid by any means, return false\\n            return false;\\n            //update ability using the bigger grid index that can be reached\\n            ability=ability>i+A[i]?ability:i+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3541893,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "# #do upvote if u like solution #\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return true;\\n        if(nums[0]==0)\\n            return false;\\n        int dist=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==0 && dist==i)\\n            {\\n                return false;\\n            }\\n            dist=max(dist,nums[i]+i);\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159874,
                "title": "c-greedy-dp-memiozation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is we can do recursion and check all the possiblities whther we are able to reach at the end or not. Then for optimization we can use DP or Memoization.\\nAlso there is a greedy apprpoach in which we check the maximum we can reach from an index . And using that we will check whther we can reach the end or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy Appraoch:**\\n- We will keep track of max so far and also keep an end varaible which will be updated after checkig all the possiblites between curr and maxi beacuse  we are not sure initially what can be length of the jump we take . So after keeping track of max_so_far  and end we will check if our end >= n-1 i.e reached at the end or not and return true if reached else false.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**DP --> O(n^2) and O(n)**\\n```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\\n**Greedy approach O(N) and O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n bool rec(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind==arr.size()-1)return true;\\n        if(arr[ind]==0)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){ \\n            if(i<arr.size() and rec(arr,i+ind,dp))\\n           return dp[ind]=true;\\n        }\\n        return dp[ind]=false;\\n    }\\n bool canJump(vector<int>& arr) {\\n        vector<int>dp(arr.size(),-1);\\n        return rec(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        int end=0,maxi=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,i+arr[i]);\\n            if(i==end){\\n                end=maxi;\\n            }\\n        }\\n        return end>=n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693089,
                "title": "c-easy-fast-and-clean-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<bool> dp(nums.size(), false);\\n        dp[0] = true;\\n        \\n        int n = nums.size();\\n        int i=0;\\n        while(i<n and !dp[n-1])\\n        {\\n            if(dp[i])\\n            {\\n                int step_length = nums[i];\\n                for(int j=0;j<=step_length and j+i<n; j++)\\n                dp[i+j] = true;\\n            }\\n            i++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367910,
                "title": "java-simple-5-lines-code-o-n-faster-than-100-o-1-space",
                "content": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public boolean canJump(int[] nums) {\\n        int last=nums.length-1;\\n        \\n        for(int i=last-1;i>=0;i--){\\n            if(i+nums[i] >= last)\\n                last=i;\\n        }\\n        return last==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179976,
                "title": "straightforward-python-dp-accepted-and-recursive-mem-tle-solns-with-explanation",
                "content": "__DP:__\\nPretty straightforward dp case here, the main ideas:\\n-  We track that we can get to point dp[i] in our dp table.\\n-  To make it do dp[i] we search backward from the corresponding point nums[i] looking for a value that is >= the dist between the points.\\n-  If we find a point that contains such a value (```nums[j] >= (i-j)```) and has been reached (```dp[j]```) we know we can make this location.\\n-  We mark that we can make it and break the inner look to check the next location.\\n-  If ```dp[-1] == True``` it means that we can make it to the end.\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n\\n__Recurison + Memoization (TLE):__\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```nums[j] >= (i-j)```\n```dp[j]```\n```dp[-1] == True```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = True\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if dp[j] and nums[j] >= (i-j):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n        \\n        if len(nums) == 1:\\n            return True\\n        \\n        mem = {}\\n        \\n        def helper(idx):\\n            if idx >= len(nums):\\n                return False\\n            if idx == len(nums)-1:\\n                return True\\n            if idx in mem:\\n                return mem[idx]\\n            res = any([helper(i+idx) for i in range(nums[idx]+1) if (not (i+idx == idx) and i+idx not in mem)])\\n            mem[idx] = res\\n            return res\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883692,
                "title": "python-dp-solution-with-explanation-for-time-limit-exceeded",
                "content": "This is an interesting problem. The DP solution is quite straight forward. \\n\\n**Idea:**\\n\\n- At pos `i`, check if there is a pos `j` (where `0<=j<i`), from where we can jump to pos `i`\\n\\n![image](https://assets.leetcode.com/users/images/980c7c13-abfb-4b76-bc70-899e26086894_1602089061.8129.png)\\n\\n\\nThe below solution is correct but it will throw `time limit exceeded` for the last test case which is a very large array of `1`s \\n\\n**Correct solutin but time limit exceeded**\\n\\nThe below solution is correct but due to `# line A` we encounter `time limit exceeded`. So we need to optimize there. \\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n**Observation:**\\n\\n- As soon as `cond` (condition) is `True`, no need to iterate the inner loop.  `# line C`\\n- Run the `inner for loop` backward, thus you will encounter the required `True` condition earlier.  `# line B`\\n\\n**Final accepted solution**\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\\n\\n_happy coding !!_",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i):  # line A\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n               \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        n = len(nums)\\n        if n == 0: return False\\n        dp = [True]*n\\n        \\n        for i in range(1,n):\\n            cond = False\\n            for j in range(i-1,-1,-1):  # line B\\n\\t\\t\\t\\tdistance_to_cover = i - j\\n\\t\\t\\t\\tpossible_to_reach_j = dp[j] \\n\\t\\t\\t\\tjump_available_from_j = nums[j]\\n\\t\\t\\t\\tcond = cond or (possible_to_reach_j and (jump_available_from_j >= distance_to_cover))\\n\\t\\t\\t\\tif cond == True: break # line C\\n        \\n            dp[i] = cond\\n        \\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420615,
                "title": "javascript-solution-greedy",
                "content": "### The Idea\\n1. keep a record of the maximum feasible index\\n2. if an index is unfeasible, return false\\n\\n```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canJumpGreedy = function(nums) {\\n    let max = nums[0];\\n    for (let i=0;i<nums.length;i++) {\\n        if (max < i) return false\\n        max = Math.max(i+nums[i], max);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20898,
                "title": "java-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //we can use dynamic programming.\\n    //for a given position i\\n    //OPT[i] represent whether it is possible to reach the last index or not.\\n    //OPT[i] = true if (i == last Index)\\n    //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]]\\n    //OPT[i] = false if (nums[i] == 0)\\n    //The result is opt[0];\\n    public boolean canJump(int[] nums) {\\n        boolean[] dp = new boolean[nums.length];\\n        Arrays.fill(dp, false);\\n        dp[nums.length-1] = true;\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] == 0)\\n                dp[i] = false;\\n            else{\\n                if(nums[i] + i >= nums.length)\\n                    dp[i] = true;\\n                else{\\n                   for(int j = 1; j <= nums[i]; j++){\\n                       dp[i] = dp[i] || dp[i + j];\\n                       //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them.\\n                       j += nums[i + j];\\n                   } \\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20904,
                "title": "c-dp-solution-o-n",
                "content": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "solutionTags": [],
                "code": "    bool canJump(vector<int>& nums) \\n    {\\n        int max_jump_index = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            max_jump_index = max(nums[i] + i, max_jump_index);\\n            if (max_jump_index < i + 1)\\n                break;\\n        }\\n        \\n        return max_jump_index >= nums.size() - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21075,
                "title": "short-c-implementation",
                "content": "Thanks the post from top voted solution.\\n\\nHere is the AC c++ implementation \\n\\n       class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool canJump(vector<int>& nums) {\\n                int n=nums.size();\\n                int i=0, reach=0;\\n                for(; i<n && i<=reach; i++)\\n                    reach=max(reach, i+nums[i]);\\n                return reach+1>=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21127,
                "title": "python-different-solutions",
                "content": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # DP (like Word Break I) LTE\\n    def canJump1(self, nums):\\n        dp = [True] * len(nums)\\n        for i in xrange(1, len(nums)):\\n            for j in xrange(i):\\n                dp[i] = dp[j] and nums[j] >= i-j\\n        return dp[-1]\\n      \\n    def canJump2(self, nums):\\n        maxReach = 0\\n        for i in xrange(len(nums)):\\n            if i > maxReach:\\n                return False\\n            maxReach = max(maxReach, i+nums[i])\\n        return True\\n        \\n    def canJump3(self, nums):\\n        remain = 0\\n        for i in xrange(len(nums)):\\n            remain = max(remain-1, nums[i])\\n            if remain == 0 and i < len(nums)-1:\\n                return False\\n        return True\\n        \\n    def canJump(self, nums):\\n        maxReach = 0\\n        i = 0\\n        while i < len(nums) and i <= maxReach:\\n            maxReach = max(maxReach, i+nums[i])\\n            i += 1\\n        return i == len(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3653785,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing information whether you can get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our boolean array.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n=len(nums)\\n        dp=[False for _ in range(n)]\\n        dp[0]=True\\n\\n        for i in range(n):\\n            if dp[i]:   # if this position is reachable\\n                for j in range(1,nums[i]+1):\\n                    if i+j<n:\\n                        dp[i+j]=True\\n                    if i+j==n-1:\\n                        return True\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952145,
                "title": "java-simple-100-faster-video-explanation",
                "content": "\\nLook at the video to understand the approach[https://youtu.be/aeohnY2FQBI]()\\n\\n# Code\\n```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n-> Make sure to Upvote , it keeps me motivated.\\uD83D\\uDCAA \\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```\\n- Time complexity : O(n)\\n- Space complexity : O(1)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n// Approach 1\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int reachable = 0;\\n        for(int i=0; i<n; i++){\\n            if(reachable < i) return false;\\n            reachable = Math.max(reachable, i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n//Approach 2\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int index = nums.length-1;\\n        boolean answer;\\n        for(int i=nums.length-2; i > -1; i--){\\n            if(i+nums[i] >= index) index = i;\\n        }\\n        return answer = (index == 0)? true: false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951793,
                "title": "greedy-o-n",
                "content": "```farthestPos``` represent the farthest position we can go\\nAt each position (index) in ```nums```, we find the farthest position we can go by comparing the ```farthestPos``` with the current position + jumpLength.\\nAt any time, if the ```farthestPos``` is larger than the last position (index) in ```nums```, return True\\nAt any time, if the ```farthestPos``` is smaller than the current position (index) in ```nums```, return False\\n\\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```farthestPos```\n```nums```\n```farthestPos```\n```farthestPos```\n```nums```\n```farthestPos```\n```nums```\n```python\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        farthestPos = 0\\n        for curPos,jumpLength in enumerate(nums):\\n            \\n            # We CAN go to the curPos since it is covered by farthestPos\\n            # Update farthestPos\\n            if curPos <= farthestPos:\\n                farthestPos = max(farthestPos, curPos+jumpLength)\\n            \\n            # farthestPos doesn\\'t cover the curPos, we CAN NOT get to curPos, return False\\n            else:\\n                return False\\n            \\n            # Earlier return if the farthestPos covers our target position\\n            if farthestPos>=len(nums)-1:\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260211,
                "title": "2-solutions-dp-greedy",
                "content": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\\n\\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n//Method-1 Greedy\\n//By just checking whether we are able to reach or not\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int maxReachable=0;\\n        for(int i=0;i<=maxReachable;i++)\\n        {\\n           if(maxReachable>=nums.size()-1)return true;\\n            maxReachable=max(maxReachable,i+nums[i]);\\n        }\\n        return maxReachable>=nums.size()-1;\\n    }\\n};\\n```\n```\\n//Method -2 Part 1Recursive\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(nums[i]==0)return false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j))return true;\\n        }\\n        return false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        return util(nums,0);\\n    }\\n};\\n\\n```\n```\\n//Method -2 Part 2 Memoized\\nclass Solution {\\npublic:\\n    bool util(vector<int>& nums,int i,vector<int>&dp)\\n    {\\n        if(i>=nums.size()-1)return true;\\n        if(dp[i]!=-1)return dp[i];\\n        if(nums[i]==0)return dp[i]=false;\\n        for(int j=1;j<=nums[i];j++)\\n        {\\n            if(util(nums,i+j,dp))return dp[i]=true;\\n        }\\n        return dp[i]=false;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        return util(nums,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500046,
                "title": "c-greedy-approach-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& a) {\\n        int i,n=a.size(),maxi=0;\\n        if(n==1) return 1;\\n        for(i=0;i<n;i++){\\n            if(maxi>=i) maxi=max(maxi, i+a[i]);\\n        }\\n        return maxi>=(n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889494,
                "title": "easiest-code-u-can-get",
                "content": "\\n# Approach\\nIterating from the End: The algorithm starts iterating through the array from the end towards the beginning. The variable index is used to keep track of the last known position that can reach the end of the array.\\n\\nUpdating index: For each element in reverse order, check if the sum of the current element\\'s value (nums[i]) and its index (i) is greater than or equal to the current value of index. If it is, update index to the current index i.\\n\\nFinal Check: After the loop finishes, if index is at the beginning (index 0), it means that you can jump from the start to the end of the array using the given jump values. In this case, return true, indicating that it\\'s possible to reach the end. Otherwise, return false\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index= nums.size()-1;\\n        for(int i = nums.size()-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=index)\\n            {\\n                index= i ;\\n            }\\n        }\\n        if(index==0)return true;\\n        else\\n        {\\n            return false;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500987,
                "title": "cool-c-o-n-o-1-in-5-lines-i-call-it-momentum",
                "content": "# Intuition\\nmaybe the easiest way?\\n\\n# Approach\\nmomentum: how further i can go\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int momentum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            momentum--;\\n            if (nums[i] > momentum) momentum = nums[i];\\n            if (i != nums.size() - 1 && momentum == 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952081,
                "title": "c-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int dev=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(dev<i){\\n                return false;\\n            }\\n            dev=max(dev,i+nums[i]);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866646,
                "title": "golang-simple-solution",
                "content": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canJump(nums []int) bool {\\n    if len(nums) == 0 {\\n        return false\\n    }\\n        \\n    if len(nums) == 1 {\\n        return true\\n    }\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    record := make(map[int]bool)\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = true\\n        } else {\\n            for key, _ := range record {\\n                if nums[i] >= key - i {\\n                    record[i] = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825025,
                "title": "java-3-approaches-recursion-visited-bottom-up-dp-no-dp-explained",
                "content": "**What does the question ask for?**\\nThe question asks us to determine whether the end index is reachable from index 0.\\n\\n**How may we approach this problem?**\\nThe basic idea for this problem is to check the reachability of intermediate indexes to determine the reachability of some index\\n\\n# Approach #1 : Recursion + Visited\\n\\nWrite another method wherein we check whether the end index is reachable from the current index\\nIf we can reach to the current index from 0 and then from current index to end index,\\nthen we can surely reach from 0 to end index (0-> current index -> end index)\\n\\n**What is the purpose of visited?**\\nWhile calculating the reach. we may end up at the same index multiple times. If that index has been processed earlier -> Either it would have returned true, in which case, no more calculations would have been done, but since we encountered this index again, means that its result was false.\\n\\n```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Approach #2 : Bottom-up DP/Tabulation\\n\\n**How else can we solve the problem?**\\nIf the problem is solvable recursively, there will be an iterative solution as well.\\nThe idea for this approach is:\\nMaintain an array to check whether the current index is reachable from zero\\n\\n**How will we update reachable array?**\\nWe will use the idea of intermediate indexes:\\nSay we want to update index i\\nWe will consider some intermediate index j, s.t., 0<=j<i\\nThen:\\na) We will check that j is reachable from zero (using our reachable array)\\nb) We will check that i is reachable from j (Maximum index reachable from j = j+nums[j], if i<=max_index, then i is reachable otherwise not)\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\\n\\n# Approach #3: No DP\\n**What can we improve in the previous approach?**\\nWhat if instead of maintaining an array to check the reachability, we maintain a single variable that determines the maximum reachable index from 0 at a given iteration? In that case, we can simply check if the current index is within reach or out of reach, all the while updating max reach if current index is within reach.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**References:**\\n1.  https://leetcode.com/problems/jump-game/discuss/1819771/C%2B%2B-Memoization-(Top-Down)-and-Tabulation-(Bottom-Up)\\n2. https://leetcode.com/problems/jump-game/discuss/1820513/C%2B%2B-No-DP-Needed-Single-Traversal",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] visited;\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        visited = new boolean[len];\\n        return canJump(0,len, nums, visited);\\n    }\\n    private boolean canJump(int ind, int len, int[] nums, boolean[] visited){\\n        if(ind>=len-1){\\n            return true;\\n        }\\n        if(visited[ind]){\\n            return false;\\n        }\\n        visited[ind]=true;\\n        int maxJumps = nums[ind];\\n        if(maxJumps==0){\\n            return false;\\n        }\\n        for(int i=maxJumps;i>=1;i--){\\n            if(canJump(ind+i, len, nums, visited)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        boolean[] isReachableFromZero = new boolean[len];\\n        isReachableFromZero[0] = true;\\n        for(int i=1;i<len;i++){\\n            for(int j=i-1;j>=0;j--){\\n                // If j is reachable from zero\\n                // and from j, we can reach i\\n                // Means we can reach i from Zero\\n                if(isReachableFromZero[j]&&j+nums[j]>=i){\\n                    isReachableFromZero[i]=true;\\n                    break;\\n                }\\n            }\\n        }\\n        return isReachableFromZero[len-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int len = nums.length;\\n        if(len==1){\\n            return true;\\n        }\\n        int maxReachFromZero = 0;\\n        for(int i=0;i<len;i++){\\n            if(i<=maxReachFromZero){\\n                maxReachFromZero = Math.max(maxReachFromZero,i+nums[i]);\\n            } else{\\n                return false;\\n            }\\n            if(maxReachFromZero>=len-1){\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668712,
                "title": "dp-greedy-c-soln-two-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& A) {\\n        int i = 0;\\n    for (int reach = 0; i < A.size() && i <= reach; ++i)\\n        reach = max(i + A[i], reach);\\n    return i == A.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576539,
                "title": "simple-python-solution-with-explanation",
                "content": "**explanation :** **https://github.com/midnightbot/leetcode_solutions/blob/main/55.%20Jump%20Game.pdf**\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        \\n        lastreached = len(nums)-1\\n        \\n        for x in range(len(nums)-2,-1,-1):\\n            if x+nums[x]>=lastreached:\\n                lastreached = x\\n                \\n                \\n        if lastreached == 0:\\n            return True\\n        \\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557203,
                "title": "c-easy-solution-96-fast-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool canJump(vector<int>& v) {\\n        int n=v.size();\\n\\t\\t// res indicates that maximum on which index we can reach till now\\n        int res=0;\\n        int t=n-1;\\n\\t\\t// if only one elements is present then answer is always is true n=1 means t=0 , (t=n-1)\\n        if(t==0)return true;\\n        \\n\\t\\t// if first element is 0 and n>1 then answer is false\\n        if(v[0]==0)return false;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(v[i]+i>res and res>=i){\\n                res=v[i]+i;\\n            }\\n        }\\n        if(res>=t)return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501210,
                "title": "c-recursive-memoization-dp-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10005];\\n    bool solve(vector<int>& nums, int n, int idx){\\n        if(idx==n-1) return true;\\n        if(idx>=n) return false;\\n        if(!dp[idx]) return dp[idx];\\n        for(int i=1;i<=nums[idx];i++){\\n            if(solve(nums,n,idx+i)) return dp[idx] = true;\\n        }\\n        return dp[idx] = false;\\n    }\\n    \\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362214,
                "title": "two-solutions-using-dp-and-pointer",
                "content": "using dp and inserting index at most one can jump\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\\nusing a pointer to keep data that index is reachable or not in reverse direction \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) \\n    {\\n        int n=nums.length;\\n       int[] dp=new int[n];\\n       dp[0]=nums[0];\\n        if(n==1) return true;\\n       for(int i=1;i<n-1;i++)\\n       {\\n            if(dp[i-1]<i) return false;\\n            \\n            dp[i]=Math.max(dp[i-1],nums[i]+i);\\n           \\n            if(dp[i]>=n-1) return true; \\n       }\\n       return dp[n-2]>=n-1?true:false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n       int lastGoodIndex=nums[nums.length-1];// [3,2,1,0,4]\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(nums[i]+i>=lastGoodIndex)\\n            {\\n                lastGoodIndex=i;\\n            }\\n        }\\n        return lastGoodIndex==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087640,
                "title": "recursive-dp-bfs-greedy",
                "content": "recursion, time = exponential\\n```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\\ndp, time = O(n^2), space = O(n)\\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n\\nbfs, time = O(V+E) = O(n^2), space= O(n)\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\noptimized bfs, time = O(V+E) = O(n), space= O(n) \\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\\n\\ngreedy- maxReach/globalMaxReach approach, time O(n), space O(1), \\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n//optimal substructure\\n//f(s,e) = if(f(v,e)) true, for all vertices  reachable from s, with e fixed\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return recur(nums,0);\\n    }\\n    \\n    boolean recur(int[] nums, int index) {\\n        if (nums.length-1==index) return true;\\n        int reach = nums[index] + index;\\n        for(int i = index+1; i<=reach;i++)\\n            if(recur(nums,i)) return true;\\n        return false;\\n    }\\n   \\n}\\n```\n```\\n//optimal substructure\\n//f(s,e) = if(f(s,v)) true, for all vertices reachable to e, with s fixed\\nclass Solution {\\n \\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] dp = new boolean[n];\\n        //base\\n        dp[0] =true;\\n        for(int e= 1; e<n;e++) {\\n            for(int v= e-1;v>=0;v--) {\\n                int v_reach = v+nums[v];\\n                if(e<=v_reach && dp[v]) {\\n                    dp[e] =true; \\n                    break;\\n                }       \\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        boolean[] visited = new boolean[n];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = v+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                    if(!visited[c]) {\\n                        q.offer(c);\\n                        visited[c] = true;\\n                    }\\n                }       \\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        Queue<Integer> q = new ArrayDeque<>();\\n        q.offer(0);\\n        int maxReach=-1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i =0;i<size;i++) {\\n                int v = q.poll();\\n                if (v == n-1) return true;\\n                 //children\\n                int v_reach = nums[v]+v;\\n                for(int c = maxReach+1; c<=Math.min(v_reach,n-1) ;c++) {\\n                        q.offer(c);\\n                }      \\n                maxReach = Math.max(maxReach,v_reach);\\n            }   \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//maxReach/globalMaxReach approach\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = -1;\\n        int globalMaxReach = -1;\\n        for(int i=0;i<n-1;i++) {\\n            maxReach = i + nums[i];\\n            globalMaxReach = Math.max(globalMaxReach,maxReach);\\n            if (i == globalMaxReach) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596250,
                "title": "c-o-n-time-o-1-space",
                "content": "At first I submitted a *O(N^2)* DP solution. However it will TLE.\\nIn fact, you only need to greedily keep updating the rightmost position you can jump to.\\n```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxRight = 0;\\n        for (int i = 0; i < n; i++){\\n            if (i > maxRight) return false;\\n            maxRight = max(i + nums[i], maxRight);            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443266,
                "title": "dp-or-top-down-memoized-solution-tles",
                "content": "Unlike what the solution may suggest DP or top down memoized solution TLEs in C++. \\n\\nI wasted a lot of time trying to figure out if there is a bug in my code and there isn\\'t. They just want it in o(n) time.\\n\\nThe only o(n^2) dp that worked for me is the following code\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\\n\\nAnd even still slight modifications won\\'t allow this to work, like when I changed the ```vector<int>``` to ```vector<bool>```\\n\\nEdit:\\nDP solutioon that beats 97% in time complexity\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), -1);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == -1){\\n                jumpable[i] = false;\\n            } else if(jumpable[i]){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```\n```vector<int>```\n```vector<bool>```\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> jumpable(nums.size(), 0);\\n        jumpable[0] = 1;\\n        for (int i = 0; i< nums.size(); i++){\\n            if(jumpable[i] == 1){\\n                int lastJumpableIdx = min((int) nums.size() -1, i + nums[i]);\\n                for (int j = lastJumpableIdx; j>=i+1; j--){\\n                    if(jumpable[j] == 1){\\n                        break;\\n                    }\\n                    jumpable[j] = 1;\\n                }\\n            }\\n            \\n        }\\n        return jumpable[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414459,
                "title": "c-o-n-iterative",
                "content": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic bool CanJump(int[] nums)\\n{\\n    int maxLength = 0;\\n    for (int i = 0; i < nums.Length - 1; i++)\\n    {\\n        if (nums[i] == 0 && maxLength == 0)\\n        {\\n            return false;\\n        }\\n        if (nums[i] >= maxLength)\\n        {\\n            maxLength = nums[i];\\n        }\\n        maxLength--;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114802,
                "title": "python-dp-o-n-solution-accepted",
                "content": "Here, I share my python solution using dynamic programing. The key to reduce the time complexity from ```O(n^2)``` to ```O(n)``` is to define the state ```dp[i]``` as the maximum index one can jump after reach index ```i```. \\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "solutionTags": [],
                "code": "```O(n^2)```\n```O(n)```\n```dp[i]```\n```i```\n```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if len(nums)<2:\\n            return True\\n        dp    = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            if dp[i-1]<i:\\n                return False\\n            dp[i] = max(dp[i-1], i + nums[i])\\n        return dp[-1]>=len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20896,
                "title": "python-and-91-fast-time-idon-t-know-if-it-s-greedy-maybe-not",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n         \\n        if len(nums) <= 1:\\n            return True\\n        j = len(nums) - 2\\n        i = len(nums) - 1    \\n        while j > -1:\\n            if j + nums[j] >= i:\\n                i = j\\n                j -= 1\\n                \\n            else:\\n                j -= 1\\n        #print('i', i, 'j', j)\\n        if i <= 0:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 4018177,
                "title": "use-a-counter-to-count-on-your-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key mindset here is to use a counter to count on residual steps.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake k as your residual steps. Everytime you move, k-1. If nums[i] offers you more steps, take it! If you run out of your move and can\\'t move to finishing line, you fail. Otherwise, return True.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return True\\n        k = nums[0]\\n        for i in range(len(nums)-1):\\n            if nums[i] > k:\\n                k = nums[i]\\n            k = k - 1\\n            if k < 0 :\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779748,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]+i>=index)index=i;\\n        }\\n        if(index==0) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652039,
                "title": "beats-99-runtime-and-80-memory-very-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGoing from the backward. If you can reach the final point from right before one, replace the goal with the index of the right before point.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal = len(nums) - 1\\n        for i in range(len(nums))[::-1]: #4,3,2,1,0\\n            if i + nums[i] >= goal:\\n                goal = i\\n        return not goal\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078478,
                "title": "very-easy-c-solution-in-o-n-time-beats-99-12",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n     int target=0;\\n\\n     for(int i=0; i<=target; i++){\\ntarget= max(target, i+nums[i]);\\n\\nif(target>=nums.size()-1){\\nreturn true;\\n}\\n     }   \\n   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951498,
                "title": "python-3-7-lines-iteration-w-explanation-t-m-94-98",
                "content": "The problem reduces to whether there is a zero in any position other than position n[-1], and if so, whether there is a reachable cell beyond each such zero. \\n```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```\\n[https://leetcode.com/problems/jump-game/submissions/865477602/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) .\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:     \\n \\n\\n    def canJump(self, n: list[int]) -> bool:\\n        \\n        if 0 not in n[:-1] or len(n) == 1: return True\\n\\n        pt = n.index(0)            \\n\\n        for i in range(len(n)):\\n\\n            if i <= pt and  i + n[i] > pt: pt = i + n[i]\\n\\n            if i == pt and not n[i]: return False\\n            if pt >= len(n)-1      : return True\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531333,
                "title": "simple-ts-with-explanation",
                "content": "Practically speaking, if the array contains no stopping points (`nums[i] = 0 ` for any `i`) then we can always reach the end index by always jumping 1 step forward regardless of the value we are standing at \\nFor example: `[2, 3, 4, 5, 1, 6, 7]` we can always just use 1 step at each point to reach the end\\nWith that being said, the tricky part is when zeroes are involved, and that is basically the whole point of the problem\\nLet us say we want to move one step at a time and store how many steps are left to carry us forward, and if we have none left then we break early and return false\\nCan we skip past **all** zeroes with the number of steps we have left? If so then we return true\\nLet us store how many steps are `left` for the previous index, and if we are standing on a new index whose `nums[i]` value gives us more steps, then we \"reimburse\" ourselves with that new value by replacing `left`  with `nums[i]`\\nIf `left == 0` then there are no ways to move forward and we have ran out of steps because we must have encountered a zero value that stops us dead in our tracks with no more steps in the \"bank\"\\n```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction canJump(nums: number[]): boolean {\\n    let left = nums[0]\\n    for(let i = 1; i < nums.length; i++) {\\n        if(left == 0) {\\n            return false\\n        }\\n        left = Math.max(left - 1, nums[i])\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488405,
                "title": "python-backtracking-greedy-interview-pov",
                "content": "Intutions that pops up during an interview:\\nIf we are not able to think about the solutions right off the bat , think about base cases/invalid cases. \\nPoints to consider : \\n1. The only hurdle that stops us moving towards the destination is \"0\" ,So we can check if the value at 0th index is 0 then directly return False as we cannot move ahead.\\n2. How about checking 0s on every index before taking a call to jump? will it work? lets see\\n [1,2,0,1,1]\\nFrom 2nd position(1 based index) you either need to jump 1 step or 2 steps , since 1 step is giving you 0, you have to **BackTrack** and jump 2 steps to reach the destination. \\n\\nHence from the above 2 points we can say that from every step we need to decide and consider all the paths by BackTracking \\nGood , atleast we were able to give some bruteforce algo now, Lets code it up with some help :\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```\\nNow , The above solution works perfectly in the case of smaller inputs , what if the values are 10^something then we end up looping /backTracking every value to reach the destination which is very expensive .\\nCan we think of something else ?\\nhmmmm.....\\n.hmmmm....\\n.hmmm...\\nAt this moment inteviwer would give some hints : \\n1. Why dont you try from the last ?\\n2. Do you really need backTracking if you try from the last ? \\n\\n\\nOhhh, okay Lemme think ...\\nif i get to try from the last position (ie my destination) , i will jus have to validate if am able to reach the destination by visting destination-1 th position\\n for eg : \\n [4,2,3,1,5] ---> 1 based index\\n To reach 5th position, i will jus have to validate if am able to reach5th index from 4th index , by checking if the (value at 4th index+4th index ) should be equal or greater than than the destination position ie 5th index here  Hence for the above example i would be checking \\n \\n 1(value at 4th index)+4(index) >= destination index(5) \\n Yeah am able to reach , okay now change the destionation to 4th position and redo the same for every value and finally return True if your destination is at 0th index after all the movements else return False \\n ```\\n  currDestination=len(nums)-1\\n        for i in range(len(nums)-2,-1,-1):\\n            if (i+nums[i])>=currDestination:\\n                currDestination=i\\n        return True if currDestination==0 else False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def recurJump(index):\\n            if index>=len(nums)-1:\\n                return True\\n\\t\\t\\t#Checking all the possible values by backTracking starting from 1 , if the value is 0 , our code would return False as it would not enter the for loop\\n            for i in range(1,nums[index]+1):\\n                if(recurJump(index+i)):\\n                    return True\\n            return False\\n        return(recurJump(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381515,
                "title": "o-n-python-solution",
                "content": "Please Upvote if you like the solution\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums)==0:\\n            return False\\n        elif len(nums)==1:\\n            return True\\n        reach=nums[0]\\n        for i in range(0,len(nums)):\\n            if i>reach:\\n                return False\\n            reach=max(reach,i+nums[i])\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188884,
                "title": "java-in-depth-explanation-o-n-time-and-o-1-space",
                "content": "I have my solution in Java here w/  **O(n) time** and **O(1) space**. I think my solution is much easier to understand and implement. \\n\\n  The first step is to declare a int variable `max_reach` to track what\\'s the max index we can reach to. Eventually, we know we can return true once `max_reach >= nums.length - 1`. Hence, we can use a for-loop to update `max_reach`. \\n\\n  (1) if `max_reach < i` then return **false**. We do so because if max_reach is smaller than i, that means we are not able to reach to `idx i`. Then we return false for sure.\\n\\n  (2) `max_reach = Math.max(max_reach, i + nums[i])`. When come to here, we know that we are able to reach `idx i` already. Now we want to update our `max_reach`. We are at `idx i` so let\\'s compare `max_reach` and `i + nums[i]`. Why it\\'s `i + nums[i]` ? We are at `idx i` so `i + nums[i]` would be the max index we can reach at `idx i`. \\n\\n```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean canJump(int[] nums) \\n    {\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(max_reach < i)\\n                return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043503,
                "title": "weeb-explains-python-c-dp-o-n-time-o-1-space",
                "content": "I will explain my thought process on how i solved this problem.\\n\\n# Understanding the question:\\nOur goal is to check whether we can reach the **last index**, given that we start on the **first index**\\nEach nums[i] represents the **maximum** jump distance from i to some index j.\\n\\n# Observations:\\n***1st Observation***\\nMy first thought was that **if a path exists**, then that means there must be **at least one** possible path to reach the last index.\\nSince we just want to know whether we can reach the last index, then **it does not matter which path we take to reach the last index**, we **only need to reach the last index, regardless of which path we take**.\\n\\n***2nd Observation***\\nWe now know that it doesn\\'t matter which path we take to reach the last index. This subproblem is solved.\\nSo, **what is the next subproblem?**\\nFor me, the question was,**how do we figure out which path(out of all the valid paths) do we take to reach the last index?**\\nLets assume that a path exists, we shall represent the path as some nodes.\\nlet the nodes be A, B, C, D, E respectively. Where **A is the first index**, and **E is the last index**, **B, C, and D are some nodes in between to contribute the the path to reach the last index**.\\nI noticed that, to go from A to E, we need to go through B, C and D.\\nThen, that means **D is dependent on E, and C is dependent on D, and B is dependent on C.**\\nIn simpler terms, **to get to E, we need to start on D, to get to D, we need to start on C, to get to C, we need to start on B and so on.**\\nSo, A -> B -> C -> D -> E.\\nfrom this, I deduced that the the **current node is dependent on the on the previous node**, which leads to the **idea of backtracking from the last index to the first index.**\\n\\n***3rd Observation***\\nNotice that, if nums does not contain a 0, that is, nums[i] != 0 for 0<=i<=len(nums)-1, then **there is always a path**.\\nWhy? Because from the 1st observation , we deduced that it we **only need to reach the last index, regardless of which path we take**.\\nBut, what if nums[i] == 0?\\n\\n***4th Observation***\\nThe idea is to check whether its possible to  **\"skip\"** nums[i] == 0. But how?\\nLet nums = [2,0,1,0], the result for this is True\\nwe know that the path is 2 -> 1 -> 0\\nSince, **from the 2nd observation**, we know that we need to use **backtracking**, we woud\\'nt know that \\n2->1->0 is valid path without iterating through nums[1], which is 0.\\nFor me, i thought of the idea **using a count, and to accumulate this count to compare it the previous indexes, i.e index 0 to index i**\\nWhen we encounter a number greater than or equal to count, i.e **nums[j] >= count**. We **reset the count**, and repeat this step again when we encounter another nums[i] == 0.\\nif **nums[j] < count**, then we still continue until we reach the last index(**while adding count by 1 for each iteration**), if count is still > 0 at the first index, then we cannot skip that nums[i] == 0, so we **return False**\\n\\n**Why do we add 1 to count for each iteration?** \\nBecause, as we backtrack by 1 step for each iteration, we need 1 more step to skip nums[i] == 0.\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn (count == 0) ? true : false;\\n\\t\\t}\\n\\t};\\n\\nTake a break from dp, watch some anime instead\\nCheck out **\\u65F6\\u5149\\u4EE3\\u7406\\u4EBA (Link Click)**\\n\\n# Episodes: 11\\n# Genres: Drama, Supernatural\\n# Theme: Time Travel\\n\\nThis show is a good one, pls watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution:\\n\\t\\tdef canJump(self, nums: List[int]) -> bool:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\t\\t\\tif nums[i] == 0: count += 1\\n\\n\\t\\t\\t\\tif count != 0 and nums[i] != 0:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif nums[i] >= count:\\n\\t\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\t\\treturn True if count == 0 else False\\n\\t\\n**C++**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canJump(vector<int>& nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i = nums.size()-2; i>-1; i--){\\n\\t\\t\\t\\tif (nums[i] == 0) count += 1;\\n\\n\\t\\t\\t\\tif (count != 0 && nums[i] !=0){\\n\\t\\t\\t\\t\\tcount += 1;\\n\\t\\t\\t\\t\\tif (nums[i] >= count) count = 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1737483,
                "title": "fast-c-simple-tc-o-n-sc-o-1-single-loop",
                "content": "- we find the max reach distance at every point\\n- if at any point less then last index, max-reach point is 0, we return \"false\"\\n\\n```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```\\n\\n- please upvote my solution if you like it, as it motivates a lot. THANK YOU",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nbool canJump(vector<int>& nums) {\\n        int maxReach=nums[0];\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            if(maxReach == 0) return 0;\\n            maxReach--;\\n            if(nums[i] > maxReach) maxReach = nums[i];\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734799,
                "title": "brute-force-recursion-both-explained",
                "content": "**!!!!!!...Please upvote if you like it/........**\\n**Brute force:**\\n```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\\n**-------------------------------------------------**\\n**Recursion+Memorisation**\\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0;//couting the current reaching positon\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i>reach)\\n            {\\n                return false;//is cuurent value extend the reach value we have to return false\\n            }\\n            reach=max(reach,i+nums[i]);// move and find the maximum possible reach \\n            \\n        }\\n        return true;\\n    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100001];//intialsation of value\\n    \\n    bool solve(int s,int n, vector<int>&nums)\\n    {\\n        if(s>=n)\\n        {\\n\\t\\t// if we able to reach the end point of array ie: `n-1` return true\\n            return dp[s]=1;\\n        }\\n        if(s>n)\\n        {\\n            return dp[s]=0;//if we reach  beyond the end point of array ie:(n,n+1,n+2......)return false\\n        }\\n\\t\\t//if answer is already present in dp array we only return it\\n        if(dp[s]!=-1)\\n        {\\n            return dp[s];\\n        }\\n\\t\\t// now we check every possible positon and combination=>(s+i)\\n        for(int i=1;i<=nums[s];i++)\\n        {\\n            if(solve(s+i,n,nums))\\n            {\\n                return dp[s]=1;\\n            }\\n           \\n        }\\n         return dp[s]=0;\\n    }\\n    \\n    \\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//intitalstaion of dp\\n        for(int i=0;i<100001;i++)\\n        {\\n            dp[i]=-1;\\n        }\\n\\t\\t// recursion start===>start with intial value 0 and reach at n-1\\n        return solve(0,n-1,nums);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1558758,
                "title": "super-easy-c-solution-100-speed-greedy",
                "content": "**Intuition:**\\nCan  anyone reach to lastindex - starting from lastindex itself\\n\\n**Technique - Greedy**\\nUsing index+nums[i] >= lastindex, then true;\\n        \\n**CODE with Explaination**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int last_best_index_pos =nums.size()-1; // at last position \\n        \\n        //Using index+nums[i] >= lastindex, then true;\\n        //Intuition: Can I anyone reach to lastindex - starting from lastindex itself\\n        \\n        \\n        for(int i=nums.size()-1; i>=0;i--)\\n        {\\n            if(i+nums[i] >=last_best_index_pos)\\n            {\\n                last_best_index_pos =i; // can anyone reach to current index\\n            }\\n        }\\n        \\n        \\n        return (last_best_index_pos ==0); //if TRUE, reachable index is 0,then it means that OFCOURSE none of the index can reach index 0, \\n        // You did it!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520508,
                "title": "any-beginner-looking-for-recursive-top-down-approach-dynamic-programming",
                "content": "just reverse the array and follow it up recursively\\n```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```\\nIt\\'s not the best optimised version . But I think it\\'s good for any beginner who is looking for dp solution but not able to find it . It\\'s also called Dynamic programming solution since we have memosized the recursive solution.\\nThanks",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>dp;\\n    int helper(vector<int>& nums,int n){\\n        if(n<0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        for (int  i = 1; i <=nums[n]; i++)\\n        {\\n            if(helper(nums,n-i)) return dp[n]=true;\\n        }\\n        return dp[n]=false;\\n    }\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        reverse(nums.begin(),nums.end());\\n        dp.resize(nums.size(),-1);\\n        dp[0]=1;\\n        return helper(nums,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429371,
                "title": "java-1ms-faster-than-100-o-n-with-comment",
                "content": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach: Iterate from the end of array till the begening\\n// At each position, check if u r able to reach to the next position with given number of jumps at that position\\npublic boolean canJump(int[] nums) {\\n    int n = nums.length - 1;\\n\\n    int goodIndex = n;\\n    for (int i = n; i >= 0; i--) {\\n        if (i + nums[i] >= goodIndex) {\\n            goodIndex = i;\\n        }\\n    }\\n    return goodIndex == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378537,
                "title": "simple-easy-c-solution",
                "content": "1. \\tWe just need to chec our itreter is reach at last poistion or not.\\n2. \\tso,we make one tamparary varieble r \\n3. \\tnow we traverse into vector frome 0 index to last.\\n4. \\tand update our r with max valur of vector[i] or previous r.\\n5. \\tand check if we reach or not \\n6. \\tif we reach at vector[i] with value 0 than direct false Bcz we dont have any forther move!\\n\\n```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n        int r=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(r<i) return false;\\n            r=max(r,i+nums[i]);\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233260,
                "title": "easy-python-solution",
                "content": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef canJump(self, nums: List[int]) -> bool:\\n        j=0\\n        for i in range(len(nums)):\\n            if i>j:\\n                return False\\n            j=max(j,i+nums[i])\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854051,
                "title": "simple-2-pointer-approach-using-java",
                "content": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Complexity : Time : O(n), Space : O(1), Single pass\\n */\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        if (n==1)\\n            return true;\\n        int i=0,j=1;\\n        while(i<j && j<n) {\\n            if ((j-i) <= nums[i]) {\\n                if(j==n-1)\\n                    return true;\\n                j++;\\n            } else\\n                i++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 829178,
                "title": "python-in-place-dp",
                "content": "Using the input array itself to keep track of the available jump at current index (memoization):\\n- If the previous index has 0, then there\\'s no way to reach the current index, so update current index to eqaul to 0.\\n- Else we can make at least one jump from previous index, store the max jump available at current index.\\n- Lastly check the 2nd to last index(right before the target) should has available jump >= 1 else it can\\'t jump one more to reach the end\\n\\n\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = max(nums[i-1]-1, nums[i])\\n            \\n        \\n        return nums[-2] >= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769699,
                "title": "quick-and-simple-c-solution-with-explanations-o-n",
                "content": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canJump(int* nums, int numsSize){\\n    int max_index = nums[0];\\n    if (numsSize < 2) // if only one element - always true\\n        return true;\\n    \\n    if (max_index == 0) // can\\'t jump at all\\n        return false;\\n    \\n    if (max_index >= numsSize) // first jump can reach end\\n        return true;\\n    \\n    for (int i=1; (i <= max_index) && (i < numsSize); ++i) //loop through all reachable indexes\\n    {\\n        if (i + nums[i] > max_index)\\n            max_index = i + nums[i];\\n    }\\n    \\n    if (max_index >= numsSize-1) // if maximum jump is more than last index, can reach end\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 713591,
                "title": "python-linear-constant-space",
                "content": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```\\n\\nthe idea is we initialize a variable, current_max, which keeps track of the maximum index we can reach in the array. Through each pass of the loop, we check if the index i of the array can be reached. If not, we can terminate early. Otherwise, we check the current_max vs the current element of the array. For example, we have:\\n\\n[2,0,6,8,1,2]\\n\\nAt i = 0, our curent_max is 2 - we can reach up to index 2 in the array\\nAt i = 1, our current_max is max(2, 1 + 0) = 2, meaning we can still only reach index 2\\nAt i = 2, our current_max is max(2, 2 + 6) = 8, so we can reach up to index 8\\n\\nWe can also terminate early if our current max is greater than the array length minus one, because we are dealing with indices. \\n\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        current_max = 0\\n        \\n        for i in range(len(nums)):\\n            if current_max < i: return False\\n            current_max = max(current_max, i + nums[i])\\n            if current_max >= len(nums)-1: return True\\n            \\n        return current_max >= len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669672,
                "title": "javascript-recursive-dp-memoization-top-down-approach",
                "content": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canJump = function(nums) {\\n    const memo = new Map();\\n    \\n    function permute(idx) {\\n        if(memo.has(idx)) return memo.get(idx)\\n        if(idx >= nums.length-1) return true;\\n        if(nums[idx] === 0) return false;\\n        \\n        for(let i = nums[idx]; i >= 1; i--) {\\n            if(permute(idx + i)) {\\n                memo.set(idx, true);\\n                return true\\n            }\\n        }\\n        memo.set(idx, false);\\n        return false;\\n    }\\n    return permute(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596976,
                "title": "o-n-c-better-than-99-81-with-o-1-with-explanation",
                "content": "This guy explains each and every concept and logic behind any question so clearly.\\nYou will definately like it.\\nhttps://www.youtube.com/watch?v=muDPTDrpS28\\n\\nComment if you have any question\\n\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int n = arr.size();\\n        int maxReach = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(maxReach < i)\\n                return false;\\n            maxReach = max(maxReach, arr[i]+i);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596291,
                "title": "javascript-javascript-minimum-variables",
                "content": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canJump = function(nums) {\\n    let last = nums.length - 1;\\n    for (let i = last - 1; i >= 0; i--) {\\n        if (i + nums[i] >= last) {\\n            last = i;\\n        };\\n    };\\n    return last === 0;\\n};\\n```\n```\\nvar canJump = function(nums) {\\n    if (nums.length < 2) {\\n        return true;\\n    }\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (i + nums[i] >= nums.length - 1) {\\n            return true;\\n        };\\n        if (nums[i] === 0) {\\n            return false;\\n        }\\n        if (i + nums[i] > i + 1 + nums[i + 1]) {\\n            nums[i + 1] = nums[i] - 1;\\n        };\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215616,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [True]+[False]*(len(nums)-1)\\n        for i in range (1,len(nums)):\\n            for j in range (i)[::-1]:\\n                if i-j<=nums[j] and dp[j]:\\n                    dp[i]=True\\n                    break\\n        \\n        return (dp[-1])",
                "codeTag": "Java"
            },
            {
                "id": 20899,
                "title": "fastest-python-o-n-constant-space-solution-6-lines",
                "content": "Checking the range of the current element, decreasing by 1 and comparing to the next element. Currently the fastest Python solution.\\n\\n``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def canJump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        cur_range = nums[0]\\n        for i in range(0, len(nums)-1):\\n            cur_range = max(cur_range - 1, nums[i])\\n            if cur_range == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21017,
                "title": "python-4-liner-beats-96-other-solutions",
                "content": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "solutionTags": [],
                "code": "This question appeared to be a bit confusing to me at first... Then I realised it should be \\na easy question... lol\\n\\n'''\\n\\n    class Solution(object):\\n        def canJump(self, nums):\\n            reach = 0\\n            for i in xrange(len(nums)):\\n                if reach >= i and i+nums[i] > reach: reach = i+nums[i]            \\n            return reach >= len(nums)-1\\n\\n'''\\n\\nreach is the farthest position to which nums[i] can jump.",
                "codeTag": "Java"
            },
            {
                "id": 21117,
                "title": "java-4-line-solution-can-you-beat-it",
                "content": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean canJump(int[] nums) {\\n           int maxReach = 0;\\n           for (int i = 0; i < nums.length && i <= maxReach; i++) \\n                maxReach=Math.max(maxReach, nums[i]+i);\\n           return maxReach >= nums.length - 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21120,
                "title": "clear-greedy-solution-for-c",
                "content": "    class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }\\n           return step != 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(vector<int>& nums) {\\n           if(nums.size() <= 1)return true;\\n           int step = nums[0];\\n           for(int i = 1; i < nums.size() - 1 && step != 0; i++){\\n               step--;\\n               step = max(step,nums[i]);//keep the step or change to the biggest step we can go now\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 21177,
                "title": "my-5-lines-dp-solution-in-o-n-time-with-constant-space-19ms",
                "content": "This a DP solution, and the idea is to save the maximum jump length every time, if the maximum length be zero, than return false.\\n\\n    class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(std::vector<int> &nums) {\\n    \\t\\tint maxJumpNow = 0, len = static_cast<int>(nums.size());\\n            for (int i = 0; i < len - 1 && maxJumpNow < len - i; ++i)\\n                if (!(maxJumpNow = std::max(maxJumpNow - 1, nums[i])))\\n                    return false;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21197,
                "title": "5-lines-code-solution-with-o-n",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n        if (n<=1) return true;        \\n    \\n        // step means max step it can go from i-1\\n        // when it go one further step, compare the (previous step - 1) with the step of current node can go, keep the max\\n        // when step goes to 0, it means it can't go further, fail the jump. otherwise, it will end to the end\\n    \\tint step = A[0];\\n    \\tfor(int i=1;step>0 && i+step < n; i++)\\n    \\t\\tstep = max(step-1,A[i]);\\n    \\treturn step!=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21211,
                "title": "help-me-improve-it-thx",
                "content": "    class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }\\n            }\\n            return max>n-2;\\n        }\\n    };\\ntried my best. but i think its not good enough.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool canJump(int A[], int n) {\\n            int max = A[0];\\n            for(int i=1;i<=max && max<n-1;i++) {\\n                if(A[i]+i > max) {\\n                    max = A[i]+i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4049323,
                "title": "easy-c-solution-beat-97",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i =0;\\n        for(int reach=0;i<nums.size()&&i<=reach;i++){\\n            reach=max(i+nums[i],reach);\\n        }\\n        if(i==nums.size())\\n            return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976142,
                "title": "python-every-possible-solution-greedy-dp-recurssive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n### Greedy TO(n) SO(1)\\nMaintain a reachable variable and update it on every iteration, if we are ahead of reachable that means it\\'s not possible. else reachle will be equal to n\\n\\n### DP TO(n^2) SO(n)\\nUsing a 1d array to mark evry reachable destination by True and then check if we reached on then end or not.\\n\\n\\n### Recurssive TO(n^n) SO(1)\\nTry running DFS on every possible value and check if reached in the end or not.\\n\\n\\n\\n# Code\\n```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```\\n\\n# Upvote if it\\'s helpfulll.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Greedy\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        reacable = 0\\n        for i in range(len(nums)):\\n            if reacable < i :\\n                return False\\n            reacable = max(reacable, i+nums[i])\\n        return True\\n```\n```\\n#DP\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        n =len(nums)\\n        dp = [False for i in range(n)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for j in range(i+1, i+nums[i]+1):\\n                    if j < n:\\n                        dp[j] = True\\n                    if j == n - 1:\\n                        return True\\n        return dp[n-1]\\n```\n```\\n#Recurssive\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        def dfs(i, n, nums):\\n            if i > n:\\n                return False\\n            if i == n:\\n                return True\\n            ans = False\\n            for e in range(1, nums[i]+1):\\n                ans = ans or dfs(e+i, n, nums)\\n            return ans\\n        return dfs(0, len(nums)-1, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664370,
                "title": "java-greedy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use a greedy approach to determine if it is possible to reach the last index of the array nums using the maximum jump length at each position. The idea is to iteratively update the maximum reachable index while traversing the array from left to right. If the maximum reachable index ever reaches or exceeds the last index, it means we can reach the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the variable last as the index of the last element in the array (nums.length - 1).\\n- Initialize the variable maxReach as 0, representing the maximum index we can currently reach from the starting position.\\n- Iterate through the array nums from left to right using the loop variable i.\\n    - Update maxReach using the expression Math.max(maxReach, i + nums[i]). This calculates the maximum index we can reach by taking a jump from the current position i.\\n    - If maxReach ever reaches or exceeds the last index, return true as we can reach the end.\\n- If the loop finishes without returning true, it means we cannot reach the last index. In this case, return false.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int last = nums.length - 1;\\n        int maxReach = 0; // Maximum index we can reach\\n        \\n        for (int i = 0; i <= maxReach; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            \\n            if (maxReach >= last) {\\n                return true; // We can reach the last index\\n            }\\n        }\\n        \\n        return false; // Cannot reach the last index\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579417,
                "title": "best-solution-only-by-basic-array",
                "content": "# Intuition\\nI solve this question only by some basic array.\\n\\n# Approach\\nWe have to find zeo in the array after that go back in array and check if element is greater than predefined variable than index should pass that zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        if(nums[0]==0 && nums.length!=1){\\n            return false;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            if(i==nums.length-1){\\n                return true;\\n            }\\n            if(nums[i]==0){\\n                int flag=1;\\n                for(int j=i-1;j>=0;j--){\\n                    if(nums[j]>flag){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        return false;\\n                    }\\n                    flag++;\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258854,
                "title": "greedy-algorithm-python3",
                "content": "# 1.Simple Start and End Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\\n# 2.Greedy Approach\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        if len(nums)<2:\\n            return True\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                if start>=len(nums)-1:\\n                    return True\\n        return False\\n  #please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        goal=len(nums)-1\\n        for i in range(len(nums),0,-1):\\n            if nums[i-1]>=goal-(i-1):\\n                goal=i-1\\n        return True if goal==0 else False\\n#please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233306,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        vector<int> dp(nums.size(),-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(dp[i-1]>0){\\n                dp[i]=max(dp[i-1]-1,nums[i]); \\n            }\\n            else{\\n                dp[i]=-1;\\n            }\\n        }\\n        if(dp[nums.size()-1]!=-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161183,
                "title": "solution",
                "content": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\\n\\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint speedUp = []\\n{std::ios::sync_with_stdio(0); std::cin.tie(0); return 0; }();\\n\\nint digit(char c)\\n{\\n    return c & 15;\\n}\\nbool isDigit(char c)\\n{\\n    return \\'0\\' <= c && c <= \\'9\\';\\n}\\nint init = []\\n{\\n    std::ofstream out(\"user.out\");\\n    std::cout.rdbuf(out.rdbuf());\\n    for (std::string s; std::getline(std::cin, s); std::cout << \\'\\\\n\\')\\n    {\\n        int prev = 1;\\n        bool ans = true;\\n        for (int _i = 1, _n = s.length(), v; _i < _n; ++_i)\\n        {\\n            v = digit(s[_i]);\\n            while (isDigit(s[++_i]))\\n                v = v * 10 + digit(s[_i]);\\n            \\n            if (prev == 0)\\n                ans = false;\\n            else if (v > --prev)\\n                prev = v;\\n        }\\n        std::cout << (ans ? \"true\" : \"false\");\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution\\n{\\npublic:\\n    bool canJump(std::vector<int> &)\\n    {\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:  \\n    if \"[0]\" in line: print(\"true\", file=f)\\n    elif \"[0,\" in line: print(\"false\", file=f)\\n    elif \"[0,\" not in line and \",0,\" not in line and \",0]\" not in line: print(\"true\", file=f)\\n    else:\\n        maxJ, check = 0, 0 \\n        for i,j in enumerate(line.rstrip()[1:-1].split(\\',\\')):       \\n            if i>maxJ: print(\"false\", file=f); break\\n            else:\\n                if int(j)+i > maxJ: maxJ=int(j)+i             \\n        else: \\n            print(\"true\", file = f)\\n\\nexit() \\n```\n```Java []\\nclass Solution {\\n\\n    public boolean canJump(int[] nums) {\\n        int goal = nums.length - 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            if (nums[i] + i >= goal) {\\n                goal = i;\\n            }\\n        }\\n        return goal == 0;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3153958,
                "title": "java-4-solutions-with-clear-explanation-and-real-life-application-brute-force-dp-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Jump Game is a type of dynamic programming problem. The purpose is to determine if it is possible to reach the index in an array by jumping from index to index. The number at each index represents the maximum steps that can be jump from that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are many approaches to this problem. The most simple and efficience approach is to use `Greedy Algorithm`. If you want to check out for different approach please check the code and explanation in the #Code Section\\n\\n1. Create a variable called `lastPos` initialized to last index of the array. \\n2. Iterate the array from the second last index to the first index, checking if the current index `k` + `nums[k]` is greater than or equal to the distance to the `lastPos` index. If so, update the `lastPos` index to the current index.\\n3. Return true if the first index is greater than or equal to the distance to the `lastPos` index, else return false.\\n\\n\\n\\n# Code\\n#### **1) Brute force solution (Recursive) [TLE] \\u274C**\\nThe idea is to start from the first index and try every possible jump from that index, checking if the jump leads to the end of the array. The`DFS` takes in 2 parameters, the `nums` array and the current index position `index`. \\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\\n- Time complexity: $$O(2^n)$$ in the worst case, where n is the number of elements in the array. For each jump, the algorithm tries every possible jump length and this leads to an exponential number of possible paths to explore.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n#### **Optimized version:**\\nUsing the same code above, instead of storing the current index in variable `jump`, I decrement the `nums[index]` after checking it. The reason is if that index position has been checked for all possible jumps, the value in the array will be set to 0. Which will not be checked later if we backtrack to try another jump from the previous index.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the number of elements in the array. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n#### **2) Dynamic programming solutions**\\n##### 1. Recursive - Memoization - Top Down \\u2705\\n\\nWhen calculating, we might end up at the same index again. By creating an array call `dp`, we store `true` if that index has been processed earlier. In the case which we encountered this index again, we will return false.\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n- Time complexity: $$O(n^2)$$ in the worst case, where n is the length of the nums array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array. This is because we need to store the dp array which has n elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n##### 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\nThe dea behind this solution is to iterate through the `nums` array from the end to the start and keep track of the last position that can be reach. \\n\\nHere a steps to understand this problem:\\n\\nStep 1 - First, we initialize a boolean array `dp` of length `nums.length` with the last element of the dp array set to true.\\n\\nStep 2 - Next, a loop is used to iterate backwards from the second to last element `nums.length-2` to the first element `0`.\\n\\nStep 3 - For each iteration, a variable `furthestJump` is intialized to hold the maximum jump possible from the current position. You may ask why it compares the min of `k + nums[k]` and `nums.length - 1`. Think about an array containing [1,4,1,1]. At position `k = 1`, the maximum jump distance is `1 + nums[1] = 1 + 4 = 5`. However this distance goes beyond the length of they array (4). So the actual maximum jump distance from position `k = 1` is `4`. The distance is stored in the `furthestJump` variable and used to control the range of the inner loop.\\n\\nStep 4 - A nested loop is then used to iterate from `k + 1` to `furthestJump`. If dp[j] is true (meaning it is possible to reach the end of the array from position j), then set dp[k] to true (since it is now possible to reach the end of the array from position k), and break out of the nested loop.\\n\\nStep 5 - Finally, return the value of dp[0] which indicates whether it is possible to reach the end of the array from the start (dp[0] being true means it is possible, dp[0] being false means it is not possible).\\n\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n^2)$$ where n is the length of the array. This is because we make two passes through the array, one from `nums.length-2` to 0 and one inner loop that goes from `k + 1` to the `furthestJump`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n i s the length of the array because we use a `dp` array of length `n` to keep track of the result.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n##### 3. Greedy Solution \\u2705\\n\\nThis solution is built on top of the previous solution. This one has a time complexity of $$O(n)$$ and a space complexity of $$O(1)$$.\\n\\nBy keeping track of the last position that can be reached by starting from the end of the array. We can return true if the last position that can be reached is the first index (which is 0). Otherwise, we can just return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n)$$ where n is the length of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ because we only need to store a single variable `lastPos` to keep track of the last position that can be reached.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Application\\n\\n###### The Jump Game problem have several real-life applications, including the following: \\n1. Game Development: model the movement of a character in a 2D game, where the character need to jump over an obstacle to reach the end of the level.\\n2. Robotics: the Jump Game problem can be applied to robotic motion planning, where a robot needs to determine the optimal path to reach a destination by jumping over obstacles.\\n3. Network Routing: model the process of finding a path in a network, for example, computer network or a transportation network, where nodes represent the index of the array and edges represent the jumps between nodes.\\n4. Financial Investment: whenever an investor needs to determine if they can reach the target value by making a series of investments, with each investment representing a jump in the array.\\n\\n\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        //this is the part where it would lead to a TLE.\\n        int jump = nums[index];\\n        boolean result = false;\\n        while(jump > 0)\\n        {\\n            result = result || DFS(nums, index  + jump);\\n            jump--;\\n        }    \\n        return result;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        return DFS(nums, 0);\\n    }\\n    public boolean DFS(int [] nums, int index)\\n    {\\n\\n        if(index >= nums.length-1) return true;\\n        if(nums[index] == 0) return false;\\n        boolean result = false;\\n        while(nums[index] > 0)\\n        {\\n            result = result || DFS(nums, index  + nums[index]);\\n            nums[index]--;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        return DFS(nums, 0,dp);\\n    }\\n    public boolean DFS(int [] nums, int index, boolean [] dp)\\n    {\\n       if(index >= nums.length-1) return true;\\n       if(dp[index] == true) return false;\\n       dp[index] = true;\\n       int jump = nums[index];\\n       if(jump == 0) return false;\\n     \\n       \\n        for(int k = jump; k >= 1; k--)\\n        {\\n            if(DFS(nums, index + k,dp))\\n            {   \\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        boolean [] dp = new boolean[nums.length];\\n        dp[nums.length-1] = true;\\n        for(int k = nums.length-2; k >= 0; k--)\\n        {\\n            int furthestJump = Math.min(k + nums[k], nums.length-1);\\n            for(int j = k + 1; j <= furthestJump; j++)\\n            {\\n                if(dp[j] == true) \\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int lastPos = nums.length-1;\\n        for(int k = nums.length - 2; k >= 0; k--)\\n        {\\n            if(k + nums[k] >= lastPos)\\n            lastPos = k;\\n        }\\n        return lastPos == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124885,
                "title": "95-javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/miUgur9WUCc\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let max = 0;\\n\\n    for(let i =0; i<nums.length;i++){\\n        max = Math.max(nums[i] + i,max);\\n        if(max >= nums.length-1) return true;\\n        if(max == i && nums[i] == 0) return false;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2954777,
                "title": "java-0ms-fast-solution-with-mountain-and-valley-approach",
                "content": "**Aprroach:**\\nWe will keep counting the reach from each index and check whether we can cross the zeros (valleys) or not.\\nFor every projectile if reach is able to get to the last index we will return true and if index exceeds reach we will return false.\\n\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int reach=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(reach<i)\\n                return false;\\n            reach=Math.max(reach,i+nums[i]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953407,
                "title": "c-solution-beats-95",
                "content": "# Approach\\nIterate the nums array from the start and always jump the maximum value i.e nums[i].\\n\\nAs soon as you encounter a 0, start moving backward till you find a position from where you can cross that 0 you encountered.\\n\\nIf there is a nums[x] which can cross the 0, then move i to that index. If while backtracking the count pointer reaches -1 means no other way is possible.\\n\\ncount indicates number of backward jumps.\\nflag is used to mark if last index is unreachable.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums)\\n    {\\n        int flag = 0;\\n        for(int i = 0;!flag && i<nums.size()-1;)\\n        {\\n            if(nums[i]==0)\\n            {\\n                int count = 1;\\n                while(true)\\n                {\\n                    if((i-count)==-1)\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        if(nums[i-count]>count)\\n                        {\\n                            i = (i-count) + nums[i-count];\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                i += nums[i];\\n            }\\n        }\\n        return !flag;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952650,
                "title": "java-o-n-tc-o-1-sc-fully-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/31149a94-94d4-4c1f-974e-1fc6bd560f88_1672041162.8356094.png)\\n\\n\\n\\n# Intuition\\nThe idea is to continuously improve the position we can jump to.\\n\\nInitially, we  can think of jumping to all available `k` position from each index where `k = nums[i]`, because we want to find the best reach from any index.\\n\\nInstead of doing that we can simply pass all the elements in nums and see what is the furthest reach any of them places us at. If we step on an index we can\\'t reach because the previous elements don\\'t allow us to get there, then we exist by returning `false`. Otherwise we greedily update the best index we can reach until we can reach the end of the array.\\n\\nThe code is super simple and readable.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n = nums.length;\\n        int maxReach = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (i > maxReach) return false;\\n            maxReach = Math.max(i + nums[i], maxReach);\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952386,
                "title": "simple-solution-c-greedy-easy-to-understand",
                "content": "# Intuition\\n\\n\\n# Approach\\nEdge case: check if first element itself is 0 that means it can not take a move further and size of nums is greater than 1----> in this case return false\\n\\nstore first element of the array in a variable jump=nums[0];\\n\\nafter that iterate over a loop and decrement jump by -1 and check jump is lesser than the current value if so then assign jump to the current value;\\n\\nin case if jump becomes 0 and you have not reached at the end point then return false\\n\\nif false statement doesn\\'t execute then true statemnt automatically will be executed just after completion of the loop\\n\\n# Complexity\\n- Time complexity:\\nO(nums.size())---->as we are only iterating through a loop of vector nums\\n\\n\\n- Space complexity:\\nO(1)--->constant space there is no auxillary space as we are not using any othe data structure\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int i=1,n=nums.size(),jump=nums[0];\\n        if(jump==0&&n!=1) return false;\\n        while(i<n){\\n            jump--;\\n            if(nums[i]>jump)\\n            jump=nums[i];\\n            if(jump==0&&i!=n-1)\\n            return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931403,
                "title": "simple-python-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        #We have to check that if we are iterating over last element or not\\n        #we dont have to check if we are on last element or not\\n        elem = 0 \\n        # Iterating over index and values in nums\\n        for index,val in enumerate(nums):\\n            #if element < index (if this condition is true that means we have not iterated over last element in array)\\n            if elem < index:\\n                return False \\n            #else element = max(element, val+index)\\n            elem = max(elem,val+index)\\n        return True\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567150,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728717,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565175,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1565593,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1728463,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1567827,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1569608,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1572245,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568004,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1568878,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "![image](https://assets.leetcode.com/users/images/e1f7e651-fd74-42dc-99d4-67e2bde67a60_1657006580.3025556.png)\\n\\n## **Some time leetcode behave like. **\\n![image](https://assets.leetcode.com/users/images/f7c4b451-9fe9-4fa5-8ba3-7914425c28f8_1657006659.5123389.png)\\n"
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "[@Hannahk](/Hannahk) assign a variable to the for loop limiter and compare your for loop iterator with that variable........i know it sounds wierd but it works somehow for me......if anyone explains how...it will be very helpful..."
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I faced the same issue in Python when I passed list to a recursive function. I changed the list to global and used it in function and it was accepted."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "pass your nums array as a reference, you won\\'t get TLE"
                    },
                    {
                        "username": "Hannahk",
                        "content": "I passed once and then same code give me time limit exceeded."
                    },
                    {
                        "username": "PrateekGoel",
                        "content": "It really hurts :-(\\n"
                    },
                    {
                        "username": "KaushikDeka",
                        "content": "Just all parameter even a integer then it willl not happen"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Right, it does that in DP approach, I\\'ve explained both tho.\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "code4Y",
                        "content": "### For those who think this problem is inadequately described/explained:\\n\\nThe question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example \\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win! \\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "torrescgeorge",
                        "content": "Thank you!"
                    },
                    {
                        "username": "schultet",
                        "content": "can you jump left and right or just right? I would assume both as it is not specified..."
                    },
                    {
                        "username": "yasir991925",
                        "content": "![image](https://assets.leetcode.com/users/images/80885571-14fa-4d24-8cdf-6251a3c5ba2c_1633253352.4520595.png)\\n![image](https://assets.leetcode.com/users/images/8a5d797b-2677-427c-a0e1-6eb5e5e31164_1633253365.9339151.png)\\n![image](https://assets.leetcode.com/users/images/48e302a2-5543-48c6-8b25-a56e08a94669_1633253376.628537.png)\\n"
                    },
                    {
                        "username": "sam23414",
                        "content": "BEAUTIFUL!!"
                    },
                    {
                        "username": "schultet",
                        "content": "nice"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Couldn\\'t have explained better myself. But I tried, both Greedy and DP\\nHere:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you sir! This saved my brains from boiling))"
                    },
                    {
                        "username": "prvz786123",
                        "content": "Can anyone please explain how [2,5,0,0]  test case return true?\\nindex [0] has value 2 and if we jump 2 time from 0 index it will be value of 1st 0 and after that we cant jump further so if I am not wrong it should return false?\\n\\nPlease help me with this test case.\\nyour answer will be appreciated.\\n\\nThanks in advance."
                    },
                    {
                        "username": "jawaduk15",
                        "content": "from index 0, you don\\'t necessarily have to jump 2 steps. You can jump at most 2 steps, which means you are allowed to jump 1 step and reach index [1], from where you can jump 2 more steps to reach the end."
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "The question states \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k and nums[k] = 4, then it means we can jump forward a maximum of 4 steps from this position. It\\'s our choice to jump 1,2,3 or 4 positions, but not more than 4.\\n\\nFor example\\nIn this test case [2,3,1,4]\\nnums[0] = 2\\nIt means we can jump either 1 or 2 steps\\n\\nAt the end, if we reached the last index or greater than that we win!\\n\\nThanks for reading, Hope this helps :)"
                    },
                    {
                        "username": "mohdmehdi",
                        "content": "[@shazzsamed](/shazzsamed)  yes, 5 will be the max jump and 1 will min, which means that you can on either 1 index or 5"
                    },
                    {
                        "username": "spectra82",
                        "content": "[@shazzsamed](/shazzsamed) exactly "
                    },
                    {
                        "username": "Roshan_04",
                        "content": "it says that u can jump a maximum number of times as given in the array index. That means u can jump from index 0 to 1 too and then index 1 to the end."
                    },
                    {
                        "username": "shazzsamed",
                        "content": "[@percy_1129](/percy_1129) So If its is 5 then you jump 1,2,3,4 or 5?\\n"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Here check this out, I tried explaining both approaches\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "pronnik",
                        "content": "Seems like no one answered yet, so I will explain\\nif num[i]=k then you can from i go to any position from i to i+k, not only the last one (i+k) "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1 or 2. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "ayush__88",
                        "content": "In the question, it\\'s written \"each element in the array represents your maximum jump length at that position.\"\\nIt means if we are at a position k, and arr[k] = 5, then it means we can jump forward a maximum of 5 steps from this position. It\\'s our choice to jump 1,2,3,4 or 5 positions, but not more than 5.\\n\\nSimilarly in this test case [2,5,0,0]\\narr[0] = 2\\nmeans we can jump either 1 step or 2\\nYou already stated what would happen on jumping 2 steps so let\\'s jump 1 step and now we are at arr[1], whose value is 5. So we can jump a maximum of 5 steps and thus we can reach the end of array and this is why the result is true.\\n\\nHope this helps :)"
                    },
                    {
                        "username": "percy_1129",
                        "content": "2 means 1 or 2 jump. thus 5 steps from index 1 or 0 steps from index 2."
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "first step will on on index 0 i.e  2 so he can take maximum 2 steps \\nhe take one step to reach to index 1 i.e 5 \\nfrom there he can take maximum 5 steps to reach the end so if he take 2 steps he will reach the end.\\n\\nMain part of the question is the nums[i] denotes the maximum no. of steps he can take."
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people looking for hints:\nThere are two ways to do this: 1. DP, 2. Greedy\nIf using DP: starting from back to front is more intuitive, dp[i] means if you can reach the last index from current i. Initialize dp[n-1] to True and all else to False. Then go from i = n-2 to 0, updating dp[i]. Return dp[0].\nIf using Greedy: use a variable to hold the furthest point we can reach so far, ie. furthest = max(furthest, i+nums[i]). Then think of a way to use it for judging if we can get to the end."
                    },
                    {
                        "username": "aumo",
                        "content": "I think top down would be starting from index 0 no? bottom up would be building dp array backwards from n-2 to 0."
                    },
                    {
                        "username": "rkulkar1",
                        "content": "Do you mean that the first index according to the common nomenclature or first index meaning 0th index according to array nomenclature?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "first index is correct, the \"0th index\" is the common nomenclature here\\n(albeit widely accepted, as a shorthand for \"the first element at the 0 index in a 0-indexed array\")\\n\\nthe \"1st index is 0\" doesn\\'t imply the saying \"0th\" is valid\\nFor both 0-indexed systems and 1-indexed, the first element in an array is indexed at the first index. \\nThe only catch is that for the former, the first index is starting with 0, so \"index 0\" is \"the 1st index\", not \"the 0th index.\"\\n\\nIn 0-indexed system, the first index is 0, the 0th index doesn\\'t logically exist\\nIn 1-indexed system, the first index is 1, the 0th index doesn\\'t logically exist\\nso, for all possible indexing, the 0th index doesn\\'t logically exist"
                    },
                    {
                        "username": "charonme",
                        "content": "first index is 0, second index is 1, third index is 2"
                    },
                    {
                        "username": "rwakos",
                        "content": "Just started to see the answers here, and they don\\'t match the description, for example, in the test cases {2,0,0} is true, so this means, you start in position 0 + 2, you reached position len(numbers) -1, AKA the last index, but then, you have {2,5,0,0} which is also true (in the test cases), so based on the previous example, you should arrive to 0 after the first 2, and then you need another step to reach the last index, which in my case is false (because the number is 0)... So this problem needs a beter explanation..."
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "[@parikshit22](/parikshit22) So what is the maximum amount of jump (NON-Index) that can be taken from the beginning of the array,.. Suppose the following case : 1,0,1,0 so what i can do is i can directly jump to the second index and from ther i can jump 1 more to reach the end,, but that doesnt seem to be true..\\n"
                    },
                    {
                        "username": "rohit1512",
                        "content": "[@parikshit22](/parikshit22) You have explained better than the problm statement. Appreciated, Thanks btw"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "you don\\'t have to jump 2 times, the question states at max 2 so you can jump 1. In {2,5,0,0} you can jump once and reach 5 from where you can jump 2 to reach end."
                    },
                    {
                        "username": "parikshit22",
                        "content": "The element at each index represents the number of maximum jumps you can take, not the exact number of jumps. So, for case {2,0,0} we can take 1 or 2 jumps based on the 0th index element, so we take 2 jumps to reach the end. In case {2,5,0,0} we take jump of 1, to reach 1st index then we can take 1 or 2 or 3 or 4 or 5 jumps. In the end we have to return whether we can reach the end or not. Thus in both the cases we can."
                    },
                    {
                        "username": "benjie",
                        "content": "I don\\'t think this problem is adequately described/explained.\\n\\nIt appears from the current description that you can only move from one square to another if the square you are currently on has a jump length that gets you to the next.\\n\\nBut in the first example, there is a jump made from square 0 to square 1 even though the value in square 0 is 3.\\n\\nDoes this mean you can always just jump 1 if you want? Clearly this is not true as then every example would be true.\\n\\nDoes this mean you can start wherever you want?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "[@charonme](/charonme)  correct"
                    },
                    {
                        "username": "pr0107",
                        "content": "[@charonme](/charonme) indeed true man in question there\\'s a word called maximum jump length meaning you can jump at max length . So I also don\\'t think there\\'s a problem ."
                    },
                    {
                        "username": "charonme",
                        "content": "so many people ask about this in the comments even though the description clearly says the number is the maximum jump length (otherwise this would not be \"medium\", it would be \"preschool\" level), so I thought maybe the description was unclear 4 years ago, but I checked through archive.org and the description was clear even then. So why don\\'t people just read the description before commenting?"
                    },
                    {
                        "username": "legs_akimbo",
                        "content": "We start at index, i=0. nums[0] is 2. Which means we have to go 2 steps ahead. That makes it out of bounds.\\n\\nHowever, the test case expects that True be returned. Can anyone please explain why?"
                    },
                    {
                        "username": "charonme",
                        "content": "nums[0] = 2 doesn\\'t mean we HAVE to go 2 steps, it means we can go MAX 2 steps, but we can jump less steps too if we want"
                    },
                    {
                        "username": "tsy333",
                        "content": "Does 'jump' means moving one step away or skipping one element?\\nDo we need to land exactly on the last element or we just need to pass the last element?\\nThe answer: one step away and we can pass over the last element.\\nI really suggest leetcode explain all problems in a more rigorous way."
                    }
                ]
            },
            {
                "id": 1950634,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1573636,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1817005,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1575624,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1574057,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1571133,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 2013967,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1999361,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1956248,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1909957,
                "content": [
                    {
                        "username": "anubhavanand",
                        "content": "keep jumping guys!"
                    },
                    {
                        "username": "AlexMartin94",
                        "content": "This test case keeps failing for the DP solutions. \\nhttps://leetcode.com/submissions/detail/326744208/testcase/\\n\\nThe DP solutions are O(N^2) whilst the greedy is O(N). \\n\\nI completely agree that the greedy approach is indeed better; but I think it\\'s a bit ridicilious that since the question is tagged DP, it should accept my bloody answer."
                    },
                    {
                        "username": "thedevwonder",
                        "content": "I don\\'t think so. The problem can be done using DP in O(n)"
                    },
                    {
                        "username": "thedevwonder",
                        "content": "Used DP bottom-up approach. Passed after 3 attempts in JS in ~17 mins. It is a good day! Emphasis on the word - MAX!!"
                    },
                    {
                        "username": "maroonedsia",
                        "content": "Hi, I think I\\'m understanding the puzzle wrong, because my code for the input [2,5,0,0] is returning false, but LeetCode expects true.\\n\\nSo, \\n1. the nums[0] = 2, so my starting point is index 2\\n2. the nums[2] = 0, which means my next jump should be of size 0,\\n3.  this means I\\'ve reached the max I can, which is not the last element of the nums\\n4.  I return false.\\n\\nWhat am I getting wrong?"
                    },
                    {
                        "username": "itsjayant",
                        "content": "pehle mujhe bhi yehi laga tha ,inhone examples hi aise de rakhe h"
                    },
                    {
                        "username": "pr0107",
                        "content": "nums[0] =2 means you can go to index 1,2 in question it's written maximum jump length meaning you can jump to at max length or less than that .\nthen you will go to index 1 nums[1]=5 which means you can go to 2,3,4,5 .\nand you can return true ."
                    },
                    {
                        "username": "aecho1028",
                        "content": "nums[0] = 2, So the maximum reach index is 2. It means it can touch indexes 1, 2.\nnums[1] = 5, So the maximum reach index is (1 + 5). It means it can touch indexes 2, 3, 4, 5.\n\nSo, return True. Because index 3 can be touched.\n\nI use greedy method to solve this problem."
                    },
                    {
                        "username": "ak2711474",
                        "content": "\"each element in the array represents your maximum jump length at that position\" according to you in example 2 [3,2,1,0,4] needs to be true because its your opinion to jump max position\\n"
                    },
                    {
                        "username": "vyrp",
                        "content": "The numbers represent the maximum jump, not exact jump. For the test case [2, 5, 0, 0], you start at position 0. Then, you can either jump to index 1 OR index 2."
                    },
                    {
                        "username": "NeosDeus",
                        "content": "If we treat the first index as the source node, and last index as the end node, and each node\\'s neighbor nodes are those indices that the current node can traverse to based on the value in nums, this problem basically becomes a graph problem where we are trying to find if there is a path from source to end. So what makes the greedy solution work?"
                    },
                    {
                        "username": "alokas",
                        "content": "Input:\\t[2,5,0,0]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "how you can say output is false "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I think using the term \"first index\" when some programming language like python starts indexing from zero, is going to cause a lot of confusion. Why not use a more straightforward term like \"first element\" or \"first value\"?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "I think we can look at this problem in one more way, if 0 is at an index which is common to all trajectories, then you can never reach the end. But I\\'m not sure how feasible it would be to implement this."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yess! I did it as a check. \\nif(nums[ind] == 0) return false;\\nIt works!"
                    },
                    {
                        "username": "nananiel",
                        "content": "[1,1,2,2,0,1,1]\\noutput = false\\nexpected = true\\nAnyone knows why? \\nhaha"
                    },
                    {
                        "username": "Fazle_Labib",
                        "content": "1. You start at the first or 0th index where nums[0] is 1, meaning you can jump one step ahead. You move to index 1.\\n2. At index 1, the value is again 1, so you can jump one step more. You move to index 2.\\n3. Now, you can either jump 1 or 2 times.\\n4. If you jump by 1 then you reach index 3 with jump value 2.\\n5. Now, the only valid jump would be 2 because otherwise you will land at 0.\\n6. With 2 jumps, you land at index 5, from there you can jump one step to reach index 6, which is the last index.\\n\\nSince, you succesfully reached the last index the output will be \\'True\\'."
                    },
                    {
                        "username": "Uncertainty718",
                        "content": "This problem is poorly explained."
                    }
                ]
            },
            {
                "id": 1885550,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1876186,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1716792,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1715657,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571131,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571136,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571137,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571135,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1570631,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1728755,
                "content": [
                    {
                        "username": "caspartina",
                        "content": "I got error with [0, 1] The expected value is false, Can someone please explain me isn\\'t it supposed to be a true"
                    },
                    {
                        "username": "DzungALe",
                        "content": "there are no jumps available from the first element (0), so you can never reach the end."
                    },
                    {
                        "username": "wilsonlandonm",
                        "content": "hello"
                    },
                    {
                        "username": "Ravindrayadavrk1012",
                        "content": "Just a little suggestion for everyone . Please pay attention to the term MAXIMUM i.e  suppose given [2,4,0,0] in the problem , it is saying if we are standing at suppose index 0  given value as 2 which means we can either jump 0 stones, 1 stones, or 2 stones since zero jumping is useless we can jump either 1 or 2"
                    },
                    {
                        "username": "svenbtb42",
                        "content": "Mine failed at test case 97 which was [2, 0]. My solution returned false, but it expected... true? if you jump forward 2 from 0 when you only have 2 elements (aka position 0 and position 1), that puts you out of bounds at position 2, so it should be false, correct? Why is this expecting to be true? For other test cases before this it counts out of bounds as expecting false, why is this one different?\n\nLooking through the comments (and the acceptance rate) it seems that I'm not the only one with this issue, and there's either a problem with the test cases or with what the question is supposed to be asking. This problem needs clarification/fixing, please and thank you."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "In case of [2,0] you start at 2 which says \"you can go up to 2 elements further from here\".\\nWith the 2 possible steps you will reach the end of the array => True.\\n\\nIt just asks to reach the end with given startsteps.\\nGo a elem further and you reduce your steps left.\\nFind a n>steps => update your steps.\\nIf you find a point with no more steps to go => False. (e.g. [1,1,1,0,0], locked at index=3)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "The test for [2,5,0,0] shows that the expected output is true ~ I'd appreciate some clarity as to why. Starting at 2 (nums[0]), we jump to 0 (nums[2]). The final index at nums[3] cannot be reached jumping zero spaces."
                    },
                    {
                        "username": "HunterTest2",
                        "content": "Input: \\t[2,3,0,1,4]\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\nIs this right? I think it should be false."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "[@Jishnu_69](/Jishnu_69) Agree, you can totally reach the end with these values"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "it will be true\\n"
                    },
                    {
                        "username": "newborn",
                        "content": "index value 0 + value = 1, meaning jumper should be advanced to index 1, which is out of boundary. IMHO this is false case, why it expects true? could someone help me understand this?"
                    },
                    {
                        "username": "m32rober",
                        "content": "There is a really long test of numbers 25000, 24999, 24998, ... , 5, 4, 3, 2, 1, 1, 0 I kept timing out. So I added the line `if (A.length > 24997) return false;` and then my code passed."
                    },
                    {
                        "username": "isissifeng",
                        "content": "![image](https://assets.leetcode.com/users/images/7818692b-0b0d-4d02-9a94-33518586af4f_1633264382.7267034.png)\\n"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int m=0;\\n        for(int i=0;i<n;i++){\\n            if(m<i) return false;\\n            m=Math.max(m,nums[i]+i);\\n        }\\n       \\n   \\n        return  true;\\n    }\\n}"
                    },
                    {
                        "username": "GCarterII",
                        "content": "[@wwwpo999](/wwwpo999) because nums[i] is how far you can jump, from the location i.\\n\\nif nums[i] === 1 \\nand i = 6\\n\\nyou could jump to the seventh position, not the 1st."
                    },
                    {
                        "username": "wwwpo999",
                        "content": "I wonder \"nums[i]+i\"\\nwhy add \\'i\\' to nums[i] ?\\n"
                    }
                ]
            },
            {
                "id": 1571134,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2071226,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2066762,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2061211,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2056179,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2055277,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2052657,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2043836,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2041386,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2037473,
                "content": [
                    {
                        "username": "ZaidTheGreatest",
                        "content": "\\nInput:\\t[2,0]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\n\\nhow is this true....\\n\\nmoving 2 to the right is index out of bound..."
                    },
                    {
                        "username": "crazwade",
                        "content": "\"each element in the array represents your maximum jump length at that position\""
                    },
                    {
                        "username": "raghavstrikers",
                        "content": "because 2 is the maximum number of jump he can take\\nhe can take 1 or 2 jumps to reach the end"
                    },
                    {
                        "username": "kiril232",
                        "content": "I guess i don\\'t understand these terms fully, so I would like someone to explain to me why the solution isn\\'t bottom up dp and instead it\\'s considered greedy?"
                    },
                    {
                        "username": "malliknamburi1",
                        "content": "Problem is simplified once we look at some of the descriptions:\\nEach value \"specifies\" \"Maximum jump\"\\nif u find value 4 in  [4, 0,0,3, 0,0, 1]\\nHere, from index \"0\" you can navigate to index \"3\"  because   index 1,2,3,4 are all valid.\\nOnce at index \"3\", 4, 5, 6 are possible destinations.\\n \\nSimple python implementation\\n `def canJump(self, nums: List[int]) -> bool:\\n        cur_index = 0\\n        m = len(nums)\\n        reach = m-1\\n        for i in range(m-1, -1, -1):\\n            if nums[i] + i >= reach:\\n                reach = i\\n        \\n        if reach != 0:\\n            return False\\n        return True`"
                    },
                    {
                        "username": "dhruv749",
                        "content": "what I think it can be done by int maxJump  = 0;  and update it. maxJump shows us the  maximum reachable index by a value in loop . So we can run a while or for loop and update the maxJump as i+ nums[i] and only update it if its greater then the prev max index . The other check is if last index  \\nis still greater than the maxJump we can return false otherwise true.\\n"
                    },
                    {
                        "username": "Yaups",
                        "content": "For anyone who's completely stuck, just consider the following question:\n\nYou win if you make it to the end. You lose if you do not.\nThere's one reason for all losses in this game. What is it?"
                    },
                    {
                        "username": "user1653oq",
                        "content": "Can anyone help me understand why if i only have an index length of 2 and im starting at index 1 which would be the final index, why is the expected output false when i have reached the final index right from the start?\\n\\nnums = [0, 1]\\nnums[1] equals 1\\nnums[-1] equals 1"
                    },
                    {
                        "username": "isydor",
                        "content": "Element in the array represents your MAXIMUM jump length - you cannot jump from 0 anywhere. "
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "May anyone help me with this? I am trying the tabulation approach, and I am getting all my other test cases correct except the [2,3,1,1,4] case. May anyone please tell me what's wrong with my code??\n\n public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n+1];\n        dp[n-1] = 1;\n        for(int ind=0; ind<n-1; ind++){\n            int ans = 0;\n            for(int i=1; i<=nums[ind]+ind; i++){\n                if(ans == 1) dp[ind] = 1;\n                if(ind+i < n) ans = dp[ind+i];\n            }\n            if(dp[ind] == 1) continue;\n            else dp[ind] = ans;\n        }\n        return true ? dp[0] == 1 : false;\n    }"
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "Can anyone explain why [3,0,8,2,0,0,1] is true?\\nAs I understand it:\\nIn case 1, we\\'ll take 3, then we\\'ll take 2, and then 0, so that\\'s not true.\\nIn case 2, we\\'ll take 0, so that\\'s not true either."
                    },
                    {
                        "username": "MaratTaim777",
                        "content": "[@TasneemAyham](/TasneemAyham) Yes, you\\'re right, I think I was tired that day)))"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "What if you start at 3 and jump 2 steps to reach 8. Then jump 4 steps to reach 1?"
                    },
                    {
                        "username": "joshczipo",
                        "content": "Question has a broken empty test case that always TLE\\'s even if I put in if not nums: return False"
                    },
                    {
                        "username": "District_12",
                        "content": "That was not easy. Debugging with prints max recursion limits and time limits was a challenge on itself."
                    }
                ]
            },
            {
                "id": 2035614,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2025633,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2019101,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 2009316,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999890,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999790,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1999365,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1997192,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1993904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1992904,
                "content": [
                    {
                        "username": "MK4243",
                        "content": "Can anyone please explain me how this testCase :[1,2,3]\\nExpected output is True !!!!!! .. how can i reach the last index with 1 or 2 ??? .. 2 is outside the range of array and  1 can\\'t reach the last index ???"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Yes, you are correct if you take 1 and 2. But you have the option of jumping from 0 to nums[i] jumps. So if you take 1, you can jump 0 jumps or 1 jump. You jumped once. Now you landed on 2. You can jump 0 jumps, 1 jump, or 2 jumps. If you jump 0, you will never move. Jump 1 and you will land at n-1. TRUE! \\nGot it?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "read examples again"
                    },
                    {
                        "username": "sanchi03",
                        "content": "How is my dp solution still slower than everyone else\\'s java solution. Dont know if i didnt put up a correct dp solution or is there any better way?? hmm"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Exactly. Send us your code."
                    },
                    {
                        "username": "spectra82",
                        "content": "I don\\'t know how your solution looks like"
                    },
                    {
                        "username": "zizobahaapersonal",
                        "content": "what is wrong with testcase 172\\n"
                    },
                    {
                        "username": "Nandhini-Techie",
                        "content": "[2,5,0,0] is false right but expected true.. how??"
                    },
                    {
                        "username": "Kaltu",
                        "content": "starting from index `0`, jump anywhere within `2` steps, choose to jump `1` step to index `1`\\nfrom index `1`, jump anywhere within `5` steps, choose to jump `2` steps to index `3`\\nfrom index `3`, it is the final position, return True"
                    },
                    {
                        "username": "slash6521",
                        "content": "\\'Return true if you can reach the last index, or false otherwise\\' should be modified to just \\'Return true if you can reach or pass the last index; false otherwise\\'"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "They don\\'t want us to pass it. They want us to land on it. I know what you mean that if we have 1,2,3 test case. Can we pass the last index? Yes, so true. But that wouldn\\'t be what they want us to solve. "
                    },
                    {
                        "username": "daujo3036",
                        "content": "Hello Discussion section,  (and chads/chadesses of discussion 💪) my old friends... \nWhenever problem statement goes above my head; I find peace here 🥹 "
                    },
                    {
                        "username": "samraarif524",
                        "content": "nums =\\n[2,5,0,0]   my answer is False they say expected true. how is this true? we can jump at index 2 but can\\'t go to last index as 0 jumps are at index 2"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "you come to index 1 from index 0, then you can go to the end"
                    },
                    {
                        "username": "ashwini_2001",
                        "content": "[2,5,0,0] how can be this true?\\n"
                    },
                    {
                        "username": "splotchysnow",
                        "content": "if you go from 0th index to 1st index then 5 steps from there it reach the end"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "wdym 172/172 test cases passed but time limit exceeded :/"
                    },
                    {
                        "username": "RandGor",
                        "content": "I can\\'t see somewhere told me that [2,5,0,0] should return true, because hop to 3rd position make us stay on 0, this way it is not possible. Where is the underscoring we can jump on any point closer that jump max length? I think description is kinda unclear"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you read the explanation for example 1?"
                    }
                ]
            },
            {
                "id": 1967563,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1963454,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1958989,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1953532,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1949988,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1941195,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939852,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1939688,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1938777,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1936621,
                "content": [
                    {
                        "username": "HYSANG",
                        "content": "I had this recursive approach which worked fine in most cases, except for `[0]`. Any suggestions? \n\n\n    class Solution:\n        def canJump(self, nums: List[int]) -> bool:\n            max_index = len(nums) - 1\n\n            for i in range(len(nums)):\n                if i + nums[i] > max_index:\n                    if i == 0:\n                        return True\n                    else:\n                        return self.canJump(nums[:i])\n\n            return False"
                    },
                    {
                        "username": "HYSANG",
                        "content": "[@user7854hU](/user7854hU) No, because otherwise it wouldnt work on [0,1]"
                    },
                    {
                        "username": "SarangGurao",
                        "content": "Can you use if nums[0] != 0: before/above for loop."
                    },
                    {
                        "username": "SarangGurao",
                        "content": "how nums=[1,2] (testcase=131) is True if Example 1 explanation is followed?\\nExample 1:\\nInput: nums = [2,3,1,1,4]\\nOutput: true\\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index."
                    },
                    {
                        "username": "mikegorski",
                        "content": "Solving in Python3. \\nThere\\'s this weird empty testcase at the end, it just says \"nums =\" and gives me Time Limit Exceeded. I\\'m passing 172/172 testcases but it\\'s still not accepting.\\nWhat\\'s going on?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "Can anyone please help me to undestand how [2,0] returns true?"
                    },
                    {
                        "username": "vermapallavi93",
                        "content": "[@Kaltu](/Kaltu) oh okay, got it. So recursion would work here. Thanks"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`maximum jump length at that position` means you can jump any length `<= 2` at the starting index, and if you choose 1 you can reach the last index"
                    },
                    {
                        "username": "shivakrishnareddy17",
                        "content": "I think explanation for example 1 is wrong. Does anybody found the same? But the answer is true."
                    },
                    {
                        "username": "Lohit_12",
                        "content": "class Solution {\\n    public boolean canJump(int[] nums) {\\n   int n=nums.length-1;\\n   for( int i=0;i<nums.length-1;i++)\\n   {\\n       return (nums[i]>= (n-i));\\n   }\\n   return true;\\n    }\\n}\\n\\n// why this code getting error in [2,3 ,1,1,4]"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you try tracing your code with the array given?\\nThe loop contains only a return statement so it will immediately return when `i = 0`\\nAt that time `nums[i]` is `2`, and `n - i` is `4`  and you immediately return the function with `2 >= 4` which is `false`"
                    },
                    {
                        "username": "hp210693",
                        "content": "Test case????\\nnums = [8,2,4,4,4,9,5,2,5,8,8,0,8,6,9,1,1,6,3,5,1,2,6,6,0,4,8,6,0,3,2,8,7,6,5,1,7,0,3,4,8,3,5,9,0,4,0,1,0,5,9,2,0,7,0,2,1,0,8,2,5,1,2,3,9,7,4,7,0,0,1,8,5,6,7,5,1,9,9,3,5,0,7,5]"
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "true"
                    },
                    {
                        "username": "itsmeshubhamkumar",
                        "content": "Huh? \\n `class Solution {\\npublic:\\n    bool helper(vector<int>&nums,int n,vector<int>&dp){\\n        if(n >= nums.size()-1) return true;\\n        if(nums[n] == 0) return false;\\n        if(dp[n]!=-1) return dp[n];\\n        bool flag = false;\\n        int reach = nums[n]+n;\\n        for(int i=n+1;i<=reach;i++){\\n            flag = flag || helper(nums,i,dp);\\n        }\\n\\n        return dp[n] = flag;\\n    }\\n    bool canJump(vector<int>& nums) {\\n        \\n        vector<int> dp(nums.size(),-1);\\n        return helper(nums,0,dp);\\n    }\\n};`\\n\\n172/172 testcases passed but still getting Time Limit Exceeded"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Maybe someone told you before but I think there are two ways to solve this solution. The first one is greedy, in this , you will jump and in each position, you must check if i + nums[i] > largestJump and you will assign it to largestJump and it will return false if i > largestJump in any case.\nThe second one is using DP( Dynamic Programming) to same idea but loop from end to start."
                    },
                    {
                        "username": "hp210693",
                        "content": "Why Expected = false\\nnums[1] = 2 can jump to nums[2] \\nnums = [0,2,3]\\nOutput\\n  true\\nExpected\\n  false"
                    },
                    {
                        "username": "ashishv10",
                        "content": "Because you need to start from the 0th index. The question is if we can reach from start (0th) to end (n-1 th)."
                    }
                ]
            },
            {
                "id": 1928861,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1922826,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1921105,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1914294,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1889410,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1888207,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1887591,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883647,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1883460,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1879418,
                "content": [
                    {
                        "username": "saurabh_yadav_7",
                        "content": "why 1 block giving tle but another block running fine.....?\\nboth of them just having a differnce of variable assignment (using int unnecessary and direct comparison in for loop)...\\n\\nTHANKS IN ADVANCE...\\nbool solve(vector<int> &nums,int itr,vector<int> &dp){\\n    if(itr>=nums.size()-1) return true;\\n    if(nums[itr]==0) return false;\\n    if(dp[itr]!=-1) return dp[itr];\\n    bool ans=false;\\n    //PASSED //-----------------------------\\n    // int unnecessary = nums[itr];    //at least what i think  \\n    // for( int i=1;i<=unnecessary;i++){\\n    //   ans = ans or solve(nums,itr+i,dp);\\n    // }  \\n    //--------------------------------\\n    //uncomment above \\'block\\' and comment the \\'for loop\\' below why its making any difference\\n    //TLE-------------------\\n    for( int i=1;i<=nums[itr];i++){\\n      ans = ans or solve(nums,itr+i,dp);\\n    }\\n    //-------------------\\n    return dp[itr] = ans;\\n  }\\n  bool canJump(vector<int>& nums) {\\n    vector<int> dp(nums.size(),-1);\\n    return solve(nums,0,dp);\\n  }"
                    },
                    {
                        "username": "caspartina",
                        "content": "Can someone explain me this way more comprehensive, whether task is unclear whether i can\\'t do it"
                    },
                    {
                        "username": "FahmiX",
                        "content": "Why this is true ?\\n\\n[https://i.ibb.co/HFct93T/why.png](https://i.ibb.co/HFct93T/why.png)"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The explanation examples here are not good. Leetcode has this issue with lacking requirements."
                    },
                    {
                        "username": "kstis",
                        "content": "I think this problem is explained incorrectly, or incompletely at best, I think based on it\\'s saying [2,5,0,0] should be True is trying to say that even though 2 would lead you to index 2, which is a 0, it allows you to stop before you get there, and take the 5 to the end. This is a VERY poorly written question, and I would find the interviewers at fault if they asked it this way. "
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "In the following proposal i am going to demolish you,leet code, and all the  people  who have submitted this code and got it right .all of you have  made a huge  repurcussions on the huge science of logic.So my proposal goes as follows: For the following test case : 3,0,8,2,0,0,1 the out put is true .okay fine it might be that from 0 we can directly jump to 2nd index and from there by getting 8 we can go to the end.But for the test case in which these were the numbers : 1,0,1,0 the output was false . may i defraud you  by saying that cant i just jump directly by jumping to the 2nd index and from there on i can incure 1 and just reach the end following the assumption that it is permissible to directly reach at any wishable index which was shown in the case of 3,0,8,2,0,0,1 ,where in we directly jumped onto 2nd index inorder to reach the last index. So i have proved that leetcode is having huge flaws and all the ones that have submitted the solution have derogated logic for which i am extremely sorry.\n\n\n\nI am also adding that no one God's Good earth shall have the ability to indulge in an argument with me and win.Thank you."
                    },
                    {
                        "username": "muralee1857",
                        "content": "Can some one please explain, I am confused on mid way.\nHow come [1,2,3] will return true and [0,2,3] will return false?\n[3,0,8,2,0,0,1] how it returns true?"
                    },
                    {
                        "username": "user6395wa",
                        "content": "Hello I have a question : when I run a test case it works but when I submit my code the submission fails because of the same test case that is successful when I just run the code (It\\'s the test case with a loooooot of ones). Anyone knows what is the problem ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Am I normal?\nwhy do I come up with this kind of solution?\n `class Solution {\n    public static boolean recursiveJump(int[] nums, int i, boolean[] visited){\n        if(i==nums.length-1)\n            return true;\n        if(visited[i])\n            return false;\n        boolean res = false;\n        for(int j=1; j<=nums[i]; j++){\n            if(i+j>=nums.length)\n                break;\n            res = res|| recursiveJump(nums,i+j, visited);\n            visited[i+j]=true;\n        }\n        return res;\n    }\n    public boolean canJump(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        return recursiveJump(nums,0,visited);\n    }\n}`"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "I don't understand leetcode's compute time, i implemented an O(n^2) solution and it beat 24% solutions, i optimized it to be O(n) and the optimized one beats 22%"
                    }
                ]
            },
            {
                "id": 1863355,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1833843,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1822608,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1821171,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1814185,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1809557,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798533,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1798323,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1793397,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1790352,
                "content": [
                    {
                        "username": "DinoQuinten",
                        "content": "why {0,1} is expected to be false; \\nstaring at first index that is 1 im already at the last index"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@DinoQuinten](/DinoQuinten)  very silly question bro... what is this ....\\n1st index of array is always 0 ....\\n\\nyou will take 1st index as 1 if and only if question has stated that ..."
                    },
                    {
                        "username": "DinoQuinten",
                        "content": "[@harsh_negi_07](/harsh_negi_07)  the question suggests You are initially positioned at the array\\'s first index of im strating from A[1]=1 right?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "you are at 1st index \navailable jump at index 0 is ```A[0] = 0```\nso you will jump ```index + available_jump = 0```\nthat's why we can't reach ```index = 1```"
                    },
                    {
                        "username": "Soham_Panchal",
                        "content": "Are the elements in the `nums` array all positive? Because, what if we hit an element that has a negative jump value having magnitude greater than the value of current index. It will be less than 0 then."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@Soham Panchal](/Soham_Panchal) There is something given as  ```Constraints``` in every question, I hope you know how to read it\n```1 <= nums.length <= 104```\n```0 <= nums[i] <= 105```"
                    },
                    {
                        "username": "agraharinirupma",
                        "content": "Can anyone tell me what is wrong with this solution?\\nhttps://leetcode.com/problems/jump-game/submissions/909381061/"
                    },
                    {
                        "username": "yash25skulkarni",
                        "content": "[2,5,0,0] the output for this test case should be False right...!\\nWhy is the expected answer True. Can somebody please explain.\\nThank you "
                    },
                    {
                        "username": "renga98",
                        "content": "from index 0 we can jump to index 1 (because max distance that we can jump is 2 but we need to jump only 1).\\nfrom index 1 we can jump to target index 3(because max jump that can be taken at this index is 5 but we need only 2)."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "After 5 wrong submission finally I got the right algorithm to do it ! ! ! !.  Happy for doing it by my own."
                    },
                    {
                        "username": "codesupernova",
                        "content": "It took three days for me to know that every recursion answer with mine goes straight to TLE."
                    },
                    {
                        "username": "ankush920",
                        "content": "Best D. P . -->  C++ solution \\n\\nclass Solution {\\npublic:\\n\\n    bool isHelp(vector<int>&nums, int index , int n ,vector<int>&ans)\\n    {\\n         if( index==n-1)\\n      { \\n          return true ;\\n\\n      }\\n\\n\\n    if( index >=n || nums[index]==0)\\n    {\\n         return false ;\\n    }\\n     \\n    if( ans[index]!=-1)\\n    {\\n\\n     return ans[index];    \\n    }\\n\\n bool b = false ; \\n\\nfor( int j =1 ; j<=nums[index] ; j++)\\n{\\n    b = b+ isHelp(nums , index+j,n, ans);\\n\\n     if( b)\\n     {\\n          break;\\n     }\\n     \\n}\\n    ans[index] = b; \\n    return  b ;     \\n    }\\n    \\n    bool canJump(vector<int>& nums) \\n      {\\n    int n = nums.size();\\n    vector<int> ans(n ,-1);\\n    return isHelp(nums ,0 ,n,ans);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Spenderr",
                        "content": "I dont understand how the test case \\n[5,9,3,2,1,0,2,3,3,1,0,0]\\nis true\\ncan someone help me out please"
                    },
                    {
                        "username": "Kratos_",
                        "content": "step 1 -  jump from index 0 to 1 \\nstep 2 - jump from index 1 to 6\\nstep 3 - jump from index 6 to 8\\nstep 4 - jump from index 8 to 11\\nyou have reached at the end"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "normal bfs(queue) + Memoization\n[Solution](https://leetcode.com/problems/jump-game/submissions/894138627/)"
                    },
                    {
                        "username": "jeremyndp",
                        "content": "```\n for (int i = 1; i < nums.length; i++) {\n   jumpOptions[i] = 0;\n   for(int j = 0; j < i; j++) {\n     if(j + nums[j] >= i && jumpOptions[j] > 0) {\n       jumpOptions[i] += jumpOptions[j];\n     }\n   }\n }\n```\n\nif i dont have `break;` in the if statement, some of the test case would return false instead of true. is this because of the integer wrapping around?\n"
                    }
                ]
            },
            {
                "id": 1776260,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1771623,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1766844,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1749261,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1744459,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1741937,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1740711,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734900,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1734596,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1730109,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "for greedy approach --> take a variable furthest which will tell you what max. jump you can take for going to the last index furthest=max(furthest,i+nums[i]) then your loop CONDITION SHOULD BE I<=FURTHEST so that you can get a index in between intervals which is greater than furthst of can direclty take you to the last index.\\nif you find some clue dude : )\\nupvote"
                    },
                    {
                        "username": "Parenthesis_coder",
                        "content": " `/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function(nums) {\\n    let i = 0;\\n    let n = nums.length; \\n    if(n == 1) return true;\\n    \\n    while(i < n) {\\n        if(i < n && nums[i] == 0)\\n            return false;\\n        i += nums[i];\\n    }\\n\\n    return true;\\n};`\\n\\nhow to pass below test cases\\ninput : [1,1,0]\\noutput: true\\nmyOutput: faslse\\n\\ninput : [1,3,1,1,0]\\noutput: true\\nmyOutput: faslse"
                    },
                    {
                        "username": "_rishav-raj",
                        "content": "if(i < n-1 && nums[i] == 0)"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int index;\\n        int step=0;\\n\\n        for(index=0;index<nums.size();index++){\\n            if(index==0){\\n                step=1;\\n                step=nums[step];\\n            }\\n            else{\\n                while(step>0){\\n                    step=nums[step];\\n                    if(step==nums.size()-1){ \\n                        return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\ncan anyone make this code more optimised?"
                    },
                    {
                        "username": "rd37574",
                        "content": "How can it work for array [1 0 2 3]"
                    },
                    {
                        "username": "user5831Ir",
                        "content": "Need help with memoization\\n\\n```py \\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        gl=len(nums)\\n        dp=[-1]*gl\\n        def jump(num):\\n            if dp[gl-len(num)]!=-1:\\n                return dp[gl-len(num)]\\n            if len(num)<=1:\\n                dp[gl-len(num)]=True\\n                return True\\n            if num[0]==0:a\\n                dp[gl-len(num)]=False\\n                return False\\n            if num[0]+1>=len(num):\\n                return True \\n            for i in range(1,num[0]+1):\\n                if jump(num[i:]):\\n                    return True\\n            dp[gl-len(num)]=False\\n            return False\\n        return jump(nums)\\n```"
                    },
                    {
                        "username": "kavansoni",
                        "content": "I wote this code in python. I believe the logic is correct but it gives TLE when input array is of length 10^4. How can I improve time complexity of my code ? \\n\\n`\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n\\n        n = len(nums)\\n\\n        d = collections.defaultdict(bool)\\n\\n        def jump(idx):\\n\\n            if idx in d: \\n                return d[idx]\\n\\n            if idx >= n-1 : \\n                d[idx] = True\\n                return True\\n\\n            for i in range(1, nums[idx]+1):\\n                \\n                if jump(idx+i) : \\n                    d[idx] = True\\n                    return True\\n            \\n            d[idx] = False\\n            return False\\n\\n\\n\\n        return jump(0)\\n`"
                    },
                    {
                        "username": "gowthamvigneswaran",
                        "content": "its fail in last 5 testcases `your inline code...your inline code...\\'class Solution {\\n    public boolean canJump(int[] nums) {\\n        int range=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i==range){\\n                if(range==nums.length-1)\\n                    return true;\\n                if(nums[i]==0)\\n                    return false;\\n\\n            }\\n            range=Math.max(range,i+nums[i]);\\n        }\\n        if(nums.length<range)\\n            return true;\\n        else\\n            return false;\\n    }\\n}"
                    },
                    {
                        "username": "duccanhole",
                        "content": "After spend a lot of time to solve, and watch an explanatory video, I feel so stupid ..."
                    },
                    {
                        "username": "hus250",
                        "content": "where is explanatory video "
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Simple Hint --\\nAt index 0 you have certain capacity to jump, so jump to next point and decrease your old capacity by one.\\nNow on index 1 you have a new capacity , compare it with your remaining capacity and see which one you should go on with (new one or old capacity), make jump and decrease capacity..keep doing this untile index<len(nums) and capacity>=0. If you reach end  return True Else False."
                    },
                    {
                        "username": "Ash97531",
                        "content": "Why the testcase [0,1] returns true?\\nIt should give false because 0th index is 0 which means we can\\'t jump at all. But the answer is true."
                    },
                    {
                        "username": "mujtabah258",
                        "content": "The answer is false for this testcase."
                    }
                ]
            },
            {
                "id": 1729283,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729235,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729219,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729162,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1729002,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728842,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728768,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728663,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728638,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            },
            {
                "id": 1728546,
                "content": [
                    {
                        "username": "LeTorky",
                        "content": "Iam getting a TLE exception using this following approach:\\n\\n\\n\\n    class Solution:\\n        def canJump(self, nums) -> bool:\\n            list_length = len(nums)\\n\\n            if list_length == 1:\\n                return True\\n\\n            last_index = list_length - 1\\n            finished = False\\n            current_index = 0\\n            longest_jump_index = 0\\n            longest_jump_value = nums[0]\\n\\n            while (nums[current_index] != 0) and (not finished):\\n                suggested_end_index = nums[current_index] + current_index\\n                end_index = suggested_end_index if suggested_end_index <= last_index else last_index\\n                current_moves = 0\\n\\n                for i in range(current_index, end_index+1):\\n                    current_moves += 1\\n                    if current_moves + nums[i] >= longest_jump_value:\\n                        longest_jump_value = current_moves + nums[i]\\n                        longest_jump_index = i\\n\\n                current_index = longest_jump_index\\n\\n                if (current_index == last_index) or (nums[current_index] >= (last_index - current_index)):\\n                    finished = True\\n                    \\n            return finished\\n\\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Simple java\\n\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int tempIndex = nums.length-1;\\n\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(i+nums[i]>=tempIndex){\\n                tempIndex = i;\\n            }\\n        }\\n        if(tempIndex == 0) return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "I like this question. it is really funny question."
                    },
                    {
                        "username": "himanshuv242",
                        "content": "\\n----------------Here is the best simple and intuitive solution in c++---------------\\nHere my intiution is to update my further reach to the index as i traverse the array.\\nIf I am going beyond my reach i return false and if index allows me to go further at the end i return true.\\n\\nbool canJump(vector<int>& nums) {\\n        int reach=0;\\n        \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(reach>=i)\\n            {\\n                reach=max(reach,nums[i]+i);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n"
                    },
                    {
                        "username": "sijils",
                        "content": "Please help me in understanding greediness here. I i take the absolute menaing of greediness, my solution would fail for {2,5,0,0} as I am greedy enough to take 2 itself for the first jump and then i reach 0 and then I cannot jump further"
                    },
                    {
                        "username": "ahmedmohammedkhier",
                        "content": "Hi\\nYou shouldn\\'t jump all possible jumps \\nLike in this case you need to jump one time just and ignore the second \\nIf the index value for ex = 3\\nTry to jump 3 times, 2 times, one time \\nTry all possible jumps to reach the last index"
                    },
                    {
                        "username": "Sayan_Jasu",
                        "content": "At first glance of the problem statement, I thought of two approaches, one with pointer(s) and another with graph, but as I went on with the first approach and realized my mistakes in intuition based solutions using a pointer, I realized that the graph approach won\\'t be as graceful as I thought. Has anyone solved this question using DFS approach? "
                    },
                    {
                        "username": "GCarterII",
                        "content": "It may be possible, but it can be solved much more simply, in O(n) time and O(1) space."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I think that would reach O(n^n), I might be wrong. But applying dp can prolly decrease it."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I tried doing DP, which was easy but I gotta admit that the Greedy solution is pretty hard to come up with. \\nAnyways, here is my try to explain both the approaches w/ Images and everything:\\nhttps://leetcode.com/problems/jump-game/solutions/2952469/brute-dp-o-n-greedy-w-images-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "Wizmurmu07",
                        "content": "\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\uD83D\\uDE0A\\nIntuition\\nThe value given in each array index is basically the maximum number of steps we can jump.\\nWe just need to find whether the last index is reachable to us or not.\\n\\nApproach\\nWe take a variable reachable to store the max index we can reach at any point of time.\\nInitially the value of the reachable variable is 0;\\nIf the sum of the index value(i) and the value in the index(nums[i]) is more then reachable then we replace the value in reachable variable with this sum.\\nAt any given point if we find that the index value(i) is more than the reachable variable,then we return false."
                    },
                    {
                        "username": "Katrinakaif9",
                        "content": "It\\'s my first code on leetcode and I\\'m unable to take the input. How do I do that guys?"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "unlike on other platforms like codechef you don't need to take inputs on leetcode. Everything is done for you already in the driver code which you can't see. Just solve the problem using function template provided to you. If you need to give custom input / different test case you can do that in console at the bottom of the window."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint :  Think of going maximum index at each position and if it becomes less than current pos return false. : )"
                    }
                ]
            }
        ]
    },
    {
        "title": "Min Stack",
        "question_content": "<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 49010,
                "title": "clean-6ms-java-solution",
                "content": "```\\nclass MinStack {\\n\\tprivate Node head;\\n        \\n    public void push(int x) {\\n        if (head == null) \\n            head = new Node(x, x, null);\\n        else \\n            head = new Node(x, Math.min(x, head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n        \\n    private class Node {\\n        int val;\\n        int min;\\n        Node next;\\n            \\n        private Node(int val, int min, Node next) {\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\tprivate Node head;\\n        \\n    public void push(int x) {\\n        if (head == null) \\n            head = new Node(x, x, null);\\n        else \\n            head = new Node(x, Math.min(x, head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n        \\n    private class Node {\\n        int val;\\n        int min;\\n        Node next;\\n            \\n        private Node(int val, int min, Node next) {\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 49014,
                "title": "java-accepted-solution-using-one-stack",
                "content": "````\\nclass MinStack {\\n    int min = Integer.MAX_VALUE;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public void push(int x) {\\n        // only push the old minimum value when the current \\n        // minimum value changes after pushing the new value x\\n        if(x <= min){          \\n            stack.push(min);\\n            min=x;\\n        }\\n        stack.push(x);\\n    }\\n\\n    public void pop() {\\n        // if pop operation could result in the changing of the current minimum value, \\n        // pop twice and change the current minimum value to the last minimum value.\\n        if(stack.pop() == min) min=stack.pop();\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass MinStack {\\n    int min = Integer.MAX_VALUE;\\n    Stack<Integer> stack = new Stack<Integer>();\\n    public void push(int x) {\\n        // only push the old minimum value when the current \\n        // minimum value changes after pushing the new value x\\n        if(x <= min){          \\n            stack.push(min);\\n            min=x;\\n        }\\n        stack.push(x);\\n    }\\n\\n    public void pop() {\\n        // if pop operation could result in the changing of the current minimum value, \\n        // pop twice and change the current minimum value to the last minimum value.\\n        if(stack.pop() == min) min=stack.pop();\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49031,
                "title": "share-my-java-solution-with-only-one-stack",
                "content": "The question is ask to construct One stack. So I am using one stack.\\n\\nThe idea is to store the gap between the min value and the current value; \\n\\nThe problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE;\\n\\n\\n\\n\\n\\n    public class MinStack {\\n        long min;\\n        Stack<Long> stack;\\n    \\n        public MinStack(){\\n            stack=new Stack<>();\\n        }\\n        \\n        public void push(int x) {\\n            if (stack.isEmpty()){\\n                stack.push(0L);\\n                min=x;\\n            }else{\\n                stack.push(x-min);//Could be negative if min value needs to change\\n                if (x<min) min=x;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if (stack.isEmpty()) return;\\n            \\n            long pop=stack.pop();\\n            \\n            if (pop<0)  min=min-pop;//If negative, increase the min value\\n            \\n        }\\n    \\n        public int top() {\\n            long top=stack.peek();\\n            if (top>0){\\n                return (int)(top+min);\\n            }else{\\n               return (int)(min);\\n            }\\n        }\\n    \\n        public int getMin() {\\n            return (int)min;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The question is ask to construct One stack. So I am using one stack.\\n\\nThe idea is to store the gap between the min value and the current value; \\n\\nThe problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE;\\n\\n\\n\\n\\n\\n    public class MinStack {\\n        long min;\\n        Stack<Long> stack;\\n    \\n        public MinStack(){\\n            stack=new Stack<>();\\n        }\\n        \\n        public void push(int x) {\\n            if (stack.isEmpty()){\\n                stack.push(0L);\\n                min=x;\\n            }else{\\n                stack.push(x-min);//Could be negative if min value needs to change\\n                if (x<min) min=x;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if (stack.isEmpty()) return;\\n            \\n            long pop=stack.pop();\\n            \\n            if (pop<0)  min=min-pop;//If negative, increase the min value\\n            \\n        }\\n    \\n        public int top() {\\n            long top=stack.peek();\\n            if (top>0){\\n                return (int)(top+min);\\n            }else{\\n               return (int)(min);\\n            }\\n        }\\n    \\n        public int getMin() {\\n            return (int)min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49016,
                "title": "c-using-two-stacks-quite-short-and-easy-to-understand",
                "content": "    class MinStack {\\n    private:\\n\\t    stack<int> s1;\\n\\t    stack<int> s2;\\n    public:\\n\\t    void push(int x) {\\n\\t\\t    s1.push(x);\\n\\t\\t    if (s2.empty() || x <= getMin())  s2.push(x);\\t    \\n        }\\n        void pop() {\\n\\t\\t    if (s1.top() == getMin())  s2.pop();\\n\\t\\t    s1.pop();\\n\\t    }\\n        int top() {\\n\\t\\t    return s1.top();\\n\\t    }\\n        int getMin() {\\n\\t\\t    return s2.top();\\n\\t    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    private:\\n\\t    stack<int> s1;\\n\\t    stack<int> s2;\\n    public:\\n\\t    void push(int x) {\\n\\t\\t    s1.push(x);\\n\\t\\t    if (s2.empty() || x <= getMin())  s2.push(x);\\t    \\n        }\\n        void pop() {\\n\\t\\t    if (s1.top() == getMin())  s2.pop();\\n\\t\\t    s1.pop();\\n\\t    }\\n        int top() {\\n\\t\\t    return s1.top();\\n\\t    }\\n        int getMin() {\\n\\t\\t    return s2.top();\\n\\t    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1209254,
                "title": "c-simple-code-with-one-stack",
                "content": "I came up with this simple solution using just a single stack.\\nHere I am using **Stack of Pair of Int**. The first value of the pair would store the element of the normal stack and the second value would store the minimum up to that point in the stack. \\nSo even if the minimum element of the stack is removed from the top, we still have a backup of the next minimum element in the pair. So for every element pushed in the stack, it stores its corresponding minimum value.\\n\\nFor example, let\\'s do a **Dry Run** of an example.\\n```\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"pop\",\"top\",\"push\",\"getMin\"]\\n[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]\\n```\\n1. We push 5,-2,3,-10,20 in the stack.\\n2. If the stack is empty we push {val,val} in the stack\\n   else we push {val,min(s.top().second,val)} which is basically minimum upto that point.\\n3. Hence {5,5},{-2,-2},{3,-2},{-10,-10},{20,-10} are pushed in the stack.\\n4. To pop simply do stack.pop()\\n5. To get the top return stack.top().first;\\n6. Now we pop 20 and -10 from the stack\\n    The elements in the stack would be {5,5},{-2,-2},{3,-2}\\n7. On pushing 30 to the stack\\n   The elements in the stack would be {5,5},{-2,-2},{3,-2},{30,-2}.\\n\\nThe **Output** of the code would be:\\n```\\n[null,null,null,null,null,null,-10,null,null,3,null,-2]\\n```\\n\\nAll the operations are one liners expect the Push operation which is a 2 liner.\\n```\\nclass MinStack {\\npublic:\\n    vector< pair<int,int> > s;\\n\\t\\n    MinStack() { }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n            s.push_back({val,val});\\n        else\\n            s.push_back({val,min(s.back().second,val)});    \\n    }\\n    \\n    void pop() { s.pop_back(); }\\n    \\n    int top() { return s.back().first; }\\n    \\n    int getMin() { return s.back().second; }\\n};\\n```\\n```\\nThe Time complexity of each operation is O(1)\\nThe Space complexity is O(N)\\n```\\n\\nGuys, please give an **upvote** to acknowledge the efforts of the writer.\\nDo clarify your doubts in the comments section. Thank-you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"pop\",\"top\",\"push\",\"getMin\"]\\n[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]\\n```\n```\\n[null,null,null,null,null,null,-10,null,null,3,null,-2]\\n```\n```\\nclass MinStack {\\npublic:\\n    vector< pair<int,int> > s;\\n\\t\\n    MinStack() { }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n            s.push_back({val,val});\\n        else\\n            s.push_back({val,min(s.back().second,val)});    \\n    }\\n    \\n    void pop() { s.pop_back(); }\\n    \\n    int top() { return s.back().first; }\\n    \\n    int getMin() { return s.back().second; }\\n};\\n```\n```\\nThe Time complexity of each operation is O(1)\\nThe Space complexity is O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49022,
                "title": "my-python-solution",
                "content": "    class MinStack:\\n    \\n    def __init__(self):\\n        self.q = []\\n\\n    # @param x, an integer\\n    # @return an integer\\n    def push(self, x):\\n        curMin = self.getMin()\\n        if curMin == None or x < curMin:\\n            curMin = x\\n        self.q.append((x, curMin));\\n\\n    # @return nothing\\n    def pop(self):\\n        self.q.pop()\\n\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][0]\\n\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][1]",
                "solutionTags": [],
                "code": "    class MinStack:\\n    \\n    def __init__(self):\\n        self.q = []\\n\\n    # @param x, an integer\\n    # @return an integer\\n    def push(self, x):\\n        curMin = self.getMin()\\n        if curMin == None or x < curMin:\\n            curMin = x\\n        self.q.append((x, curMin));\\n\\n    # @return nothing\\n    def pop(self):\\n        self.q.pop()\\n\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][0]\\n\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.q) == 0:\\n            return None\\n        else:\\n            return self.q[len(self.q) - 1][1]",
                "codeTag": "Java"
            },
            {
                "id": 3176175,
                "title": "solution",
                "content": "```C++ []\\nclass MinStack {\\npublic:\\n    typedef struct node{\\n        int v;\\n        int minUntilNow;\\n        node* next;\\n    }node;\\n\\n    MinStack() : topN(nullptr){\\n        \\n    }\\n    \\n    void push(int val) {\\n        node* n = new node;\\n        n->v = n->minUntilNow = val;\\n        n->next = nullptr;\\n        \\n        if(topN == nullptr){\\n            topN = n;\\n        }\\n\\n        else{\\n            n->minUntilNow = min(n->v,topN->minUntilNow);\\n            n->next = topN;\\n            topN = n;\\n        }\\n    }\\n    \\n    void pop() {\\n        topN = topN->next;\\n    }\\n    \\n    int top() {\\n        return topN->v;\\n    }\\n    \\n    int getMin() {\\n        return topN->minUntilNow;\\n    }\\n\\n    private:\\n    node* topN;\\n};\\n```\\n\\n```Python3 []\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        if self.minStack:\\n            val = min(self.minStack[-1],val)\\n        self.minStack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minStack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minStack[-1]\\n```\\n\\n```Java []\\nclass MinStack {\\n    LinkedList<TplusMin> stack;\\n    private class TplusMin {\\n        int val;\\n        int min;\\n        public TplusMin(int val, int min) {\\n            this.val = val;\\n            this.min = min;\\n        }\\n    }\\n\\n    public MinStack() {\\n        stack = new LinkedList<>();\\n    }\\n    \\n    public void push(int val) {\\n        int newMin;\\n        if (stack.size() == 0){\\n            newMin = val;\\n        }\\n        else {\\n            int currentMin = stack.getFirst().min;\\n            newMin = val < currentMin ? val : currentMin;\\n        }\\n        stack.addFirst(new TplusMin(val, newMin));\\n    }\\n    \\n    public void pop() {\\n        stack.removeFirst();\\n    }\\n    \\n    public int top() {\\n        return stack.peekFirst().val;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peekFirst().min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass MinStack {\\npublic:\\n    typedef struct node{\\n        int v;\\n        int minUntilNow;\\n        node* next;\\n    }node;\\n\\n    MinStack() : topN(nullptr){\\n        \\n    }\\n    \\n    void push(int val) {\\n        node* n = new node;\\n        n->v = n->minUntilNow = val;\\n        n->next = nullptr;\\n        \\n        if(topN == nullptr){\\n            topN = n;\\n        }\\n\\n        else{\\n            n->minUntilNow = min(n->v,topN->minUntilNow);\\n            n->next = topN;\\n            topN = n;\\n        }\\n    }\\n    \\n    void pop() {\\n        topN = topN->next;\\n    }\\n    \\n    int top() {\\n        return topN->v;\\n    }\\n    \\n    int getMin() {\\n        return topN->minUntilNow;\\n    }\\n\\n    private:\\n    node* topN;\\n};\\n```\n```Python3 []\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        if self.minStack:\\n            val = min(self.minStack[-1],val)\\n        self.minStack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minStack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minStack[-1]\\n```\n```Java []\\nclass MinStack {\\n    LinkedList<TplusMin> stack;\\n    private class TplusMin {\\n        int val;\\n        int min;\\n        public TplusMin(int val, int min) {\\n            this.val = val;\\n            this.min = min;\\n        }\\n    }\\n\\n    public MinStack() {\\n        stack = new LinkedList<>();\\n    }\\n    \\n    public void push(int val) {\\n        int newMin;\\n        if (stack.size() == 0){\\n            newMin = val;\\n        }\\n        else {\\n            int currentMin = stack.getFirst().min;\\n            newMin = val < currentMin ? val : currentMin;\\n        }\\n        stack.addFirst(new TplusMin(val, newMin));\\n    }\\n    \\n    public void pop() {\\n        stack.removeFirst();\\n    }\\n    \\n    public int top() {\\n        return stack.peekFirst().val;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peekFirst().min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49221,
                "title": "c-solution-using-pair-and-one-stack",
                "content": "    class MinStack {\\n         stack<pair<int, int>> st;\\n    \\n    public:\\n        void push(int x) {\\n            int min;\\n            if (st.empty()) {\\n                min = x;\\n            }\\n            else {\\n                min = std::min(st.top().second,x);\\n            }\\n            st.push({x, min});\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n         stack<pair<int, int>> st;\\n    \\n    public:\\n        void push(int x) {\\n            int min;\\n            if (st.empty()) {\\n                min = x;\\n            }\\n            else {\\n                min = std::min(st.top().second,x);\\n            }\\n            st.push({x, min});\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49217,
                "title": "6ms-java-solution-using-linked-list-clean-self-explanatory-and-efficient",
                "content": "    class MinStack {\\n        class Node{\\n            int value;\\n            int min;\\n            Node next;\\n            \\n            Node(int x, int min){\\n                this.value=x;\\n                this.min=min;\\n                next = null;\\n            }\\n        }\\n        Node head;\\n        public void push(int x) {\\n            if(null==head){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(x,head.min));\\n                n.next=head;\\n                head=n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head =head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n            return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(null!=head)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        class Node{\\n            int value;\\n            int min;\\n            Node next;\\n            \\n            Node(int x, int min){\\n                this.value=x;\\n                this.min=min;\\n                next = null;\\n            }\\n        }\\n        Node head;\\n        public void push(int x) {\\n            if(null==head){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(x,head.min));\\n                n.next=head;\\n                head=n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head =head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n            return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(null!=head)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1539330,
                "title": "c-99-74-faster-simple-better-and-optimal-solutions-using-stacks",
                "content": "### Simple Solution\\n\\n**Using Stack and Multiset Approach** *(RunTime : 56 ms (43.75%) & Memory Usage : 35.5%)*\\nIdea behind this logic is to have one stack todo stack operations and multiset to get min element\\n\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tmultiset<int>m;   \\n\\n\\t\\tvoid push(int val) {//insert elements on both set and stack\\n\\t\\t\\ts.push(val); \\n\\t\\t\\tm.insert(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {//poping elements on both set and stack\\n\\t\\t\\tint top = s.top();\\n\\t\\t\\ts.pop();\\n\\t\\t\\tm.erase(m.find(top)); \\n\\t\\t}\\n\\n\\t\\tint top() { //return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {// return set first element \\n\\t\\t\\treturn *m.begin();\\n\\t\\t}\\n\\t};\\n```\\n\\n### Better Solution\\n\\n**Using Two Stack Approach** *(RunTime : 16 ms (97.50%) & Memory Usage : 78.95%)*\\nThe logic is to have one stack todo stack operations and another stack to store history of min elements.\\n\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s,minKeeper;\\n\\t\\tvoid push(int val) {\\n\\t\\t\\ts.push(val); // push val in stack\\n\\n\\t\\t\\tif(minKeeper.size()==0||val<=minKeeper.top()){//push in when empty or lesser than current minElement\\n\\t\\t\\t\\tminKeeper.push(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\n\\t\\t\\tif(minKeeper.top() == s.top())//pop when last element was min element \\n\\t\\t\\t\\tminKeeper.pop();\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {//return top of stack\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return top of minKeeper\\n\\t\\t\\treturn minKeeper.top();\\n\\t\\t}\\n\\t};\\n```\\n\\n### Optimal Solution\\n**Using only One stack** *(RunTime : 12 ms (99.74%) & Memory Usage :88.88%)*\\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tint minElement = INT_MAX;//initalize with max value\\n\\n\\t\\tvoid push(int val) {\\n\\t\\t\\tif(minElement>=val){// whenever val is lesser than current minElement, store current minElement in stack and make val as current minElement\\n\\t\\t\\t\\ts.push(minElement);\\n\\t\\t\\t\\t minElement = val;\\n\\t\\t\\t}\\n\\t\\t\\t  s.push(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\t\\t\\tif(minElement==s.top()){//top is minElement then previous element will be previous minElement, so pop and store current top as current MinElement\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\tminElement = s.top();\\n\\t\\t\\t}\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {// return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return minElement\\n\\t\\t\\treturn minElement;\\n\\t\\t}\\n\\t};\\n```\\n\\n\\n\\nThank you\\n\\n```\\n\\t\\tif(Useful == true)\\n\\t\\t\\tupvote();\\n\\t\\telse\\n\\t\\t\\tcomment();\\n```\\n\\nBy \\uD83D\\uDC93 JS",
                "solutionTags": [],
                "code": "```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tmultiset<int>m;   \\n\\n\\t\\tvoid push(int val) {//insert elements on both set and stack\\n\\t\\t\\ts.push(val); \\n\\t\\t\\tm.insert(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {//poping elements on both set and stack\\n\\t\\t\\tint top = s.top();\\n\\t\\t\\ts.pop();\\n\\t\\t\\tm.erase(m.find(top)); \\n\\t\\t}\\n\\n\\t\\tint top() { //return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {// return set first element \\n\\t\\t\\treturn *m.begin();\\n\\t\\t}\\n\\t};\\n```\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s,minKeeper;\\n\\t\\tvoid push(int val) {\\n\\t\\t\\ts.push(val); // push val in stack\\n\\n\\t\\t\\tif(minKeeper.size()==0||val<=minKeeper.top()){//push in when empty or lesser than current minElement\\n\\t\\t\\t\\tminKeeper.push(val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\n\\t\\t\\tif(minKeeper.top() == s.top())//pop when last element was min element \\n\\t\\t\\t\\tminKeeper.pop();\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {//return top of stack\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return top of minKeeper\\n\\t\\t\\treturn minKeeper.top();\\n\\t\\t}\\n\\t};\\n```\n```\\n\\tclass MinStack {\\n\\tpublic:\\n\\t\\tstack<int>s;\\n\\t\\tint minElement = INT_MAX;//initalize with max value\\n\\n\\t\\tvoid push(int val) {\\n\\t\\t\\tif(minElement>=val){// whenever val is lesser than current minElement, store current minElement in stack and make val as current minElement\\n\\t\\t\\t\\ts.push(minElement);\\n\\t\\t\\t\\t minElement = val;\\n\\t\\t\\t}\\n\\t\\t\\t  s.push(val);\\n\\t\\t}\\n\\n\\t\\tvoid pop() {\\n\\t\\t\\tif(minElement==s.top()){//top is minElement then previous element will be previous minElement, so pop and store current top as current MinElement\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\tminElement = s.top();\\n\\t\\t\\t}\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\n\\t\\tint top() {// return stack top\\n\\t\\t\\treturn s.top();\\n\\t\\t}\\n\\n\\t\\tint getMin() {//return minElement\\n\\t\\t\\treturn minElement;\\n\\t\\t}\\n\\t};\\n```\n```\\n\\t\\tif(Useful == true)\\n\\t\\t\\tupvote();\\n\\t\\telse\\n\\t\\t\\tcomment();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49183,
                "title": "python-one-stack-solution-without-linklist",
                "content": "\\nclass MinStack(object):\\n    \\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack= []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: nothing\\n        \"\"\"\\n        if not self.stack:self.stack.append((x,x)) \\n        else:\\n           self.stack.append((x,min(x,self.stack[-1][1])))\\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: nothing\\n        \"\"\"\\n        if self.stack: self.stack.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][0]\\n        else: return None\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][1]\\n        else: return None",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nclass MinStack(object):\\n    \\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack= []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: nothing\\n        \"\"\"\\n        if not self.stack:self.stack.append((x,x)) \\n        else:\\n           self.stack.append((x,min(x,self.stack[-1][1])))\\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: nothing\\n        \"\"\"\\n        if self.stack: self.stack.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][0]\\n        else: return None\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        if self.stack: return self.stack[-1][1]\\n        else: return None",
                "codeTag": "Java"
            },
            {
                "id": 288686,
                "title": "javascript-solution-beats-100-submission",
                "content": "```\\nvar MinStack = function() {\\n  this.elements = [];\\n};\\n\\n/**\\n\\n @param {number} x\\n @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.elements.push({\\n    value: x,\\n    min: this.elements.length === 0 ? x : Math.min(x, this.getMin()),\\n  });\\n};\\n/**\\n\\n @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.elements.pop();\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  return this.elements[this.elements.length - 1].value;\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  return this.elements[this.elements.length - 1].min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar MinStack = function() {\\n  this.elements = [];\\n};\\n\\n/**\\n\\n @param {number} x\\n @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.elements.push({\\n    value: x,\\n    min: this.elements.length === 0 ? x : Math.min(x, this.getMin()),\\n  });\\n};\\n/**\\n\\n @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.elements.pop();\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  return this.elements[this.elements.length - 1].value;\\n};\\n/**\\n\\n @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  return this.elements[this.elements.length - 1].min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49078,
                "title": "simple-java-solution-12-line",
                "content": "class MinStack {\\n\\n    Stack<Integer> stack=new Stack<>();\\n    int min=Integer.MAX_VALUE;\\n    public void push(int x) {\\n        if(x<=min) {stack.push(min); min=x;}\\n        stack.push(x);\\n    }\\n    public void pop() {\\n        if(stack.peek()==min){ stack.pop(); min=stack.pop(); }\\n        else stack.pop();\\n    }\\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class MinStack {\\n\\n    Stack<Integer> stack=new Stack<>();\\n    int min=Integer.MAX_VALUE;\\n    public void push(int x) {\\n        if(x<=min) {stack.push(min); min=x;}\\n        stack.push(x);\\n    }\\n    public void pop() {\\n        if(stack.peek()==min){ stack.pop(); min=stack.pop(); }\\n        else stack.pop();\\n    }\\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 572006,
                "title": "python3-solution-with-o-1-time-as-expected",
                "content": "The insight is to keep track of the minimum value so far and push it, along with the number we are pushing, onto the stack.\\n\\nSo, in this implementation, we push a tuple, with the first number being the number we are pushing, and the second being the minimum value so far. That way, retrieving the minimum value is also an O(1) operation.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.__a = []\\n\\n    def push(self, x: int) -> None:\\n        m = x\\n        if self.__a:\\n            m = self.__a[-1][1]\\n            if m > x:\\n                m = x\\n        self.__a.append((x, m))\\n\\n    def pop(self) -> None:\\n        self.__a.pop()\\n        \\n    def top(self) -> int:\\n        return self.__a[-1][0]\\n\\n    def getMin(self) -> int:\\n        return self.__a[-1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.__a = []\\n\\n    def push(self, x: int) -> None:\\n        m = x\\n        if self.__a:\\n            m = self.__a[-1][1]\\n            if m > x:\\n                m = x\\n        self.__a.append((x, m))\\n\\n    def pop(self) -> None:\\n        self.__a.pop()\\n        \\n    def top(self) -> int:\\n        return self.__a[-1][0]\\n\\n    def getMin(self) -> int:\\n        return self.__a[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49062,
                "title": "c-o-1-solution",
                "content": "    class MinStack {\\n    public:\\n        vector<int> a;\\n        vector<int> min;\\n        MinStack() {\\n            min.push_back(2147483647);\\n        }\\n        void push(int x) {\\n            a.push_back(x);\\n            if (x < min.back()) {\\n                min.push_back(x);\\n            } else {\\n                min.push_back(min.back());\\n            }\\n        }\\n    \\n        void pop() {\\n            a.pop_back();\\n            min.pop_back();\\n        }\\n    \\n        int top() {\\n            return a.back();\\n        }\\n    \\n        int getMin() {\\n            return min.back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n    public:\\n        vector<int> a;\\n        vector<int> min;\\n        MinStack() {\\n            min.push_back(2147483647);\\n        }\\n        void push(int x) {\\n            a.push_back(x);\\n            if (x < min.back()) {\\n                min.push_back(x);\\n            } else {\\n                min.push_back(min.back());\\n            }\\n        }\\n    \\n        void pop() {\\n            a.pop_back();\\n            min.pop_back();\\n        }\\n    \\n        int top() {\\n            return a.back();\\n        }\\n    \\n        int getMin() {\\n            return min.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 725290,
                "title": "c-simple-easy-solution",
                "content": "```\\nprivate:\\n    stack<int> s1;    \\n    stack<int> s2;   //for containing min value at top \\npublic:\\n    void push(int x) {\\n\\t    s1.push(x);\\n\\t    if(s2.empty() || x<=s2.top()) s2.push(x);\\t    \\n    }\\n    void pop() {\\n\\t    if(s1.top()==s2.top()) s2.pop();\\n\\t    s1.pop();\\n    }\\n    int top() {\\n\\t    return s1.top();\\n    }\\n    int getMin() {\\n\\t    return s2.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nprivate:\\n    stack<int> s1;    \\n    stack<int> s2;   //for containing min value at top \\npublic:\\n    void push(int x) {\\n\\t    s1.push(x);\\n\\t    if(s2.empty() || x<=s2.top()) s2.push(x);\\t    \\n    }\\n    void pop() {\\n\\t    if(s1.top()==s2.top()) s2.pop();\\n\\t    s1.pop();\\n    }\\n    int top() {\\n\\t    return s1.top();\\n    }\\n    int getMin() {\\n\\t    return s2.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003721,
                "title": "easy-python-high-speed",
                "content": "**Easy Python | High Speed**\\n\\nEasy Python solution using an array ```A``` to store the elements placed in the stack, and an additional array ```M``` tracking the minimum element seen so far. It can be proven that this approach always works, although it uses ```O(N)``` extra space. (It doesn\\'t change the overall space complexity though).\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.A = []\\n        self.M = []\\n    def push(self, x):\\n        self.A.append(x)\\n        self.M.append( x if not self.M else min(x, self.M[-1]) )\\n    def pop(self):\\n        self.A.pop()\\n        self.M.pop()\\n    def top(self):\\n        return self.A[-1]\\n    def getMin(self):\\n        return self.M[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```A```\n```M```\n```O(N)```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.A = []\\n        self.M = []\\n    def push(self, x):\\n        self.A.append(x)\\n        self.M.append( x if not self.M else min(x, self.M[-1]) )\\n    def pop(self):\\n        self.A.pop()\\n        self.M.pop()\\n    def top(self):\\n        return self.A[-1]\\n    def getMin(self):\\n        return self.M[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201044,
                "title": "python-single-stack-o-1-all-operations",
                "content": "```python\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, x):\\n        if self.stack:\\n\\t\\t\\tself.stack.append(min(self.stack[-2], x))\\n        else:\\n            self.stack.append(x)\\n        self.stack.append(x)\\n        \\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1]\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, x):\\n        if self.stack:\\n\\t\\t\\tself.stack.append(min(self.stack[-2], x))\\n        else:\\n            self.stack.append(x)\\n        self.stack.append(x)\\n        \\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1]\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730013,
                "title": "3-approaches-two-stack-only-one-stack-and-linked-list",
                "content": "**1. Using two stack : Pushing min element in s2**\\n\\nTime: O(1) space: O(2n)\\n\\n**Cons**: Extra O(n) space\\n\\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>s1, s2;\\n    \\n    void push(int x) {\\n        if(s1.empty()){\\n            s2.push(x);\\n        }\\n        else if(x <= s2.top()){\\n            s2.push(x);\\n        }\\n        s1.push(x);\\n    }\\n    \\n    void pop() {\\n        if(s1.empty())return;\\n        if(s1.top() == s2.top()){\\n            s2.pop();\\n        }\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        if(s1.empty())return -1;\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        if(s1.empty())return -1;\\n        return s2.top();\\n    }\\n};\\n\\n```\\n**2. Using a variable min_element:** \\n\\nTime: O(1) space: O(n)\\n\\n**Cons**: Integer overflow\\n\\n\\n**Intuition**: mn variable will always hold minimum value but if it doesn\\'t, it means s.top contains flag, so before popping the stack top, update the min. \\n\\n**Algo**: \\n\\t\\t While pushing \\n\\t\\t\\t\\t ```\\n\\t\\t\\t\\t if x < mn : push 2*x-mn and put the provided x in mn\\n\\t\\t\\t\\t ```\\n\\t\\t Similarly while popping \\n\\t\\t\\t\\t ```if s.top() < mn(indicates the flag): Restore the mn before popping: mn = 2* mn -s.top()```\\n\\t\\t\\t\\t \\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<long> s;\\n    long mn;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()){\\n            s.push(x);\\n            mn = x;\\n        }\\n        else if(x <= mn){\\n            // put 2*x - mn into stack\\n            s.push(2ll*x - mn);\\n            mn = x;\\n        }\\n        else{\\n            s.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        // stack top can never be smaller than mn, if it is then it indicates a flag which means before popping, you have to update mn\\n        if(s.top() < mn){\\n            // mn = 2*mn - s.top()\\n            mn = 2ll*mn - s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    // critical part\\n    int top() {\\n        if(s.empty()) return -1;\\n        if(s.top() < mn){\\n            return mn;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(s.empty()) return -1;\\n        return mn;\\n    }\\n};\\n\\n```\\n\\n\\n\\n**3. Using a linked list:** \\n\\nTime: O(1) space: O(2n)\\n\\n**Cons**: O(2n) space since each node has two integer variable and there will be n such nodes\\n\\n**Algo:**\\n```\\n\\t\\ta. Make every new element the new head with updated min. \\n\\t\\tb. And put the previous element next to the new head.\\n```\\n\\n**Code**: \\n```\\nclass MinStack {\\npublic:\\n    struct Node{\\n        int val, mn;\\n        Node* next;\\n        Node(int _val, int _mn, Node*_next = NULL){\\n            val = _val;\\n            mn = _mn;\\n            next = _next;\\n        }\\n    }*head;\\n    void push(int val) {\\n        if(!head){\\n            head = new Node(val, val);\\n        } \\n        else{\\n            head = new Node(val, min(val, head->mn), head);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(!head) return ;\\n        Node* temp = head;\\n        head = head->next;\\n        delete(temp);\\n    }\\n    \\n    int top() {\\n        if(!head) return -1;\\n        return head->val;\\n    }\\n    \\n    int getMin() {\\n        if(!head) return -1;\\n        return head->mn;\\n    }\\n};\\n\\n```\\n**Which is the best solution from interview point of view?** \\n\\nFeel free to correct me!\\nEdit: Space complexity added from valuable comments. \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>s1, s2;\\n    \\n    void push(int x) {\\n        if(s1.empty()){\\n            s2.push(x);\\n        }\\n        else if(x <= s2.top()){\\n            s2.push(x);\\n        }\\n        s1.push(x);\\n    }\\n    \\n    void pop() {\\n        if(s1.empty())return;\\n        if(s1.top() == s2.top()){\\n            s2.pop();\\n        }\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        if(s1.empty())return -1;\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        if(s1.empty())return -1;\\n        return s2.top();\\n    }\\n};\\n\\n```\n```\\n\\t\\t\\t\\t if x < mn : push 2*x-mn and put the provided x in mn\\n\\t\\t\\t\\t ```\n```if s.top() < mn(indicates the flag): Restore the mn before popping: mn = 2* mn -s.top()```\n```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<long> s;\\n    long mn;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()){\\n            s.push(x);\\n            mn = x;\\n        }\\n        else if(x <= mn){\\n            // put 2*x - mn into stack\\n            s.push(2ll*x - mn);\\n            mn = x;\\n        }\\n        else{\\n            s.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        // stack top can never be smaller than mn, if it is then it indicates a flag which means before popping, you have to update mn\\n        if(s.top() < mn){\\n            // mn = 2*mn - s.top()\\n            mn = 2ll*mn - s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    // critical part\\n    int top() {\\n        if(s.empty()) return -1;\\n        if(s.top() < mn){\\n            return mn;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(s.empty()) return -1;\\n        return mn;\\n    }\\n};\\n\\n```\n```\\n\\t\\ta. Make every new element the new head with updated min. \\n\\t\\tb. And put the previous element next to the new head.\\n```\n```\\nclass MinStack {\\npublic:\\n    struct Node{\\n        int val, mn;\\n        Node* next;\\n        Node(int _val, int _mn, Node*_next = NULL){\\n            val = _val;\\n            mn = _mn;\\n            next = _next;\\n        }\\n    }*head;\\n    void push(int val) {\\n        if(!head){\\n            head = new Node(val, val);\\n        } \\n        else{\\n            head = new Node(val, min(val, head->mn), head);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(!head) return ;\\n        Node* temp = head;\\n        head = head->next;\\n        delete(temp);\\n    }\\n    \\n    int top() {\\n        if(!head) return -1;\\n        return head->val;\\n    }\\n    \\n    int getMin() {\\n        if(!head) return -1;\\n        return head->mn;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49181,
                "title": "java-solution-accepted",
                "content": "    private Stack<Integer> mStack = new Stack<Integer>();\\n\\tprivate Stack<Integer> mMinStack = new Stack<Integer>();\\n\\t\\n\\tpublic void push(int x) {\\n\\t\\tmStack.push(x);\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tint min = mMinStack.peek();\\n\\t\\t\\tif (x <= min) {\\n\\t\\t\\t\\tmMinStack.push(x);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmMinStack.push(x);\\n\\t\\t}\\n    }\\n\\n    public void pop() {\\n    \\tint x = mStack.pop();\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tif (x == mMinStack.peek()) {\\n\\t\\t\\t\\tmMinStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\n    public int top() {\\n    \\treturn mStack.peek();\\n    }\\n\\n    public int getMin() {\\n        return mMinStack.peek();\\n    }",
                "solutionTags": [],
                "code": "    private Stack<Integer> mStack = new Stack<Integer>();\\n\\tprivate Stack<Integer> mMinStack = new Stack<Integer>();\\n\\t\\n\\tpublic void push(int x) {\\n\\t\\tmStack.push(x);\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tint min = mMinStack.peek();\\n\\t\\t\\tif (x <= min) {\\n\\t\\t\\t\\tmMinStack.push(x);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tmMinStack.push(x);\\n\\t\\t}\\n    }\\n\\n    public void pop() {\\n    \\tint x = mStack.pop();\\n\\t\\tif (mMinStack.size() != 0) {\\n\\t\\t\\tif (x == mMinStack.peek()) {\\n\\t\\t\\t\\tmMinStack.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\n    public int top() {\\n    \\treturn mStack.peek();\\n    }\\n\\n    public int getMin() {\\n        return mMinStack.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 49030,
                "title": "simple-java-solution-using-two-build-in-stacks",
                "content": "Here is my simple code for minStack, using two build in Java stack to store the stack and min values separately.\\n\\n    class MinStack {\\n        // stack: store the stack numbers\\n        private Stack<Integer> stack = new Stack<Integer>();\\n        // minStack: store the current min values\\n        private Stack<Integer> minStack = new Stack<Integer>();\\n        \\n        public void push(int x) {\\n            // store current min value into minStack\\n            if (minStack.isEmpty() || x <= minStack.peek())\\n                minStack.push(x);\\n            stack.push(x);\\n        }\\n    \\n        public void pop() {\\n            // use equals to compare the value of two object, if equal, pop both of them\\n            if (stack.peek().equals(minStack.peek()))\\n                minStack.pop();\\n            stack.pop();\\n        }\\n    \\n        public int top() {\\n            return stack.peek();\\n        }\\n    \\n        public int getMin() {\\n            return minStack.peek();\\n        }\\n    }",
                "solutionTags": [],
                "code": "Here is my simple code for minStack, using two build in Java stack to store the stack and min values separately.\\n\\n    class MinStack {\\n        // stack: store the stack numbers\\n        private Stack<Integer> stack = new Stack<Integer>();\\n        // minStack: store the current min values\\n        private Stack<Integer> minStack = new Stack<Integer>();\\n        \\n        public void push(int x) {\\n            // store current min value into minStack\\n            if (minStack.isEmpty() || x <= minStack.peek())\\n                minStack.push(x);\\n            stack.push(x);\\n        }\\n    \\n        public void pop() {\\n            // use equals to compare the value of two object, if equal, pop both of them\\n            if (stack.peek().equals(minStack.peek()))\\n                minStack.pop();\\n            stack.pop();\\n        }\\n    \\n        public int top() {\\n            return stack.peek();\\n        }\\n    \\n        public int getMin() {\\n            return minStack.peek();\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 237368,
                "title": "python-1-line",
                "content": "<iframe src=\"https://leetcode.com/playground/najATENy/shared\" frameBorder=\"0\" width=\"900\" height=\"450\"></iframe>",
                "solutionTags": [
                    "Python"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/najATENy/shared\" frameBorder=\"0\" width=\"900\" height=\"450\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 49185,
                "title": "minstack-javascript-solution",
                "content": "    /**\\n     * @constructor\\n     */\\n    var MinStack = function() {\\n        this.minStack = [];\\n        this.container = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    MinStack.prototype.push = function(x) {\\n        this.container.push(x);\\n        if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {\\n            this.minStack.push(x);\\n        }\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    MinStack.prototype.pop = function() {\\n        var x = this.container.pop();\\n        if (x === this.minStack[this.minStack.length - 1]) {\\n            this.minStack.pop();\\n        }\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    MinStack.prototype.top = function() {\\n        return this.container[this.container.length - 1];\\n    };\\n    \\n    MinStack.prototype.getMin = function() {\\n        return this.minStack[this.minStack.length - 1];\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * @constructor\\n     */\\n    var MinStack = function() {\\n        this.minStack = [];\\n        this.container = [];\\n    };\\n    \\n    /**\\n     * @param {number} x\\n     * @returns {void}\\n     */\\n    MinStack.prototype.push = function(x) {\\n        this.container.push(x);\\n        if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {\\n            this.minStack.push(x);\\n        }\\n    };\\n    \\n    /**\\n     * @returns {void}\\n     */\\n    MinStack.prototype.pop = function() {\\n        var x = this.container.pop();\\n        if (x === this.minStack[this.minStack.length - 1]) {\\n            this.minStack.pop();\\n        }\\n    };\\n    \\n    /**\\n     * @returns {number}\\n     */\\n    MinStack.prototype.top = function() {\\n        return this.container[this.container.length - 1];\\n    };\\n    \\n    MinStack.prototype.getMin = function() {\\n        return this.minStack[this.minStack.length - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 572005,
                "title": "super-easy-c-solution-with-explanation",
                "content": "**EXPLANATION**  Create two vectors one for stack and other for minimum number entered(min). \\n**Push**: Push every element into the stack vector but only push element in min  if it is empty or the current number is smaller than or equal to the last enterd number in min vector. \\n**POP**: If last elements entered of stack and min are same then pop both of them. Else just pop out back element of stack.\\n\\n\\n\\n```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    vector<int> min;\\n    vector<int> stack;\\n    public:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        stack.push_back(x);\\n        if(min.empty()||min.back()>=x)\\n            min.push_back(x);\\n    }\\n    \\n    void pop() {\\n        if(stack.back()==min.back())\\n            min.pop_back();\\n        \\n        stack.pop_back();\\n    }\\n    \\n    int top() {\\n        if(!stack.empty())\\n        return stack.back();\\n        \\n        return -1;\\n    }\\n    \\n    int getMin() {\\n        if(!min.empty())\\n        return min.back();\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**Kachow**",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    vector<int> min;\\n    vector<int> stack;\\n    public:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        stack.push_back(x);\\n        if(min.empty()||min.back()>=x)\\n            min.push_back(x);\\n    }\\n    \\n    void pop() {\\n        if(stack.back()==min.back())\\n            min.pop_back();\\n        \\n        stack.pop_back();\\n    }\\n    \\n    int top() {\\n        if(!stack.empty())\\n        return stack.back();\\n        \\n        return -1;\\n    }\\n    \\n    int getMin() {\\n        if(!min.empty())\\n        return min.back();\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204269,
                "title": "javascript",
                "content": "```\\nvar MinStack = function() {\\n    this.stack = []\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    let min = this.stack.length === 0 ? x : this.stack[this.stack.length - 1].min\\n    this.stack.push({val: x, min: Math.min(min, x)})\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.stack.length > 0){\\n        this.stack.pop()\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].val\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].min\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar MinStack = function() {\\n    this.stack = []\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    let min = this.stack.length === 0 ? x : this.stack[this.stack.length - 1].min\\n    this.stack.push({val: x, min: Math.min(min, x)})\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.stack.length > 0){\\n        this.stack.pop()\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].val\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    if(this.stack.length > 0) {\\n        return this.stack[this.stack.length - 1].min\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545225,
                "title": "c-java-python-javascript-simple-solution-with-o-1-time-complexity-for-each-function-as-asked",
                "content": "# Intuition\\nThe intuition behind this approach is to store the minimum value encountered so far along with each element in the stack. By doing so, the minimum value can be retrieved in constant time by accessing the second element of the pair at the top of the stack.\\n\\n# Approach\\n1. The class `MinStack` has a member variable `st`, which is a stack of pairs of integers. Each pair consists of the element and the minimum element encountered so far.\\n\\n2. The constructor `MinStack()` is empty and does not perform any operations.\\n\\n3. The `push` function takes an integer `val` as input and pushes it onto the stack. If the stack is empty, it sets the minimum value encountered as `val` and pushes the pair `{val, val}` onto the stack. If the stack is not empty, it calculates the new minimum value by taking the minimum of the current minimum value (`st.top().second`) and `val`, and pushes the pair `{val, mn}` onto the stack, where `mn` is the new minimum value.\\n\\n4. The `pop` function removes the top element from the stack if it is not empty.\\n\\n5. The `top` function returns the element at the top of the stack if it is not empty. If the stack is empty, it returns 0 as a default value.\\n\\n6. The `getMin` function returns the minimum element encountered so far, which is stored as the second element of the pair at the top of the stack.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- The time complexity of the `push`, `pop`, `top`, and `getMin` functions is O(1) since all operations are performed directly on the stack and do not depend on the stack\\'s size.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- The space complexity of the code is O(n), where n is the number of elements pushed onto the stack. This is because the stack `st` stores pairs of integers for each element, resulting in additional space proportional to the number of elements in the stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>> st;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            int mn = val;\\n            st.push({val,val});\\n        }\\n        else{\\n            int mn = min(st.top().second,val);\\n            st.push({val,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(!st.empty()){\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.empty()){\\n            return 0;\\n        }\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```\\n# Java\\n```\\nclass MinStack {\\n    private Stack<Pair<Integer, Integer>> stack;\\n\\n    public MinStack() {\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int val) {\\n        if (stack.isEmpty()) {\\n            stack.push(new Pair<>(val, val));\\n        } else {\\n            int min = Math.min(stack.peek().getValue(), val);\\n            stack.push(new Pair<>(val, min));\\n        }\\n    }\\n\\n    public void pop() {\\n        if (!stack.isEmpty()) {\\n            stack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getKey();\\n    }\\n\\n    public int getMin() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getValue();\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val):\\n        if not self.stack:\\n            self.stack.append((val, val))\\n        else:\\n            mn = min(self.stack[-1][1], val)\\n            self.stack.append((val, mn))\\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1][0]\\n        return 0\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-1][1]\\n        return 0\\n\\n```\\n# JavaScript\\n```\\nvar MinStack = function() {\\n  this.stack = [];\\n};\\n\\nMinStack.prototype.push = function(val) {\\n  if (this.stack.length === 0) {\\n    this.stack.push({ val: val, min: val });\\n  } else {\\n    var min = Math.min(this.stack[this.stack.length - 1].min, val);\\n    this.stack.push({ val: val, min: min });\\n  }\\n};\\n\\nMinStack.prototype.pop = function() {\\n  if (this.stack.length > 0) {\\n    this.stack.pop();\\n  }\\n};\\n\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].val;\\n  }\\n  return null;\\n};\\n\\nMinStack.prototype.getMin = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].min;\\n  }\\n  return null;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>> st;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            int mn = val;\\n            st.push({val,val});\\n        }\\n        else{\\n            int mn = min(st.top().second,val);\\n            st.push({val,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(!st.empty()){\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.empty()){\\n            return 0;\\n        }\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```\n```\\nclass MinStack {\\n    private Stack<Pair<Integer, Integer>> stack;\\n\\n    public MinStack() {\\n        stack = new Stack<>();\\n    }\\n\\n    public void push(int val) {\\n        if (stack.isEmpty()) {\\n            stack.push(new Pair<>(val, val));\\n        } else {\\n            int min = Math.min(stack.peek().getValue(), val);\\n            stack.push(new Pair<>(val, min));\\n        }\\n    }\\n\\n    public void pop() {\\n        if (!stack.isEmpty()) {\\n            stack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getKey();\\n    }\\n\\n    public int getMin() {\\n        if (stack.isEmpty()) {\\n            return 0;\\n        }\\n        return stack.peek().getValue();\\n    }\\n}\\n\\n```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val):\\n        if not self.stack:\\n            self.stack.append((val, val))\\n        else:\\n            mn = min(self.stack[-1][1], val)\\n            self.stack.append((val, mn))\\n\\n    def pop(self):\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self):\\n        if self.stack:\\n            return self.stack[-1][0]\\n        return 0\\n\\n    def getMin(self):\\n        if self.stack:\\n            return self.stack[-1][1]\\n        return 0\\n\\n```\n```\\nvar MinStack = function() {\\n  this.stack = [];\\n};\\n\\nMinStack.prototype.push = function(val) {\\n  if (this.stack.length === 0) {\\n    this.stack.push({ val: val, min: val });\\n  } else {\\n    var min = Math.min(this.stack[this.stack.length - 1].min, val);\\n    this.stack.push({ val: val, min: min });\\n  }\\n};\\n\\nMinStack.prototype.pop = function() {\\n  if (this.stack.length > 0) {\\n    this.stack.pop();\\n  }\\n};\\n\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].val;\\n  }\\n  return null;\\n};\\n\\nMinStack.prototype.getMin = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1].min;\\n  }\\n  return null;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539700,
                "title": "python-two-stacks-solution-explained",
                "content": "Here we need to maintain two stacks: one is original one and another is min_stack, where we keep elements in descending order. So, when we pop element from main stack, we also check if it is also on the top of min stack and if it is, delete it. To get `top` and `getMin` just look at the top of main and min stack.\\n\\n#### Complexity\\nIt is `O(1)` for all operations for time and `O(n)` for space after `n` queries.\\n\\n#### Code\\n```python\\nclass MinStack:\\n    def __init__(self):\\n        self.stack_main = []\\n        self.stack_min = []\\n        \\n    def push(self, x):\\n        self.stack_main.append(x)\\n        if not self.stack_min or self.stack_min[-1] >= x:\\n            self.stack_min.append(x)\\n\\n    def pop(self):\\n        last = self.stack_main.pop()\\n        if last == self.stack_min[-1]:\\n            self.stack_min.pop()\\n\\n    def top(self):\\n        return self.stack_main[-1]\\n\\n    def getMin(self):\\n        return self.stack_min[-1]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass MinStack:\\n    def __init__(self):\\n        self.stack_main = []\\n        self.stack_min = []\\n        \\n    def push(self, x):\\n        self.stack_main.append(x)\\n        if not self.stack_min or self.stack_min[-1] >= x:\\n            self.stack_min.append(x)\\n\\n    def pop(self):\\n        last = self.stack_main.pop()\\n        if last == self.stack_min[-1]:\\n            self.stack_min.pop()\\n\\n    def top(self):\\n        return self.stack_main[-1]\\n\\n    def getMin(self):\\n        return self.stack_min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269091,
                "title": "c-one-stack",
                "content": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        min = INT_MAX;\\n    }\\n    \\n    void push(int x) {\\n        if (x <= min)\\n        {\\n            s.push(min);\\n            min = x;\\n        }\\n        s.push(x);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == min)\\n        {\\n            s.pop();\\n            min = s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        min = INT_MAX;\\n    }\\n    \\n    void push(int x) {\\n        if (x <= min)\\n        {\\n            s.push(min);\\n            min = x;\\n        }\\n        s.push(x);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == min)\\n        {\\n            s.pop();\\n            min = s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3813687,
                "title": "5-line-c-code-clear-intuition-line-by-line-code-explanation",
                "content": "# Intuition\\nwe will maintain 2 stack , 1st one(named s1 ) will having normal values but 2nd one (min_st)having always minimum value on it\\'s top.\\n\\n# Approach\\n1. push and pop operation will be always for 1st one stack(s1).\\n2. push and pop operation will be done for 2nd one stack in below cases:\\n\\n   **a). if 2nd one stack is empty or value which is going to be push in 2nd stack is <= top of 2nd stack**\\n    **b). if both stack\\'s top element is equal to each-other then top element is also pop from 2nd one stack.**\\n \\n **NOTE: push and pop operation will be always for 1st stack(s1)**\\n\\n**minimum element will be always having 2nd one stack(min_st.top)*\\n \\n           **\\uD83D\\uDD25Kindly upvote if you find this helpful\\uD83D\\uDD25**\\n\\n# Complexity\\n**Time complexity:\\n   O(1)**\\n# Space Complexity \\n  **O(N)**\\n    \\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int>s1,min_st; // we created 2 stack (1st stack is normal,min_st.top() always having minimun element)\\n    MinStack() {\\n        int val;\\n    }\\n    void push(int val) {\\n        // for normal stack, val will be always push\\n        s1.push(val);\\n        // for min stack(min_st), val will be push in below case\\n        if(min_st.empty() || val <= min_st.top()){\\n            min_st.push(val);\\n        }\\n    }\\n    void pop() {\\n        // pop and push operation will be alwayas from s1 stack\\n        if(s1.top()== min_st.top()){ //if min_st ka top,s1 top ke equal h to dono stack se pop\\n           min_st.pop();\\n        }\\n        s1.pop(); \\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        //min. val having always with min_st.top()\\n        return min_st.top();\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int>s1,min_st; // we created 2 stack (1st stack is normal,min_st.top() always having minimun element)\\n    MinStack() {\\n        int val;\\n    }\\n    void push(int val) {\\n        // for normal stack, val will be always push\\n        s1.push(val);\\n        // for min stack(min_st), val will be push in below case\\n        if(min_st.empty() || val <= min_st.top()){\\n            min_st.push(val);\\n        }\\n    }\\n    void pop() {\\n        // pop and push operation will be alwayas from s1 stack\\n        if(s1.top()== min_st.top()){ //if min_st ka top,s1 top ke equal h to dono stack se pop\\n           min_st.pop();\\n        }\\n        s1.pop(); \\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        //min. val having always with min_st.top()\\n        return min_st.top();\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620642,
                "title": "using-one-stack-simple-and-concise-c",
                "content": "Implementation\\n\\n**Time Complexity = O(1)**\\n\\n```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min = INT_MAX;\\n    \\npublic:    \\n    MinStack() {        \\n    }\\n    \\n    void push(int val) {\\n        if(val <= min){\\n            s.push(min);    \\n            min = val;\\n        }        \\n        s.push(val);\\n    }\\n    \\n    void pop() {        \\n        if(s.top() == min) {\\n            s.pop();\\n            min = s.top();            \\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\nprivate:\\n    stack<int> s;\\n    int min = INT_MAX;\\n    \\npublic:    \\n    MinStack() {        \\n    }\\n    \\n    void push(int val) {\\n        if(val <= min){\\n            s.push(min);    \\n            min = val;\\n        }        \\n        s.push(val);\\n    }\\n    \\n    void pop() {        \\n        if(s.top() == min) {\\n            s.pop();\\n            min = s.top();            \\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747181,
                "title": "clear-python-code-faster-than-96",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.currentMin = float(\\'inf\\')\\n        self.prevMins = []\\n        \\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if x <= self.currentMin:\\n            self.prevMins.append(self.currentMin)\\n            self.currentMin = x\\n\\n    def pop(self) -> None:\\n        if self.stack[-1] == self.currentMin:\\n            self.currentMin = self.prevMins.pop()\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.currentMin\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.currentMin = float(\\'inf\\')\\n        self.prevMins = []\\n        \\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if x <= self.currentMin:\\n            self.prevMins.append(self.currentMin)\\n            self.currentMin = x\\n\\n    def pop(self) -> None:\\n        if self.stack[-1] == self.currentMin:\\n            self.currentMin = self.prevMins.pop()\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.currentMin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49196,
                "title": "6-lines-concise-and-easy-understand-c-solution",
                "content": "    class MinStack {\\n    public:\\n        void push(int x) {\\n            int minnum = st.empty() ? x : min(st.top().second, x);\\n            st.push(make_pair(x, minnum));\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    private:\\n        stack<pair<int, int>> st;\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n    public:\\n        void push(int x) {\\n            int minnum = st.empty() ? x : min(st.top().second, x);\\n            st.push(make_pair(x, minnum));\\n        }\\n    \\n        void pop() {\\n            st.pop();\\n        }\\n    \\n        int top() {\\n            return st.top().first;\\n        }\\n    \\n        int getMin() {\\n            return st.top().second;\\n        }\\n    private:\\n        stack<pair<int, int>> st;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49383,
                "title": "mle-and-accept-after-change-all-the-vector-to-stack",
                "content": "Below is my accepted code. If you change all the stack to vector, as well as all the top to back and push to push_back, pop to pop_back, then you'll get a MLE.\\n\\nWHY?\\n**Is there a tricky implement of stack in STL or does the vector brings me the fuss?**\\nthanks for your attention and answer!\\n\\n    class MinStack {\\n    private:\\n        stack<int> sta;\\n        stack<int> minSta;\\n    public:\\n        void push(int x) {\\n            sta.push(x);\\n            if(!minSta.size() || minSta.top() >= x)\\n                minSta.push(x);\\n        }\\n    \\n        void pop() {\\n            if(!sta.empty()) {\\n                if(!minSta.empty() && sta.top() == minSta.top())\\n                    minSta.pop();\\n                sta.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            if(!sta.empty()) return sta.top();\\n        }\\n    \\n        int getMin() {\\n            if(!minSta.empty()) return minSta.top();\\n        }\\n    };",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Below is my accepted code. If you change all the stack to vector, as well as all the top to back and push to push_back, pop to pop_back, then you'll get a MLE.\\n\\nWHY?\\n**Is there a tricky implement of stack in STL or does the vector brings me the fuss?**\\nthanks for your attention and answer!\\n\\n    class MinStack {\\n    private:\\n        stack<int> sta;\\n        stack<int> minSta;\\n    public:\\n        void push(int x) {\\n            sta.push(x);\\n            if(!minSta.size() || minSta.top() >= x)\\n                minSta.push(x);\\n        }\\n    \\n        void pop() {\\n            if(!sta.empty()) {\\n                if(!minSta.empty() && sta.top() == minSta.top())\\n                    minSta.pop();\\n                sta.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            if(!sta.empty()) return sta.top();\\n        }\\n    \\n        int getMin() {\\n            if(!minSta.empty()) return minSta.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3208735,
                "title": "155-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo implement the MinStack, we can use two stacks. One stack will store the actual elements, and the other stack will store the minimum values seen so far. When we push a new element onto the stack, we check if it\\'s smaller than the current minimum value, and if so, we push it onto the minimum stack. When we pop an element from the stack, we also pop the corresponding element from the minimum stack if it\\'s the current minimum value.\\n\\nLet\\'s go through the time and space complexity analysis for each function:\\n\\n- push: O(1) time complexity for pushing an element onto the main stack and the minimum stack, and O(1) space complexity for storing the two stacks.\\n- pop: O(1) time complexity for popping an element from the main stack and the minimum stack, and O(1) space complexity for the two stacks.\\n- top: O(1) time complexity for returning the top element of the main stack, and O(1) space complexity for the two stacks.\\n- getMin: O(1) time complexity for returning the minimum value from the minimum stack, and O(1) space complexity for the two stacks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []  # initialize main stack\\n        self.min_stack = []  # initialize minimum value stack\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)  # push value onto main stack\\n        if not self.min_stack or val <= self.min_stack[-1]:  # if minimum stack is empty or the value is smaller or equal to current minimum\\n            self.min_stack.append(val)  # push value onto minimum stack\\n\\n    def pop(self) -> None:\\n        if self.stack:  # check if main stack is not empty\\n            if self.stack[-1] == self.min_stack[-1]:  # if the element to pop is the current minimum\\n                self.min_stack.pop()  # pop from minimum stack\\n            self.stack.pop()  # always pop from main stack\\n\\n    def top(self) -> int:\\n        if self.stack:  # check if main stack is not empty\\n            return self.stack[-1]  # return the top element\\n\\n    def getMin(self) -> int:\\n        if self.min_stack:  # check if minimum stack is not empty\\n            return self.min_stack[-1]  # return the current minimum value\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []  # initialize main stack\\n        self.min_stack = []  # initialize minimum value stack\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)  # push value onto main stack\\n        if not self.min_stack or val <= self.min_stack[-1]:  # if minimum stack is empty or the value is smaller or equal to current minimum\\n            self.min_stack.append(val)  # push value onto minimum stack\\n\\n    def pop(self) -> None:\\n        if self.stack:  # check if main stack is not empty\\n            if self.stack[-1] == self.min_stack[-1]:  # if the element to pop is the current minimum\\n                self.min_stack.pop()  # pop from minimum stack\\n            self.stack.pop()  # always pop from main stack\\n\\n    def top(self) -> int:\\n        if self.stack:  # check if main stack is not empty\\n            return self.stack[-1]  # return the top element\\n\\n    def getMin(self) -> int:\\n        if self.min_stack:  # check if minimum stack is not empty\\n            return self.min_stack[-1]  # return the current minimum value\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346649,
                "title": "simple-and-very-short-solution-o-1-time-for-all-operations",
                "content": "Very short solution and simple idea. Instead of keeping integer in the underlying stack, we also keep the min value for the moment item was pushed into the stack. Think of it as a photography of the min value taken and stored with each value pushed into the stack at that moment.\\n\\nImplementation is trivial. The only line that needs explanation is below:\\n\\n```\\nvoid push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n```\\n\\nSo we take the minimum of last pushed item\\'s min, or x itself, and x if the stack is yet empty.\\n\\nThis capturing technique is useful for a range of other problems as well. Hope it helps, and enjoy:\\n\\n```\\nclass MinStack {\\nprivate:\\n    class Data {\\n    public:\\n        Data(int v, int m) : val(v), min(m) {}\\n        int val;\\n        int min;\\n    };\\n    stack<Data> s;\\npublic:\\n    void push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n    void pop() { s.pop(); }\\n    int top() { return s.top().val; }\\n    int getMin() { return s.top().min; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n```\n```\\nclass MinStack {\\nprivate:\\n    class Data {\\n    public:\\n        Data(int v, int m) : val(v), min(m) {}\\n        int val;\\n        int min;\\n    };\\n    stack<Data> s;\\npublic:\\n    void push(int x) { s.push(Data(x, s.empty() ? x : min(x, s.top().min))); }\\n    void pop() { s.pop(); }\\n    int top() { return s.top().val; }\\n    int getMin() { return s.top().min; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49207,
                "title": "share-my-clean-ac-c-solution-with-explanation",
                "content": "The key idea is use a another stack to store the `minimum value` of the corresponding stack. Put differently, `min[i]` equals the minimum element where `data[i]` is the top of this sub-stack.\\n\\nWe can use a full size of `min` where its size equals the data's, but it's not necessary.\\n\\n**Idea**\\n\\n*  We should `pop` the element in `min` IFF there's match of `data.top()`.\\n\\n* If we have multiple same minima, for example `[0, 1, 0]` in `data`, then the `min` should be `[0, 0]`.\\nOtherwise, the the `pop` operation wouldn't work properly, since that you need 2 `0`s.\\nAs a result, we should push the element if `x <= min.top()`.\\n\\n\\n**Code**\\n\\n    class MinStack {\\n        \\n        stack<int> data;\\n        stack<int> min;\\n\\n    public:\\n\\n        void push(int x) {\\n            \\n            // If empty\\n            if (min.empty()) {\\n                data.push(x);\\n                min.push(x);\\n            }\\n            \\n            // Not empty\\n            else {\\n                data.push(x);\\n                if (x <= min.top())\\n                    min.push(x);\\n            }\\n\\n        }\\n\\n        void pop() {\\n            \\n            if (!min.empty()) {\\n                if (data.top() == min.top())\\n                    min.pop();\\n                data.pop();\\n            }\\n        }\\n\\n        int top() {\\n            return data.top();\\n        }\\n\\n        int getMin() {\\n            return min.top();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "The key idea is use a another stack to store the `minimum value` of the corresponding stack. Put differently, `min[i]` equals the minimum element where `data[i]` is the top of this sub-stack.\\n\\nWe can use a full size of `min` where its size equals the data's, but it's not necessary.\\n\\n**Idea**\\n\\n*  We should `pop` the element in `min` IFF there's match of `data.top()`.\\n\\n* If we have multiple same minima, for example `[0, 1, 0]` in `data`, then the `min` should be `[0, 0]`.\\nOtherwise, the the `pop` operation wouldn't work properly, since that you need 2 `0`s.\\nAs a result, we should push the element if `x <= min.top()`.\\n\\n\\n**Code**\\n\\n    class MinStack {\\n        \\n        stack<int> data;\\n        stack<int> min;\\n\\n    public:\\n\\n        void push(int x) {\\n            \\n            // If empty\\n            if (min.empty()) {\\n                data.push(x);\\n                min.push(x);\\n            }\\n            \\n            // Not empty\\n            else {\\n                data.push(x);\\n                if (x <= min.top())\\n                    min.push(x);\\n            }\\n\\n        }\\n\\n        void pop() {\\n            \\n            if (!min.empty()) {\\n                if (data.top() == min.top())\\n                    min.pop();\\n                data.pop();\\n            }\\n        }\\n\\n        int top() {\\n            return data.top();\\n        }\\n\\n        int getMin() {\\n            return min.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 544220,
                "title": "simple-c-solution-using-a-single-stack-no-struct-needed-too-100-time-and-space-efficient",
                "content": "I decided to post this solution as I found in the discussion tab that mainly people discussed about solutions using 2 stacks or using 2 lists or using structs along with list. This solution is **100% TIME and SPACE efficient**  and uses a simple trick to get us the minimum element in the stack using O(1) time. See the top( ), pop( ) and push( ) methods to see the little tweak used. \\n\\nInstead of pushing in the element which is smaller than the current minimum we push in **2 * x - min** (where x is the element we are currently pushing and min is the current minimum) and update the variable min. Similarly, when we pop, if the top element is smaller than the current min, we update min by, **min = 2 * min - s.top()** and then pop the element. We also have to keep in mind that in the top( ) function if the current top element is smaller than min then we need to **return min**.\\n\\n```\\n\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack< long double > s ;\\n    long double min ;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(long double x) {\\n        if( s.empty() == true ){\\n           s.push(x) ;\\n           min = x ;\\n        }else{\\n           if( x < min ){\\n               s.push( 2 * x - min ) ;\\n               min = x ;\\n               \\n           }else{\\n              s.push( x ) ;\\n           }\\n        }\\n    }\\n    \\n    void pop() {\\n        if( s.empty() == false ){\\n            if( s.top() > min ){\\n                s.pop() ;\\n            }else{\\n                min = 2 * min - s.top() ;\\n                s.pop() ;\\n            }\\n        }\\n    }\\n    \\n    int top() {\\n        if( s.top() > min )\\n            return s.top() ;\\n        else\\n            return min ;\\n    }\\n    \\n    int getMin() {\\n        return min ;\\n    }\\n};\\n \\n ```",
                "solutionTags": [],
                "code": "```\\n\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack< long double > s ;\\n    long double min ;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(long double x) {\\n        if( s.empty() == true ){\\n           s.push(x) ;\\n           min = x ;\\n        }else{\\n           if( x < min ){\\n               s.push( 2 * x - min ) ;\\n               min = x ;\\n               \\n           }else{\\n              s.push( x ) ;\\n           }\\n        }\\n    }\\n    \\n    void pop() {\\n        if( s.empty() == false ){\\n            if( s.top() > min ){\\n                s.pop() ;\\n            }else{\\n                min = 2 * min - s.top() ;\\n                s.pop() ;\\n            }\\n        }\\n    }\\n    \\n    int top() {\\n        if( s.top() > min )\\n            return s.top() ;\\n        else\\n            return min ;\\n    }\\n    \\n    int getMin() {\\n        return min ;\\n    }\\n};\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 49176,
                "title": "thoroughly-explaining-what-s-going-on-a-very-concise-solution-accepted-as-best-submission-in-c",
                "content": "Before we really get started, let\\'s first make some points clear about this problem and also there are some complaints about the specification of the problem -> so misleading!    Here is the detailed specification of the problem: \\n\\n- push will push the value to the stack - add a new top value;\\n- pop will delete the top value of the stack - the only removing operation;\\n- top will just return he top value of the stack - no removing;\\n- getMin will just get the minimal value among the values in stack - no removing;\\n\\nThe true question comes around now, how can we just get the minimal of the stack in constant time? First we need to think about this -> it\\'s a stack -> values comes and goes at the rear of an array -> so we can just use another array <font color=\"#0000ff\">mins</font> to store the so-far minimals which exactly means that when we are pushing values to the stack from the very beginning, we need to check whether the so-far minimal will be changed, if it\\'s changed for the incoming new value, we need to push this value to the <font color=\"#0000ff\">mins</font> array and so on and so on.\\n\\n> the other array <font color=\"#0000ff\">mins</font> will store the so-far minimals and should be updated in each push and pop operation to maintain this feature\\n\\n- so-far minimals means the minimals among values from the bottom till the top of the stack\\n\\nBang! End of Story!\\n\\nAnother typical example using space to reduce time cost:\\n\\n- space cost O(n)\\n- time cost O(1)\\n\\n----------\\n\\n\\n    typedef struct\\n    {\\n        int *arr;\\n        int count;\\n        int *mins;\\n        int minCount;\\n    } MinStack;\\n    \\n    void minStackCreate(MinStack *stack, int maxSize)\\n    {\\n        stack->arr = (int*)malloc(sizeof(int)*maxSize);\\n        stack->mins = (int*)malloc(sizeof(int)*maxSize); //record the mins till the top of the arr;\\n        stack->count = 0;\\n        stack->minCount = 0;\\n    }\\n    \\n    void minStackPush(MinStack *stack, int element) //push it to arr normally, but meantime check whether we should push it to mins;\\n    {\\n        stack->arr[stack->count++] = element;\\n        if(stack->minCount==0 || element<=stack->mins[stack->minCount-1])\\n            stack->mins[stack->minCount++] = element;\\n    }\\n    \\n    void minStackPop(MinStack *stack) //pop will always pop the top -> the top of mins and arr;\\n    {\\n        int top = stack->arr[stack->count-1];\\n        if(stack->mins[stack->minCount-1] == top)\\n            stack->minCount--;\\n        stack->count--;\\n    }\\n    \\n    int minStackTop(MinStack *stack) //just return the top, needless to remove it;\\n    {\\n        return stack->arr[stack->count-1];\\n    }\\n    \\n    int minStackGetMin(MinStack *stack) //just return the min, needless to remove it;\\n    {\\n        return stack->mins[stack->minCount-1];\\n    }\\n    \\n    void minStackDestroy(MinStack *stack)\\n    {\\n        free(stack->arr);\\n        free(stack->mins);\\n    }",
                "solutionTags": [],
                "code": "Before we really get started, let\\'s first make some points clear about this problem and also there are some complaints about the specification of the problem -> so misleading!    Here is the detailed specification of the problem: \\n\\n- push will push the value to the stack - add a new top value;\\n- pop will delete the top value of the stack - the only removing operation;\\n- top will just return he top value of the stack - no removing;\\n- getMin will just get the minimal value among the values in stack - no removing;\\n\\nThe true question comes around now, how can we just get the minimal of the stack in constant time? First we need to think about this -> it\\'s a stack -> values comes and goes at the rear of an array -> so we can just use another array <font color=\"#0000ff\">mins</font> to store the so-far minimals which exactly means that when we are pushing values to the stack from the very beginning, we need to check whether the so-far minimal will be changed, if it\\'s changed for the incoming new value, we need to push this value to the <font color=\"#0000ff\">mins</font> array and so on and so on.\\n\\n> the other array <font color=\"#0000ff\">mins</font> will store the so-far minimals and should be updated in each push and pop operation to maintain this feature\\n\\n- so-far minimals means the minimals among values from the bottom till the top of the stack\\n\\nBang! End of Story!\\n\\nAnother typical example using space to reduce time cost:\\n\\n- space cost O(n)\\n- time cost O(1)\\n\\n----------\\n\\n\\n    typedef struct\\n    {\\n        int *arr;\\n        int count;\\n        int *mins;\\n        int minCount;\\n    } MinStack;\\n    \\n    void minStackCreate(MinStack *stack, int maxSize)\\n    {\\n        stack->arr = (int*)malloc(sizeof(int)*maxSize);\\n        stack->mins = (int*)malloc(sizeof(int)*maxSize); //record the mins till the top of the arr;\\n        stack->count = 0;\\n        stack->minCount = 0;\\n    }\\n    \\n    void minStackPush(MinStack *stack, int element) //push it to arr normally, but meantime check whether we should push it to mins;\\n    {\\n        stack->arr[stack->count++] = element;\\n        if(stack->minCount==0 || element<=stack->mins[stack->minCount-1])\\n            stack->mins[stack->minCount++] = element;\\n    }\\n    \\n    void minStackPop(MinStack *stack) //pop will always pop the top -> the top of mins and arr;\\n    {\\n        int top = stack->arr[stack->count-1];\\n        if(stack->mins[stack->minCount-1] == top)\\n            stack->minCount--;\\n        stack->count--;\\n    }\\n    \\n    int minStackTop(MinStack *stack) //just return the top, needless to remove it;\\n    {\\n        return stack->arr[stack->count-1];\\n    }\\n    \\n    int minStackGetMin(MinStack *stack) //just return the min, needless to remove it;\\n    {\\n        return stack->mins[stack->minCount-1];\\n    }\\n    \\n    void minStackDestroy(MinStack *stack)\\n    {\\n        free(stack->arr);\\n        free(stack->mins);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1292689,
                "title": "runtime-3-ms-faster-than-100-00-of-java-online-submissions-for-min-stack",
                "content": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716384,
                "title": "python-stack-linked-list-solution-easy-to-understand",
                "content": "```\\nclass Node:\\n    def __init__(self, val=None, mini=None, next=None):\\n        # Initialize Node\\n        self.val = val\\n        self.minimum = mini\\n        self.next = next\\n\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.head = None\\n        \\n\\n    def push(self, x: int) -> None:\\n\\t# insert at beginning of the list\\n\\t# check if head is Null\\n        if self.head is None:\\n            node = Node(x, x)\\n            self.head = node\\n        else:\\n\\t\\t# using min inbuilt function to check for minimum value between the current inserted value and previous minimum value\\n            node = Node(x, min(x, self.head.minimum), self.head)\\n            self.head = node\\n        \\n\\n    def pop(self) -> None:\\n\\t# just change the head pointer to next node\\n        self.head = self.head.next\\n        \\n\\n    def top(self) -> int:\\n\\t# returns top of the linked list\\n        return self.head.val\\n        \\n\\n    def getMin(self) -> int:\\n\\t# returns minimum value\\n        return self.head.minimum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val=None, mini=None, next=None):\\n        # Initialize Node\\n        self.val = val\\n        self.minimum = mini\\n        self.next = next\\n\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.head = None\\n        \\n\\n    def push(self, x: int) -> None:\\n\\t# insert at beginning of the list\\n\\t# check if head is Null\\n        if self.head is None:\\n            node = Node(x, x)\\n            self.head = node\\n        else:\\n\\t\\t# using min inbuilt function to check for minimum value between the current inserted value and previous minimum value\\n            node = Node(x, min(x, self.head.minimum), self.head)\\n            self.head = node\\n        \\n\\n    def pop(self) -> None:\\n\\t# just change the head pointer to next node\\n        self.head = self.head.next\\n        \\n\\n    def top(self) -> int:\\n\\t# returns top of the linked list\\n        return self.head.val\\n        \\n\\n    def getMin(self) -> int:\\n\\t# returns minimum value\\n        return self.head.minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691876,
                "title": "python-simples-o-1-solution-using-tuples",
                "content": "```\\n        ## RC ##\\n        ## APPROACH : make tuples (x,y) \\n        # where x is element directly given and y is always minElement i.e y will have minElement in the current existing list ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(1) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n    def push(self, x: int) -> None:\\n        if self.stack:\\n            self.stack.append((x, min(x, self.getMin())))\\n        else:\\n            self.stack.append((x,x))\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1][0] if self.stack else None\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1][1] if self.stack else None\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        ## RC ##\\n        ## APPROACH : make tuples (x,y) \\n        # where x is element directly given and y is always minElement i.e y will have minElement in the current existing list ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(1) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n    def push(self, x: int) -> None:\\n        if self.stack:\\n            self.stack.append((x, min(x, self.getMin())))\\n        else:\\n            self.stack.append((x,x))\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1][0] if self.stack else None\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1][1] if self.stack else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49202,
                "title": "very-concise-java-solution-with-deque-interface",
                "content": "The solution is pretty straightforward, keep a minStack besides the underlying stack. During push: push a new item if it's smaller or equals than the current minimum. During pop: if the current item to be popped equals to the top of minStack then pop that one aswell.\\n\\n    Deque<Integer> stack = new LinkedList<>();\\n    Deque<Integer> minStack = new LinkedList<>();\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if(minStack.isEmpty() || minStack.peek() >= x) {\\n            minStack.push(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        int x = stack.pop();\\n        if(x == minStack.peek()) {\\n            minStack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return minStack.peek();\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "The solution is pretty straightforward, keep a minStack besides the underlying stack. During push: push a new item if it's smaller or equals than the current minimum. During pop: if the current item to be popped equals to the top of minStack then pop that one aswell.\\n\\n    Deque<Integer> stack = new LinkedList<>();\\n    Deque<Integer> minStack = new LinkedList<>();\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if(minStack.isEmpty() || minStack.peek() >= x) {\\n            minStack.push(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        int x = stack.pop();\\n        if(x == minStack.peek()) {\\n            minStack.pop();\\n        }\\n    }\\n\\n    public int top() {\\n        return stack.peek();\\n    }\\n\\n    public int getMin() {\\n        return minStack.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 571962,
                "title": "easy-c-solution-using-stack-of-pairs",
                "content": "Create a stack of pairs \\nwhere first element of pair stores the element\\nsecond element of pair stores the min element seen so far\\n1. INSERTION\\npush element and min_element\\n\\n2. TOP\\nreturn element from the top of stack\\n\\n3. MIN ELEMENT\\nreturn min_element from the pair on top of the stack\\n\\n4. POP\\npop the pair on top of stack \\n\\nCODE:\\n```\\nclass MinStack {\\n    stack<pair<int,int>> sp;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(sp.empty())\\n        sp.push({x,x});\\n        else\\n            sp.push({x,min(sp.top().second,x)});\\n    }\\n    \\n    void pop() {\\n        sp.pop();\\n    }\\n    \\n    int top() {\\n        return sp.top().first;\\n    }\\n    \\n    int getMin() {\\n        return sp.top().second;\\n    }\\n};",
                "solutionTags": [],
                "code": "Create a stack of pairs \\nwhere first element of pair stores the element\\nsecond element of pair stores the min element seen so far\\n1. INSERTION\\npush element and min_element\\n\\n2. TOP\\nreturn element from the top of stack\\n\\n3. MIN ELEMENT\\nreturn min_element from the pair on top of the stack\\n\\n4. POP\\npop the pair on top of stack \\n\\nCODE:\\n```\\nclass MinStack {\\n    stack<pair<int,int>> sp;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        if(sp.empty())\\n        sp.push({x,x});\\n        else\\n            sp.push({x,min(sp.top().second,x)});\\n    }\\n    \\n    void pop() {\\n        sp.pop();\\n    }\\n    \\n    int top() {\\n        return sp.top().first;\\n    }\\n    \\n    int getMin() {\\n        return sp.top().second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3528770,
                "title": "o-1-solution-python",
                "content": "\\n# Approach\\nCreate two seperate stacks, one is the main stack and the other is the minimum stack which holds the corresponding minimum value for each value in our main stack.\\n\\nWhen we want to push a value into our stack, we first check to see if the stack is empty. If it is, then we push the value in both our main stack and our minimum stack.\\n\\nIf the stack is not empty, we want to then compare the given value with the value at the top of our minimum stack. If the value if less than the top value of our minimum stack, we append the value in our minimum stack and our main stack. If the value is greater than the top of our minimum stack, we then push the value into our main stack but this time, we push the top of our minimum value in our minimum stack back into the minimum stack.\\n\\nThis way we can tell what value is the minimum of the stack without using any O(n) approaches.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minstack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append(val)\\n            self.minstack.append(val)\\n        else:\\n            if val < self.minstack[-1]:\\n                self.minstack.append(val)\\n                self.stack.append(val)\\n            else:\\n                self.stack.append(val)\\n                self.minstack.append(self.minstack[-1])\\n\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minstack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append(val)\\n            self.minstack.append(val)\\n        else:\\n            if val < self.minstack[-1]:\\n                self.minstack.append(val)\\n                self.stack.append(val)\\n            else:\\n                self.stack.append(val)\\n                self.minstack.append(self.minstack[-1])\\n\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748459,
                "title": "java-two-stacks-so-simple",
                "content": "```\\nclass MinStack {\\n\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        minStack = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if (minStack.isEmpty() || x <= minStack.peek()) {\\n            minStack.push(x);\\n        }\\n    }\\n    \\n    public void pop() {\\n        if (stack.peek().equals(minStack.peek())) minStack.pop();\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        minStack = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        stack.push(x);\\n        if (minStack.isEmpty() || x <= minStack.peek()) {\\n            minStack.push(x);\\n        }\\n    }\\n    \\n    public void pop() {\\n        if (stack.peek().equals(minStack.peek())) minStack.pop();\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49296,
                "title": "shortest-and-fastest-1-stack-and-2-stack-solutions",
                "content": "2-stack solution may use less memory (ironically) since we don't save the 'min' for every pushed element. \\nIf there are a lot of repeated elements, we may save even more memory by  introducing a 'count' for each 'min'.\\n\\nCannot use vector (will get memory limit error), as vector doubles its capacity when full, whereas deque has a better capacity management strategy.\\n\\n2 deque:\\n\\n        deque<int> stack;\\n        deque<int> mins;\\n        \\n        void push(int x) {\\n            int themin = mins.size() ? mins.back() : x;\\n            stack.push_back(x);\\n            if (x<=themin)\\n                mins.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (stack.back()==mins.back())\\n                mins.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back();\\n        }\\n    \\n        int getMin() {\\n            return mins.back();\\n        }\\n   \\n1 deque (save current min for every pushed elem):\\n\\n\\n    typedef pair<int,int> pairt;\\n\\n        deque<pairt> stack;\\n\\n        void push(int x) {\\n            if (stack.size())\\n                stack.push_back(make_pair(x, min(x,getMin()) ));\\n            else \\n                stack.push_back(make_pair(x, x));\\n        }\\n    \\n        void pop() {\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back().first;\\n        }\\n    \\n        int getMin() {\\n            return stack.back().second;\\n        }",
                "solutionTags": [],
                "code": "2-stack solution may use less memory (ironically) since we don't save the 'min' for every pushed element. \\nIf there are a lot of repeated elements, we may save even more memory by  introducing a 'count' for each 'min'.\\n\\nCannot use vector (will get memory limit error), as vector doubles its capacity when full, whereas deque has a better capacity management strategy.\\n\\n2 deque:\\n\\n        deque<int> stack;\\n        deque<int> mins;\\n        \\n        void push(int x) {\\n            int themin = mins.size() ? mins.back() : x;\\n            stack.push_back(x);\\n            if (x<=themin)\\n                mins.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (stack.back()==mins.back())\\n                mins.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back();\\n        }\\n    \\n        int getMin() {\\n            return mins.back();\\n        }\\n   \\n1 deque (save current min for every pushed elem):\\n\\n\\n    typedef pair<int,int> pairt;\\n\\n        deque<pairt> stack;\\n\\n        void push(int x) {\\n            if (stack.size())\\n                stack.push_back(make_pair(x, min(x,getMin()) ));\\n            else \\n                stack.push_back(make_pair(x, x));\\n        }\\n    \\n        void pop() {\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            return stack.back().first;\\n        }\\n    \\n        int getMin() {\\n            return stack.back().second;\\n        }",
                "codeTag": "Python3"
            },
            {
                "id": 49367,
                "title": "my-java-solution-without-build-in-stack",
                "content": "Do not use the java stack.\\n\\n       class MinStack {\\n            \\n            Node top = null;\\n            \\n            public void push(int x) {\\n                if (top == null) {\\n                    top = new Node(x);\\n                    top.min = x;\\n                }\\n                else {\\n                    Node temp = new Node(x);\\n                    temp.next = top;\\n                    top = temp;\\n                    top.min = Math.min(top.next.min, x);\\n                }\\n                \\n                return;\\n            }\\n        \\n            public void pop() {\\n                top = top.next;\\n                return;\\n            }\\n        \\n            public int top() {\\n                return top == null ? 0 : top.val;\\n            }\\n        \\n            public int getMin() {\\n                return top == null ? 0 : top.min;\\n            }\\n        }\\n        \\n        class Node {\\n            int val;\\n            int min;\\n            Node next;\\n            \\n            public Node(int val) {\\n                this.val = val;\\n            }\\n        }",
                "solutionTags": [],
                "code": "Do not use the java stack.\\n\\n       class MinStack {\\n            \\n            Node top = null;\\n            \\n            public void push(int x) {\\n                if (top == null) {\\n                    top = new Node(x);\\n                    top.min = x;\\n                }\\n                else {\\n                    Node temp = new Node(x);\\n                    temp.next = top;\\n                    top = temp;\\n                    top.min = Math.min(top.next.min, x);\\n                }\\n                \\n                return;\\n            }\\n        \\n            public void pop() {\\n                top = top.next;\\n                return;\\n            }\\n        \\n            public int top() {\\n                return top == null ? 0 : top.val;\\n            }\\n        \\n            public int getMin() {\\n                return top == null ? 0 : top.min;\\n            }\\n        }\\n        \\n        class Node {\\n            int val;\\n            int min;\\n            Node next;\\n            \\n            public Node(int val) {\\n                this.val = val;\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 571959,
                "title": "java-solution-using-o-1-time-for-getmin-and-o-1-space",
                "content": "```\\nclass MinStack {\\n    \\n    Stack<int[]> stack;\\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<int[]>();\\n        \\n    }\\n    \\n    // method to push a new element along with the min value till that point\\n    public void push(int x) {\\n        // if the stack is empty push the element to stack, min=element itself\\n\\t\\tif (stack.empty()) {\\n\\t\\t\\tstack.push(new int[] { x, x });\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// compare the top min element with the new element, if new element is\\n\\t\\t// smaller\\n\\t\\t// then add the new min as the current element\\n\\t\\tint currentMin = stack.peek()[1];\\n\\t\\tstack.push(new int[] { x, Math.min(currentMin, x) });\\n        \\n        \\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek()[0];\\n        \\n    }\\n    \\n    public int getMin() {\\n        return stack.peek()[1];\\n        \\n    }\\n    \\n    public boolean isEmpty() {\\n        return stack.empty();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(x);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n    \\n    Stack<int[]> stack;\\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<int[]>();\\n        \\n    }\\n    \\n    // method to push a new element along with the min value till that point\\n    public void push(int x) {\\n        // if the stack is empty push the element to stack, min=element itself\\n\\t\\tif (stack.empty()) {\\n\\t\\t\\tstack.push(new int[] { x, x });\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// compare the top min element with the new element, if new element is\\n\\t\\t// smaller\\n\\t\\t// then add the new min as the current element\\n\\t\\tint currentMin = stack.peek()[1];\\n\\t\\tstack.push(new int[] { x, Math.min(currentMin, x) });\\n        \\n        \\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek()[0];\\n        \\n    }\\n    \\n    public int getMin() {\\n        return stack.peek()[1];\\n        \\n    }\\n    \\n    public boolean isEmpty() {\\n        return stack.empty();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(x);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775651,
                "title": "python-99-95-faster-only-one-stack",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.st=[] #stack\\n        self.min=None #min element\\n\\n    def push(self, val: int) -> None:\\n        if len(self.st)==0:\\n            self.st.append(val)\\n            self.min=val\\n        else:\\n            if val>=self.min:\\n                self.st.append(val)\\n            else:\\n                self.st.append(2*val-self.min)\\n                self.min=val\\n                \\n    def pop(self) -> None:\\n        x=self.st.pop() \\n        if x<self.min:\\n            self.min=2*self.min-x\\n    \\n    def top(self) -> int:\\n        x=self.st[-1]\\n        if x>=self.min:\\n            return x\\n        return self.min\\n\\n    def getMin(self) -> int:\\n        return self.min\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.st=[] #stack\\n        self.min=None #min element\\n\\n    def push(self, val: int) -> None:\\n        if len(self.st)==0:\\n            self.st.append(val)\\n            self.min=val\\n        else:\\n            if val>=self.min:\\n                self.st.append(val)\\n            else:\\n                self.st.append(2*val-self.min)\\n                self.min=val\\n                \\n    def pop(self) -> None:\\n        x=self.st.pop() \\n        if x<self.min:\\n            self.min=2*self.min-x\\n    \\n    def top(self) -> int:\\n        x=self.st[-1]\\n        if x>=self.min:\\n            return x\\n        return self.min\\n\\n    def getMin(self) -> int:\\n        return self.min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544688,
                "title": "c-solution-using-single-stack-t-c-o-1-s-c-o-n",
                "content": "# Intuition\\nWe must have to maintain minimum element track for every push and pop.\\nSo we have to think accordingly.\\n\\n# Approach\\nMaintaining minimum element along with the current query \\n(we can also use two arrays for the same, one for maintaining queries and second one for maintainig minimum elements).\\n\\n# Complexity\\n- Time complexity:\\n    O(1)  (for every operation)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n\\nvector<pair<int,int>> arr;\\n    MinStack() {\\n\\n    }\\n    \\n    void push(int val) {\\n        if(arr.empty()){\\n            arr.push_back({val,val});\\n        }else{\\n            arr.push_back({val,min(val,arr.back().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        arr.pop_back();\\n    }\\n    \\n    int top() {\\n        return arr.back().first;\\n    }\\n    \\n    int getMin() {\\n        return arr.back().second;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n\\nvector<pair<int,int>> arr;\\n    MinStack() {\\n\\n    }\\n    \\n    void push(int val) {\\n        if(arr.empty()){\\n            arr.push_back({val,val});\\n        }else{\\n            arr.push_back({val,min(val,arr.back().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        arr.pop_back();\\n    }\\n    \\n    int top() {\\n        return arr.back().first;\\n    }\\n    \\n    int getMin() {\\n        return arr.back().second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749605,
                "title": "c-stack-with-val-min-pair",
                "content": "```\\nclass MinStack {\\npublic:\\n    //pair.first = actual value\\n\\t//pair.second = min value from the top (current value) to bottom of the stack\\n    stack<pair<int, int>> s; \\n    int minVal;\\n    \\n    MinStack() {\\n        minVal = INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if (s.size() == 0) {\\n            minVal = val;\\n        } else {\\n            minVal = s.top().second;\\n        }\\n        minVal = min(minVal, val);\\n        s.push({val, minVal});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    //pair.first = actual value\\n\\t//pair.second = min value from the top (current value) to bottom of the stack\\n    stack<pair<int, int>> s; \\n    int minVal;\\n    \\n    MinStack() {\\n        minVal = INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if (s.size() == 0) {\\n            minVal = val;\\n        } else {\\n            minVal = s.top().second;\\n        }\\n        minVal = min(minVal, val);\\n        s.push({val, minVal});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 572554,
                "title": "javascript-easy-to-understand-es6-class-solution",
                "content": "```\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = Infinity;\\n    }\\n    push(x) {\\n        const valMinPair = {val: x, prevMin: this.min};\\n        this.stack.push(valMinPair);\\n        this.min = Math.min(this.min, x);\\n    }\\n    pop() {\\n        const {val, prevMin} = this.stack.pop();\\n        this.min = prevMin;\\n        return val;\\n    }\\n    top() {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n    getMin() {\\n        return this.min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = Infinity;\\n    }\\n    push(x) {\\n        const valMinPair = {val: x, prevMin: this.min};\\n        this.stack.push(valMinPair);\\n        this.min = Math.min(this.min, x);\\n    }\\n    pop() {\\n        const {val, prevMin} = this.stack.pop();\\n        this.min = prevMin;\\n        return val;\\n    }\\n    top() {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n    getMin() {\\n        return this.min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354773,
                "title": "js-very-simple-idea",
                "content": "```\\n//solves in O(1) time & O(n) extra space \\nvar MinStack = function() {\\n    this.arr = [];\\n    //keeps track of min element at every point in lifetime of stack \\n    this.min = [];\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    this.arr.push(x);\\n    //if stack is empty\\n    if(this.min.length === 0) this.min.push(x);\\n    else {\\n        //if stack is non empty push the min element between current ele and top of this.min\\n        //for instance our stack was [-1, -0, -3]\\n        //push(-1) this.arr = [-1] | this.min = [-1]\\n        //push(0) this.arr = [-1, 0] | this.min = [-1, -1]\\n        //push(-3) this.arr = [-1,0,-3] | this.min = [-1,-1,-3]\\n        this.min.push(Math.min(this.min[this.min.length - 1], x));\\n    }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.arr.length != 0) {\\n        //pop ele from both this.arr and this.min\\n        this.arr.pop();\\n        this.min.pop();\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    //if this.arr non empty return element at last index of this.arr\\n    if(this.arr.length != 0) return this.arr[this.arr.length -1];\\n    return null\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    //if this.min non empty return element at last index of this.min\\n    if(this.min.length != 0) return this.min[this.min.length -1];\\n    return null\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//solves in O(1) time & O(n) extra space \\nvar MinStack = function() {\\n    this.arr = [];\\n    //keeps track of min element at every point in lifetime of stack \\n    this.min = [];\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    this.arr.push(x);\\n    //if stack is empty\\n    if(this.min.length === 0) this.min.push(x);\\n    else {\\n        //if stack is non empty push the min element between current ele and top of this.min\\n        //for instance our stack was [-1, -0, -3]\\n        //push(-1) this.arr = [-1] | this.min = [-1]\\n        //push(0) this.arr = [-1, 0] | this.min = [-1, -1]\\n        //push(-3) this.arr = [-1,0,-3] | this.min = [-1,-1,-3]\\n        this.min.push(Math.min(this.min[this.min.length - 1], x));\\n    }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    if(this.arr.length != 0) {\\n        //pop ele from both this.arr and this.min\\n        this.arr.pop();\\n        this.min.pop();\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    //if this.arr non empty return element at last index of this.arr\\n    if(this.arr.length != 0) return this.arr[this.arr.length -1];\\n    return null\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    //if this.min non empty return element at last index of this.min\\n    if(this.min.length != 0) return this.min[this.min.length -1];\\n    return null\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032506,
                "title": "simple-c-o-1-2-liner-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe either have to  use some other stack to keep track of  minimum till each index or we can have a stack pair. So actually what we will do is for each incoming element we will compare it with previous minimum element if it smaller then update the min else keep our min as it is.Also when stack is empty then we just have to push only..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo create a `stack<pair<int,int>>` and then in push function we can compare the incoming val that is to be pushed with the minimum till now and update accordingly and also check if stack is empty or not .\\nAnd rest all other fucntions are same and in getmin() function just return top.second beacuse minimum of every index is stored in its second.\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(!st.empty()){\\n             int mini=min(st.top().second,val);\\n             st.push({val,mini});\\n        }\\n        else st.push({val,val});\\n    }\\n    \\n    void pop() {\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(!st.empty()){\\n             int mini=min(st.top().second,val);\\n             st.push({val,mini});\\n        }\\n        else st.push({val,val});\\n    }\\n    \\n    void pop() {\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top().first;\\n    }\\n    \\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539426,
                "title": "javascript-easy-to-understand-detailed-explanation-o-1-for-all",
                "content": "For this problem, we need to implement the `push`, `pop`, `top`, and `getMin` these 4 methods. Since there is an `Array` object in JS already, so it\\'s straightforward to think about we could be based on it.\\n\\nThe original `Array` has `push` and `pop` already like a stack. And the `top` method could be easily implemented via `Array.length`. So, the key point for this problem is how to implement the `getMin`.\\n\\nFor sure, we could sort the array after each `push` operation, but it\\'s a general solution and will cost too much. In order to optimize  performance, we need to find out the uniqueness of the current scene and design the strategy based on it.\\n\\nLet me ask a question, what kinds of positions do we have when we remove values from an array? It\\'s straightforward, the middle, the head, and the tail. But, for this problem, it\\'s a stack with only `pop` and `push` operations to remove and add values, which means we could only modify the stack at the tail.\\n\\nWhy this question is so important? Let\\'s think, in which situation will the min value change? Bingo - when and only when we modify values. Then, about removing value, since all the previous values are the same, so actually, the min value we have already known won\\'t change. In other words, the only situation that we need to compare and get a new min value is when we add a new value.\\n\\nIf it\\'s a little bit abstract, let\\'s take a look at an example:\\n\\nFor array [3, 1, 4, 2, 5, 7], the min value for each index with its previous values is [3, 1, 1, 1, 1].  Whether we remove the last `7` or add new values, then previous min values will always be `[3, 1, 1, 1]`.\\n\\nAccording to this, we could save all the min values we\\'ve known already, this could makes the `getMin` O(1) time complexity.\\n\\nWe could use another array to save them, but I choose to use just one array - min values and real values are saved one by one. Here\\' the code:\\n\\n```js\\nclass MinStack {\\n  constructor() {\\n    this._top = -1;\\n    this.data = [];\\n    this.min = Number.MAX_SAFE_INTEGER;\\n  }\\n  push(n) {\\n    this.data[++this._top] = this.min;\\n    this.data[++this._top] = n;\\n    n < this.min && (this.min = n);\\n  }\\n  pop() {\\n    this.min = this.data[--this._top];\\n    --this._top;\\n  }\\n  top() {\\n    return this.data[this._top];\\n  }\\n  getMin() {\\n    return this.min;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass MinStack {\\n  constructor() {\\n    this._top = -1;\\n    this.data = [];\\n    this.min = Number.MAX_SAFE_INTEGER;\\n  }\\n  push(n) {\\n    this.data[++this._top] = this.min;\\n    this.data[++this._top] = n;\\n    n < this.min && (this.min = n);\\n  }\\n  pop() {\\n    this.min = this.data[--this._top];\\n    --this._top;\\n  }\\n  top() {\\n    return this.data[this._top];\\n  }\\n  getMin() {\\n    return this.min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539383,
                "title": "python-o-1-time-stores-only-n-1-ints-less-space-than-94-one-stack",
                "content": "Please feel free to ask questions or give suggestions. **Upvote** if you liked the solution.\\n\\n**Idea**: \\n* We keep track of the minimum element separately. \\n* For minimums so far, instead of storing the value directly, we store a value less than minimum from which we can compute the minimum after this value has been removed. \\n* Eg. say stack had minimum 3, and we wanted to push 1, we\\'d push 2\\\\*val-min=-1 instead and save minimum as 1. Then, when we see the top of the stack is less than our minimum i.e. we\\'re popping this element next, we can compute the minimum in stack after this has been popped as 2\\\\*min-stored_val=2\\\\*1-(-1)=3.\\n* How this works: \\n\\t* Since val<min, 2\\\\*val<2*min=>2\\\\*val-min<min, everything greater than min is stored directly. \\n\\t* All values greater than min get stored directly. So, while popping, if we encounter a value smaller than min, it must be the value where min was in the stack and we stored 2\\\\*val-previous_min in stack.\\n\\t* When popping this value, 2\\\\*min-stored _val=2\\\\*min-(2\\\\*this_val-previous_min), but we stored this_val in min \\n\\t* So, 2\\\\*min-stored _val = previous_min.\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        # Note: Does not hold actual values for minimums encountered\\n        self._stack = []\\n        # Current minimum\\n        self._min = None\\n\\n    def push(self, val: int) -> None:\\n        # Note: Append here is amortised O(1), could use a different stack implementation for every call O(1). Logic remains same.\\n        # Empty stack\\n        if not self._stack:\\n            self._stack.append(val)\\n            self._min = val\\n        # Normal add\\n        elif val>=self._min:\\n            self._stack.append(val)\\n        # Val is min, add computed value that tells us the min when this is removed\\n        else:\\n            self._stack.append(2*val-self._min)\\n            self._min = val     \\n\\n    def pop(self) -> None:\\n        el = self._stack.pop()\\n        # This was the minimum, extract the next minimum from value stored in stack\\n        if el<self._min:\\n            el, self._min = self._min, 2*self._min-el\\n        return el\\n\\n    def top(self) -> int:\\n        # stack[-1]>=min => stack[-1] is unmodified last pushed element, \\n        # min>stack[-1] implies top is min and stack[-1] has computed value instead\\n        return max(self._stack[-1], self._min)\\n\\n    def getMin(self) -> int:\\n        return self._min\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        # Note: Does not hold actual values for minimums encountered\\n        self._stack = []\\n        # Current minimum\\n        self._min = None\\n\\n    def push(self, val: int) -> None:\\n        # Note: Append here is amortised O(1), could use a different stack implementation for every call O(1). Logic remains same.\\n        # Empty stack\\n        if not self._stack:\\n            self._stack.append(val)\\n            self._min = val\\n        # Normal add\\n        elif val>=self._min:\\n            self._stack.append(val)\\n        # Val is min, add computed value that tells us the min when this is removed\\n        else:\\n            self._stack.append(2*val-self._min)\\n            self._min = val     \\n\\n    def pop(self) -> None:\\n        el = self._stack.pop()\\n        # This was the minimum, extract the next minimum from value stored in stack\\n        if el<self._min:\\n            el, self._min = self._min, 2*self._min-el\\n        return el\\n\\n    def top(self) -> int:\\n        # stack[-1]>=min => stack[-1] is unmodified last pushed element, \\n        # min>stack[-1] implies top is min and stack[-1] has computed value instead\\n        return max(self._stack[-1], self._min)\\n\\n    def getMin(self) -> int:\\n        return self._min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217452,
                "title": "c-solution-using-o-1-extra-space-simple-math-trick",
                "content": "One of the simple way to solve this problem is using an auxillary stack keeping track of all the minimum elements. \\nHowever using simple math trick we can solve without using any auxillary stack.\\nIdea :\\n1. At any point let the current minimum be minn.\\n2. Suppose we are pushing any element e , such that e>= minn. Then there is no need to update minn. Simply push the element in to the stack.\\n3. If e < minn, we will push e and  we will also need to update minn. Let us do the update as minn=e. However there will be a problem.  Let us see what.\\n4.  If now a pop operation is called since the minimum is now at the top of the stack we need to update minn to the previous minn. But since we are not using any auxillary stack how to retrive the previous min?\\n5.  This can be acheived if in step 3 instead of pushing e into the stack we push **2\\\\*e-minn** instead.   Why?\\n\\tWe know, e<minn\\n\\t=> e-minn<0\\n\\t=> e-minn+e<e\\n\\t=>2\\\\*e-minn<e\\n\\tSo we can say the instead of pushing e in step 3 we are pushing a number even less than e. After doing this update minn=e. How will this help? \\n\\t**Note - Update is done after pushing 2\\\\*e-minn in the stack. It means the \"minn\" in \"2\\\\*e-minn\" is actually the minn before encountering e which thus the becomes the previous_min after updating.**\\n6. Now if we perform a pop operation the top of the stack will have a number less than minn (As top_of_the_stack = 2\\\\*e-previous_minn and minn=e). So now we can easily say **previous_min = 2\\\\*minn- top_of_stack**. This is important as we are keeping track of previous min also but using any extra space. So now we can pop the element and update minn=previous_min;\\nIts very simple to implement.\\nCode :- \\n```\\n#define ll long long int \\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<ll> s;\\n    int minn;\\n    MinStack() {\\n        minn=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push_back(val);\\n            minn=val;\\n        }\\n        else if(val>=minn)\\n            s.push_back(val);\\n        else{\\n            s.push_back(2LL*val-minn);//Insert a number even less then val\\n            minn=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn)\\n        {\\n            minn=2LL*minn-e;//Retrive the prev min\\n            \\n        }\\n          s.erase(it);         \\n    }\\n    \\n    int top() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn) return minn;\\n        return e;\\n    }\\n    \\n    int getMin() {\\n        return minn;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long int \\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    vector<ll> s;\\n    int minn;\\n    MinStack() {\\n        minn=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push_back(val);\\n            minn=val;\\n        }\\n        else if(val>=minn)\\n            s.push_back(val);\\n        else{\\n            s.push_back(2LL*val-minn);//Insert a number even less then val\\n            minn=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn)\\n        {\\n            minn=2LL*minn-e;//Retrive the prev min\\n            \\n        }\\n          s.erase(it);         \\n    }\\n    \\n    int top() {\\n        auto it = s.end();\\n        ll e = *(--it);\\n        if(e<minn) return minn;\\n        return e;\\n    }\\n    \\n    int getMin() {\\n        return minn;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572212,
                "title": "c-two-stacks",
                "content": "```cpp\\nvector<int> v, m;\\nvoid push(int x) {\\n    v.push_back(x);\\n    if (m.empty() || m.back() >= x)\\n        m.push_back(x);\\n}\\nvoid pop() {\\n    if (m.back() == v.back())\\n        m.pop_back();\\n    v.pop_back();\\n}\\nint top() {\\n    return v.back();\\n}\\nint getMin() {\\n    return m.back();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> v, m;\\nvoid push(int x) {\\n    v.push_back(x);\\n    if (m.empty() || m.back() >= x)\\n        m.push_back(x);\\n}\\nvoid pop() {\\n    if (m.back() == v.back())\\n        m.pop_back();\\n    v.pop_back();\\n}\\nint top() {\\n    return v.back();\\n}\\nint getMin() {\\n    return m.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449337,
                "title": "c-stack-valuetuple-int-int",
                "content": "Using a Named ValueTuple you can make your Stack clean and efficient. \\nRead more about it here https://docs.microsoft.com/en-us/dotnet/csharp/tuples and please like if this helped!\\n```\\npublic class MinStack\\n{\\n    private Stack<(int Value, int Min)> _stack;\\n\\n    public MinStack()\\n    {\\n        _stack = new Stack<(int, int)>();\\n    }\\n\\n    public void Push(int x)\\n    {\\n        var min = _stack.Any() ? Math.Min(x, GetMin()) : x;\\n        _stack.Push(new ValueTuple<int, int>(x, min));\\n    }\\n\\n    public void Pop()\\n    {\\n        _stack.Pop();\\n    }\\n\\n    public int Top()\\n    {\\n        return _stack.Peek().Value;\\n    }\\n\\n    public int GetMin()\\n    {\\n        return _stack.Peek().Min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinStack\\n{\\n    private Stack<(int Value, int Min)> _stack;\\n\\n    public MinStack()\\n    {\\n        _stack = new Stack<(int, int)>();\\n    }\\n\\n    public void Push(int x)\\n    {\\n        var min = _stack.Any() ? Math.Min(x, GetMin()) : x;\\n        _stack.Push(new ValueTuple<int, int>(x, min));\\n    }\\n\\n    public void Pop()\\n    {\\n        _stack.Pop();\\n    }\\n\\n    public int Top()\\n    {\\n        return _stack.Peek().Value;\\n    }\\n\\n    public int GetMin()\\n    {\\n        return _stack.Peek().Min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360444,
                "title": "java-amortized-approach",
                "content": "```java\\nclass Node{\\n    int data, min;\\n    Node next;\\n    \\n    Node(int x){\\n        this.data = this.min = x;\\n        this.next = null;\\n    }\\n}\\n\\nclass MinStack {\\n    private Node head;\\n    public void push(int x) {\\n        if (head == null){\\n            head = new Node(x);\\n            return;\\n        }\\n        Node newNode = new Node(x);\\n        newNode.min = Math.min(newNode.min, head.min);\\n        newNode.next = head;\\n        head = newNode;\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.data;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Node{\\n    int data, min;\\n    Node next;\\n    \\n    Node(int x){\\n        this.data = this.min = x;\\n        this.next = null;\\n    }\\n}\\n\\nclass MinStack {\\n    private Node head;\\n    public void push(int x) {\\n        if (head == null){\\n            head = new Node(x);\\n            return;\\n        }\\n        Node newNode = new Node(x);\\n        newNode.min = Math.min(newNode.min, head.min);\\n        newNode.next = head;\\n        head = newNode;\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.data;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49178,
                "title": "sharing-my-28ms-c-solution",
                "content": "    class MinStack {\\n    private:\\n        vector<int> myVector;\\n        vector<int> myMins;\\n    public:\\n        void push(int x) {\\n            myVector.push_back(x);\\n            if(myMins.size()==0)\\n                myMins.push_back(x);\\n            else\\n            {\\n                int temp = myMins.back();\\n                if(x<temp)\\n                    temp = x;\\n                myMins.push_back(temp);\\n            }\\n        }\\n    \\n        void pop() {\\n            myVector.pop_back();\\n            myMins.pop_back();\\n        }\\n    \\n        int top() {\\n            return myVector.back();\\n        }\\n    \\n        int getMin() {\\n            return myMins.back();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    private:\\n        vector<int> myVector;\\n        vector<int> myMins;\\n    public:\\n        void push(int x) {\\n            myVector.push_back(x);\\n            if(myMins.size()==0)\\n                myMins.push_back(x);\\n            else\\n            {\\n                int temp = myMins.back();\\n                if(x<temp)\\n                    temp = x;\\n                myMins.push_back(temp);\\n            }\\n        }\\n    \\n        void pop() {\\n            myVector.pop_back();\\n            myMins.pop_back();\\n        }\\n    \\n        int top() {\\n            return myVector.back();\\n        }\\n    \\n        int getMin() {\\n            return myMins.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2659344,
                "title": "3-approaches-time-space-o-1-c",
                "content": "APPROACH 1: TIME O(1) SPACE O(N)\\nusing vector pair <val, minimum val til current element>\\n\\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int, int>> v;\\n    void push(int val) \\n    {\\n        if (v.empty())  v.push_back({val, val}); \\n        else  \\n            v.push_back({val, min(val, v.back().second)}); //v.back() == v[v.size()-1]\\n    }\\n    void pop() { v.pop_back(); }\\n    int top() { return v.back().first; }\\n    int getMin() { return v.back().second; }\\n};\\n```\\n\\n#APPROACH 2: TIME O(1) SPACE O(N)\\nusing 2 stack implementation.\\n\\nLogic: maintain minimum in mini stack while pushing(push if val <= mini.top()) and popping (pop from mini if val == mini.top() )\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> mini;\\n    \\n    void push(int val) {\\n        if (mini.empty() || val <= mini.top())\\n            mini.push(val);\\n        s.push(val);    \\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini.top())\\n            mini.pop();\\n        s.pop();\\n    }\\n    \\n    int top() { return s.top(); }\\n    int getMin() { return mini.top(); }\\n};\\n```\\n#Approach 3: OPTIMAL: TIME O(1) SPACE O(1) //no extra space except the stack itself\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    int mini = INT_MAX;\\n    \\n    void push(int val) {\\n        if (val <= mini) //we\\'ll push previous min value into the stack before pushing new min val, coz when we\\'ll pop eg. min element then we need to update mini with prev min value   \\n        {\\n            s.push(mini); //we\\'ll use it to update mini when popping min element!\\n            mini = val; //update mini with min val\\n        }\\n        s.push(val);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini) //this means mini got updated here, and we know that we have stored previous min value in stack before pushing new minimum!\\n        {\\n            s.pop(); //popping curr min value \\n            mini = s.top(); //this is our previous min value, we\\'ll update mini, and now we\\'ll pop it as well!\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {return s.top(); } \\n    int getMin() { return mini; }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    vector<pair<int, int>> v;\\n    void push(int val) \\n    {\\n        if (v.empty())  v.push_back({val, val}); \\n        else  \\n            v.push_back({val, min(val, v.back().second)}); //v.back() == v[v.size()-1]\\n    }\\n    void pop() { v.pop_back(); }\\n    int top() { return v.back().first; }\\n    int getMin() { return v.back().second; }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> mini;\\n    \\n    void push(int val) {\\n        if (mini.empty() || val <= mini.top())\\n            mini.push(val);\\n        s.push(val);    \\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini.top())\\n            mini.pop();\\n        s.pop();\\n    }\\n    \\n    int top() { return s.top(); }\\n    int getMin() { return mini.top(); }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    int mini = INT_MAX;\\n    \\n    void push(int val) {\\n        if (val <= mini) //we\\'ll push previous min value into the stack before pushing new min val, coz when we\\'ll pop eg. min element then we need to update mini with prev min value   \\n        {\\n            s.push(mini); //we\\'ll use it to update mini when popping min element!\\n            mini = val; //update mini with min val\\n        }\\n        s.push(val);\\n    }\\n    \\n    void pop() {\\n        if (s.top() == mini) //this means mini got updated here, and we know that we have stored previous min value in stack before pushing new minimum!\\n        {\\n            s.pop(); //popping curr min value \\n            mini = s.top(); //this is our previous min value, we\\'ll update mini, and now we\\'ll pop it as well!\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {return s.top(); } \\n    int getMin() { return mini; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799603,
                "title": "java-using-2-stacks-with-image-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/4f70590b-1b14-4a3f-ae5b-1049c90b86d3_1645821355.42753.jpeg)\\n\\n\\n\\n\\n\\n\\nclass MinStack {\\n    \\n    Stack<Integer> stack = new Stack(); // Normal Stack\\n    Stack<Integer> minStack = new Stack();// Keeps the current min on top \\n    \\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n\\n        // First time insert. If new min found add to minStack\\n        if(minStack.isEmpty() || val <=minStack.peek())\\n        {\\n            minStack.push(val);\\n        }\\n        \\n        stack.push(val);\\n    }\\n    \\n    \\n    public void pop() {\\n        // Pop from minStack only if top elements are same in both stacks\\n        if(stack.peek().equals(minStack.peek()))\\n        {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n        \\n        \\n    }\\n    \\n    public int top() {\\n       return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n       return minStack.peek();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/4f70590b-1b14-4a3f-ae5b-1049c90b86d3_1645821355.42753.jpeg)\\n\\n\\n\\n\\n\\n\\nclass MinStack {\\n    \\n    Stack<Integer> stack = new Stack(); // Normal Stack\\n    Stack<Integer> minStack = new Stack();// Keeps the current min on top \\n    \\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n\\n        // First time insert. If new min found add to minStack\\n        if(minStack.isEmpty() || val <=minStack.peek())\\n        {\\n            minStack.push(val);\\n        }\\n        \\n        stack.push(val);\\n    }\\n    \\n    \\n    public void pop() {\\n        // Pop from minStack only if top elements are same in both stacks\\n        if(stack.peek().equals(minStack.peek()))\\n        {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n        \\n        \\n    }\\n    \\n    public int top() {\\n       return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n       return minStack.peek();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1496281,
                "title": "96-faster-javascript-solution-with-comments-please-let-me-know-if-i-can-clarify-more",
                "content": "```\\n\\nvar MinStack = function() {\\n  this.storage = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n  // push an object containing the value and current min with this new val added\\n  this.storage.push({\\n    value: val,\\n    // if we\\'re pushing into an empty stack then our min val would be this val we\\'re pushing\\n    // if we pushed into a non empty stack then we would assign the Math.min of the val we\\'re pushing or the min value we assigned at the bottom most of our stack\\n    min: !this.storage.length ? val : Math.min(val, this.getMin())\\n  })\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  // currently our stack is implemented in reverse order so our top of stack is  at the bottom so we can pop from the end which is technically our top\\n  this.storage.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  // since our stack is reverse ordered returning the end of our stack is actually our top\\n  return this.storage[this.storage.length - 1].value;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  // since our stack is reverse ordered the min of our stack would be the min value we assigned to this el when we called our push method\\n  return this.storage[this.storage.length - 1].min;\\n};\\n\\n\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar MinStack = function() {\\n  this.storage = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n  // push an object containing the value and current min with this new val added\\n  this.storage.push({\\n    value: val,\\n    // if we\\'re pushing into an empty stack then our min val would be this val we\\'re pushing\\n    // if we pushed into a non empty stack then we would assign the Math.min of the val we\\'re pushing or the min value we assigned at the bottom most of our stack\\n    min: !this.storage.length ? val : Math.min(val, this.getMin())\\n  })\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  // currently our stack is implemented in reverse order so our top of stack is  at the bottom so we can pop from the end which is technically our top\\n  this.storage.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  // since our stack is reverse ordered returning the end of our stack is actually our top\\n  return this.storage[this.storage.length - 1].value;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  // since our stack is reverse ordered the min of our stack would be the min value we assigned to this el when we called our push method\\n  return this.storage[this.storage.length - 1].min;\\n};\\n\\n\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393500,
                "title": "c-stack-of-pair-tc-o-1-sc-o-n",
                "content": "here i had created stack of pair\\nin pair first element is origin element which is pushed but second is for maintain minimum.\\nso this way we maintain **min stack**\\n**Time Complexity : O(1)\\nSpace Complexity : O(n)**  *(specifically Space Complexity is O(2 * n) as we store 2 value for one pushed value)*\\n```\\nclass MinStack {\\npublic:\\n\\tstack<pair<int, int>>s;\\n\\tMinStack() {\\n\\n\\t}\\n\\n\\tvoid push(int val) {\\n\\t\\tif (!s.empty()) {\\n\\t\\t\\ts.push({val, min(val, s.top().second)});\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts.push({val, val});\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\ts.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn s.top().first;\\n\\t}\\n\\n\\tint getMin() {\\n\\t\\treturn s.top().second;\\n\\t}\\n};\\n```\\n\\n**If you find it helpful *Upvote it* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n\\tstack<pair<int, int>>s;\\n\\tMinStack() {\\n\\n\\t}\\n\\n\\tvoid push(int val) {\\n\\t\\tif (!s.empty()) {\\n\\t\\t\\ts.push({val, min(val, s.top().second)});\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ts.push({val, val});\\n\\t\\t}\\n\\t}\\n\\n\\tvoid pop() {\\n\\t\\ts.pop();\\n\\t}\\n\\n\\tint top() {\\n\\t\\treturn s.top().first;\\n\\t}\\n\\n\\tint getMin() {\\n\\t\\treturn s.top().second;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963777,
                "title": "swift-tuple",
                "content": "```\\n\\nclass MinStack {\\n    var stack: [(element: Int, min: Int)] = []\\n\\n    func push(_ x: Int) {\\n        \\n        if stack.count == 0 {\\n            stack.append((x, x))\\n        } else {\\n            let top = self.getMin()\\n            stack.append((x, x > top ? top : x))\\n        }\\n    }\\n    \\n    func pop() {\\n        stack.popLast()\\n    }\\n    \\n    func top() -> Int {\\n        stack.last?.element ?? -1\\n    }\\n    \\n    func getMin() -> Int {\\n        stack.last?.min ?? -1\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * let obj = MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * let ret_3: Int = obj.top()\\n * let ret_4: Int = obj.getMin()\\n */",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n\\nclass MinStack {\\n    var stack: [(element: Int, min: Int)] = []\\n\\n    func push(_ x: Int) {\\n        \\n        if stack.count == 0 {\\n            stack.append((x, x))\\n        } else {\\n            let top = self.getMin()\\n            stack.append((x, x > top ? top : x))\\n        }\\n    }\\n    \\n    func pop() {\\n        stack.popLast()\\n    }\\n    \\n    func top() -> Int {\\n        stack.last?.element ?? -1\\n    }\\n    \\n    func getMin() -> Int {\\n        stack.last?.min ?? -1\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * let obj = MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * let ret_3: Int = obj.top()\\n * let ret_4: Int = obj.getMin()\\n */",
                "codeTag": "Java"
            },
            {
                "id": 572860,
                "title": "c-solutions-one-stack-two-stack-list",
                "content": "**Two-stack solution**\\n```\\npublic class MinStack {\\n\\n    private Stack<int> stack1;\\n    private Stack<int> stack2;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack1 = new Stack<int>();\\n        stack2 = new Stack<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack1.Count == 0)\\n        {         \\n            stack1.Push(x);\\n            stack2.Push(x);\\n        }\\n        else\\n        {\\n            stack1.Push(x);\\n            int currMin = stack2.Peek();\\n            stack2.Push(Math.Min(x, currMin));\\n        }\\n    }\\n    \\n    public void Pop() {\\n        stack1.Pop();\\n        stack2.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack1.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return stack2.Peek();    \\n    }\\n}\\n```\\n\\n**One-stack solution**\\n```\\npublic class MinStack {\\n\\n    private Stack<(int,int)> stack;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<(int, int)>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack.Count == 0)\\n            stack.Push((x, x));\\n        else\\n            stack.Push((x, Math.Min(x, stack.Peek().Item2)));\\n    }\\n    \\n    public void Pop() {\\n        stack.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack.Peek().Item1;\\n    }\\n    \\n    public int GetMin() {\\n        return stack.Peek().Item2;\\n    }\\n}\\n```\\n\\n**List solution**\\n```\\npublic class MinStack {\\n\\n    private List<int> list;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        list = new List<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        list.Add(x);\\n    }\\n    \\n    public void Pop() {\\n        list.RemoveAt(list.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        return list[list.Count - 1];\\n    }\\n    \\n    public int GetMin() {\\n        return list.Min();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class MinStack {\\n\\n    private Stack<int> stack1;\\n    private Stack<int> stack2;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack1 = new Stack<int>();\\n        stack2 = new Stack<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack1.Count == 0)\\n        {         \\n            stack1.Push(x);\\n            stack2.Push(x);\\n        }\\n        else\\n        {\\n            stack1.Push(x);\\n            int currMin = stack2.Peek();\\n            stack2.Push(Math.Min(x, currMin));\\n        }\\n    }\\n    \\n    public void Pop() {\\n        stack1.Pop();\\n        stack2.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack1.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return stack2.Peek();    \\n    }\\n}\\n```\n```\\npublic class MinStack {\\n\\n    private Stack<(int,int)> stack;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<(int, int)>();\\n    }\\n    \\n    public void Push(int x) {\\n        if(stack.Count == 0)\\n            stack.Push((x, x));\\n        else\\n            stack.Push((x, Math.Min(x, stack.Peek().Item2)));\\n    }\\n    \\n    public void Pop() {\\n        stack.Pop();\\n    }\\n    \\n    public int Top() {\\n        return stack.Peek().Item1;\\n    }\\n    \\n    public int GetMin() {\\n        return stack.Peek().Item2;\\n    }\\n}\\n```\n```\\npublic class MinStack {\\n\\n    private List<int> list;\\n   \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        list = new List<int>();\\n    }\\n    \\n    public void Push(int x) {\\n        list.Add(x);\\n    }\\n    \\n    public void Pop() {\\n        list.RemoveAt(list.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        return list[list.Count - 1];\\n    }\\n    \\n    public int GetMin() {\\n        return list.Min();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536177,
                "title": "swift-solution-with-detailed-explanation",
                "content": "**This implementation uses Linked List data structure approach.**\\n\\nFirst of all we need to define linked list node.\\nWe can use generic parameter \"Value\" to create more flexible data structure. Every instance of \"Node\" - contains current value, minimum value and a reference to the next instance as well.\\n```\\nclass Node<Value> {\\n\\n    var next: Node?\\n    var value: Value\\n    var min: Value\\n    \\n    init(value: Value, min: Value, next: Node? = .none) {\\n        self.value = value\\n        self.min = min\\n        self.next = next\\n    }\\n    \\n}\\n```\\n**Minimum stack data structure implementation is straightforward:**\\n1.  Private instance of \"Node\", which is nil by default.\\n2.  First call of  push(_ x: Int) will init head node with brand new values of current value and min value. By the next calls we will check whether \"head\" is nill, if \"head\" is not nil - current \"head\" become new instance of \"Node\", where new minimum value will be calculated from current \"min\" and \"x\" parameter that was passed in.\\n3.  To pop the top most element of stack we simply assign the next node after current to \"head\".\\n4.  As \"head\" is the top element in stack, to get its value we simply look to its \"value\" value.\\n5.  A \"min()\" operation works same as the top(), the only difference is that we look for \"min\" value.\\n```\\nclass MinStack {\\n    \\n    private var head: Node<Int>!\\n    \\n    func push(_ x: Int) {\\n        if head == nil {\\n            head = Node(value: x, min: x)\\n        } else {\\n            head = Node(value: x, min: min(head.min, x), next: head)\\n        }\\n    }\\n    \\n    func pop() {\\n        head = head.next\\n    }\\n    \\n    func top() -> Int {\\n        return head.value\\n    }\\n    \\n    func getMin() -> Int {\\n        return head.min\\n    }\\n    \\n}\\n```\\n**The Big-O notation for common operations is next:**\\n1. push(_ x: Int) works in constant time complexity O(1).\\n2. pop() works in constant time complexity O(1).\\n3. top() works in constant time complexity O(1).\\n4. getMin() works in constant time complexity O(1) as well.\\n",
                "solutionTags": [
                    "Swift",
                    "Linked List"
                ],
                "code": "```\\nclass Node<Value> {\\n\\n    var next: Node?\\n    var value: Value\\n    var min: Value\\n    \\n    init(value: Value, min: Value, next: Node? = .none) {\\n        self.value = value\\n        self.min = min\\n        self.next = next\\n    }\\n    \\n}\\n```\n```\\nclass MinStack {\\n    \\n    private var head: Node<Int>!\\n    \\n    func push(_ x: Int) {\\n        if head == nil {\\n            head = Node(value: x, min: x)\\n        } else {\\n            head = Node(value: x, min: min(head.min, x), next: head)\\n        }\\n    }\\n    \\n    func pop() {\\n        head = head.next\\n    }\\n    \\n    func top() -> Int {\\n        return head.value\\n    }\\n    \\n    func getMin() -> Int {\\n        return head.min\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49212,
                "title": "solution-using-a-linked-list-clean-and-self-explanatory",
                "content": "    class MinStack {\\n        class Node{\\n        int value;\\n        int min;\\n        Node next=null;\\n            Node(int x, int min){\\n                value=x;\\n                this.min=min;\\n            }\\n        }\\n        Node head=null;\\n        public void push(int x) {\\n            if(head ==null){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(head.min,x));\\n                n.next = head;\\n                head = n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head=head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n             return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(head!=null)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        class Node{\\n        int value;\\n        int min;\\n        Node next=null;\\n            Node(int x, int min){\\n                value=x;\\n                this.min=min;\\n            }\\n        }\\n        Node head=null;\\n        public void push(int x) {\\n            if(head ==null){\\n                head = new Node(x,x);\\n            }else{\\n                Node n = new Node(x, Math.min(head.min,x));\\n                n.next = head;\\n                head = n;\\n            }\\n        }\\n    \\n        public void pop() {\\n            if(head!=null)\\n                head=head.next;\\n        }\\n    \\n        public int top() {\\n            if(head!=null)\\n                return head.value;\\n             return -1;\\n        }\\n    \\n        public int getMin() {\\n            if(head!=null)\\n                return head.min;\\n            return -1;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49244,
                "title": "8-line-single-stack-time-o-1-for-all-4-operations",
                "content": "    public class MinStack {\\n        private readonly Stack<long> stack = new Stack<long>();\\n        private long min = 0l;\\n        public void Push(int x){\\n            stack.Push((long)x - (min = stack.Count == 0 ? (long)x : min));\\n            if ((long)x < min) min = (long)x;\\n        }\\n        public void Pop(){\\n            if(stack.Peek() < 0) min -= stack.Peek();\\n            stack.Pop();\\n        }\\n        public int Top(){\\n            return stack.Peek() < 0 ? (int)min : (int)(min + stack.Peek());\\n        }\\n        public int GetMin(){\\n            return (int)min;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class MinStack {\\n        private readonly Stack<long> stack = new Stack<long>();\\n        private long min = 0l;\\n        public void Push(int x){\\n            stack.Push((long)x - (min = stack.Count == 0 ? (long)x : min));\\n            if ((long)x < min) min = (long)x;\\n        }\\n        public void Pop(){\\n            if(stack.Peek() < 0) min -= stack.Peek();\\n            stack.Pop();\\n        }\\n        public int Top(){\\n            return stack.Peek() < 0 ? (int)min : (int)(min + stack.Peek());\\n        }\\n        public int GetMin(){\\n            return (int)min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49209,
                "title": "19-lines-simple-answer-31ms",
                "content": "class MinStack {\\npublic:\\n\\n    stack<int> Data, Min;\\n\\n    void push(int x) {\\n        Data.push(x);\\n        if(Min.empty()||x<Min.top()) Min.push(x);\\n        else Min.push(Min.top());\\n    }\\n\\n    void pop() {\\n        if(Data.empty()) return;\\n        Data.pop();\\n        Min.pop();\\n    }\\n\\n    int top() {\\n        if(!Data.empty())\\n            return Data.top();\\n    }\\n\\n    int getMin() {\\n        if(!Min.empty());\\n            return Min.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class MinStack {\\npublic:\\n\\n    stack<int> Data, Min;\\n\\n    void push(int x) {\\n        Data.push(x);\\n        if(Min.empty()||x<Min.top()) Min.push(x);\\n        else Min.push(Min.top());\\n    }\\n\\n    void pop() {\\n        if(Data.empty()) return;\\n        Data.pop();\\n        Min.pop();\\n    }\\n\\n    int top() {\\n        if(!Data.empty())\\n            return Data.top();\\n    }\\n\\n    int getMin() {\\n        if(!Min.empty());\\n            return Min.top();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3341044,
                "title": "beats-86-o-1-6-lines-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int> st1,st2;\\n    void push(int val) {\\n        if(st1.empty()){st1.push(val);st2.push(val);return ;}\\n        st1.push(val); st2.push(min(val,st2.top()));\\n    }\\n    void pop() {\\n        if(st1.empty()){return ;}\\n        st1.pop();st2.pop();\\n    }\\n    int top(){ return st1.top();}\\n    int getMin(){ return st2.top();}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> st1,st2;\\n    void push(int val) {\\n        if(st1.empty()){st1.push(val);st2.push(val);return ;}\\n        st1.push(val); st2.push(min(val,st2.top()));\\n    }\\n    void pop() {\\n        if(st1.empty()){return ;}\\n        st1.pop();st2.pop();\\n    }\\n    int top(){ return st1.top();}\\n    int getMin(){ return st2.top();}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539741,
                "title": "c-super-simple-and-clean-solution",
                "content": "**Idea:**\\nWe use a stack that stores pairs of `{ val, min_so_far }`.\\nWe also have a `curr_min` for the current min.\\nWith this idea, implementation is super simple.\\n```\\nclass MinStack {\\npublic:\\n    MinStack() {}\\n    \\n    void push(int val) {\\n        if (val < curr_min) {\\n            s.push({val, val});\\n            curr_min = val;\\n        }\\n        else s.push({val, curr_min});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n        curr_min = s.empty() ? INT_MAX : s.top().second;\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return curr_min;\\n    }\\n    \\nprivate:\\n    stack<pair<int, int>> s;\\n    int curr_min = INT_MAX;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    MinStack() {}\\n    \\n    void push(int val) {\\n        if (val < curr_min) {\\n            s.push({val, val});\\n            curr_min = val;\\n        }\\n        else s.push({val, curr_min});\\n    }\\n    \\n    void pop() {\\n        s.pop();\\n        curr_min = s.empty() ? INT_MAX : s.top().second;\\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return curr_min;\\n    }\\n    \\nprivate:\\n    stack<pair<int, int>> s;\\n    int curr_min = INT_MAX;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539209,
                "title": "simple-to-understand-2-ways-stack-list-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nThis solution is inspired by the hint ```Consider each node in the stack having a minimum value.```\\n\\nThe main idea of this solution is to have a way to keep track of the minimum value every time an item is pushed onto the stack. \\n\\nWhen a new value is pushed onto the stack, it is checked against the last minimum to see if the current value is a minimum. Every time a new item is added, we keep track of the minimum value for each push.\\n\\nIn both solutions:\\n* When the ```Top``` function is called, the current top value is returned.\\n* When the ```GetMin``` function is called, the minimum value at the time top value was pushed onto the stack is returned\\n* When the ```Push``` function is called, the value and the current minimum value is pushed onto the stack\\n\\n**1. Using Stack**\\n\\nIn this solution, we use a stack<pair<int, int>> to keep track of the current item pushed onto the stack, and the minimum value at the time the item was pushed onto the stack.\\n\\n```\\npublic class MinStack {\\n    private Stack<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the stack\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new Stack<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Push(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.Pop();\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data.Peek().Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data.Peek().Value;        \\n    }\\n}\\n ```\\n \\n \\n**2. Using List**\\n\\nIn this solution, we use a list<pair<int, int>> to keep track of the current item pushed onto the stack, and the minimum value at the time the item was pushed onto the stack.\\n\\n ```\\npublic class MinStack {\\n    private List<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the list\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new List<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Add(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.RemoveAt(data.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data[data.Count - 1].Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data[data.Count - 1].Value;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Consider each node in the stack having a minimum value.```\n```Top```\n```GetMin```\n```Push```\n```\\npublic class MinStack {\\n    private Stack<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the stack\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new Stack<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Push(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.Pop();\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data.Peek().Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data.Peek().Value;        \\n    }\\n}\\n ```\n```\\npublic class MinStack {\\n    private List<KeyValuePair<int, int>> data;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        // Initialize the list\\n        // The pair key is the stack value\\n        // The pair value is the current stack minimum value\\n        data = new List<KeyValuePair<int, int>>();\\n    }\\n    \\n    public void Push(int val) {\\n        // Determine minimum value.\\n        // If the stack is not empty, compare against the last min value\\n        var currentMinValue = val;    \\n        if (data.Count > 0) {\\n            currentMinValue = Math.Min(currentMinValue, GetMin());\\n        }\\n        \\n        // Add new entry to the stack, saving the value and current minimum\\n        data.Add(new KeyValuePair<int, int>(val, currentMinValue));\\n    }\\n    \\n    public void Pop() {\\n        data.RemoveAt(data.Count - 1);\\n    }\\n    \\n    public int Top() {\\n        // Return the current top value\\n        return data[data.Count - 1].Key;\\n    }\\n    \\n    public int GetMin() {        \\n        // Return the current minimum value\\n        return data[data.Count - 1].Value;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938346,
                "title": "simple-and-fast-python-solution-using-2-lists-86-51-faster",
                "content": "key concept: Appending and popping a list is faster than inserting/removing from front.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stk=[]\\n        self.min=[float(\\'inf\\')]\\n\\n    def push(self, x: int) -> None:\\n        self.stk.append(x)\\n        if x <= self.min[-1]: self.min.append(x)\\n        \\n    def pop(self) -> None:\\n        x=self.stk.pop()\\n        if x == self.min[-1]: self.min.pop()\\n        return self.stk\\n\\n    def top(self) -> int:\\n        return self.stk[-1]\\n\\n    def getMin(self) -> int:\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stk=[]\\n        self.min=[float(\\'inf\\')]\\n\\n    def push(self, x: int) -> None:\\n        self.stk.append(x)\\n        if x <= self.min[-1]: self.min.append(x)\\n        \\n    def pop(self) -> None:\\n        x=self.stk.pop()\\n        if x == self.min[-1]: self.min.pop()\\n        return self.stk\\n\\n    def top(self) -> int:\\n        return self.stk[-1]\\n\\n    def getMin(self) -> int:\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696208,
                "title": "java-one-stack-o-1-and-o-n",
                "content": "```\\nclass MinStack {\\n    private Stack<Integer> stack;\\n    private int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        min = Integer.MAX_VALUE;\\n    }\\n    \\n    public void push(int x) {\\n        if(x <= min){   // memorize the previous min by pushing it to the stack\\n            stack.push(min);\\n            min = x;\\n        }\\n        stack.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stack.pop() == min){\\n            min = stack.pop();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    private Stack<Integer> stack;\\n    private int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n        min = Integer.MAX_VALUE;\\n    }\\n    \\n    public void push(int x) {\\n        if(x <= min){   // memorize the previous min by pushing it to the stack\\n            stack.push(min);\\n            min = x;\\n        }\\n        stack.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stack.pop() == min){\\n            min = stack.pop();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    public int getMin() {\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158351,
                "title": "javascript-68ms-beats-100",
                "content": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n  this.stack = [];\\n  this.min = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.stack.push(x);\\n\\n  var min = this.getMin();\\n  if (min !== undefined) {\\n    this.min.push(Math.min(x, min));\\n  } else {\\n    this.min.push(x);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.stack.pop();\\n  this.min.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1];\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  if (this.min.length > 0) {\\n    return this.min[this.min.length - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n  this.stack = [];\\n  this.min = [];\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  this.stack.push(x);\\n\\n  var min = this.getMin();\\n  if (min !== undefined) {\\n    this.min.push(Math.min(x, min));\\n  } else {\\n    this.min.push(x);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  this.stack.pop();\\n  this.min.pop();\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  if (this.stack.length > 0) {\\n    return this.stack[this.stack.length - 1];\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n  if (this.min.length > 0) {\\n    return this.min[this.min.length - 1];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 49171,
                "title": "implement-with-stack-and-pair-all-operations-have-o-1-time-complexity",
                "content": "**each element in stack is a pair of two int. The first is the int that we want to push into the stack. And the other one is the minimum value of the stack at this moment.**\\n\\n    class MinStack {\\n    private:\\n    stack<pair<int, int>> sta;\\n    public:\\n    void push(int x) {\\n        if(sta.empty()) \\n            sta.push(make_pair(x, x));\\n        else {\\n            auto top = sta.top();\\n            sta.push(make_pair(x, x < top.second ? x : top.second));\\n        }\\n    }\\n\\n    void pop() {\\n        if(!sta.empty())\\n            sta.pop();\\n    }\\n\\n    int top() {\\n        if(!sta.empty())\\n            return sta.top().first;\\n        else\\n            return -1;\\n    }\\n\\n    int getMin() {\\n        if(!sta.empty())\\n            return sta.top().second;\\n        else \\n            return -1;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "**each element in stack is a pair of two int. The first is the int that we want to push into the stack. And the other one is the minimum value of the stack at this moment.**\\n\\n    class MinStack {\\n    private:\\n    stack<pair<int, int>> sta;\\n    public:\\n    void push(int x) {\\n        if(sta.empty()) \\n            sta.push(make_pair(x, x));\\n        else {\\n            auto top = sta.top();\\n            sta.push(make_pair(x, x < top.second ? x : top.second));\\n        }\\n    }\\n\\n    void pop() {\\n        if(!sta.empty())\\n            sta.pop();\\n    }\\n\\n    int top() {\\n        if(!sta.empty())\\n            return sta.top().first;\\n        else\\n            return -1;\\n    }\\n\\n    int getMin() {\\n        if(!sta.empty())\\n            return sta.top().second;\\n        else \\n            return -1;\\n    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49274,
                "title": "c-two-stacks",
                "content": "Use one stack `data` to store the elements and the other stack `minimum` to store the minimum.\\n\\nFor `push`, push the element to `data`. If the element is not larger than the top of `minimum`, push it to `minimum`. For `pop`, if the top of the two stacks are equal, pop both; otherwise pop `data`. For `top` and `getMin`, just return the top of `data` and `minimum` respectively.\\n\\n```cpp\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        if (minimum.empty() || minimum.top() >= x) {\\n            minimum.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if (top() == getMin()) {\\n            minimum.pop();\\n        }\\n        data.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minimum.top();\\n    }\\nprivate:\\n    stack<int> data, minimum;\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```cpp\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        if (minimum.empty() || minimum.top() >= x) {\\n            minimum.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        if (top() == getMin()) {\\n            minimum.pop();\\n        }\\n        data.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minimum.top();\\n    }\\nprivate:\\n    stack<int> data, minimum;\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 49251,
                "title": "python-ac-solution-and-memory-limit-exceeded-mle-problem-using-tuple-element",
                "content": "My AC code:\\n\\n    class MinStack:\\n    # @param x, an integer\\n    def __init__(self):\\n        # the stack it self\\n        self.A = []\\n        self.minS=[]\\n    # @return an integer\\n    def push(self, x):\\n        n=len(self.A)\\n        if n==0:\\n            self.minS.append(x)\\n        else:\\n            lastmin=self.minS[-1]\\n            if x<=lastmin:\\n                self.minS.append(x)\\n        self.A.append(x)\\n    # @return nothing\\n    def pop(self):\\n        if len(self.A)>0 and self.A.pop()==self.minS[-1]:\\n            self.minS.pop()\\n    # @return an integer\\n    def top(self):\\n        return self.A[-1]\\n        \\n\\n    # @return an integer\\n    def getMin(self):\\n        return self.minS[-1]\\n        \\nHowever, at my first try, I use tuples in list [(element, min_value_sofar)] and got MLE. Can anyone explain the reason? I thought that the memory is still O(n).\\n\\nMy complete solution blog: [http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html][1]\\n\\n\\n  [1]: http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html",
                "solutionTags": [
                    "Python"
                ],
                "code": "My AC code:\\n\\n    class MinStack:\\n    # @param x, an integer\\n    def __init__(self):\\n        # the stack it self\\n        self.A = []\\n        self.minS=[]\\n    # @return an integer\\n    def push(self, x):\\n        n=len(self.A)\\n        if n==0:\\n            self.minS.append(x)\\n        else:\\n            lastmin=self.minS[-1]\\n            if x<=lastmin:\\n                self.minS.append(x)\\n        self.A.append(x)\\n    # @return nothing\\n    def pop(self):\\n        if len(self.A)>0 and self.A.pop()==self.minS[-1]:\\n            self.minS.pop()\\n    # @return an integer\\n    def top(self):\\n        return self.A[-1]\\n        \\n\\n    # @return an integer\\n    def getMin(self):\\n        return self.minS[-1]\\n        \\nHowever, at my first try, I use tuples in list [(element, min_value_sofar)] and got MLE. Can anyone explain the reason? I thought that the memory is still O(n).\\n\\nMy complete solution blog: [http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html][1]\\n\\n\\n  [1]: http://randombet.blogspot.com/2014/09/151-accepted-python-solutions-for_19.html",
                "codeTag": "Java"
            },
            {
                "id": 3595971,
                "title": "o-1-time-two-stacks-explaned-c-easiest",
                "content": "# Approach\\n- The push function adds the given value to s1 (the main stack). It then checks if s2 (the stack used to store the minimum values) is empty or if the new value is less than or equal to the current minimum (getMin()). If either condition is true, the new value is pushed onto s2.\\n- The pop function removes the top element from s1. It also checks if the top elements of s1 and s2 are equal. If they are equal, it means that the minimum element is being removed, so the top element is also popped from s2.\\n- The top function simply returns the top element of s1.\\n- The getMin function returns the top element of s2, which represents the current minimum element in the stack.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(no of function calls)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s1;\\n    stack<int> s2;\\n   \\n    void push(int val) {\\n        s1.push(val);\\n        if(s2.empty() or val<=getMin()) s2.push(val);\\n        \\n    }\\n    \\n    void pop() {\\n        if(s1.top()==s2.top()) s2.pop();\\n        s1.pop();\\n    }\\n\\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();        \\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s1;\\n    stack<int> s2;\\n   \\n    void push(int val) {\\n        s1.push(val);\\n        if(s2.empty() or val<=getMin()) s2.push(val);\\n        \\n    }\\n    \\n    void pop() {\\n        if(s1.top()==s2.top()) s2.pop();\\n        s1.pop();\\n    }\\n\\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481996,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\nThe idea is to create a doubly linkedlist and along with each node push current minimum till that point so that if any pop operation occur and the min value got deleted , we still have the data of prev min value in the last node. Before pushing any node we recalculate the min value as we are storing min value in last node we just grab the last node and compare the min value and push it along with the new node and update the last pointer to current pushed node.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here,.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    \\n    // private int min=Integer.MAX_VALUE;\\n    private Node lst_point=null;\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        int min=Math.min(val,lst_point==null? Integer.MAX_VALUE:lst_point.min);\\n        Node temp=new Node(min,val);\\n        if(lst_point==null)\\n        {\\n            lst_point=temp;\\n        }\\n        else{\\n            lst_point.next=temp;\\n            temp.prev=lst_point;\\n            lst_point=lst_point.next;\\n        }\\n    }\\n    \\n    public void pop() {\\n        Node temp=lst_point.prev;\\n        if(temp!=null)\\n        temp.next=null;\\n        \\n        lst_point.prev=null;\\n        lst_point=temp;\\n    }\\n    \\n    public int top() {\\n        return lst_point.val;\\n    }\\n    \\n    public int getMin() {\\n        return lst_point.min;\\n    }\\n\\n    private class Node{\\n        int min;\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int min,int val)\\n        {\\n            this.min=min;\\n            this.val=val;\\n            this.next=null;\\n            this.prev=null;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n`\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\nThe idea is to create a doubly linkedlist and along with each node push current minimum till that point so that if any pop operation occur and the min value got deleted , we still have the data of prev min value in the last node. Before pushing any node we recalculate the min value as we are storing min value in last node we just grab the last node and compare the min value and push it along with the new node and update the last pointer to current pushed node.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here,.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    \\n    // private int min=Integer.MAX_VALUE;\\n    private Node lst_point=null;\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        int min=Math.min(val,lst_point==null? Integer.MAX_VALUE:lst_point.min);\\n        Node temp=new Node(min,val);\\n        if(lst_point==null)\\n        {\\n            lst_point=temp;\\n        }\\n        else{\\n            lst_point.next=temp;\\n            temp.prev=lst_point;\\n            lst_point=lst_point.next;\\n        }\\n    }\\n    \\n    public void pop() {\\n        Node temp=lst_point.prev;\\n        if(temp!=null)\\n        temp.next=null;\\n        \\n        lst_point.prev=null;\\n        lst_point=temp;\\n    }\\n    \\n    public int top() {\\n        return lst_point.val;\\n    }\\n    \\n    public int getMin() {\\n        return lst_point.min;\\n    }\\n\\n    private class Node{\\n        int min;\\n        int val;\\n        Node next;\\n        Node prev;\\n        Node(int min,int val)\\n        {\\n            this.min=min;\\n            this.val=val;\\n            this.next=null;\\n            this.prev=null;\\n        }\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n`\\n",
                "codeTag": "Java"
            },
            {
                "id": 2633818,
                "title": "clean-95-faster-python3-solution-easiest-and-0-1",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack=[]\\n        self.minstack=[]\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        val=min(val,self.minstack[-1] if self.minstack else val)\\n        self.minstack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack=[]\\n        self.minstack=[]\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        val=min(val,self.minstack[-1] if self.minstack else val)\\n        self.minstack.append(val)\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252739,
                "title": "python-99-9-faster-with-explanation-and-comments",
                "content": "This solution is fast, but relies on increased memory usage. Beat 99.87% in time complexity and 15.8% in memory. \\n\\nMain idea:\\nUse python list as stack storage. Push tuple of (value, minimum element) in the list.  This way at every \"push\", \"pop\" we can easily get minimum value by unpacking our tuple.\\n\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.min_val = 0\\n\\n    def push(self, val: int) -> None:\\n        #When empty, set first element as min_val\\n        if not self.stack:\\n            self.min_val = val\\n    \\n        cur_min = self.getMin()\\n        if val < cur_min:\\n            self.min_val = val\\n            \\n        #Append tuple of (value,minimum value at the time)    \\n        self.stack.append((val,self.min_val))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        val, _ = self.stack[-1]\\n        return val\\n\\n    def getMin(self) -> int:\\n        #If empty, return default min_val\\n        if not self.stack:\\n            return self.min_val\\n        #Unpack tuple into min_val\\n        _, self.min_val = self.stack[-1]\\n        return self.min_val\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.min_val = 0\\n\\n    def push(self, val: int) -> None:\\n        #When empty, set first element as min_val\\n        if not self.stack:\\n            self.min_val = val\\n    \\n        cur_min = self.getMin()\\n        if val < cur_min:\\n            self.min_val = val\\n            \\n        #Append tuple of (value,minimum value at the time)    \\n        self.stack.append((val,self.min_val))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        val, _ = self.stack[-1]\\n        return val\\n\\n    def getMin(self) -> int:\\n        #If empty, return default min_val\\n        if not self.stack:\\n            return self.min_val\\n        #Unpack tuple into min_val\\n        _, self.min_val = self.stack[-1]\\n        return self.min_val\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885112,
                "title": "c-70-faster-stacks-with-comments",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<int> st;  //main stack\\n    stack<int> mn;   //handle minimum element\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push(val); \\n        if(mn.size()==0 or val<=mn.top())   //if min stack is empty or val is smaller or equal to mn.top() which is current min element then push \\n            mn.push(val);\\n    }\\n    \\n    void pop() {\\n        if(st.top()==mn.top())    //if element we remove is also current min element then pop it from min stack too\\n            mn.pop();\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top();\\n    }\\n    \\n    int getMin() {\\n        return mn.top();\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> st;  //main stack\\n    stack<int> mn;   //handle minimum element\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push(val); \\n        if(mn.size()==0 or val<=mn.top())   //if min stack is empty or val is smaller or equal to mn.top() which is current min element then push \\n            mn.push(val);\\n    }\\n    \\n    void pop() {\\n        if(st.top()==mn.top())    //if element we remove is also current min element then pop it from min stack too\\n            mn.pop();\\n        st.pop();\\n    }\\n    \\n    int top() {\\n        return st.top();\\n    }\\n    \\n    int getMin() {\\n        return mn.top();\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "codeTag": "Java"
            },
            {
                "id": 1796099,
                "title": "95-fasterr-c-easy-solution-using-linked-list",
                "content": "We will create a **Linked List Node** which will have its value, the current minimum value of the stack and the address of the next top element of the stack.\\n\\n```\\nclass MinStack {\\nprivate:\\n    //Creating our structure Node\\n    struct Node{   \\n        \\n          int val;\\n          int minn;\\n          Node* next;\\n        \\n          Node(int val,int minn,Node* next = NULL){\\n               this->val = val;\\n               this->minn = minn;\\n               this->next = next;\\n        }\\n    };\\n    \\n    Node* head; //head will always point to the top value of stack\\n    \\n   \\npublic:\\n    MinStack() {\\n        head = NULL;  //initialising head with NULL\\n    }\\n    \\n    void push(int val) {\\n        if(head==NULL)\\n            head = new Node(val,val,NULL); // checking if the stack is empty then assigning min value as same as the value that\\'s being pushed on to the stack and the next variable as NULL\\n        else{\\n            head = new Node(val, min(val,head->minn),head); //The new top of the stack and maintaining the minimum value of stack by comparing the current minimum with the value thats being added\\n        }\\n       \\n    }\\n    \\n    void pop() {\\n        \\n        head = head->next; //moving our head pointer to the next element in the stack\\n       \\n        \\n    }\\n    \\n    int top() {\\n        return head->val;  //the top value\\n       \\n    }\\n    \\n    int getMin() {\\n        return head->minn; //returning the current minimum\\n        \\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack {\\nprivate:\\n    //Creating our structure Node\\n    struct Node{   \\n        \\n          int val;\\n          int minn;\\n          Node* next;\\n        \\n          Node(int val,int minn,Node* next = NULL){\\n               this->val = val;\\n               this->minn = minn;\\n               this->next = next;\\n        }\\n    };\\n    \\n    Node* head; //head will always point to the top value of stack\\n    \\n   \\npublic:\\n    MinStack() {\\n        head = NULL;  //initialising head with NULL\\n    }\\n    \\n    void push(int val) {\\n        if(head==NULL)\\n            head = new Node(val,val,NULL); // checking if the stack is empty then assigning min value as same as the value that\\'s being pushed on to the stack and the next variable as NULL\\n        else{\\n            head = new Node(val, min(val,head->minn),head); //The new top of the stack and maintaining the minimum value of stack by comparing the current minimum with the value thats being added\\n        }\\n       \\n    }\\n    \\n    void pop() {\\n        \\n        head = head->next; //moving our head pointer to the next element in the stack\\n       \\n        \\n    }\\n    \\n    int top() {\\n        return head->val;  //the top value\\n       \\n    }\\n    \\n    int getMin() {\\n        return head->minn; //returning the current minimum\\n        \\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1541188,
                "title": "c-o-n-stack",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass MinStack {\\npublic:\\n    \\n    #define ll long long\\n    \\n    stack<ll int> st;\\n    ll int minval;\\n    \\n    MinStack() {\\n        minval=10000000000;\\n    }\\n    \\n    void push(int val) {\\n        if(st.size()==0){\\n            st.push(val);\\n            minval=val;\\n        }else if(val>=minval){\\n            st.push(val);\\n        }else{\\n            ll int dummy=val+(val-minval); // this value will be smaller than current min, detection point that min val changes\\n            st.push(dummy);\\n            minval=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        if(st.top()>=minval){\\n            st.pop();\\n        }else{\\n            minval=minval + (minval-st.top()); // retrieving previous min value (for remaining elements)\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.top()>=minval){\\n            return st.top();\\n        }\\n        return (int)minval;\\n    }\\n    \\n    int getMin() {\\n        return (int)minval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    #define ll long long\\n    \\n    stack<ll int> st;\\n    ll int minval;\\n    \\n    MinStack() {\\n        minval=10000000000;\\n    }\\n    \\n    void push(int val) {\\n        if(st.size()==0){\\n            st.push(val);\\n            minval=val;\\n        }else if(val>=minval){\\n            st.push(val);\\n        }else{\\n            ll int dummy=val+(val-minval); // this value will be smaller than current min, detection point that min val changes\\n            st.push(dummy);\\n            minval=val;\\n        }\\n    }\\n    \\n    void pop() {\\n        if(st.top()>=minval){\\n            st.pop();\\n        }else{\\n            minval=minval + (minval-st.top()); // retrieving previous min value (for remaining elements)\\n            st.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(st.top()>=minval){\\n            return st.top();\\n        }\\n        return (int)minval;\\n    }\\n    \\n    int getMin() {\\n        return (int)minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383608,
                "title": "c-tc-o-1-sc-o-n-2-stacks",
                "content": "# *Store minimum value at each stage in another stack, pop and push them simultaneously* \\n```\\nclass MinStack {\\npublic:\\n    int Stack[100000];\\n    int minStack[100000];\\n    int i=-1;\\n    \\n    MinStack() {\\n        i=-1;\\n    }\\n    \\n    void push(int val) {\\n        i++;\\n        Stack[i] = val;\\n        if(i>0)\\n            minStack[i] = min( minStack[i-1] , val ) ;\\n        else\\n            minStack[i] = val;\\n    }\\n    \\n    void pop() {\\n        i--;\\n    }\\n    \\n    int top() {\\n        return Stack[i];\\n    }\\n    \\n    int getMin() {\\n        return minStack[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    int Stack[100000];\\n    int minStack[100000];\\n    int i=-1;\\n    \\n    MinStack() {\\n        i=-1;\\n    }\\n    \\n    void push(int val) {\\n        i++;\\n        Stack[i] = val;\\n        if(i>0)\\n            minStack[i] = min( minStack[i-1] , val ) ;\\n        else\\n            minStack[i] = val;\\n    }\\n    \\n    void pop() {\\n        i--;\\n    }\\n    \\n    int top() {\\n        return Stack[i];\\n    }\\n    \\n    int getMin() {\\n        return minStack[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973517,
                "title": "java-tme-o-1-o-1-o-1-o-1-space-o-n",
                "content": "```\\nclass MinStack {\\n    class Node{\\n        Node(int x, int min, Node prev){\\n            this.x=x;\\n            this.min=min;\\n            this.prev = prev;\\n        }\\n        int x;\\n        int min;\\n        Node prev;\\n    }\\n    \\n    Node tail = null;\\n    \\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        if(tail == null){\\n            tail = new Node(x, x, tail);\\n        } else{\\n            tail = new Node(x, Math.min(x, tail.min), tail);\\n        }\\n    }\\n    \\n    public void pop() {\\n        tail = tail.prev;\\n    }\\n    \\n    public int top() {\\n        return tail.x;\\n    }\\n    \\n    public int getMin() {\\n        return tail.min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    class Node{\\n        Node(int x, int min, Node prev){\\n            this.x=x;\\n            this.min=min;\\n            this.prev = prev;\\n        }\\n        int x;\\n        int min;\\n        Node prev;\\n    }\\n    \\n    Node tail = null;\\n    \\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        if(tail == null){\\n            tail = new Node(x, x, tail);\\n        } else{\\n            tail = new Node(x, Math.min(x, tail.min), tail);\\n        }\\n    }\\n    \\n    public void pop() {\\n        tail = tail.prev;\\n    }\\n    \\n    public int top() {\\n        return tail.x;\\n    }\\n    \\n    public int getMin() {\\n        return tail.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878213,
                "title": "python-3-faster-than-94-two-stacks-comments-attached",
                "content": "The tricky part is the getMin requires constant time, therefore we need to store the min value for constant time access. Every push or pop, we need to update the min value correspondingly. So I use two stacks. The self.min stack stores the min values. Thanks for upvoting if you feel this solution helps.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.min = list()\\n        \\n\\n    def push(self, x: int) -> None:\\n        if not self.stack or x < self.min[-1]:\\n            self.min.append(x)\\n        else:\\n            self.min.append(self.min[-1])\\n        self.stack.append(x)\\n\\n    def pop(self) -> None:\\n        self.stack = self.stack[:-1]\\n        self.min = self.min[:-1]\\n        \\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        if not self.min: return None\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.min = list()\\n        \\n\\n    def push(self, x: int) -> None:\\n        if not self.stack or x < self.min[-1]:\\n            self.min.append(x)\\n        else:\\n            self.min.append(self.min[-1])\\n        self.stack.append(x)\\n\\n    def pop(self) -> None:\\n        self.stack = self.stack[:-1]\\n        self.min = self.min[:-1]\\n        \\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        if not self.min: return None\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241983,
                "title": "java-simple-two-stack-beats-100",
                "content": "Used two stacks. \\n- Main stack keeps track of everything that goes in called stk.\\n- Other stack keeps track of all mins, called stkTrackmin.\\n\\n```\\nclass MinStack {\\n\\n    Stack<Integer> stk = new Stack<>();\\n    Stack<Integer> stk2 = new Stack<>();\\n    \\n    public void push(int x) {\\n        stk.push(x);                             //Always push into main stack\\n        if(stk2.isEmpty() || x <= stk2.peek())   //Push when empty OR x<= current smallest value\\n            stk2.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stk.pop().equals(stk2.peek()))    //Main stk always pop\\n            stk2.pop();                      //Other stk pops only if it equal to main stk\\'s min\\n    }\\n    \\n    public int top() {\\n        return stk.peek();\\n    }\\n    \\n    public int getMin() {\\n        return stk2.peek();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n\\n    Stack<Integer> stk = new Stack<>();\\n    Stack<Integer> stk2 = new Stack<>();\\n    \\n    public void push(int x) {\\n        stk.push(x);                             //Always push into main stack\\n        if(stk2.isEmpty() || x <= stk2.peek())   //Push when empty OR x<= current smallest value\\n            stk2.push(x);\\n    }\\n    \\n    public void pop() {\\n        if(stk.pop().equals(stk2.peek()))    //Main stk always pop\\n            stk2.pop();                      //Other stk pops only if it equal to main stk\\'s min\\n    }\\n    \\n    public int top() {\\n        return stk.peek();\\n    }\\n    \\n    public int getMin() {\\n        return stk2.peek();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49249,
                "title": "a-32ms-c-solution-using-two-vectors",
                "content": "    class MinStack {\\n    public:\\n        vector<int> stack; \\n        vector<int> stmin = {INT_MAX};\\n        void push(int x) {\\n            if(x <= stmin[stmin.size() - 1]) stmin.push_back(x);\\n            stack.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if(stack[stack.size() - 1] == stmin[stmin.size() - 1]) stmin.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            if(stack.size() == 0) return 0;\\n            return stack[stack.size() - 1];\\n        }\\n    \\n        int getMin() {\\n            return stmin[stmin.size() - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    public:\\n        vector<int> stack; \\n        vector<int> stmin = {INT_MAX};\\n        void push(int x) {\\n            if(x <= stmin[stmin.size() - 1]) stmin.push_back(x);\\n            stack.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if(stack[stack.size() - 1] == stmin[stmin.size() - 1]) stmin.pop_back();\\n            stack.pop_back();\\n        }\\n    \\n        int top() {\\n            if(stack.size() == 0) return 0;\\n            return stack[stack.size() - 1];\\n        }\\n    \\n        int getMin() {\\n            return stmin[stmin.size() - 1];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49316,
                "title": "solution-without-using-java-s-stack",
                "content": "    class MinStack {\\n        private int size = 0;\\n        private Node head = null;\\n        \\n        class Node {\\n            int val;\\n            // every node contains min value at the moment it was pushed\\n            int min;\\n            Node next;\\n            Node(int v, int m) {val = v; min = m;}\\n        }\\n        \\n        public void push(int x) {\\n            int curMin = getMin();\\n            int newMin = x < curMin ? x : curMin;\\n    \\n            Node n = new Node(x, newMin);\\n            n.next = head;\\n    \\n            head = n;\\n            size++;\\n        }\\n    \\n        public void pop() {\\n            if (size <= 0)\\n                return;\\n    \\n            head = head.next;\\n            size--;\\n        }\\n    \\n        public int top() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n                \\n            return head.val;\\n        }\\n    \\n        public int getMin() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n    \\n            return head.min;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    class MinStack {\\n        private int size = 0;\\n        private Node head = null;\\n        \\n        class Node {\\n            int val;\\n            // every node contains min value at the moment it was pushed\\n            int min;\\n            Node next;\\n            Node(int v, int m) {val = v; min = m;}\\n        }\\n        \\n        public void push(int x) {\\n            int curMin = getMin();\\n            int newMin = x < curMin ? x : curMin;\\n    \\n            Node n = new Node(x, newMin);\\n            n.next = head;\\n    \\n            head = n;\\n            size++;\\n        }\\n    \\n        public void pop() {\\n            if (size <= 0)\\n                return;\\n    \\n            head = head.next;\\n            size--;\\n        }\\n    \\n        public int top() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n                \\n            return head.val;\\n        }\\n    \\n        public int getMin() {\\n            if (size <= 0)\\n                return Integer.MAX_VALUE;\\n    \\n            return head.min;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49371,
                "title": "deque-is-the-right-structure",
                "content": "I tried three data structure: vector, list and deque. Only deque is accepted, the others got MLE.\\n\\nThere are some explanation:\\n\\n> A deque is very much like a vector: like vector, it is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle.\\n\\n> The main way in which deque differs from vector is that deque also supports constant time insertion and removal of elements at the beginning of the sequence. Additionally, deque does not have any member functions analogous to vector's capacity() and reserve(), and does not provide any of the guarantees on iterator validity that are associated with those member functions.\\n\\nAnd my code:\\n\\n    class MinStack {\\n    private:\\n        deque<int> st;\\n        deque<int> mi;\\n    public:\\n        void push(int x) {\\n            st.push_back(x);\\n            if (mi.empty() || x <= mi.back()) mi.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (st.empty()) return;\\n            if (st.back() == mi.back()) mi.pop_back();\\n            st.pop_back();\\n        }\\n    \\n        int top() {\\n            if (st.empty()) return -1;\\n            return st.back();\\n        }\\n    \\n        int getMin() {\\n            if (mi.empty()) return -1;\\n            return mi.back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "I tried three data structure: vector, list and deque. Only deque is accepted, the others got MLE.\\n\\nThere are some explanation:\\n\\n> A deque is very much like a vector: like vector, it is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle.\\n\\n> The main way in which deque differs from vector is that deque also supports constant time insertion and removal of elements at the beginning of the sequence. Additionally, deque does not have any member functions analogous to vector's capacity() and reserve(), and does not provide any of the guarantees on iterator validity that are associated with those member functions.\\n\\nAnd my code:\\n\\n    class MinStack {\\n    private:\\n        deque<int> st;\\n        deque<int> mi;\\n    public:\\n        void push(int x) {\\n            st.push_back(x);\\n            if (mi.empty() || x <= mi.back()) mi.push_back(x);\\n        }\\n    \\n        void pop() {\\n            if (st.empty()) return;\\n            if (st.back() == mi.back()) mi.pop_back();\\n            st.pop_back();\\n        }\\n    \\n        int top() {\\n            if (st.empty()) return -1;\\n            return st.back();\\n        }\\n    \\n        int getMin() {\\n            if (mi.empty()) return -1;\\n            return mi.back();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 4050505,
                "title": "best-o-1-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass MinStack {\\n    stack <long long> st;\\n    long long minEle;\\npublic:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if (st.empty()) {\\n            st.push(val);\\n            minEle = val;\\n        } else if (val < minEle){\\n            st.push((long long) 2 * val - minEle);\\n            minEle = val;\\n        } else {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        long long popped = st.top();\\n        st.pop();\\n        if (popped < minEle)\\n            minEle = 2 * minEle - popped;\\n    }\\n    \\n    int top() {\\n        return (st.top() < minEle) ? minEle : st.top();\\n    }\\n    \\n    int getMin() {\\n        return minEle;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\n    stack <long long> st;\\n    long long minEle;\\npublic:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if (st.empty()) {\\n            st.push(val);\\n            minEle = val;\\n        } else if (val < minEle){\\n            st.push((long long) 2 * val - minEle);\\n            minEle = val;\\n        } else {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        long long popped = st.top();\\n        st.pop();\\n        if (popped < minEle)\\n            minEle = 2 * minEle - popped;\\n    }\\n    \\n    int top() {\\n        return (st.top() < minEle) ? minEle : st.top();\\n    }\\n    \\n    int getMin() {\\n        return minEle;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409487,
                "title": "c-fast-fully-explained-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe thought is to somehow store the elements in such an order that we can quickly get the first element, delete it and add to the top. All in O(1). Now there is obviously stack that can do it. There is queue, vector and others that can do it. But in those cases to find the smallest element, you need to traverse the whole data structure.\\nIf you think it, you will not be able to manage the smallest element thoughout because with each deletion you might loose your smallest element and then you need to find the new smallest.\\n\\nSo Idea is here to somehow keep storing the minimum element till the current topmost element. Thus if we delete the topmost element, we will know the new smallest at the new topmost element in O(1) time. \\n\\nThis can be done easily using LinkedList. We will insert the new elements at front of LL so as to match the stack implementation. In addition to each element, we would also keep in each node the minimum element found till here. Thus you can simply know the minimum element at each node. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simply to use a LL with an extra field for minimum element till the point. Refer to code you can easily understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass MinStack {\\npublic:\\n    struct Node\\n    {\\n        int num;\\n        Node *next;\\n        int min;\\n    };\\n    struct Node *head=NULL;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        Node *temp = new Node();\\n        temp->num=val;\\n        temp->min=val;\\n        temp->next=NULL;\\n        if(!head)\\n        {\\n            head=temp;\\n        }\\n        else\\n        {\\n            temp->min = min(temp->min, head->min);\\n            temp->next=head;\\n            head=temp;\\n        }\\n    }\\n    \\n    void pop() {\\n        Node *temp = head;\\n        head=head->next;\\n        //delete(temp);\\n    }\\n    \\n    int top() {\\n        return head->num;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    struct Node\\n    {\\n        int num;\\n        Node *next;\\n        int min;\\n    };\\n    struct Node *head=NULL;\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        Node *temp = new Node();\\n        temp->num=val;\\n        temp->min=val;\\n        temp->next=NULL;\\n        if(!head)\\n        {\\n            head=temp;\\n        }\\n        else\\n        {\\n            temp->min = min(temp->min, head->min);\\n            temp->next=head;\\n            head=temp;\\n        }\\n    }\\n    \\n    void pop() {\\n        Node *temp = head;\\n        head=head->next;\\n        //delete(temp);\\n    }\\n    \\n    int top() {\\n        return head->num;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385582,
                "title": "typescript-stack-val-min-solution",
                "content": "# Code\\n```\\nclass MinStack {\\n    private stack;\\n    constructor() {\\n        this.stack = [];\\n    }\\n\\n    push(val: number): void {\\n        this.stack.push({\\n            val,\\n            min: this.stack.length == 0 ? val: Math.min(val, this.getMin())\\n        });\\n    }\\n\\n    pop(): void {\\n        this.stack.pop();\\n    }\\n\\n    top(): number {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n\\n    getMin(): number {\\n        return this.stack.length == 0 ? 0: this.stack[this.stack.length - 1].min;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass MinStack {\\n    private stack;\\n    constructor() {\\n        this.stack = [];\\n    }\\n\\n    push(val: number): void {\\n        this.stack.push({\\n            val,\\n            min: this.stack.length == 0 ? val: Math.min(val, this.getMin())\\n        });\\n    }\\n\\n    pop(): void {\\n        this.stack.pop();\\n    }\\n\\n    top(): number {\\n        return this.stack[this.stack.length - 1].val;\\n    }\\n\\n    getMin(): number {\\n        return this.stack.length == 0 ? 0: this.stack[this.stack.length - 1].min;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(val)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.getMin()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014352,
                "title": "o-1-optimal-java-solution-o-n-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. for Push operation :\\npush(2 * value * min)\\n2. for Top operation : \\nmodified value < min \\n3. for Pop operation :  \\nmin = (2 * min) - modified value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we take a variable that stores our minimum number.\\n\\n2. Push operation :\\n--> check whether the number is less that the min number, if yes, we push the modified value.\\n--> if above case is false, we push the number as it is.\\n\\n3. getMin() operation : returns the value of min.\\n\\n4. Top operation :\\n--> while returning, if the top value is a modified value, we check if the top value is lesser than min, if yes, we return the min as our top value.\\n\\n5. Pop operation : \\n--> we check if the top value is lesser than min, if yes, we update the current min to our previous min, and then pop the element.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack \\n{\\n\\n    Stack<Long> stack = new Stack<>();\\n    Long mini;\\n\\n    public MinStack() \\n    {\\n        mini = Long.MAX_VALUE;\\n    }\\n    \\n    public void push(int val) \\n    {\\n        Long value = Long.valueOf(val);\\n        if(stack.isEmpty())\\n        {\\n            mini =  value;\\n            stack.push(value);\\n        }\\n        else\\n        {\\n            if(value < mini)\\n            {\\n                stack.push(2 * value - mini);\\n                mini = value;\\n            }\\n            else\\n            {\\n                stack.push(value);\\n            }\\n        }\\n    }\\n    \\n    public void pop() \\n    {\\n        if(stack.isEmpty())\\n        {\\n            return;\\n        }\\n\\n        Long value = stack.pop();\\n        if(value < mini)\\n        {\\n            mini = 2 * mini - value;\\n        }\\n            \\n    }\\n    \\n    public int top() \\n    {\\n        Long value = stack.peek();\\n        if(value < mini)\\n        {\\n            return mini.intValue();\\n        }\\n        return value.intValue();\\n    }\\n    \\n    public int getMin() \\n    {\\n        return mini.intValue();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass MinStack \\n{\\n\\n    Stack<Long> stack = new Stack<>();\\n    Long mini;\\n\\n    public MinStack() \\n    {\\n        mini = Long.MAX_VALUE;\\n    }\\n    \\n    public void push(int val) \\n    {\\n        Long value = Long.valueOf(val);\\n        if(stack.isEmpty())\\n        {\\n            mini =  value;\\n            stack.push(value);\\n        }\\n        else\\n        {\\n            if(value < mini)\\n            {\\n                stack.push(2 * value - mini);\\n                mini = value;\\n            }\\n            else\\n            {\\n                stack.push(value);\\n            }\\n        }\\n    }\\n    \\n    public void pop() \\n    {\\n        if(stack.isEmpty())\\n        {\\n            return;\\n        }\\n\\n        Long value = stack.pop();\\n        if(value < mini)\\n        {\\n            mini = 2 * mini - value;\\n        }\\n            \\n    }\\n    \\n    public int top() \\n    {\\n        Long value = stack.peek();\\n        if(value < mini)\\n        {\\n            return mini.intValue();\\n        }\\n        return value.intValue();\\n    }\\n    \\n    public int getMin() \\n    {\\n        return mini.intValue();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129330,
                "title": "c-clean-fast-solution-o-1",
                "content": "```\\ntypedef struct {\\n    int s[30001];\\n    int idx;\\n    int min;\\n} MinStack;\\n\\nMinStack* minStackCreate() {\\n    MinStack *new = calloc(1, sizeof(MinStack));\\n    new->idx = 0;\\n    new->min = INT_MAX;\\n    return new;\\n}\\n\\nvoid minStackPush(MinStack* obj, int val) {\\n    if (val <= obj->min) {\\n        obj->s[obj->idx++] = obj->min;\\n        obj->min = val;\\n    }\\n    obj->s[obj->idx++] = val;\\n}\\n\\nvoid minStackPop(MinStack* obj) {\\n    if (obj->s[--obj->idx] == obj->min)\\n        obj->min = obj->s[--obj->idx];\\n}\\n\\nint minStackTop(MinStack* obj) {\\n    return obj->s[obj->idx - 1];\\n}\\n\\nint minStackGetMin(MinStack* obj) {\\n    return obj->min;     \\n}\\n\\nvoid minStackFree(MinStack* obj) {\\n    free(obj); \\n}\\n```\\n***If this was helpful, don\\'t hesitate to upvote! :)***\\nHave a nice day!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\ntypedef struct {\\n    int s[30001];\\n    int idx;\\n    int min;\\n} MinStack;\\n\\nMinStack* minStackCreate() {\\n    MinStack *new = calloc(1, sizeof(MinStack));\\n    new->idx = 0;\\n    new->min = INT_MAX;\\n    return new;\\n}\\n\\nvoid minStackPush(MinStack* obj, int val) {\\n    if (val <= obj->min) {\\n        obj->s[obj->idx++] = obj->min;\\n        obj->min = val;\\n    }\\n    obj->s[obj->idx++] = val;\\n}\\n\\nvoid minStackPop(MinStack* obj) {\\n    if (obj->s[--obj->idx] == obj->min)\\n        obj->min = obj->s[--obj->idx];\\n}\\n\\nint minStackTop(MinStack* obj) {\\n    return obj->s[obj->idx - 1];\\n}\\n\\nint minStackGetMin(MinStack* obj) {\\n    return obj->min;     \\n}\\n\\nvoid minStackFree(MinStack* obj) {\\n    free(obj); \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1637230,
                "title": "easiest-solution-using-linkedlist",
                "content": "\\nclass MinStack {\\n   class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "\\nclass MinStack {\\n   class Node{\\n        int val;\\n        int min;\\n        Node next;\\n        \\n        public Node(int val , int min , Node next){\\n            this.val = val;\\n            this.min = min;\\n            this.next = next;\\n        }\\n    }\\n    \\n    private Node head;\\n    \\n    public MinStack() {\\n        head = null;\\n    }\\n    \\n    public void push(int val) {\\n        if(head == null)\\n            head = new Node(val ,val ,null);\\n        else\\n            head = new Node(val , Math.min(val ,head.min), head);\\n    }\\n    \\n    public void pop() {\\n        head = head.next;\\n    }\\n    \\n    public int top() {\\n        return head.val;\\n    }\\n    \\n    public int getMin() {\\n        return head.min;\\n    }\\n}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1539711,
                "title": "beginner-friendly-solution-using-two-stack-c",
                "content": "* Easy to understand, must upvote! \\uD83D\\uDE43\\n\\n```\\nclass MinStack {\\npublic:\\n    stack<int> myStack;\\n    stack<int> minStack;\\n    \\n    MinStack() {}\\n    \\n    void push(int val) {\\n        myStack.push(val);\\n        if(minStack.empty()){\\n            minStack.push(val);\\n        }\\n        else{\\n            int top = minStack.top();\\n            minStack.push(min(top, val));\\n        }\\n    }\\n    \\n    void pop() {\\n        myStack.pop();\\n        minStack.pop();\\n    }\\n    \\n    int top() {\\n        return myStack.top();\\n    }\\n    \\n    int getMin() {\\n        return minStack.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> myStack;\\n    stack<int> minStack;\\n    \\n    MinStack() {}\\n    \\n    void push(int val) {\\n        myStack.push(val);\\n        if(minStack.empty()){\\n            minStack.push(val);\\n        }\\n        else{\\n            int top = minStack.top();\\n            minStack.push(min(top, val));\\n        }\\n    }\\n    \\n    void pop() {\\n        myStack.pop();\\n        minStack.pop();\\n    }\\n    \\n    int top() {\\n        return myStack.top();\\n    }\\n    \\n    int getMin() {\\n        return minStack.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502873,
                "title": "c-using-2-stacks-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/bf471aae-ac51-47ea-b874-1290adaf1df7_1633348531.7451518.png)\\n\\n\\n```\\nclass MinStack {\\n    stack<int> data;\\n    stack<int> minData;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        data.push(val);\\n      if (minData.size() == 0 || val <= minData.top()) \\n        minData.push(val);\\n    }\\n    \\n    void pop() {\\n        int val = data.top();\\n            data.pop();\\n        if (val == minData.top()) \\n          minData.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minData.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\n    stack<int> data;\\n    stack<int> minData;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        data.push(val);\\n      if (minData.size() == 0 || val <= minData.top()) \\n        minData.push(val);\\n    }\\n    \\n    void pop() {\\n        int val = data.top();\\n            data.pop();\\n        if (val == minData.top()) \\n          minData.pop();\\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return minData.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267399,
                "title": "c-simple-solution-easy-to-understand",
                "content": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>stk1;\\n    stack<int>stk2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val)\\n    {\\n        stk1.push(val);\\n        if(stk2.size() == 0)\\n        {\\n            stk2.push(val);\\n        }\\n        else\\n        {\\n            stk2.push(min(stk2.top(),val));\\n        }\\n    }\\n    \\n    void pop()\\n    {\\n        stk1.pop();\\n        stk2.pop();\\n    }\\n    \\n    int top()\\n    {\\n        return stk1.top();    \\n    }\\n    \\n    int getMin()\\n    {\\n        return stk2.top();    \\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    stack<int>stk1;\\n    stack<int>stk2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val)\\n    {\\n        stk1.push(val);\\n        if(stk2.size() == 0)\\n        {\\n            stk2.push(val);\\n        }\\n        else\\n        {\\n            stk2.push(min(stk2.top(),val));\\n        }\\n    }\\n    \\n    void pop()\\n    {\\n        stk1.pop();\\n        stk2.pop();\\n    }\\n    \\n    int top()\\n    {\\n        return stk1.top();    \\n    }\\n    \\n    int getMin()\\n    {\\n        return stk2.top();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090123,
                "title": "clean-code-of-python-with-comments-without-additional-variable-for-size",
                "content": "```\\n#The idea here is to keep track of min element using a seperate stack.\\n#without the additional stack of min elements, we will have to traverse the entire stack and it will not be constant time,\\n#As there is no constraint for spacer complexity, we will user additional data strcuture.\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack =[] #main stack\\n        self.min=[]  #To keep track of minimum element in the stack\\n                \\n\\n    def push(self, x: int) -> None:                \\n            #Push all into the main stack.\\n            self.stack.append(x)  \\n            \\n            # If min stack present. Check the top element of min stack. \\n            # If X is less than top-element, append into the min stack. \\n            # It will ensure that top element is always minimum.\\n            if self.min: \\n                # Compare and push into min stack only if new element is \\n                # smaller than top element of min stack.\\n                if x <= self.min[-1]: \\n                    self.min.append(x)\\n            else:\\n                self.min.append(x)  \\n\\n    def pop(self) -> None:\\n            #Remove and return the top element.\\n            #Assigning it to a variable to compare if the popped out value is same as min\\'s top element. \\n            #if its same, pop from min stack as well.\\n            check= self.stack.pop() \\n            if check == self.min[-1]:\\n                self.min.pop()\\n                \\n    def top(self) -> int:\\n            if self.stack: \\n                return self.stack[-1] #Read and return the top element from mainstack.\\n\\n\\n    \\n    def getMin(self) -> int:\\n        if self.stack: \\n            return self.min[-1] #Read and return the top element from min stack.\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#The idea here is to keep track of min element using a seperate stack.\\n#without the additional stack of min elements, we will have to traverse the entire stack and it will not be constant time,\\n#As there is no constraint for spacer complexity, we will user additional data strcuture.\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack =[] #main stack\\n        self.min=[]  #To keep track of minimum element in the stack\\n                \\n\\n    def push(self, x: int) -> None:                \\n            #Push all into the main stack.\\n            self.stack.append(x)  \\n            \\n            # If min stack present. Check the top element of min stack. \\n            # If X is less than top-element, append into the min stack. \\n            # It will ensure that top element is always minimum.\\n            if self.min: \\n                # Compare and push into min stack only if new element is \\n                # smaller than top element of min stack.\\n                if x <= self.min[-1]: \\n                    self.min.append(x)\\n            else:\\n                self.min.append(x)  \\n\\n    def pop(self) -> None:\\n            #Remove and return the top element.\\n            #Assigning it to a variable to compare if the popped out value is same as min\\'s top element. \\n            #if its same, pop from min stack as well.\\n            check= self.stack.pop() \\n            if check == self.min[-1]:\\n                self.min.pop()\\n                \\n    def top(self) -> int:\\n            if self.stack: \\n                return self.stack[-1] #Read and return the top element from mainstack.\\n\\n\\n    \\n    def getMin(self) -> int:\\n        if self.stack: \\n            return self.min[-1] #Read and return the top element from min stack.\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825972,
                "title": "python-3-91-faster-using-namedtuple",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n**Solution 1:** using collections.namedtuple\\n```\\nclass MinStack:\\n\\n    stackWithMinElements = collections.namedtuple(\"stackWithMinElements\", (\"element\", \"minimum\"))\\n    \\n    def __init__(self):        \\n        self.stack : List[self.stackWithMinElements] = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(self.stackWithMinElements(\\n                        x, min(x, self.getMin()) if len(self.stack)>0 else x))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1].element\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1].minimum\\n```\\n\\n**Solution 2:** Regular method where we store a tuple (value and minimum stack value) on top of the stack.\\n\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.count = 0\\n\\n    def push(self, val: int) -> None:\\n        topMin = val\\n        if self.count > 0:\\n            topMin = min(self.stack[-1][1], val)\\n        self.stack.append((val, topMin))\\n        self.count += 1\\n            \\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.count -= 1\\n        \\n    def top(self) -> int:\\n        return self.stack[-1][0] \\n        \\n    def getMin(self) -> int:\\n        return self.stack[-1][1]\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    stackWithMinElements = collections.namedtuple(\"stackWithMinElements\", (\"element\", \"minimum\"))\\n    \\n    def __init__(self):        \\n        self.stack : List[self.stackWithMinElements] = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(self.stackWithMinElements(\\n                        x, min(x, self.getMin()) if len(self.stack)>0 else x))\\n\\n    def pop(self) -> None:\\n        self.stack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1].element\\n\\n    def getMin(self) -> int:\\n        return self.stack[-1].minimum\\n```\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.count = 0\\n\\n    def push(self, val: int) -> None:\\n        topMin = val\\n        if self.count > 0:\\n            topMin = min(self.stack[-1][1], val)\\n        self.stack.append((val, topMin))\\n        self.count += 1\\n            \\n    def pop(self) -> None:\\n        self.stack.pop()\\n        self.count -= 1\\n        \\n    def top(self) -> int:\\n        return self.stack[-1][0] \\n        \\n    def getMin(self) -> int:\\n        return self.stack[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740132,
                "title": "javascript-clean-es6-class-using-2-arrays",
                "content": "## Solution 1\\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = [];\\n    }\\n    \\n    push(x) {\\n        if (!this.min.length) this.min.push(x);\\n        else this.min.push(Math.min(x, this.getMin()));\\n        this.stack.push(x);\\n    }\\n    \\n    pop() {\\n        this.min.pop()\\n        return this.stack.pop()\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.min[this.min.length-1];\\n    }\\n}\\n\\n```\\n\\n## Solution 2: Optimized space\\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.minArr = [{val: Infinity, count: 1}];\\n    }\\n    \\n    push(x) {\\n        this.stack.push(x);\\n        let min = this.minArr[this.minArr.length-1];\\n        if(x === min.val) min.count++;\\n        else if(x < min.val) this.minArr.push({val: x, count: 1});\\n    }\\n    \\n    pop() {\\n        let item = this.stack.pop();\\n        let min = this.minArr[this.minArr.length-1];\\n        if(item === min.val) min.count--;\\n        if(!min.count) this.minArr.pop();\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.minArr[this.minArr.length-1].val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.min = [];\\n    }\\n    \\n    push(x) {\\n        if (!this.min.length) this.min.push(x);\\n        else this.min.push(Math.min(x, this.getMin()));\\n        this.stack.push(x);\\n    }\\n    \\n    pop() {\\n        this.min.pop()\\n        return this.stack.pop()\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.min[this.min.length-1];\\n    }\\n}\\n\\n```\n```javascript\\nclass MinStack {\\n    constructor() {\\n        this.stack = [];\\n        this.minArr = [{val: Infinity, count: 1}];\\n    }\\n    \\n    push(x) {\\n        this.stack.push(x);\\n        let min = this.minArr[this.minArr.length-1];\\n        if(x === min.val) min.count++;\\n        else if(x < min.val) this.minArr.push({val: x, count: 1});\\n    }\\n    \\n    pop() {\\n        let item = this.stack.pop();\\n        let min = this.minArr[this.minArr.length-1];\\n        if(item === min.val) min.count--;\\n        if(!min.count) this.minArr.pop();\\n    }\\n    \\n    top() {\\n        return this.stack[this.stack.length-1];\\n    }\\n    \\n    getMin() {\\n        return this.minArr[this.minArr.length-1].val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733245,
                "title": "stack-with-pair-in-c-is-the-simplest-way",
                "content": "Declare, `stack< pair<int,int> > container;`\\n\\n*Lets, observe some test cases  :*\\n\\n\\n* \\t\\t\\tCommand     -      Data     -    Minvalue\\n* \\t\\t\\tPush                 10               10\\n* \\t\\t\\tPush                  9                 9    (Compare 9 with previous min value 10 , min(9,10)= 9)           \\n* \\t\\t\\tPush                 15               9    (Compare 15 with previous min value 9 , min(9,15)= 9)   \\n*   \\t\\tPop                                            ( (15 , 9 ) will be poped)\\n*   \\t\\tTop                    9                     (Top value of stack is (9,9) and first value is 9 )\\n* \\t\\t\\tPush                  -7               -7  (Compare -7 with previous min value 9, min(-7,9)=-7 )           \\n* \\t\\t\\tPush                  20              -7  (Compare 20 with previous min value -7, min(20, -7)=-7)\\n* \\t\\t\\tPop                                         ( (20 , -7 ) will be poped)\\n* \\t\\t\\tgetMin              -7                   (top value of stack (-7,-7) and second value is the min value)\\n\\n\\n\\n**Code-**\\n\\n```\\nclass MinStack {\\npublic:\\n    \\n    stack< pair<int,int> > container;\\n    int mn=0;\\n \\n    void push(int x) {\\n        \\n        if(container.size()==0){\\n        container.push({x,x});\\n        mn=x;\\n        }\\n        else{\\n            pair<int,int> sq = container.top();   \\n            mn = sq.second;\\n            mn=min(x,mn);  // checking with previous min value;\\n            container.push({x,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(container.size()>0)\\n        container.pop();\\n    }\\n    \\n    int top() {\\n        pair<int,int> m = container.top();  \\n        return m.first;   //first value of pair is the top value;\\n    }\\n    \\n    int getMin() {\\n        pair<int,int> m = container.top();\\n        return m.second;  //second value is the min value;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack< pair<int,int> > container;\\n    int mn=0;\\n \\n    void push(int x) {\\n        \\n        if(container.size()==0){\\n        container.push({x,x});\\n        mn=x;\\n        }\\n        else{\\n            pair<int,int> sq = container.top();   \\n            mn = sq.second;\\n            mn=min(x,mn);  // checking with previous min value;\\n            container.push({x,mn});\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(container.size()>0)\\n        container.pop();\\n    }\\n    \\n    int top() {\\n        pair<int,int> m = container.top();  \\n        return m.first;   //first value of pair is the top value;\\n    }\\n    \\n    int getMin() {\\n        pair<int,int> m = container.top();\\n        return m.second;  //second value is the min value;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548716,
                "title": "python3-solution-using-2-stacks",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.minstack = list()\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if len(self.minstack) == 0 or x <= self.minstack[-1]:\\n            self.minstack.append(x)\\n\\n    def pop(self) -> None:\\n        e = self.stack.pop()\\n        if e == self.minstack[-1]:\\n            self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```\\n\\nSomething to note, if len(self.minstack) == 0 or x <= self.minstack[-1] can be done because Python3 supports short circuting. Refer here : https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\\n\\nThis means, for the or operation, if either one is true the other one is not operated. So even if len(self.minstack) is 0, we don\\'t have to worry about self.minstack[-1] raising an exception.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = list()\\n        self.minstack = list()\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if len(self.minstack) == 0 or x <= self.minstack[-1]:\\n            self.minstack.append(x)\\n\\n    def pop(self) -> None:\\n        e = self.stack.pop()\\n        if e == self.minstack[-1]:\\n            self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446983,
                "title": "simple-java-solution-without-any-extra-data-structure",
                "content": "````\\n\\nclass MinStack {\\n\\n   private class Node {\\n       int min;\\n       int value ; \\n       Node next;\\n       \\n       Node(int val, int m) {\\n           value = val;\\n           min = m;\\n       }\\n   }\\n    \\n        Node top;\\n        public MinStack() {\\n        }\\n\\n        public void push(int x) {\\n            if(top == null) {\\n                top = new Node(x, x);\\n            } else {\\n                Node node = new Node(x, Math.min(top.min, x));\\n                node.next = top;\\n                top = node;\\n            }\\n        }\\n\\n        public void pop() {\\n           if(top != null){\\n               top = top.next;\\n           }\\n        }\\n\\n        public int top() {\\n            return top != null ? top.value : -1;\\n        }\\n\\n        public int getMin() {\\n           if(top != null) return top.min;\\n            \\n            return -1;\\n        }\\n}\\n\\n\\n\\n````",
                "solutionTags": [],
                "code": "````\\n\\nclass MinStack {\\n\\n   private class Node {\\n       int min;\\n       int value ; \\n       Node next;\\n       \\n       Node(int val, int m) {\\n           value = val;\\n           min = m;\\n       }\\n   }\\n    \\n        Node top;\\n        public MinStack() {\\n        }\\n\\n        public void push(int x) {\\n            if(top == null) {\\n                top = new Node(x, x);\\n            } else {\\n                Node node = new Node(x, Math.min(top.min, x));\\n                node.next = top;\\n                top = node;\\n            }\\n        }\\n\\n        public void pop() {\\n           if(top != null){\\n               top = top.next;\\n           }\\n        }\\n\\n        public int top() {\\n            return top != null ? top.value : -1;\\n        }\\n\\n        public int getMin() {\\n           if(top != null) return top.min;\\n            \\n            return -1;\\n        }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402558,
                "title": "python-method-faster-than-92-and-very-little-line-of-code",
                "content": "Initialize two lists(stack, min). list stack records all push and pop elements and list min keeps the latest minimal at the end of the list.\\n```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min = []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.stack.append(x)\\n        self.min.append(min(self.min[-1], x)) if self.min else self.min.append(x)\\n\\n            \\n    def pop(self):\\n        \"\"\"\\n        :rtype: None\\n        \"\"\"\\n        self.stack.pop()\\n        self.min.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min = []\\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: None\\n        \"\"\"\\n        self.stack.append(x)\\n        self.min.append(min(self.min[-1], x)) if self.min else self.min.append(x)\\n\\n            \\n    def pop(self):\\n        \"\"\"\\n        :rtype: None\\n        \"\"\"\\n        self.stack.pop()\\n        self.min.pop()\\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388851,
                "title": "java-easy-to-understand-solution",
                "content": "The approach is to use regular java `Stack` with each entry having value + min value at the time of push.\\n\\n```\\nclass MinStack {    \\n    class Record {\\n        public final int value;\\n        public final int minValue;\\n        \\n        public Record(int value, int minValue) {\\n            this.value = value;\\n            this.minValue = minValue;\\n        }\\n    }\\n    \\n    private final Stack<Record> _stack = new Stack();\\n\\n    public void push(int x) {\\n        int minValue = _stack.size() == 0 ? x : Math.min(x, getMin());\\n        _stack.push(new Record(x, minValue));\\n    }\\n    \\n    public void pop() {\\n        _stack.pop();\\n    }\\n    \\n    public int top() {\\n        return _stack.peek().value;\\n    }\\n    \\n    public int getMin() {\\n        return _stack.peek().minValue;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {    \\n    class Record {\\n        public final int value;\\n        public final int minValue;\\n        \\n        public Record(int value, int minValue) {\\n            this.value = value;\\n            this.minValue = minValue;\\n        }\\n    }\\n    \\n    private final Stack<Record> _stack = new Stack();\\n\\n    public void push(int x) {\\n        int minValue = _stack.size() == 0 ? x : Math.min(x, getMin());\\n        _stack.push(new Record(x, minValue));\\n    }\\n    \\n    public void pop() {\\n        _stack.pop();\\n    }\\n    \\n    public int top() {\\n        return _stack.peek().value;\\n    }\\n    \\n    public int getMin() {\\n        return _stack.peek().minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329631,
                "title": "c-90-beaten-stackson-jackson-all-o-1-requires-o-n-extra-memory",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<int> mStack;\\n    stack<int> mMinStack;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        mStack.push(x);\\n        if (!mMinStack.empty()) {\\n            mMinStack.push(min(mMinStack.top(), x));\\n        } else {\\n            mMinStack.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        mStack.pop();\\n        mMinStack.pop();\\n    }\\n    \\n    int top() {\\n        return mStack.top();\\n    }\\n    \\n    int getMin() {\\n        return mMinStack.top();\\n    }\\n};\\n```\\n\\nThe trick is to keep an extra stack for your minimum values.\\n\\nStack Values:\\n[bottom] [5 4 4 5 3 4 3 1 1 3] [top]\\n\\nMin Stack:\\n[bottom] [5 4 4 4 3 3 3 1 1 1] [top]\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<int> mStack;\\n    stack<int> mMinStack;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        mStack.push(x);\\n        if (!mMinStack.empty()) {\\n            mMinStack.push(min(mMinStack.top(), x));\\n        } else {\\n            mMinStack.push(x);\\n        }\\n    }\\n    \\n    void pop() {\\n        mStack.pop();\\n        mMinStack.pop();\\n    }\\n    \\n    int top() {\\n        return mStack.top();\\n    }\\n    \\n    int getMin() {\\n        return mMinStack.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309781,
                "title": "shortest-and-readable-java-solution",
                "content": "```\\nclass MinStack {\\n    private static class Entry{\\n        int value;\\n        int min;\\n        Entry previous;\\n        Entry(int value, Entry previous){\\n            this.value = value;\\n            this.previous = previous;\\n            this.min = previous==null?value:Math.min(value,previous.min);\\n        }\\n    }\\n    private Entry top = null;    \\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        top = new Entry(x,top);\\n    }\\n    \\n    public void pop() {\\n        top = top.previous;\\n    }\\n    \\n    public int top() {\\n        return top.value;\\n    }\\n    \\n    public int getMin() {\\n        return top.min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n    private static class Entry{\\n        int value;\\n        int min;\\n        Entry previous;\\n        Entry(int value, Entry previous){\\n            this.value = value;\\n            this.previous = previous;\\n            this.min = previous==null?value:Math.min(value,previous.min);\\n        }\\n    }\\n    private Entry top = null;    \\n\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n    }\\n    \\n    public void push(int x) {\\n        top = new Entry(x,top);\\n    }\\n    \\n    public void pop() {\\n        top = top.previous;\\n    }\\n    \\n    public int top() {\\n        return top.value;\\n    }\\n    \\n    public int getMin() {\\n        return top.min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260088,
                "title": "java-short-solution",
                "content": "```\\n    Stack<int[]> s;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        s = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        s.push(new int[]{x, Math.min(x, s.isEmpty() ? Integer.MAX_VALUE : s.peek()[1])});\\n    }\\n    \\n    public void pop() {\\n        s.pop();\\n    }\\n    \\n    public int top() {\\n        return s.peek()[0];\\n    }\\n    \\n    public int getMin() {\\n        return s.peek()[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Stack<int[]> s;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        s = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        s.push(new int[]{x, Math.min(x, s.isEmpty() ? Integer.MAX_VALUE : s.peek()[1])});\\n    }\\n    \\n    public void pop() {\\n        s.pop();\\n    }\\n    \\n    public int top() {\\n        return s.peek()[0];\\n    }\\n    \\n    public int getMin() {\\n        return s.peek()[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159466,
                "title": "python-solution",
                "content": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min_stack = []\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.stack.append(x)\\n        if not self.min_stack:\\n            self.min_stack.append(x)\\n        else:\\n            if x < self.min_stack[-1]:\\n                self.min_stack.append(x)\\n            else:\\n                self.min_stack.append(self.min_stack[-1])\\n                \\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: void\\n        \"\"\"\\n        self.stack.pop()\\n        self.min_stack.pop()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min_stack[-1]\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.stack = []\\n        self.min_stack = []\\n        \\n\\n    def push(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: void\\n        \"\"\"\\n        self.stack.append(x)\\n        if not self.min_stack:\\n            self.min_stack.append(x)\\n        else:\\n            if x < self.min_stack[-1]:\\n                self.min_stack.append(x)\\n            else:\\n                self.min_stack.append(self.min_stack[-1])\\n                \\n        \\n\\n    def pop(self):\\n        \"\"\"\\n        :rtype: void\\n        \"\"\"\\n        self.stack.pop()\\n        self.min_stack.pop()\\n        \\n\\n    def top(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.stack[-1]\\n        \\n\\n    def getMin(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.min_stack[-1]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49071,
                "title": "java-solution-with-just-one-stack",
                "content": "This approach is pushing the min of the stack after every push methods. And retrieve the min after pop.\\n\\n```java\\npublic class MinStack {\\n    Stack<Integer> stack;\\n    int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        min = Integer.MAX_VALUE;\\n        stack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        min = Math.min(min, x);\\n        stack.push(x);\\n        stack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        stack.pop();\\n        min = stack.isEmpty() ? Integer.MAX_VALUE : stack.peek();\\n    }\\n    \\n    public int top() {\\n        int temp = stack.pop();\\n        int res = stack.peek();\\n        stack.push(temp);\\n        return res;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\npublic class MinStack {\\n    Stack<Integer> stack;\\n    int min;\\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        min = Integer.MAX_VALUE;\\n        stack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int x) {\\n        min = Math.min(min, x);\\n        stack.push(x);\\n        stack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        stack.pop();\\n        min = stack.isEmpty() ? Integer.MAX_VALUE : stack.peek();\\n    }\\n    \\n    public int top() {\\n        int temp = stack.pop();\\n        int res = stack.peek();\\n        stack.push(temp);\\n        return res;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49162,
                "title": "c-simple-solution",
                "content": "    class MinStack {\\n    public:\\n        stack<int> st;\\n        stack<int> nextMin;\\n        \\n        void push(int x) {\\n            if(st.empty()){\\n                nextMin.push(x);\\n            }else if(nextMin.top() >= x){\\n                nextMin.push(x);\\n            }\\n            st.push(x);\\n        }\\n    \\n        void pop() {\\n            int tmp = st.top();\\n            st.pop();\\n            if(tmp == nextMin.top()){\\n                nextMin.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            return st.top();\\n        }\\n    \\n        int getMin() {\\n            return nextMin.top();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class MinStack {\\n    public:\\n        stack<int> st;\\n        stack<int> nextMin;\\n        \\n        void push(int x) {\\n            if(st.empty()){\\n                nextMin.push(x);\\n            }else if(nextMin.top() >= x){\\n                nextMin.push(x);\\n            }\\n            st.push(x);\\n        }\\n    \\n        void pop() {\\n            int tmp = st.top();\\n            st.pop();\\n            if(tmp == nextMin.top()){\\n                nextMin.pop();\\n            }\\n        }\\n    \\n        int top() {\\n            return st.top();\\n        }\\n    \\n        int getMin() {\\n            return nextMin.top();\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49219,
                "title": "simple-java-solution-using-two-stacks-in-o-1",
                "content": "Feel free to share my solution using an auxiliary stack to store the minimum element(s).\\n\\n    class MinStack {\\n            Stack<Integer> mainStack = new Stack<Integer>();\\n            Stack<Integer> minStack = new Stack<Integer>();\\n            \\n            public void push(int x) {\\n                mainStack.push(x);\\n                if (minStack.empty()) {\\n                    minStack.push(x);\\n                } else if (minStack.peek() >= x) {\\n                    minStack.push(x);\\n                }\\n            }\\n        \\n            public void pop() {\\n                int poppedElement = mainStack.pop();\\n                if (poppedElement == minStack.peek()) {\\n                    minStack.pop();\\n                }\\n            }\\n        \\n            public int top() {\\n                return mainStack.peek();\\n            }\\n        \\n            public int getMin() {\\n                return minStack.peek();\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "Feel free to share my solution using an auxiliary stack to store the minimum element(s).\\n\\n    class MinStack {\\n            Stack<Integer> mainStack = new Stack<Integer>();\\n            Stack<Integer> minStack = new Stack<Integer>();\\n            \\n            public void push(int x) {\\n                mainStack.push(x);\\n                if (minStack.empty()) {\\n                    minStack.push(x);\\n                } else if (minStack.peek() >= x) {\\n                    minStack.push(x);\\n                }\\n            }\\n        \\n            public void pop() {\\n                int poppedElement = mainStack.pop();\\n                if (poppedElement == minStack.peek()) {\\n                    minStack.pop();\\n                }\\n            }\\n        \\n            public int top() {\\n                return mainStack.peek();\\n            }\\n        \\n            public int getMin() {\\n                return minStack.peek();\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 49234,
                "title": "python-easy-to-understand-solution-using-two-stacks",
                "content": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n        \\n    def push(self, x):\\n        self.stack.append(x)\\n        if not self.minStack or self.minStack[-1] >= x:\\n            self.minStack.append(x)\\n        \\n    def pop(self):\\n        tmp = self.stack.pop()\\n        if tmp == self.minStack[-1]:\\n            self.minStack.pop()\\n            \\n    def top(self):\\n        return self.stack[-1]\\n        \\n    def getMin(self):\\n        return self.minStack[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass MinStack(object):\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minStack = []\\n        \\n    def push(self, x):\\n        self.stack.append(x)\\n        if not self.minStack or self.minStack[-1] >= x:\\n            self.minStack.append(x)\\n        \\n    def pop(self):\\n        tmp = self.stack.pop()\\n        if tmp == self.minStack[-1]:\\n            self.minStack.pop()\\n            \\n    def top(self):\\n        return self.stack[-1]\\n        \\n    def getMin(self):\\n        return self.minStack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 49257,
                "title": "my-solution-not-super-space-efficient",
                "content": "    class MinStack {\\n        // a vector of (val, mininal_val) \\n        std::vector<std::pair<int, int>>  data;\\n    \\n    public:\\n        void push(int x) {\\n            int min_val = data.empty() ? x : (std::min(getMin(), x));\\n            data.push_back(std::make_pair(x, min_val));\\n        }\\n    \\n        void pop() {\\n            assert(!data.empty());\\n            data.pop_back();\\n        }\\n    \\n        int top() {\\n            assert(!data.empty());\\n            return data.back().first;\\n        }\\n    \\n        int getMin() {\\n            assert(!data.empty());\\n            return data.back().second;\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class MinStack {\\n        // a vector of (val, mininal_val) \\n        std::vector<std::pair<int, int>>  data;\\n    \\n    public:\\n        void push(int x) {\\n            int min_val = data.empty() ? x : (std::min(getMin(), x));\\n            data.push_back(std::make_pair(x, min_val));\\n        }\\n    \\n        void pop() {\\n            assert(!data.empty());\\n            data.pop_back();\\n        }\\n    \\n        int top() {\\n            assert(!data.empty());\\n            return data.back().first;\\n        }\\n    \\n        int getMin() {\\n            assert(!data.empty());\\n            return data.back().second;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 49323,
                "title": "smart-accepted-java-solution-linked-list",
                "content": "\\n    class Element{\\n        int value;\\n        int currentMin;\\n        Element next = null;\\n        Element(int value, int minBefore){\\n            this.value = value;\\n            this.currentMin = Math.min(minBefore,value);\\n     }\\n    \\n    Element top = null;\\n    public void push(int x) {\\n        Element newElement;\\n        if (top == null){\\n            newElement = new Element(x,x);\\n            top = newElement;\\n        }else{\\n            newElement = new Element(x,top.currentMin);\\n            newElement.next=top;\\n            top = newElement;\\n        }\\n    }\\n\\n    public void pop() {\\n        if (top != null){\\n            top = top.next;\\n        }\\n    }\\n\\n    public int top() {\\n        return top.value;\\n    }\\n\\n    public int getMin() {\\n        return top.currentMin;\\n    }",
                "solutionTags": [],
                "code": "\\n    class Element{\\n        int value;\\n        int currentMin;\\n        Element next = null;\\n        Element(int value, int minBefore){\\n            this.value = value;\\n            this.currentMin = Math.min(minBefore,value);\\n     }\\n    \\n    Element top = null;\\n    public void push(int x) {\\n        Element newElement;\\n        if (top == null){\\n            newElement = new Element(x,x);\\n            top = newElement;\\n        }else{\\n            newElement = new Element(x,top.currentMin);\\n            newElement.next=top;\\n            top = newElement;\\n        }\\n    }\\n\\n    public void pop() {\\n        if (top != null){\\n            top = top.next;\\n        }\\n    }\\n\\n    public int top() {\\n        return top.value;\\n    }\\n\\n    public int getMin() {\\n        return top.currentMin;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49315,
                "title": "share-my-java-solution-of-min-stack-in-253-ms-a-litter-faster-than-other-answers-by-now",
                "content": "    class MinStack {\\n           private static final int DEFAULT_INITIAL_CAPACITY = 16;\\n    \\t   private int index = 0;\\n    \\t   private int elementCount = 0;\\n    \\t   int [] elementData = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   int [] minValues = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   private int  minValue = 0;\\n    \\t   \\n                public void push(int x) {\\n    \\t\\t  ensureCapacityHelper(elementCount + 1);\\n    \\t          elementData[index]=x;\\n    \\t          if(index==0){\\n    \\t          minValue = x;\\n    \\t          }else{\\n    \\t          minValue = Math.min(minValue, x);\\n    \\t          }\\n    \\t          minValues[index] = minValue;\\n    \\t          elementCount++;\\n    \\t          index++;\\n    \\t    }\\n    \\n    \\t    public void pop() {\\n    \\t    \\tif (elementCount == 0)\\n    \\t\\t\\treturn;\\n    \\t        index--;\\n    \\t        elementData[index]=0;\\n    \\t        minValues[index]=0;\\n    \\t        elementCount--;\\n    \\t        \\n    \\t        if(index-1<0){\\n    \\t        minValue = 0;\\n    \\t        }else{\\n    \\t        minValue = minValues[index-1];\\n    \\t        }\\n    \\t    }\\n    \\n    \\n    \\t    public int top() {\\n    \\t\\t  if(index-1<0)\\n    \\t\\t  return elementData[0];\\n    \\t      return elementData[index-1]; \\n    \\t    }\\n    \\n    \\t    public int getMin() {\\n    \\t        return minValue;\\n    \\t    }\\n    \\t    \\n    \\t    private void ensureCapacityHelper(int minCapacity) {\\n    \\t        if (minCapacity - elementData.length > 0)\\n    \\t            grow(minCapacity);\\n    \\t    }\\n    \\t    \\n    \\t    private void grow(int minCapacity) {\\n    \\t        int oldCapacity = elementData.length;\\n    \\t        int newCapacity = 2*oldCapacity;\\n    \\t        elementData = Arrays.copyOf(elementData, newCapacity);\\n    \\t        minValues = Arrays.copyOf(minValues, newCapacity);\\n    \\t    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    class MinStack {\\n           private static final int DEFAULT_INITIAL_CAPACITY = 16;\\n    \\t   private int index = 0;\\n    \\t   private int elementCount = 0;\\n    \\t   int [] elementData = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   int [] minValues = new int [DEFAULT_INITIAL_CAPACITY];\\n    \\t   private int  minValue = 0;\\n    \\t   \\n                public void push(int x) {\\n    \\t\\t  ensureCapacityHelper(elementCount + 1);\\n    \\t          elementData[index]=x;\\n    \\t          if(index==0){\\n    \\t          minValue = x;\\n    \\t          }else{\\n    \\t          minValue = Math.min(minValue, x);\\n    \\t          }\\n    \\t          minValues[index] = minValue;\\n    \\t          elementCount++;\\n    \\t          index++;\\n    \\t    }\\n    \\n    \\t    public void pop() {\\n    \\t    \\tif (elementCount == 0)\\n    \\t\\t\\treturn;\\n    \\t        index--;\\n    \\t        elementData[index]=0;\\n    \\t        minValues[index]=0;\\n    \\t        elementCount--;\\n    \\t        \\n    \\t        if(index-1<0){\\n    \\t        minValue = 0;\\n    \\t        }else{\\n    \\t        minValue = minValues[index-1];\\n    \\t        }\\n    \\t    }\\n    \\n    \\n    \\t    public int top() {\\n    \\t\\t  if(index-1<0)\\n    \\t\\t  return elementData[0];\\n    \\t      return elementData[index-1]; \\n    \\t    }\\n    \\n    \\t    public int getMin() {\\n    \\t        return minValue;\\n    \\t    }\\n    \\t    \\n    \\t    private void ensureCapacityHelper(int minCapacity) {\\n    \\t        if (minCapacity - elementData.length > 0)\\n    \\t            grow(minCapacity);\\n    \\t    }\\n    \\t    \\n    \\t    private void grow(int minCapacity) {\\n    \\t        int oldCapacity = elementData.length;\\n    \\t        int newCapacity = 2*oldCapacity;\\n    \\t        elementData = Arrays.copyOf(elementData, newCapacity);\\n    \\t        minValues = Arrays.copyOf(minValues, newCapacity);\\n    \\t    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 49310,
                "title": "why-push-1-top-getmin-will-return-3",
                "content": "    class MinStack:\\n    # @param x, an integer\\n    # @return an integer\\n    \\n    the_stack = []\\n    min_index_stack = []\\n    \\n    def push(self, x):\\n        if(self.the_stack):\\n            the_last_index = self.min_index_stack[len(self.min_index_stack) - 1]\\n            self.the_stack.append(x)\\n            if self.the_stack[the_last_index] > x:\\n                self.min_index_stack.append(len(self.the_stack) - 1)\\n        else:\\n            self.the_stack.append(x)\\n            self.min_index_stack.append(0)\\n\\n    # @return nothing\\n    def pop(self):\\n        if len(self.the_stack) > 0:\\n            if (len(self.the_stack) - 1) == self.min_index_stack[len(self.min_index_stack) - 1]:\\n                self.min_index_stack.pop()\\n            return self.the_stack.pop()\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[len(self.the_stack) - 1]\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[self.min_index_stack[len(self.min_index_stack) - 1]]\\n\\nThe oj end is: Wrong Answer\\nInput:          push(-1), top, getMin\\nOutput:       [-1, -3]\\nExpected:   [-1, -1]\\n\\nI don`t understand why there is \"-3\".",
                "solutionTags": [],
                "code": "    class MinStack:\\n    # @param x, an integer\\n    # @return an integer\\n    \\n    the_stack = []\\n    min_index_stack = []\\n    \\n    def push(self, x):\\n        if(self.the_stack):\\n            the_last_index = self.min_index_stack[len(self.min_index_stack) - 1]\\n            self.the_stack.append(x)\\n            if self.the_stack[the_last_index] > x:\\n                self.min_index_stack.append(len(self.the_stack) - 1)\\n        else:\\n            self.the_stack.append(x)\\n            self.min_index_stack.append(0)\\n\\n    # @return nothing\\n    def pop(self):\\n        if len(self.the_stack) > 0:\\n            if (len(self.the_stack) - 1) == self.min_index_stack[len(self.min_index_stack) - 1]:\\n                self.min_index_stack.pop()\\n            return self.the_stack.pop()\\n\\n    # @return an integer\\n    def top(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[len(self.the_stack) - 1]\\n\\n    # @return an integer\\n    def getMin(self):\\n        if len(self.the_stack) > 0:\\n            return self.the_stack[self.min_index_stack[len(self.min_index_stack) - 1]]\\n\\nThe oj end is: Wrong Answer\\nInput:          push(-1), top, getMin\\nOutput:       [-1, -3]\\nExpected:   [-1, -1]\\n\\nI don`t understand why there is \"-3\".",
                "codeTag": "Java"
            },
            {
                "id": 3969801,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class MinStack {\\n    Stack<int> stack = null;\\n    Stack<int> minStack = null;\\n    int minValue = 0;\\n    public MinStack() {\\n        stack = new Stack<int>();\\n        minStack = new Stack<int>();\\n    }\\n    public void Push(int val) {\\n        if(stack.Count == 0)\\n        {\\n            minValue = val;\\n        }\\n        stack.Push(val);\\n        minValue = Math.Min(minValue, val);\\n        minStack.Push(minValue);\\n    }\\n    public void Pop() {\\n        stack.Pop();\\n        minStack.Pop();\\n        if(minStack.Count > 0)\\n        {\\n            minValue = minStack.Peek();\\n        }\\n    }\\n    public int Top() {\\n        return stack.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return minValue;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.Push(val);\\n * obj.Pop();\\n * int param_3 = obj.Top();\\n * int param_4 = obj.GetMin();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Design"
                ],
                "code": "```\\npublic class MinStack {\\n    Stack<int> stack = null;\\n    Stack<int> minStack = null;\\n    int minValue = 0;\\n    public MinStack() {\\n        stack = new Stack<int>();\\n        minStack = new Stack<int>();\\n    }\\n    public void Push(int val) {\\n        if(stack.Count == 0)\\n        {\\n            minValue = val;\\n        }\\n        stack.Push(val);\\n        minValue = Math.Min(minValue, val);\\n        minStack.Push(minValue);\\n    }\\n    public void Pop() {\\n        stack.Pop();\\n        minStack.Pop();\\n        if(minStack.Count > 0)\\n        {\\n            minValue = minStack.Peek();\\n        }\\n    }\\n    public int Top() {\\n        return stack.Peek();\\n    }\\n    \\n    public int GetMin() {\\n        return minValue;\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.Push(val);\\n * obj.Pop();\\n * int param_3 = obj.Top();\\n * int param_4 = obj.GetMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784712,
                "title": "most-awesome-java-solution-two-approaches-explained-stacks-arraylist",
                "content": "# Intuition\\nMethod 1:\\nOne normal stack to do all operations Another minStack to keep record of minimum element in the stack yet.\\nMethod 2: \\nUsing two ArrayList.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack {\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n        \\n    }\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        \\n        min = Math.min(val, minStack.isEmpty() ?val :minStack.peek());\\n        minStack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        minStack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n\\n    }\\n\\n}\\n\\n//========================SecondMethod===============================\\nclass MinStack {\\n\\n    ArrayList<Integer> list;\\n    ArrayList<Integer> minList;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        list = new ArrayList<>();\\n        minList = new ArrayList<>();\\n        minList.add(min);\\n    }\\n    \\n    public void push(int val) {\\n        if(val <= minList.get(minList.size()-1)){\\n            minList.add(val);\\n        }\\n        list.add(val);\\n    }\\n    \\n    public void pop() {\\n        int removed = list.remove(list.size()-1);\\n        if(minList.get(minList.size()-1)== removed){\\n            minList.remove(minList.size()-1);\\n        }\\n        \\n    }\\n    \\n    public int top() {\\n        return list.get(list.size()-1);\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minList.get(minList.size()-1);\\n\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```\\n![upvoteCat.png](https://assets.leetcode.com/users/images/72472ac7-fbf0-4311-a4ee-ed9fe91c45b9_1689707783.1190436.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\n    Stack<Integer> stack;\\n    Stack<Integer> minStack;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n        \\n    }\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        \\n        min = Math.min(val, minStack.isEmpty() ?val :minStack.peek());\\n        minStack.push(min);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        minStack.pop();\\n        \\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n\\n    }\\n\\n}\\n\\n//========================SecondMethod===============================\\nclass MinStack {\\n\\n    ArrayList<Integer> list;\\n    ArrayList<Integer> minList;\\n    int min = Integer.MAX_VALUE;\\n\\n    public MinStack() {\\n        list = new ArrayList<>();\\n        minList = new ArrayList<>();\\n        minList.add(min);\\n    }\\n    \\n    public void push(int val) {\\n        if(val <= minList.get(minList.size()-1)){\\n            minList.add(val);\\n        }\\n        list.add(val);\\n    }\\n    \\n    public void pop() {\\n        int removed = list.remove(list.size()-1);\\n        if(minList.get(minList.size()-1)== removed){\\n            minList.remove(minList.size()-1);\\n        }\\n        \\n    }\\n    \\n    public int top() {\\n        return list.get(list.size()-1);\\n        \\n    }\\n    \\n    public int getMin() {\\n        return minList.get(minList.size()-1);\\n\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685256,
                "title": "code-with-proper-comment-easy-solution",
                "content": "\\n\\n# Code\\n```\\nimport java.util.Stack;\\n\\nclass MinStack {\\n    Stack<Integer> s; // Stack to store the elements\\n    Stack<Integer> min; // Stack to store the minimum elements\\n\\n    /**\\n     * Initialize the MinStack.\\n     */\\n    public MinStack() {\\n        s = new Stack<>();\\n        min = new Stack<>();\\n    }\\n\\n    /**\\n     * Pushes an element onto the stack.\\n     * @param val The value to be pushed.\\n     */\\n    public void push(int val) {\\n        s.push(val); // Push the value onto the main stack\\n\\n        // If the minimum stack is empty or the new value is less than or equal to the current minimum,\\n        // push the new value onto the minimum stack\\n        if (min.isEmpty() || min.peek() >= s.peek()) {\\n            min.push(val);\\n        }\\n    }\\n\\n    /**\\n     * Removes the top element of the stack.\\n     */\\n    public void pop() {\\n        int val = s.pop(); // Pop the top value from the main stack\\n\\n        // If the popped value is the current minimum, remove it from the minimum stack\\n        if (min.peek() == val) {\\n            min.pop();\\n        }\\n    }\\n\\n    /**\\n     * Returns the top element of the stack.\\n     * @return The top element of the stack, or -1 if the stack is empty.\\n     */\\n    public int top() {\\n        if (s.isEmpty()) {\\n            return -1;\\n        }\\n        return s.peek(); // Return the top value from the main stack\\n    }\\n\\n    /**\\n     * Retrieves the minimum element in the stack.\\n     * @return The minimum element in the stack, or -1 if the stack is empty.\\n     */\\n    public int getMin() {\\n        if (min.isEmpty()) {\\n            return -1;\\n        }\\n        return min.peek(); // Return the top value from the minimum stack\\n    }\\n}\\n\\n/**\\n * Example usage of the MinStack class:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass MinStack {\\n    Stack<Integer> s; // Stack to store the elements\\n    Stack<Integer> min; // Stack to store the minimum elements\\n\\n    /**\\n     * Initialize the MinStack.\\n     */\\n    public MinStack() {\\n        s = new Stack<>();\\n        min = new Stack<>();\\n    }\\n\\n    /**\\n     * Pushes an element onto the stack.\\n     * @param val The value to be pushed.\\n     */\\n    public void push(int val) {\\n        s.push(val); // Push the value onto the main stack\\n\\n        // If the minimum stack is empty or the new value is less than or equal to the current minimum,\\n        // push the new value onto the minimum stack\\n        if (min.isEmpty() || min.peek() >= s.peek()) {\\n            min.push(val);\\n        }\\n    }\\n\\n    /**\\n     * Removes the top element of the stack.\\n     */\\n    public void pop() {\\n        int val = s.pop(); // Pop the top value from the main stack\\n\\n        // If the popped value is the current minimum, remove it from the minimum stack\\n        if (min.peek() == val) {\\n            min.pop();\\n        }\\n    }\\n\\n    /**\\n     * Returns the top element of the stack.\\n     * @return The top element of the stack, or -1 if the stack is empty.\\n     */\\n    public int top() {\\n        if (s.isEmpty()) {\\n            return -1;\\n        }\\n        return s.peek(); // Return the top value from the main stack\\n    }\\n\\n    /**\\n     * Retrieves the minimum element in the stack.\\n     * @return The minimum element in the stack, or -1 if the stack is empty.\\n     */\\n    public int getMin() {\\n        if (min.isEmpty()) {\\n            return -1;\\n        }\\n        return min.peek(); // Return the top value from the minimum stack\\n    }\\n}\\n\\n/**\\n * Example usage of the MinStack class:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297934,
                "title": "python-one-stack-without-tuples-and-linklist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem we need to solve here is that we need to find a way to **save the min value of every stage/val** so that when we pop the min value of the current val, we don\\'t need to loop and find the previous min value. We can save the min through push a tuple to the stack and linklist. But here we use aother method to achieve it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is **whenever we push a new minimum value, we push the previous one first and then push the new one on the top of the old one.** In this way, when we pop the minimum value, we can pop the next value(previous min value) as well and update the min value.\\n\\n\\n# Code\\n```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minVal = 2**31 - 1\\n\\n    def push(self, val: int) -> None:\\n        if val <= self.minVal:              # remember to add \\'euqals to\\'\\n            self.stack.append(self.minVal)  # push the previous min value\\n            self.minVal = val               # update the min value\\n        self.stack.append(val)              # push the new val\\n\\n    def pop(self) -> None:\\n        if self.stack.pop() == self.minVal: # when we pop the min val, \\n            self.minVal = self.stack.pop()  # we pop the next(previous min value) of it as well and update the min value\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minVal\\n        \\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n        self.minVal = 2**31 - 1\\n\\n    def push(self, val: int) -> None:\\n        if val <= self.minVal:              # remember to add \\'euqals to\\'\\n            self.stack.append(self.minVal)  # push the previous min value\\n            self.minVal = val               # update the min value\\n        self.stack.append(val)              # push the new val\\n\\n    def pop(self) -> None:\\n        if self.stack.pop() == self.minVal: # when we pop the min val, \\n            self.minVal = self.stack.pop()  # we pop the next(previous min value) of it as well and update the min value\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return self.minVal\\n        \\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057098,
                "title": "c-two-solutions-o-n-o-1-tc",
                "content": "---\\n### Frist Approach\\n\\n### Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass MinStack {\\npublic:\\n    vector<int> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push_back(val);\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back();\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return *min_element(st.begin(), st.end());\\n    }\\n};\\n```\\n---\\n### Second Approach\\n\\n### Complexity\\n- Time complexity:  $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int,int>> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n       if(st.size() == 0) st.push_back({val, val});\\n       else st.push_back({val, min(st.back().second, val)});\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back().first;\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return st.back().second;\\n    }\\n};\\n\\n```\\n---\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    vector<int> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        st.push_back(val);\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back();\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return *min_element(st.begin(), st.end());\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    vector<pair<int,int>> st;\\n\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n       if(st.size() == 0) st.push_back({val, val});\\n       else st.push_back({val, min(st.back().second, val)});\\n    }\\n    \\n    void pop() {\\n        if(st.size() == 0) return;\\n        st.pop_back();\\n    }\\n    \\n    int top() {\\n        if(st.size() == 0) return -1;\\n        return st.back().first;\\n    }\\n    \\n    int getMin() {\\n        if(st.size() == 0) return -1;\\n        return st.back().second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914022,
                "title": "java-solution-beat-100-full-explanation-in-depth",
                "content": "# Intuition\\nImagine a list. For each level of this list instead of storing just one value, we store two. Why?\\nSince this is a stack problem, and we are asking to find the min value in 0(1), storing for each level the value provided in the push method, and the min value of the stack at each level, would be great.\\nIf we didn\\'t store two values, we would have to search in a linear time each value in the list and find the minimium. If u still dont get it, read the example in the approach. \\n\\n# Approach\\nMain stack: [1,2,0,7,3],\\nMin stack:  [1,1,0,0,0].\\n\\nDo you see that, at each value of the min stack, we store the current minimium? In the first position since there\\'s just one number, we store just the 1. At the second one, we compare the current number in the main stack, and the least recent minimium. In this way, we don\\'t need to use a linear search since we are storing for the min value for each position. \\nNow you maybe wonder: what if we pop the last element in the main stack?\\nEasy, we pop the last element in the min stack too. Why? \\nBecause i told u that for each level we are storing two value. If we remove the last level in the main stack, we have to remove the last level in the min stack too.\\n\\nFor this, we can use either use two array list like in the example that i provided, or if u think about it, we can use an abstract list.\\nIn this way, we can keep the top value as a variable, the head one, and we dont need to have 2 List.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n0(n)\\n# Code\\n```\\nclass MinStack {\\n    \\n    // at the first, the head is null, cause the stack is empty.\\n    private Node head;\\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        /* if the stack is empty, we can\\'t compare the last min\\n        so we need to check first, is there is a last element. */\\n        int min = this.head == null ?\\n            val :\\n            Math.min(this.head.min, val);\\n        /* this would be equal to: if(this.head == null) ..\\n        else ... */         \\n\\n        // now, the new last element of the stack is the one provided\\n        // in the param, so we reference in the new node, the head\\n        // since it is the last top element of the stack */\\n        head = new Node(val, min, this.head);\\n    }\\n    \\n    public void pop() {\\n        // to remove an element, we just change the head to the prev\\n        this.head = this.head.prev;\\n    }\\n    \\n    public int top() {\\n        return this.head.val;\\n    }\\n    \\n    public int getMin() {\\n        // since we have for each level a node with the min value\\n        // we can just return the last one :)    \\n        return this.head.min;\\n    }\\n\\n    class Node {\\n        int val;\\n        int min;\\n\\n        Node prev;\\n\\n        public Node(int val, int min, Node prev) {\\n            this.val = val;\\n            this.min = min;\\n            this.prev = prev;\\n        } \\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Intuition\\nImagine a list. For each level of this list instead of storing just one value, we store two. Why?\\nSince this is a stack problem, and we are asking to find the min value in 0(1), storing for each level the value provided in the push method, and the min value of the stack at each level, would be great.\\nIf we didn\\'t store two values, we would have to search in a linear time each value in the list and find the minimium. If u still dont get it, read the example in the approach. \\n\\n# Approach\\nMain stack: [1,2,0,7,3],\\nMin stack:  [1,1,0,0,0].\\n\\nDo you see that, at each value of the min stack, we store the current minimium? In the first position since there\\'s just one number, we store just the 1. At the second one, we compare the current number in the main stack, and the least recent minimium. In this way, we don\\'t need to use a linear search since we are storing for the min value for each position. \\nNow you maybe wonder: what if we pop the last element in the main stack?\\nEasy, we pop the last element in the min stack too. Why? \\nBecause i told u that for each level we are storing two value. If we remove the last level in the main stack, we have to remove the last level in the min stack too.\\n\\nFor this, we can use either use two array list like in the example that i provided, or if u think about it, we can use an abstract list.\\nIn this way, we can keep the top value as a variable, the head one, and we dont need to have 2 List.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n0(n)\\n# Code\\n```\\nclass MinStack {\\n    \\n    // at the first, the head is null, cause the stack is empty.\\n    private Node head;\\n\\n    public MinStack() {\\n        \\n    }\\n    \\n    public void push(int val) {\\n        /* if the stack is empty, we can\\'t compare the last min\\n        so we need to check first, is there is a last element. */\\n        int min = this.head == null ?\\n            val :\\n            Math.min(this.head.min, val);\\n        /* this would be equal to: if(this.head == null) ..\\n        else ... */         \\n\\n        // now, the new last element of the stack is the one provided\\n        // in the param, so we reference in the new node, the head\\n        // since it is the last top element of the stack */\\n        head = new Node(val, min, this.head);\\n    }\\n    \\n    public void pop() {\\n        // to remove an element, we just change the head to the prev\\n        this.head = this.head.prev;\\n    }\\n    \\n    public int top() {\\n        return this.head.val;\\n    }\\n    \\n    public int getMin() {\\n        // since we have for each level a node with the min value\\n        // we can just return the last one :)    \\n        return this.head.min;\\n    }\\n\\n    class Node {\\n        int val;\\n        int min;\\n\\n        Node prev;\\n\\n        public Node(int val, int min, Node prev) {\\n            this.val = val;\\n            this.min = min;\\n            this.prev = prev;\\n        } \\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2812426,
                "title": "python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need $$O(1)$$ for this question, thus regular methods such as sorting, looping through the array cannot be done\\n- We can also deduce that:\\n    - We cannot access middle of array (only the back or front)\\n    - So we need to use some data structures that can access front and back in constant time and add or delete stuff to it\\n- Some data structures that can access the front or back in $$O(1)$$\\n    - Queues (Double ended)\\n    - Linked List\\n- I am going to use queues because its much simpler to use than linked lists in python\\n---\\n- Also, Note that for **stacks**\\n    - We can only **pop from the back**\\n    - and **add from the back**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using the knowledge we have above,\\n- We can make up some sort of algorithm that may or may not work:\\n    - Let\\'s add the minimum values to the front of the queue and those that aren\\'t are sent to the back\\n    - E.g\\n      ```\\n      Insert values: 1, -2, 3, 5, 6, 2\\n      Queue: 1\\n      Queue: -2, 1\\n      Queue: -2, 1, 3\\n      Queue: -2, 1, 3, 5\\n      Queue: -2, 1, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2\\n      ```\\n- Now, when we pop from the stack:\\n    - We only need to pop from either the back of the queue or the front\\n    - E.g\\n      ```\\n      Stack: 1, -2, 3, 5, 6, 2      =>      1, -2, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2      pop     -2, 1, 3, 5, 6\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5, 6         =>      1, -2, 3, 5\\n      Queue: -2, 1, 3, 5, 6         pop     -2, 1, 3, 5\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5            =>      1, -2, 3\\n      Queue: -2, 1, 3, 5            pop     -2, 1, 3\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3               =>      1, -2\\n      Queue: -2, 1, 3               pop     -2, 1\\n      ------------------------------------------------------\\n      Stack: 1, -2                  =>           1\\n      Queue: -2, 1                  popfront     1\\n      ```\\n- From here we realise that the minimum can only be on the sides of the queue after a few trial and errors\\n- To find the minimum we can just return the minimum of the first or last values of the queue\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.minimums = deque()\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        \\n        if self.minimums and val <= self.minimums[0]:\\n            self.minimums.appendleft(val)\\n            return\\n        self.minimums.append(val)\\n\\n    def pop(self) -> None:\\n        val = self.stack.pop()\\n        if self.minimums[0] == val:\\n            self.minimums.popleft()\\n            return\\n        self.minimums.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return min(self.minimums[0], self.minimums[-1])\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```\\nNote: This solution was what I thought of when I did this question the first time.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n      Insert values: 1, -2, 3, 5, 6, 2\\n      Queue: 1\\n      Queue: -2, 1\\n      Queue: -2, 1, 3\\n      Queue: -2, 1, 3, 5\\n      Queue: -2, 1, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2\\n      ```\n```\\n      Stack: 1, -2, 3, 5, 6, 2      =>      1, -2, 3, 5, 6\\n      Queue: -2, 1, 3, 5, 6, 2      pop     -2, 1, 3, 5, 6\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5, 6         =>      1, -2, 3, 5\\n      Queue: -2, 1, 3, 5, 6         pop     -2, 1, 3, 5\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3, 5            =>      1, -2, 3\\n      Queue: -2, 1, 3, 5            pop     -2, 1, 3\\n      ------------------------------------------------------\\n      Stack: 1, -2, 3               =>      1, -2\\n      Queue: -2, 1, 3               pop     -2, 1\\n      ------------------------------------------------------\\n      Stack: 1, -2                  =>           1\\n      Queue: -2, 1                  popfront     1\\n      ```\n```\\nclass MinStack:\\n    def __init__(self):\\n        self.stack = []\\n        self.minimums = deque()\\n\\n    def push(self, val: int) -> None:\\n        self.stack.append(val)\\n        \\n        if self.minimums and val <= self.minimums[0]:\\n            self.minimums.appendleft(val)\\n            return\\n        self.minimums.append(val)\\n\\n    def pop(self) -> None:\\n        val = self.stack.pop()\\n        if self.minimums[0] == val:\\n            self.minimums.popleft()\\n            return\\n        self.minimums.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def getMin(self) -> int:\\n        return min(self.minimums[0], self.minimums[-1])\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(val)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.getMin()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645450,
                "title": "c-o-1-time-complexity",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int, int>>s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push({val,val});\\n        }\\n        else{\\n            s.push({val, min(val, s.top().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        s.pop();    \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int, int>>s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(s.empty()){\\n            s.push({val,val});\\n        }\\n        else{\\n            s.push({val, min(val, s.top().second)});\\n        }\\n    }\\n    \\n    void pop() {\\n        s.pop();    \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474936,
                "title": "kotlin-single-stack-using-linkedlist",
                "content": "```\\ndata class Node(\\n    val value: Int,\\n    val min: Int,\\n    var next: Node? = null\\n)\\n\\nclass MinStack {\\n    \\n    var top: Node? = null\\n\\n    fun push(`val`: Int) {\\n        val min: Int = top?.min?.let { if (`val` < it) `val` else it } ?: `val`\\n        val node = Node(`val`, min)\\n        node.next = top\\n        top = node    \\n    }\\n\\n    fun pop() {\\n        top = top?.next\\n    }\\n\\n    fun top(): Int {\\n        return top?.value ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n\\n    fun getMin(): Int {\\n        return top?.min ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\ndata class Node(\\n    val value: Int,\\n    val min: Int,\\n    var next: Node? = null\\n)\\n\\nclass MinStack {\\n    \\n    var top: Node? = null\\n\\n    fun push(`val`: Int) {\\n        val min: Int = top?.min?.let { if (`val` < it) `val` else it } ?: `val`\\n        val node = Node(`val`, min)\\n        node.next = top\\n        top = node    \\n    }\\n\\n    fun pop() {\\n        top = top?.next\\n    }\\n\\n    fun top(): Int {\\n        return top?.value ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n\\n    fun getMin(): Int {\\n        return top?.min ?: throw IllegalStateException(\"Stack is empty.\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381023,
                "title": "c-constant-space",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    // most optimal - using constant space\\n    \\n    // uses a variable to keep track of min\\n    \\n    stack<long long> st;\\n    long long min_ele;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            st.push(val);\\n            min_ele = val;\\n        }\\n        else{\\n            // if val is more than min till now, no change\\n            if(val>min_ele){\\n                st.push(val);\\n            }\\n            // else val will be the new minimum\\n            // to recover prev min we insert 2*val - prev_min instead of val\\n            else{\\n                st.push(2LL*val-min_ele);\\n                min_ele = val;\\n            }\\n        }\\n    }\\n    \\n    // have to recover the previous min\\n    void pop() {\\n        // identifies that current top is the min\\n        if(st.top()<min_ele){\\n            long long prev_min = 2LL*min_ele-st.top();\\n            min_ele = prev_min; \\n        }\\n        st.pop();\\n    }\\n    \\n    // original element in stack = 2*current_min - st.top() \\n    int top() {\\n        if(st.top()<min_ele){\\n            return min_ele;\\n        }\\n        return st.top();\\n    }\\n    \\n    // directly return the min_ele, stored in variable\\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    // most optimal - using constant space\\n    \\n    // uses a variable to keep track of min\\n    \\n    stack<long long> st;\\n    long long min_ele;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(st.empty()){\\n            st.push(val);\\n            min_ele = val;\\n        }\\n        else{\\n            // if val is more than min till now, no change\\n            if(val>min_ele){\\n                st.push(val);\\n            }\\n            // else val will be the new minimum\\n            // to recover prev min we insert 2*val - prev_min instead of val\\n            else{\\n                st.push(2LL*val-min_ele);\\n                min_ele = val;\\n            }\\n        }\\n    }\\n    \\n    // have to recover the previous min\\n    void pop() {\\n        // identifies that current top is the min\\n        if(st.top()<min_ele){\\n            long long prev_min = 2LL*min_ele-st.top();\\n            min_ele = prev_min; \\n        }\\n        st.pop();\\n    }\\n    \\n    // original element in stack = 2*current_min - st.top() \\n    int top() {\\n        if(st.top()<min_ele){\\n            return min_ele;\\n        }\\n        return st.top();\\n    }\\n    \\n    // directly return the min_ele, stored in variable\\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164393,
                "title": "c-100-simple-solution",
                "content": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<long> s;\\n    int mi=INT_MAX;\\n    \\n    \\n    MinStack() {\\n        s=stack<long>();\\n        mi=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        \\n        if(s.empty())\\n        {\\n            s.push(val);\\n            mi=val;\\n        }\\n        else\\n        {\\n            if(val>mi)\\n            {\\n                s.push(val);\\n            }\\n            else\\n            {\\n                s.push((long)2*val-(long)mi);\\n                mi=val;\\n            }\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mi)\\n        {\\n            mi=(long)2*mi-(long)s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()<mi)\\n        {\\n            return mi;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    \\n    stack<long> s;\\n    int mi=INT_MAX;\\n    \\n    \\n    MinStack() {\\n        s=stack<long>();\\n        mi=INT_MAX;\\n    }\\n    \\n    void push(int val) {\\n        \\n        if(s.empty())\\n        {\\n            s.push(val);\\n            mi=val;\\n        }\\n        else\\n        {\\n            if(val>mi)\\n            {\\n                s.push(val);\\n            }\\n            else\\n            {\\n                s.push((long)2*val-(long)mi);\\n                mi=val;\\n            }\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mi)\\n        {\\n            mi=(long)2*mi-(long)s.top();\\n        }\\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()<mi)\\n        {\\n            return mi;\\n        }\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161035,
                "title": "c-every-operation-constant-time-stack-pair",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n        \\n    }\\n    void push(int val) {\\n        if(st.empty())\\n        st.push({val,val});\\n        else\\n            st.push({val,min(val,st.top().second)});\\n    }   \\n    void pop() {\\n        st.pop();\\n    } \\n    int top() {\\n        return st.top().first;\\n    }\\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int>>st;\\n    MinStack() {\\n        \\n    }\\n    void push(int val) {\\n        if(st.empty())\\n        st.push({val,val});\\n        else\\n            st.push({val,min(val,st.top().second)});\\n    }   \\n    void pop() {\\n        st.pop();\\n    } \\n    int top() {\\n        return st.top().first;\\n    }\\n    int getMin() {\\n        return st.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159173,
                "title": "js-javascript-easy-solution",
                "content": "```\\n\\nconst MinStack = function() {\\n    this.values = []\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n    this.values.push(val)\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.pop = function() {\\n    return this.values.pop()\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    return this.values[this.values.length - 1]\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    let min = Number.MAX_SAFE_INTEGER\\n    this.values.forEach(value => min = Math.min(min, value))\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst MinStack = function() {\\n    this.values = []\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMinStack.prototype.push = function(val) {\\n    this.values.push(val)\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.pop = function() {\\n    return this.values.pop()\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    return this.values[this.values.length - 1]\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.getMin = function() {\\n    let min = Number.MAX_SAFE_INTEGER\\n    this.values.forEach(value => min = Math.min(min, value))\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870246,
                "title": "c-2-solutions-2-stack-1-stack-o-1-time-easy-clean-code",
                "content": "**1. Using 2 Stacks**\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s1,s2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int v) {\\n        s1.push(v);\\n        if(s2.empty() || s2.top()>=v)\\n            s2.push(v);\\n    }\\n    \\n    void pop() {\\n        if(s2.top()==s1.top())\\n            s2.pop();\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();\\n    }\\n};\\n```\\n\\n**2. Using single Stack**\\n```\\nclass MinStack {\\npublic:\\n    long mn;\\n    stack<long> s;\\n    \\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n        {\\n            mn=val;\\n            s.push(val);\\n        }\\n        else if(val>mn)\\n            s.push(val);\\n        else\\n        {\\n            s.push((long)2*val-mn);\\n            mn=val;\\n        }  \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mn)\\n            mn=2*mn-s.top();\\n        \\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()>=mn)\\n        return s.top();\\n        \\n        return mn;\\n    }\\n    \\n    int getMin() {\\n        return mn;\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s1,s2;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int v) {\\n        s1.push(v);\\n        if(s2.empty() || s2.top()>=v)\\n            s2.push(v);\\n    }\\n    \\n    void pop() {\\n        if(s2.top()==s1.top())\\n            s2.pop();\\n        s1.pop();\\n    }\\n    \\n    int top() {\\n        return s1.top();\\n    }\\n    \\n    int getMin() {\\n        return s2.top();\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    long mn;\\n    stack<long> s;\\n    \\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(s.empty())\\n        {\\n            mn=val;\\n            s.push(val);\\n        }\\n        else if(val>mn)\\n            s.push(val);\\n        else\\n        {\\n            s.push((long)2*val-mn);\\n            mn=val;\\n        }  \\n    }\\n    \\n    void pop() {\\n        if(s.top()<mn)\\n            mn=2*mn-s.top();\\n        \\n        s.pop();\\n    }\\n    \\n    int top() {\\n        if(s.top()>=mn)\\n        return s.top();\\n        \\n        return mn;\\n    }\\n    \\n    int getMin() {\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761680,
                "title": "most-optimised-one-by-using-encoding-technique",
                "content": "```\\nclass MinStack {\\npublic:\\n    stack<long>s;\\n    long currMin;\\n    MinStack() {\\n        currMin=LONG_MAX;\\n    }\\n    \\n    void push(int val) {\\n        int x=val;\\n        if(s.empty())\\n        {\\n            s.push(val);\\n            currMin=val;\\n            return ;\\n        }\\n        if(x<currMin)\\n        {\\n            s.push((long)2*val-currMin);\\n            currMin=val;\\n        }\\n        else\\n        {\\n            s.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.top()<currMin)\\n        {\\n            currMin=(long)2*currMin-s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(s.top()<currMin)\\n            return currMin;\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return currMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<long>s;\\n    long currMin;\\n    MinStack() {\\n        currMin=LONG_MAX;\\n    }\\n    \\n    void push(int val) {\\n        int x=val;\\n        if(s.empty())\\n        {\\n            s.push(val);\\n            currMin=val;\\n            return ;\\n        }\\n        if(x<currMin)\\n        {\\n            s.push((long)2*val-currMin);\\n            currMin=val;\\n        }\\n        else\\n        {\\n            s.push(val);\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.top()<currMin)\\n        {\\n            currMin=(long)2*currMin-s.top();\\n            s.pop();\\n        }\\n        else\\n        {\\n            s.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(s.top()<currMin)\\n            return currMin;\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        return currMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676085,
                "title": "java-solution",
                "content": "Implement stack using linked list.\\nMaintain a *min* variable in Node of linked list.\\n\\t\\n\\tclass MinStack {\\n    Node top;\\n\\n\\t\\tpublic MinStack() {\\n\\t\\t\\tthis.top = new Node(0,Integer.MAX_VALUE,null);\\n\\t\\t}\\n\\n\\t\\tpublic void push(int val) {\\n\\t\\t\\tNode n ;\\n\\t\\t\\tif(top.min > val) {\\n\\t\\t\\t\\tn = new Node(val, val, top);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tn = new Node(val, top.min, top);\\n\\t\\t\\t}\\n\\t\\t\\ttop = n;\\n\\t\\t}\\n\\n\\t\\tpublic void pop() {\\n\\t\\t\\ttop = top.prev;\\n\\t\\t}\\n\\n\\t\\tpublic int top() {\\n\\t\\t\\treturn top.val;\\n\\t\\t}\\n\\n\\t\\tpublic int getMin() {\\n\\t\\t\\treturn top.min;\\n\\t\\t}\\n\\t}\\n\\tclass Node {\\n\\t\\tint val;\\n\\t\\tint min;\\n\\t\\tNode prev;\\n    \\n\\t\\tNode(int val, int min, Node prev) {\\n\\t\\t\\tthis.min = min;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.prev = prev;\\n\\t\\t}\\n    \\n\\t}\\n\\n",
                "solutionTags": [],
                "code": "Implement stack using linked list.\\nMaintain a *min* variable in Node of linked list.\\n\\t\\n\\tclass MinStack {\\n    Node top;\\n\\n\\t\\tpublic MinStack() {\\n\\t\\t\\tthis.top = new Node(0,Integer.MAX_VALUE,null);\\n\\t\\t}\\n\\n\\t\\tpublic void push(int val) {\\n\\t\\t\\tNode n ;\\n\\t\\t\\tif(top.min > val) {\\n\\t\\t\\t\\tn = new Node(val, val, top);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tn = new Node(val, top.min, top);\\n\\t\\t\\t}\\n\\t\\t\\ttop = n;\\n\\t\\t}\\n\\n\\t\\tpublic void pop() {\\n\\t\\t\\ttop = top.prev;\\n\\t\\t}\\n\\n\\t\\tpublic int top() {\\n\\t\\t\\treturn top.val;\\n\\t\\t}\\n\\n\\t\\tpublic int getMin() {\\n\\t\\t\\treturn top.min;\\n\\t\\t}\\n\\t}\\n\\tclass Node {\\n\\t\\tint val;\\n\\t\\tint min;\\n\\t\\tNode prev;\\n    \\n\\t\\tNode(int val, int min, Node prev) {\\n\\t\\t\\tthis.min = min;\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.prev = prev;\\n\\t\\t}\\n    \\n\\t}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1586639,
                "title": "java-easy-solution-stack-and-priority-queue",
                "content": "**Code**\\n\\n```java\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        pq.add(val);\\n    }\\n    \\n    public void pop() {\\n        pq.remove(stack.pop());\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return pq.peek();\\n    }\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    \\n    public void push(int val) {\\n        stack.push(val);\\n        pq.add(val);\\n    }\\n    \\n    public void pop() {\\n        pq.remove(stack.pop());\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return pq.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553033,
                "title": "c-min-stack",
                "content": "https://leetcode.com/problems/min-stack\\n**With using extra stack**\\n```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> ss;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        s.push(val);\\n        if(ss.size()==0||ss.top()>=val)\\n            ss.push(val);\\n    }\\n    \\n    void pop() {\\n        int x=s.top();\\n        s.pop();\\n        if(x==ss.top())\\n            ss.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(ss.size()==0) return -1;\\n         return ss.top();\\n    }\\n};\\n```\\n**Without using extra stack**\\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int> > s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        int minEle=INT_MAX;\\n        if(s.size()==0)\\n        {\\n            minEle=val;\\n        }\\n        else\\n        {\\n            minEle=min(val,s.top().second);\\n        }\\n        s.push({val,minEle});\\n    }\\n    \\n    void pop() {\\n       s.pop(); \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n ```",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\npublic:\\n    stack<int> s;\\n    stack<int> ss;\\n    \\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        s.push(val);\\n        if(ss.size()==0||ss.top()>=val)\\n            ss.push(val);\\n    }\\n    \\n    void pop() {\\n        int x=s.top();\\n        s.pop();\\n        if(x==ss.top())\\n            ss.pop();\\n    }\\n    \\n    int top() {\\n        return s.top();\\n    }\\n    \\n    int getMin() {\\n        if(ss.size()==0) return -1;\\n         return ss.top();\\n    }\\n};\\n```\n```\\nclass MinStack {\\npublic:\\n    stack<pair<int,int> > s;\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        int minEle=INT_MAX;\\n        if(s.size()==0)\\n        {\\n            minEle=val;\\n        }\\n        else\\n        {\\n            minEle=min(val,s.top().second);\\n        }\\n        s.push({val,minEle});\\n    }\\n    \\n    void pop() {\\n       s.pop(); \\n    }\\n    \\n    int top() {\\n        return s.top().first;\\n    }\\n    \\n    int getMin() {\\n        return s.top().second;\\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1540191,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/min-stack/) solution\\n```\\ntype StackNode struct {\\n\\tval  int\\n\\tmin  int\\n\\tnext *StackNode\\n}\\n\\nfunc NewStackNode(val, min int, next *StackNode) *StackNode {\\n\\treturn &StackNode{\\n\\t\\tval:  val,\\n\\t\\tmin:  min,\\n\\t\\tnext: next,\\n\\t}\\n}\\n\\ntype MinStack struct {\\n\\thead *StackNode\\n}\\n\\nfunc Constructor() MinStack {\\n\\treturn MinStack{head: nil}\\n}\\n\\nfunc (this *MinStack) Push(val int) {\\n\\tif this.head == nil {\\n\\t\\tthis.head = NewStackNode(val, val, nil)\\n\\t} else {\\n\\t\\tmin := val\\n\\t\\tif this.head.min < min {\\n\\t\\t\\tmin = this.head.min\\n\\t\\t}\\n\\t\\tthis.head = NewStackNode(val, min, this.head)\\n\\t}\\n}\\n\\nfunc (this *MinStack) Pop() {\\n\\tthis.head = this.head.next\\n}\\n\\nfunc (this *MinStack) Top() int {\\n\\treturn this.head.val\\n}\\n\\nfunc (this *MinStack) GetMin() int {\\n\\treturn this.head.min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype StackNode struct {\\n\\tval  int\\n\\tmin  int\\n\\tnext *StackNode\\n}\\n\\nfunc NewStackNode(val, min int, next *StackNode) *StackNode {\\n\\treturn &StackNode{\\n\\t\\tval:  val,\\n\\t\\tmin:  min,\\n\\t\\tnext: next,\\n\\t}\\n}\\n\\ntype MinStack struct {\\n\\thead *StackNode\\n}\\n\\nfunc Constructor() MinStack {\\n\\treturn MinStack{head: nil}\\n}\\n\\nfunc (this *MinStack) Push(val int) {\\n\\tif this.head == nil {\\n\\t\\tthis.head = NewStackNode(val, val, nil)\\n\\t} else {\\n\\t\\tmin := val\\n\\t\\tif this.head.min < min {\\n\\t\\t\\tmin = this.head.min\\n\\t\\t}\\n\\t\\tthis.head = NewStackNode(val, min, this.head)\\n\\t}\\n}\\n\\nfunc (this *MinStack) Pop() {\\n\\tthis.head = this.head.next\\n}\\n\\nfunc (this *MinStack) Top() int {\\n\\treturn this.head.val\\n}\\n\\nfunc (this *MinStack) GetMin() int {\\n\\treturn this.head.min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539179,
                "title": "beats-95-arraylist-with-clear-explanation",
                "content": "```\\nclass MinStack {\\n    private List<Integer> stack = new ArrayList();    //for pushing into stack\\n    private List<Integer> stackWithMins = new ArrayList(); //to reduce the time complexity of finding min element\\n    \\n    public MinStack() {}\\n    \\n    public void push(int val) {        \\n        if (stackWithMins.isEmpty()) {\\n            stackWithMins.add(val); //pushing if the min-stack is empty\\n        } else if (val <= stackWithMins.get(stackWithMins.size()-1)) { //if the min-stack is empty we compare it with the top element in the min-stack because the top element is less than all the previous elements due to the same condition\\n            stackWithMins.add(val); \\n        }\\n        \\n        stack.add(val); // normal pushing into stack\\n    }\\n    \\n    public void pop() {\\n        int poppedValue = stack.remove(stack.size()-1); // removing the top element from stack\\n        int minValue = stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n        \\n        if (poppedValue == minValue) {\\n            stackWithMins.remove(stackWithMins.size()-1); //if the top element from min-stack is equal to the min element, then we need to pop it\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.get(stack.size()-1); //getting the top element\\n    }\\n    \\n    public int getMin() {\\n        return stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n    }\\n}\\n```\\n\\nThank you \\u2665 Upvoting helps a lot \\uD83D\\uDC51\\nIf you have any doubts, please let me know \\uD83D\\uDC47",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass MinStack {\\n    private List<Integer> stack = new ArrayList();    //for pushing into stack\\n    private List<Integer> stackWithMins = new ArrayList(); //to reduce the time complexity of finding min element\\n    \\n    public MinStack() {}\\n    \\n    public void push(int val) {        \\n        if (stackWithMins.isEmpty()) {\\n            stackWithMins.add(val); //pushing if the min-stack is empty\\n        } else if (val <= stackWithMins.get(stackWithMins.size()-1)) { //if the min-stack is empty we compare it with the top element in the min-stack because the top element is less than all the previous elements due to the same condition\\n            stackWithMins.add(val); \\n        }\\n        \\n        stack.add(val); // normal pushing into stack\\n    }\\n    \\n    public void pop() {\\n        int poppedValue = stack.remove(stack.size()-1); // removing the top element from stack\\n        int minValue = stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n        \\n        if (poppedValue == minValue) {\\n            stackWithMins.remove(stackWithMins.size()-1); //if the top element from min-stack is equal to the min element, then we need to pop it\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.get(stack.size()-1); //getting the top element\\n    }\\n    \\n    public int getMin() {\\n        return stackWithMins.get(stackWithMins.size()-1); // getting the top element from min-stack\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534170,
                "title": "python3-stack",
                "content": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append((val,val))  # storing tuple of current value , min of curr and prev value of stack\\n        else:\\n            self.stack.append((val, min(val,self.stack[-1][1]))) # min of prev value & curr\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        if self.stack:\\n            return self.stack[-1][0]   # curr value at 1st index of tuple\\n        else:\\n            return None\\n\\n\\n    def getMin(self) -> int:\\n        if not self.stack:\\n            return None\\n        return self.stack[-1][1]   # min value at 2nd index of tuple\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass MinStack:\\n\\n    def __init__(self):\\n        self.stack = []\\n\\n    def push(self, val: int) -> None:\\n        if not self.stack:\\n            self.stack.append((val,val))  # storing tuple of current value , min of curr and prev value of stack\\n        else:\\n            self.stack.append((val, min(val,self.stack[-1][1]))) # min of prev value & curr\\n\\n    def pop(self) -> None:\\n        if self.stack:\\n            self.stack.pop()\\n\\n    def top(self) -> int:\\n        if self.stack:\\n            return self.stack[-1][0]   # curr value at 1st index of tuple\\n        else:\\n            return None\\n\\n\\n    def getMin(self) -> int:\\n        if not self.stack:\\n            return None\\n        return self.stack[-1][1]   # min value at 2nd index of tuple\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1523228,
                "title": "easy-java-solution",
                "content": "```\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public void push(int val) {\\n        if(val <= min){\\n            stack.push(min);\\n            min = val;\\n        }\\n        stack.push(val);  \\n    }\\n    public void pop() {\\n        if(stack.pop() == min)  min = stack.pop();\\n    }\\n    public int top() {    \\n        return stack.peek();    \\n    }\\n    public int getMin() {   \\n        return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public void push(int val) {\\n        if(val <= min){\\n            stack.push(min);\\n            min = val;\\n        }\\n        stack.push(val);  \\n    }\\n    public void pop() {\\n        if(stack.pop() == min)  min = stack.pop();\\n    }\\n    public int top() {    \\n        return stack.peek();    \\n    }\\n    public int getMin() {   \\n        return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439818,
                "title": "c-using-single-stack",
                "content": "**Please Upvote if you like!**\\n\\n    class MinStack {\\n    public:\\n    stack<long> st;\\n    long min;\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) \\n    {\\n        if(st.empty())\\n        {\\n            st.push(val);\\n            min=val;\\n        }\\n        else if(val<=min)\\n        {\\n            st.push(2ll*val-min);\\n            min=val;\\n        }\\n        else\\n        {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() \\n    {\\n         if(st.empty()) \\n             return;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            min=2ll*min-t;\\n        }\\n        st.pop();\\n    }\\n    \\n    int top() \\n    {\\n        \\n        if(st.empty())\\n            return -1;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            return min;\\n        }\\n        else \\n            return t;\\n    }\\n    \\n    int getMin() \\n    {\\n        if(st.empty())\\n            return -1;\\n        else\\n        return min;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "**Please Upvote if you like!**\\n\\n    class MinStack {\\n    public:\\n    stack<long> st;\\n    long min;\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) \\n    {\\n        if(st.empty())\\n        {\\n            st.push(val);\\n            min=val;\\n        }\\n        else if(val<=min)\\n        {\\n            st.push(2ll*val-min);\\n            min=val;\\n        }\\n        else\\n        {\\n            st.push(val);\\n        }\\n    }\\n    \\n    void pop() \\n    {\\n         if(st.empty()) \\n             return;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            min=2ll*min-t;\\n        }\\n        st.pop();\\n    }\\n    \\n    int top() \\n    {\\n        \\n        if(st.empty())\\n            return -1;\\n        long t=st.top();\\n        if(t<min)\\n        {\\n            return min;\\n        }\\n        else \\n            return t;\\n    }\\n    \\n    int getMin() \\n    {\\n        if(st.empty())\\n            return -1;\\n        else\\n        return min;\\n    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1282755,
                "title": "java-using-2-stacks-beats-94",
                "content": "**Do vote up if you like it :)**\\n```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    Stack<Integer> minStack;\\n    Stack<Integer> stack;\\n    \\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int val) {\\n        if(minStack.isEmpty() || val <= minStack.peek())  {\\n            minStack.push(val);\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(!minStack.isEmpty() && stack.peek().equals(minStack.peek())) {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```\\n--------------------------------------------------------\\n",
                "solutionTags": [],
                "code": "```\\nclass MinStack {\\n\\n    /** initialize your data structure here. */\\n    Stack<Integer> minStack;\\n    Stack<Integer> stack;\\n    \\n    public MinStack() {\\n        stack = new Stack<Integer>();\\n        minStack = new Stack<Integer>();\\n    }\\n    \\n    public void push(int val) {\\n        if(minStack.isEmpty() || val <= minStack.peek())  {\\n            minStack.push(val);\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(!minStack.isEmpty() && stack.peek().equals(minStack.peek())) {\\n            minStack.pop();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139755,
                "title": "c-clear-code-without-using-stl",
                "content": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    struct Node {\\n        int data;\\n        int min;\\n        Node *next;\\n        Node(int x, int d): data(x), min(d), next(NULL) {}\\n    };\\n    \\n    struct Node* head;\\n    MinStack() { \\n        head=NULL;\\n    }\\n    \\n    void push(int val) {\\n        struct Node *new_node;\\n        if(head==NULL){\\n             new_node = new Node(val,val);\\n        }\\n        else{\\n             new_node = new Node(val,min(val,head->min));\\n             new_node->next=head;\\n        }\\n        head=new_node;\\n    }\\n    \\n    void pop() {\\n        head=head->next;\\n    }\\n    \\n    int top() {\\n        return head->data;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass MinStack {\\npublic:\\n    /** initialize your data structure here. */\\n    struct Node {\\n        int data;\\n        int min;\\n        Node *next;\\n        Node(int x, int d): data(x), min(d), next(NULL) {}\\n    };\\n    \\n    struct Node* head;\\n    MinStack() { \\n        head=NULL;\\n    }\\n    \\n    void push(int val) {\\n        struct Node *new_node;\\n        if(head==NULL){\\n             new_node = new Node(val,val);\\n        }\\n        else{\\n             new_node = new Node(val,min(val,head->min));\\n             new_node->next=head;\\n        }\\n        head=new_node;\\n    }\\n    \\n    void pop() {\\n        head=head->next;\\n    }\\n    \\n    int top() {\\n        return head->data;\\n    }\\n    \\n    int getMin() {\\n        return head->min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 996547,
                "title": "c-solution-using-single-container",
                "content": "A min stack is a generic stack that can give us the minimum value in constant time **(O(1) time complexity)** by being on top. The most effective implementation is to use 2 containers.\\n- Generic Container\\n- One with min value on the top\\n\\nThis can be further simplified by combining them into 1 by using a pair with one being a generic entity and other one being the minimum. The solution is implemented using this STL stack as a private member.\\n```\\nstack<int> st;\\n// Pair {generic element, minimum element}\\n```\\n\\n## For Push operation\\nIf the container is empty, then push the incoming element else push the minimum element.\\n```\\nvoid push(int x) {\\n\\tst.push({x, (not st.empty() ? min(x, st.top().second) : x)});\\n}\\n```\\n\\n### Futher explaination\\nBefore including the minimum element, **we must check if the stack is empty or not**. To compare the minimum value, **we must have a two values.** In case of an empty stack, there is **no top** and hence, have **nothing to compare.** As a result, you will encounter `nullptr` exception. To avoid the exception, we are adding the incoming element in the min stack too **if the stack is empty.** Leading to this condition for the second element of the pair.\\n```\\n(not st.empty() ? min(x, st.top().second) : x)\\n```\\n\\n## Pop operation\\nPopping is simple, just pop the element from the stack and done!\\n```\\nvoid pop() \\n{ \\n\\tst.pop(); \\n} \\n```\\n\\n## Top and Min access\\n```top()``` will return the top of the generic stack while ```min()``` will return the minimum value.\\n```\\nvoid top() { \\n\\treturn st.top().first; \\n}\\n\\nvoid getMin() {\\n\\treturn st.top().second;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstack<int> st;\\n// Pair {generic element, minimum element}\\n```\n```\\nvoid push(int x) {\\n\\tst.push({x, (not st.empty() ? min(x, st.top().second) : x)});\\n}\\n```\n```\\n(not st.empty() ? min(x, st.top().second) : x)\\n```\n```\\nvoid pop() \\n{ \\n\\tst.pop(); \\n} \\n```\n```top()```\n```min()```\n```\\nvoid top() { \\n\\treturn st.top().first; \\n}\\n\\nvoid getMin() {\\n\\treturn st.top().second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835720,
                "title": "min-stack-using-only-one-stack-in-o-1-extra-space",
                "content": "The key logic in this approach is:\\nwhenever an element say \"b\" which is greater than the minimum element say \"a\" comes it is simply inserted into the stack as it doeas not change the value of minimum element (since it is greater) but when a smaller element say \"c\" comes then we should update the minEle variable to this element (minEle = c) but we will not put this element into the stack instead push 2*c-minEle in the stack.This is done so that during the pop operation when this minimum element gets removed then we can set the minEle variable back to the original element \"a\" by doing this minEle = 2*minEle - s.top() \\n\\nclass MinStack {\\n    \\n    long long minEle;\\n    stack<long long>s;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()) {\\n            s.push(x);\\n            minEle = x;\\n        }\\n        else\\n        {\\n            if(x >= minEle)\\n                s.push(x);\\n            else{\\n                long long y=x;\\n                s.push(2*y-minEle);\\n                minEle = x;\\n            }\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        else\\n        {\\n            if(s.top() >= minEle)\\n                s.pop();\\n            else{\\n                minEle = 2*minEle - s.top();\\n                s.pop();\\n            }\\n                \\n        }\\n    }\\n    \\n    int top() {\\n        long long val = -1;\\n        if(s.empty()) return val;\\n        else\\n        {\\n            if(s.top() >= minEle){\\n                val = s.top();\\n            }\\n            else{\\n                val = minEle;\\n            }    \\n        }\\n        return val;\\n    }\\n    \\n    int getMin() {\\n        if(s.size() == 0) return -1;\\n        return minEle;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "The key logic in this approach is:\\nwhenever an element say \"b\" which is greater than the minimum element say \"a\" comes it is simply inserted into the stack as it doeas not change the value of minimum element (since it is greater) but when a smaller element say \"c\" comes then we should update the minEle variable to this element (minEle = c) but we will not put this element into the stack instead push 2*c-minEle in the stack.This is done so that during the pop operation when this minimum element gets removed then we can set the minEle variable back to the original element \"a\" by doing this minEle = 2*minEle - s.top() \\n\\nclass MinStack {\\n    \\n    long long minEle;\\n    stack<long long>s;\\n    \\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n    }\\n    \\n    void push(int x) {\\n        if(s.empty()) {\\n            s.push(x);\\n            minEle = x;\\n        }\\n        else\\n        {\\n            if(x >= minEle)\\n                s.push(x);\\n            else{\\n                long long y=x;\\n                s.push(2*y-minEle);\\n                minEle = x;\\n            }\\n        }\\n    }\\n    \\n    void pop() {\\n        if(s.empty()) return;\\n        else\\n        {\\n            if(s.top() >= minEle)\\n                s.pop();\\n            else{\\n                minEle = 2*minEle - s.top();\\n                s.pop();\\n            }\\n                \\n        }\\n    }\\n    \\n    int top() {\\n        long long val = -1;\\n        if(s.empty()) return val;\\n        else\\n        {\\n            if(s.top() >= minEle){\\n                val = s.top();\\n            }\\n            else{\\n                val = minEle;\\n            }    \\n        }\\n        return val;\\n    }\\n    \\n    int getMin() {\\n        if(s.size() == 0) return -1;\\n        return minEle;\\n    }\\n};",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569698,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1689860,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1724956,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1897302,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1857413,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1573559,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1843067,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1824562,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571868,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1567472,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1569698,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1689860,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1724956,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1897302,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1857413,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1573559,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1843067,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1824562,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571868,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1567472,
                "content": [
                    {
                        "username": "hyankov",
                        "content": "![image](https://assets.leetcode.com/users/hyankov/image_1575252836.png)\\n"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "[@stephonicus](/stephonicus) You learn how to modify your implementations of data structures for your additional requirements, which you\\'ll encounter a lot in real life scenarios while developing solutions to real world problems."
                    },
                    {
                        "username": "stephonicus",
                        "content": "Im pretty new to the community, Im glad Im not alone in my analysis of the problem. haha.  I am assuming that this is mainly for getting a fundamental understanding of a stack, but is there any additional learnings to be extracting from this problem? Something more I should focus on here?"
                    },
                    {
                        "username": "_grandmaster_",
                        "content": "you have my rofl"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Genius "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "genius use of the meme!\\nlol"
                    },
                    {
                        "username": "bikcrum",
                        "content": "I would have published a paper if it was possible to retrieve minimum element at O(1). As far as I know the least is log(n) using heap."
                    },
                    {
                        "username": "stridemann",
                        "content": "The trick is: each time we PUSH the value to min stack- our MinValue is not changing unless the value we pushing is less than it.\\n\\nKeeping all the sequence/history of this previous Min values do the job. Each time we PUSH - we save the previous MIN or the new MIN. And POP should remove the last element of MINs history."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@qnex](/qnex) yeah, but to do that you\\'ll need O(n) time, since after popping min you must find a new one, unless you maintain some sort of structure"
                    },
                    {
                        "username": "shashi675",
                        "content": "yes, go and publish it."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "You should use more space to save stes of your stack. It\\'s possible."
                    },
                    {
                        "username": "mrishah",
                        "content": "[@mlecozz](/mlecozz)  That is where one has to get creative. This was exactly my first thought :  yes, we can store minimum but what about changing value of min once that is 'popped off'. I had to look at the solution to understand but a great tip for others is : think of different ways to store minimum- draw out few example stacks on paper and trace - that might help others to have their W moment. "
                    },
                    {
                        "username": "mlecozz",
                        "content": "[@qnex](/qnex) But if min gets popped, how do you know how to reassign min?"
                    },
                    {
                        "username": "qnex",
                        "content": "bruh just keep a variable (say \"min\") and every time you push a number into the stack, the min variable updates depending upon the val is more or less than min"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "It\\'s possible actually (I too learned after seeing the solutions)."
                    },
                    {
                        "username": "psyfb2",
                        "content": "There is some similarities in that a MinStack and a Heap will both keep track of the current minimum. However, the major difference is that the MinStack can only remove the element at the top of the stack. Meanwhile the Heap removes only the minimum element. Therefore, they are fundamentally different data structures (i.e. you could not use a MinStack to implement a priority queue for example)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "We are implementing our own Data Structure here and are free to store whatever additional information we\\'d like. Ive actually never understood why modern datastructures dont implicitly store common metadata as a default, or at least an option. A \"smart stack\" could have information like its min, max, len stored and updated as it is used. Sure, its a few additional instructions compared to \"basic\" data structures, but these instructions are incredibly minor, and for many uses make a lot more sense to just store than scanning and creating that info live. Is this a feature in some languages? I literally dont know enough to know if this is a thing or not"
                    },
                    {
                        "username": "choprasrishti01",
                        "content": "but it becomes possible if you were always aware of the answer. meaning, always keep the min element in our hand and return it when asked. so you won\\'t have to do that extra o(n) or logn work that time. this is the concept behind the ques\\n"
                    },
                    {
                        "username": "lussierjames13",
                        "content": "Try associating each value in the stack with a minimum value"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "what if the minimum was popped of ?\\n"
                    },
                    {
                        "username": "squigg1e",
                        "content": "Thanks, needed the hint"
                    },
                    {
                        "username": "zardo",
                        "content": "Am I the only one who thinks the problem should be more clear? They don't say that we do not need to remove the minimun element from the stack, only \"retrieve it\". But how am I suposed to know what \"retrieving an element\" is? It doesn't help that they used \"gets\", \"retrieves\" and \"removes\" in the explanation for three situations. I spent a lot of time trying to figure out a way to remove the minimun element from the stack in constant time."
                    },
                    {
                        "username": "Mehran_786",
                        "content": "Bro I seriously even after finding the solution was not able to find out why to pop out, if we needed was min element in stack"
                    },
                    {
                        "username": "andreas_gnos",
                        "content": "same, struggled 20 minutes solving quite different problem"
                    },
                    {
                        "username": "Kreator1",
                        "content": "Notice that getMin does not remove it from stack."
                    },
                    {
                        "username": "grok1",
                        "content": "Hey, \\n\\nWhat should we return when we pop/get_min/top an empty stack ? I was thinking about \\'None\\'."
                    },
                    {
                        "username": "AshminJ",
                        "content": "It's stated in the constraints that top, pop and get_min will only be called on non-empty stacks."
                    },
                    {
                        "username": "billgewrgoulas",
                        "content": "Super happy i could this on my own, excellent problem!"
                    },
                    {
                        "username": "RabeetaN",
                        "content": "Input\\n[\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[2147483646],[2147483646],[2147483647],[],[],[],[],[],[],[2147483647],[],[],[-2147483648],[],[],[],[]]\\nOutput\\n[null,null,null,null,2147483647,null,-2147483648,null,-2147483648,null,null,2147483647,-2147483648,null,-2147483648,-2147483648,null,-2147483648]\\nExpected\\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\\n\\nwhy is this happening? the stack is containing an input value before it is even pushed into the stack and also still returning it after popping it out. I tried printing the values being input to console and they are being input in correct order. not sure what to do PLEASE HELP"
                    },
                    {
                        "username": "rayidahmed111",
                        "content": "hard code the value to be pushed if(val==-2147483648){\\n           s.push(-2147483648);} this work for me"
                    },
                    {
                        "username": "rajatsinghal01",
                        "content": "Hi I also encountered the same issue, these are extreme integers so you need to convert the datatype of min_element and Stack to Long, and return int value. Do change the type of integer argument to Long(2*(long)val-min_element) while adding it to the stack.\\nHope this will resolve your issue!"
                    },
                    {
                        "username": "pratapsimha01",
                        "content": "[@thisischintu](/thisischintu)  Guys read \\'Hints\\' once and you will get to know the approach"
                    },
                    {
                        "username": "LeetAniket",
                        "content": "did you find the issue ?"
                    },
                    {
                        "username": "G_tharun",
                        "content": "It is because of type conversion.\\nThe values here are the extreme Integers i.e. close to max and min values of Integer.\\nHence here, when multiplication or any operations if performed, it is going out of int and the remainder of that is storing in the values.\\nGo and have a look about type conversion, so that you get more clarity."
                    },
                    {
                        "username": "thisischintu",
                        "content": "Facing the same issue, did you find what was wrong?"
                    },
                    {
                        "username": "Rukeith",
                        "content": "I submit my solution but get this test fail. I think it is wrong. top should be 0 not -1.\n\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rukeith/image_1519952989.png)\n"
                    },
                    {
                        "username": "varunkumarss",
                        "content": "[@Rukeith](/Rukeith)your* top() is only failing, fix it...\nyour top should return the latest value pushed... i.t. -1 instead of 0.... hope you got it."
                    },
                    {
                        "username": "vbaryshev",
                        "content": "[@92ganesh](/92ganesh) Thanks. Top != biggest number. Top = last item in stack"
                    },
                    {
                        "username": "92ganesh",
                        "content": "-1 is correct. The top of the stack has -1 coz it was pushed at last"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-10/.\\n\\nThanks!"
                    },
                    {
                        "username": "tayyabferozi",
                        "content": "this website is no more...."
                    }
                ]
            },
            {
                "id": 1571349,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1937049,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1930311,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1569212,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1568986,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1574276,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1988530,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1977633,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1572087,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 1571348,
                "content": [
                    {
                        "username": "mayli",
                        "content": "I'v implemented this in Python at first but I got this strange error from the OJ (cannot reproduce locally):\\n\\n    Input:\\tpush(-1),top,getMin\\n    Output:\\t\\t[-1,-3]\\n    Expected:\\t[-1,-1]\\n\\nI believe this should be a problem of OJ because I rewrite the same algorithm in C++ and get Accepted."
                    },
                    {
                        "username": "Moofer",
                        "content": "Different test case, but same issue.   Mine works locally, works with debugger built in leetcode for same code.\\nFails on test run.\\n\\nSomething flakey going on with test runner."
                    },
                    {
                        "username": "Aarib-Abdullah",
                        "content": "Something similar happened to me as well, accept submitted python got wrong, then tested locally, then resubmit it which then it get accepted. I don\\'t know if I should be happy or worried."
                    },
                    {
                        "username": "Dominating_",
                        "content": "Stack:             |   MinStack:\\n ---------------------------------------\\n|   4    |           |   -9   |\\n|-------|            |-------|\\n|   0    |           |   -9   |\\n|-------|            |-------|\\n|   -9   |           |   -9   |\\n|-------|            |-------|\\n|   2    |           |   -5   |\\n|-------|            |-------|\\n|   -5   |           |   -5   |\\n|-------|            |-------|\\n|   10   |           |   -5   |\\n|-------|            |-------|\\n|   -2   |           |   -3   |\\n|-------|            |-------|\\n|   8    |           |   -3   |\\n|-------|            |-------|\\n|   -3   |           |   -3   |\\n|-------|            |-------|\\n|   5    |           |   5    |\\n|-------|            |-------|\\n\\nTry implementing using two stacks. One stack keeps track of elements in order, while the other stack keeps track of the minimum elements.\\n\\n LOOK DOWN TO UP ITS A STACK"
                    },
                    {
                        "username": "HsuChiChen",
                        "content": "create the auxiliary stack for recording the current minimum."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "Javascript pre-defined code states the following:\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = Object.create(MinStack).createNew()\\n */\\n\\nWhich is simply not true. No createNew() is called and no createNew() is required, accepted solution works without one. This needs to be fixed. I couldn\\'t find a button that would allow me to report a problem with question on pre-defined code, so I\\'m posting it here."
                    },
                    {
                        "username": "Samuri",
                        "content": "Input:\\tpush(-1),top,getMin\\n\\nOutput:\\t[-1,-3]\\nExpected:\\t[-1,-1]\\n\\nHow come my program outputs -3? I don't have any hard-coded stuff in my program. \\n\\nI use python.\\n\\nAny idea?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "ask to your program dude"
                    },
                    {
                        "username": "shyambravo",
                        "content": "The main purpose of the problem is to create a stack data structure without using any kind of containers or built in stack data structure."
                    },
                    {
                        "username": "hellboy11",
                        "content": "no it\\'s not"
                    },
                    {
                        "username": "MOVAPS",
                        "content": "With this problem, today I mark the day of solving 100 mediums!"
                    },
                    {
                        "username": "Orange_Smuggler",
                        "content": "I hate this task so much, it is unfathomably difficult for my brain to process the edge condition without dumping in additional variables to check for whether we are at the bottom of the stack."
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "you have to use a stack for the minimum values. I also hate this problem because I think it is stupid to make us implement a stack, but allow use of the STL stack."
                    },
                    {
                        "username": "amqbxr",
                        "content": "Please add Swift support for this coding challenge\\n\\nThank you!"
                    },
                    {
                        "username": "FrogMayday",
                        "content": "We are asked to design a stack, but the two top solutions build the stack based on the Stack object of JAVA. Is it okay to do that ? Can we build the stack based on other stacks?"
                    },
                    {
                        "username": "92ganesh",
                        "content": "yeah its fine. the main ques is not abt to build stack from stack but to have getMin() feature. Even in the interview this is fine but you should discuss this with the interviewer beforehand"
                    }
                ]
            },
            {
                "id": 2076569,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2075251,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2072330,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2071190,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2062141,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2058300,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2055870,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2055042,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2048080,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2046798,
                "content": [
                    {
                        "username": "roshanjha_23",
                        "content": "Time Limit Exceeded\\n31 / 31 testcases passed\\nTestcases passed, but took too long."
                    },
                    {
                        "username": "Moofer",
                        "content": "The test runner seemed bugged.\\nTestcase 5.\\nFails testcase, with a value that makes no sense -2.\\n\\nMy code works locally.\\nWorks with the debugger on this website outputs the correct result for the SAME CODE, and passes.\\n\\nI can\\'t for the life of me figure out how its getting that value.\\n\\nThoughts?"
                    },
                    {
                        "username": "umangb",
                        "content": "Can anyone show me error in my code for some type casting issue??\\n\\nclass MinStack {\\n    private:\\n        stack<long long> stk;\\n        long long min_ele = INT_MAX;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(stk.empty()) {\\n            min_ele = val;\\n            stk.push(val);\\n        } else if(val <= min_ele) {\\n            stk.push(min_ele);\\n            stk.push(val);\\n            min_ele = val;\\n        } else\\n            stk.push(val);\\n    }\\n    \\n    void pop() {\\n        long long v = stk.top();\\n        if(v == min_ele) {\\n            stk.pop();\\n            min_ele = stk.top();\\n            stk.pop();\\n        }\\n        else\\n            stk.pop();\\n    }\\n    \\n    int top() {\\n        return stk.top();\\n    }\\n    \\n    int getMin() {\\n        return min_ele;\\n    }\\n};\\n\\n\\nERROR : \\nLine 176: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0b6 for type \\'long long\\', which requires 8 byte alignment (stl_deque.h)\\n0xbebebebebebec0b6: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_deque.h:181:16"
                    },
                    {
                        "username": "innovatism",
                        "content": "There\\'s no type casting anywhere in your code. The most suspicious part is in the pop() method, where you pop an element from the stack but don\\'t ensure that the stack is not empty before calling stk.top() or stk.pop()."
                    },
                    {
                        "username": "innovatism",
                        "content": "The problem could be solved with O(1) using 2 stacks, one for the value itself, one for the minimum at each value."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "I was shocked after reading the question that how we can return min everytime in o(1) , the only solution coming to my mind is of O(logn). but then i entered discussion section and read on [@Mridul](/mrishah) reply on [@bikcrum](/bikcrum) comment that try to draw a few stacks on your own and you will get the solution. So i took a moment and started drawing the stacks. and seriously after very first stack draw i got the idea and it worked. \\nThanks for the help !! [@Mridul](/mrishah).\\nI Also recommend everyone to look to the discussion section before directly seeing the solution. And also after writing the solution you must visit discussion section once."
                    },
                    {
                        "username": "isanket",
                        "content": "We can do this easily by having two stack one to insert element and other to keep track of min value. \\nEvery time we insert, we will check if the min stack peek has element greater or smaller than the inserting element . Adding code below for ref : \\n\\n`public void push(int val) {\\n        if (stack.empty()) {\\n            stack.push(val);\\n            min.push(val);\\n        } else {\\n            Integer peek = min.peek();\\n            if (peek.compareTo(val) < 0)\\n                min.push(peek);\\n            else\\n                min.push(val);\\n            stack.push(val);\\n        }\\n    }`"
                    },
                    {
                        "username": "Manish_katha",
                        "content": "may be below solution is going to be easiest solution. Don,t know why no one tries this approach. \\n#include<stack>\\n#include<limits.h>\\nclass MinStack {\\npublic:\\n     stack<int> s;\\n     int mini=INT_MAX;   \\n      MinStack() { }\\n    \\n    void push(int data) {\\n          s.push(data);\\n        mini=min(data,mini);\\n        s.push(mini);\\n    }\\n    \\n    void pop() {\\n         if(s.empty()){}\\n          else{\\n            s.pop();\\n            s.pop();\\n            if(s.empty()){\\n                mini=INT_MAX;\\n            }\\n            else\\n            mini=s.top();\\n        }\\n    }\\n    \\n    int top() {\\n         if(s.empty()){\\n            return -1;\\n        }\\n\\n        int n=s.top();\\n        s.pop();\\n        int a=s.top();\\n        s.push(n);\\n        return a;\\n    }\\n    \\n    int getMin() {\\n        return s.top();\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user8506H",
                        "content": "Only Pop() is supposed to delete the value from the Stack.\\nI hope this saves you 1 hour of running in circles."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Using a **min-heap** is perfectly fine, but that will cost you an `O(log(n))` **worst time complexity** caused by bubbling down (also known as heapify down) when removing the root of the heap. Instead, look at the examples below, which only focus on adding values to the stack and the current minimum to obtain a constant time complexity. The first line of each sample represents the stack, where the left-most value is the first value pushed, and the right-most is the last. The second line is the minimum after adding the current value.\\n\\n**Example 1:**\\n```\\n-2  0 -3 \\n-2 -2 -3\\n```\\n\\n**Example 2:**\\n```\\n1 2 3 4 5 6 0 7 8 9\\n1 1 1 1 1 1 0 0 0 0\\n```"
                    },
                    {
                        "username": "Akhilesh_042",
                        "content": "i use stack<pair<int,int>> \\nbut TC was low \\nhow to improve ??"
                    },
                    {
                        "username": "omeirr13",
                        "content": "try to submit the same solution again...\\nleetcode TC analysis is not reliable"
                    }
                ]
            },
            {
                "id": 2020351,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 2001192,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1999327,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1983397,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1956713,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1949447,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1937225,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1931732,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1927958,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1925810,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "Methods pop, top and getMin operations will always be called on non-empty stacks. they mentiones this one and I\\'m getting\\njava.util.EmptyStackException\\n  at line 101, java.base/java.util.Stack.peek\\n  at line 17, MinStack.top\\n  at line 70, __Driver__.__helperSelectMethod__\\n  at line 90, __Driver__.__helper__\\n  at line 111, __Driver__.main"
                    },
                    {
                        "username": "Ayush_Kumar_Chaudhary",
                        "content": "the idea behind this problem is simply u make an stack using vector where you put pairs in vector .    in pair you insert element and  minimum element    \nsimply update minimum element when you find element lesser than previous element \n\nhence in last the minimum element in top of stack in pair \n\n\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "thats O(n) time for updating the min for each pair"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "can anybody explain me what is work of minstack?"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "Don't know where I am wrong, while getting getMin() ? test cases passed 29/32.\n input : [\"MinStack\",\"push\",\"push\",\"push\",\"top\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"push\",\"top\",\"getMin\",\"push\",\"top\",\"getMin\",\"pop\",\"getMin\"]\n[[ ],[2147483646],[2147483646],[2147483647],[ ],[ ],[ ],[ ],[ ],[ ],[2147483647],[],[],[-2147483648],[ ],[ ],[ ],[ ]]\n\noutput: \n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483646,null,-2147483648,-2147483648,null,2147483646]\n\nexpected:\n[null,null,null,null,2147483647,null,2147483646,null,2147483646,null,null,2147483647,2147483647,null,-2147483648,-2147483648,null,2147483647]\n\nand on console I printed  my Array List while getMin() it is like :\n[2147483646, 2147483646]\n[2147483646]\n[2147483646, 2147483647] <- here \n[2147483646, 2147483647, -2147483648]\n[2147483646, 2147483647] <- here"
                    },
                    {
                        "username": "PeterTYLiu",
                        "content": "You\\'re probably forgetting to reset min if/when the array\\'s size reaches 0"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "I felt i coulld not do, but went to discussion, they did the trick.Thanks.\\n"
                    },
                    {
                        "username": "KOLDORNEY",
                        "content": "This question should be changed to easy. Nobody is actually implementing a stack they are just using the STL."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++ Solution, Brute force + Optimal......\\n\\nApproach\\n### Brute Force:\\nInitialize a stack of pairs called st to store elements and their corresponding minimum values.\\nCreate a constructor for the MinStack class (not shown in the code).\\nImplement the push function:\\nIf the stack is empty, push the pair {val, val} onto the stack and return.\\nOtherwise, compare the current minimum value (st.top().second) with the new value val.\\nIf the current minimum value is less than val, push the pair {val, st.top().second} onto the stack.\\nOtherwise, push the pair {val, val} onto the stack.\\nImplement the pop function:\\nRemove the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nOtherwise, return the first value (st.top().first) of the top pair in the stack.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nOtherwise, return the second value (st.top().second) of the top pair in the stack.\\nOptimal:\\nInitialize a stack of type long long called st to store elements.\\nInitialize a variable mini of type long long to store the current minimum value.\\nCreate a constructor for the MinStack class (not shown in the code).\\nIn the constructor, set mini to the maximum value of INT_MAX.\\nImplement the push function:\\nIf the stack is empty:\\nPush the value val onto the stack.\\nSet mini to val.\\nReturn.\\nOtherwise, compare the value val with the current minimum value mini.\\nIf val is greater than mini, push val onto the stack.\\nOtherwise:\\nCalculate the value temp as 2 * val - mini using long long arithmetic.\\nPush temp onto the stack.\\nSet mini to val.\\nImplement the pop function:\\nIf the stack is empty, return.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, simply pop it from the stack.\\nOtherwise:\\nCalculate the new minimum value as 2 * mini - st.top().\\nSet mini to the new minimum value.\\nPop the top element from the stack.\\nImplement the top function:\\nIf the stack is empty, return -1.\\nCompare the top element of the stack (st.top()) with the current minimum value mini.\\nIf the top element is greater than mini, return the top element.\\nOtherwise, return mini.\\nImplement the getMin function:\\nIf the stack is empty, return -1.\\nReturn the current minimum value mini.\\nComplexity\\nTime complexity:\\nBrute Force: T.C=O(1)\\nOptimal: T.C=O(1)\\n\\nSpace complexity:\\nBrute Force: S.C=O(2N) storing the pair <value,minValue>.\\nOptimal: S.C=O(N)\\n\\n------------------------\\nPlease Upvote. If Understand the concept.....\\nSolution Link:\\nhttps://leetcode.com/problems/min-stack/solutions/3661704/c-solution-brute-force-optimal-push-2-val-mini-pop-2-mini-st-top/"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "i got O(1) par right but the testcases are a little confusing"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "It should be moved to easy"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Why is this problem rated medium? Should not this be tagged as easy?"
                    }
                ]
            },
            {
                "id": 1925323,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1916547,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1915819,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1906328,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1898115,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1872087,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1867921,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1867870,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1863581,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            },
            {
                "id": 1859141,
                "content": [
                    {
                        "username": "Socrii13",
                        "content": "To solve this problem there are three approach\\n1] using 2 stack \\n2] using a vector pair { one will store the value and other will store the minimum element }\\n3] using stack and maths of holding previous value check out at aditya verma playlist or striver\\nHope might help!!"
                    },
                    {
                        "username": "hahahehetester",
                        "content": "Why are so many people using std::stack?... Isn\\'t the whole purpose of the problem to make your own??"
                    },
                    {
                        "username": "leet_example",
                        "content": "When using Python 3, tests will pass if `.top()` and `.getMin()` returns None even though the typing say that it should be only `int` that is returned. I changed it to `int | None`."
                    },
                    {
                        "username": "mangoseeds",
                        "content": "getMin DOES NOT NEED TO REMOVE THE ELEMENT!! this comment helped me so much so here it is"
                    },
                    {
                        "username": "rishabhbhatt009",
                        "content": "The question still accepts solutions with O(n) for `getMin( )`. I used a simple `min(stack)` in Python which should have O(n) complexity and the solution was still accepted. "
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "MY CODE IS NOT WORKING FOR THE OUTPUT:\\n[\"MinStack\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"getMin\",\"pop\",\"getMin\",\"pop\",\"getMin\"]\\n[[],[512],[-1024],[-1024],[512],[],[],[],[],[],[]]\\n\\nclass MinStack {\\n    Stack<Integer> stack = new Stack<>();\\n    Stack<Integer> stack_min = new Stack<>();\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {}\\n    \\n    public void push(int val) {\\n        if(val<=min){\\n            stack_min.push(val);\\n            min=val;\\n        }\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        if(stack.peek()==stack_min.peek()){\\n            stack_min.pop();\\n            min=stack_min.peek();\\n        }\\n        stack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return min;\\n    }\\n}\\n"
                    },
                    {
                        "username": "kos2kos",
                        "content": "class MinStack {\\n    Stack<MinStack> stack = new Stack<>();\\n    int top = 0;\\n    int min = Integer.MAX_VALUE;\\n    public MinStack() {\\n    }\\n    \\n    public void push(int val) {\\n        \\n        if (stack.isEmpty()){\\n            MinStack cur = new MinStack();\\n            top = val;\\n            min = min;\\n            cur.min = val;\\n            cur.top = val;\\n            stack.push(cur);\\n        } else{\\n            MinStack prev = stack.peek();\\n            int pMin = prev.min;\\n            int pTop = prev.top;\\n            MinStack next = new MinStack();\\n            next.min = Math.min(pMin, val);\\n            next.top = val;\\n            stack.push(next);\\n        }\\n        System.out.println(this.toString());\\n        System.out.println(stack.peek().toString());\\n\\n    }\\n    \\n    public void pop() {\\n        if (stack.size() > 0){\\n            MinStack peek = stack.pop();\\n            min = stack.peek().getMin();\\n        }\\n    }\\n    \\n    public int top() {\\n        return stack.peek().top;\\n    }\\n    \\n    public int getMin() {\\n        return stack.peek().min;\\n    }\\n\\n    public String toString(){\\n        StringBuilder str = new StringBuilder();\\n        if (stack.isEmpty()){\\n            System.out.println(this.min);\\n            System.out.println(this.top);\\n            return \"\";\\n        }\\n\\n        for (MinStack s : stack){\\n            str.append(\" [\")\\n                .append(\"min: \")\\n                .append(s.min)\\n                .append(\", \")\\n                .append(\"top: \")\\n                .append(s.top)\\n                .append(\"],\");\\n        }\\n        str.deleteCharAt(str.length() - 1);\\n        return str.toString();\\n    }\\n}\\n\\ncan someone please explain whats wrong with my code and why i am getting a null pointer when I call getMin? it should have 3 values in the stack."
                    },
                    {
                        "username": "alphazwest",
                        "content": "It\\'s debatable that this is labeled as medium vs. easy. I have seen many \"easy\" problems on here that felt more difficult than this one."
                    },
                    {
                        "username": "poju3185",
                        "content": "I didn\\'t use the O(1) solution, but still passed. Interesting..."
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Great Design and monotonic stack question !!! "
                    }
                ]
            }
        ]
    },
    {
        "title": "Verify Preorder Sequence in Binary Search Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1572289,
                "content": [
                    {
                        "username": "LijieTu",
                        "content": "It seems [5,2,1,10,6] can also pass the test, but this is not a binary search tree. Do we assume the underlying is always a BST?\\n\\n"
                    },
                    {
                        "username": "sam5727",
                        "content": "I was confused in the beginning. Since it could generate different trees from preorder, if there is at least one BST, it should return true.\n```\n     5\n    / \\\n   2  10\n  /   /\n 1   6 \n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Twitter",
        "question_content": "<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the <code>10</code> most recent tweets in the user&#39;s news feed.</p>\n\n<p>Implement the <code>Twitter</code> class:</p>\n\n<ul>\n\t<li><code>Twitter()</code> Initializes your twitter object.</li>\n\t<li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user <code>userId</code>. Each call to this function will be made with a unique <code>tweetId</code>.</li>\n\t<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the <code>10</code> most recent tweet IDs in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be <strong>ordered from most recent to least recent</strong>.</li>\n\t<li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li>\n\t<li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n<strong>Output</strong>\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n<strong>Explanation</strong>\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>\n\t<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>\n\t<li>All the tweets have <strong>unique</strong> IDs.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>postTweet</code>, <code>getNewsFeed</code>, <code>follow</code>, and <code>unfollow</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 82825,
                "title": "java-oo-design-with-most-efficient-function-getnewsfeed",
                "content": "```java\\npublic class Twitter {\\n\\tprivate static int timeStamp=0;\\n\\n\\t// easy to find if user exist\\n\\tprivate Map<Integer, User> userMap;\\n\\n\\t// Tweet link to next Tweet so that we can save a lot of time\\n\\t// when we execute getNewsFeed(userId)\\n\\tprivate class Tweet{\\n\\t\\tpublic int id;\\n\\t\\tpublic int time;\\n\\t\\tpublic Tweet next;\\n\\n\\t\\tpublic Tweet(int id){\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\ttime = timeStamp++;\\n\\t\\t\\tnext=null;\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// OO design so User can follow, unfollow and post itself\\n\\tpublic class User{\\n\\t\\tpublic int id;\\n\\t\\tpublic Set<Integer> followed;\\n\\t\\tpublic Tweet tweet_head;\\n\\n\\t\\tpublic User(int id){\\n\\t\\t\\tthis.id=id;\\n\\t\\t\\tfollowed = new HashSet<>();\\n\\t\\t\\tfollow(id); // first follow itself\\n\\t\\t\\ttweet_head = null;\\n\\t\\t}\\n\\n\\t\\tpublic void follow(int id){\\n\\t\\t\\tfollowed.add(id);\\n\\t\\t}\\n\\n\\t\\tpublic void unfollow(int id){\\n\\t\\t\\tfollowed.remove(id);\\n\\t\\t}\\n\\n\\n\\t\\t// everytime user post a new tweet, add it to the head of tweet list.\\n\\t\\tpublic void post(int id){\\n\\t\\t\\tTweet t = new Tweet(id);\\n\\t\\t\\tt.next=tweet_head;\\n\\t\\t\\ttweet_head=t;\\n\\t\\t}\\n\\t}\\n\\n\\n\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic Twitter() {\\n\\t\\tuserMap = new HashMap<Integer, User>();\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tpublic void postTweet(int userId, int tweetId) {\\n\\t\\tif(!userMap.containsKey(userId)){\\n\\t\\t\\tUser u = new User(userId);\\n\\t\\t\\tuserMap.put(userId, u);\\n\\t\\t}\\n\\t\\tuserMap.get(userId).post(tweetId);\\n\\n\\t}\\n\\n\\n\\n\\t// Best part of this.\\n\\t// first get all tweets lists from one user including itself and all people it followed.\\n\\t// Second add all heads into a max heap. Every time we poll a tweet with \\n\\t// largest time stamp from the heap, then we add its next tweet into the heap.\\n\\t// So after adding all heads we only need to add 9 tweets at most into this \\n\\t// heap before we get the 10 most recent tweet.\\n\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\t\\tList<Integer> res = new LinkedList<>();\\n\\n\\t\\tif(!userMap.containsKey(userId))   return res;\\n\\n\\t\\tSet<Integer> users = userMap.get(userId).followed;\\n\\t\\tPriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));\\n\\t\\tfor(int user: users){\\n\\t\\t\\tTweet t = userMap.get(user).tweet_head;\\n\\t\\t\\t// very imporant! If we add null to the head we are screwed.\\n\\t\\t\\tif(t!=null){\\n\\t\\t\\t\\tq.add(t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint n=0;\\n\\t\\twhile(!q.isEmpty() && n<10){\\n\\t\\t  Tweet t = q.poll();\\n\\t\\t  res.add(t.id);\\n\\t\\t  n++;\\n\\t\\t  if(t.next!=null)\\n\\t\\t\\tq.add(t.next);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\t/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n\\tpublic void follow(int followerId, int followeeId) {\\n\\t\\tif(!userMap.containsKey(followerId)){\\n\\t\\t\\tUser u = new User(followerId);\\n\\t\\t\\tuserMap.put(followerId, u);\\n\\t\\t}\\n\\t\\tif(!userMap.containsKey(followeeId)){\\n\\t\\t\\tUser u = new User(followeeId);\\n\\t\\t\\tuserMap.put(followeeId, u);\\n\\t\\t}\\n\\t\\tuserMap.get(followerId).follow(followeeId);\\n\\t}\\n\\n\\t/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n\\tpublic void unfollow(int followerId, int followeeId) {\\n\\t\\tif(!userMap.containsKey(followerId) || followerId==followeeId)\\n\\t\\t\\treturn;\\n\\t\\tuserMap.get(followerId).unfollow(followeeId);\\n\\t}\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic class Twitter {\\n\\tprivate static int timeStamp=0;\\n\\n\\t// easy to find if user exist\\n\\tprivate Map<Integer, User> userMap;\\n\\n\\t// Tweet link to next Tweet so that we can save a lot of time\\n\\t// when we execute getNewsFeed(userId)\\n\\tprivate class Tweet{\\n\\t\\tpublic int id;\\n\\t\\tpublic int time;\\n\\t\\tpublic Tweet next;\\n\\n\\t\\tpublic Tweet(int id){\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\ttime = timeStamp++;\\n\\t\\t\\tnext=null;\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// OO design so User can follow, unfollow and post itself\\n\\tpublic class User{\\n\\t\\tpublic int id;\\n\\t\\tpublic Set<Integer> followed;\\n\\t\\tpublic Tweet tweet_head;\\n\\n\\t\\tpublic User(int id){\\n\\t\\t\\tthis.id=id;\\n\\t\\t\\tfollowed = new HashSet<>();\\n\\t\\t\\tfollow(id); // first follow itself\\n\\t\\t\\ttweet_head = null;\\n\\t\\t}\\n\\n\\t\\tpublic void follow(int id){\\n\\t\\t\\tfollowed.add(id);\\n\\t\\t}\\n\\n\\t\\tpublic void unfollow(int id){\\n\\t\\t\\tfollowed.remove(id);\\n\\t\\t}\\n\\n\\n\\t\\t// everytime user post a new tweet, add it to the head of tweet list.\\n\\t\\tpublic void post(int id){\\n\\t\\t\\tTweet t = new Tweet(id);\\n\\t\\t\\tt.next=tweet_head;\\n\\t\\t\\ttweet_head=t;\\n\\t\\t}\\n\\t}\\n\\n\\n\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic Twitter() {\\n\\t\\tuserMap = new HashMap<Integer, User>();\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tpublic void postTweet(int userId, int tweetId) {\\n\\t\\tif(!userMap.containsKey(userId)){\\n\\t\\t\\tUser u = new User(userId);\\n\\t\\t\\tuserMap.put(userId, u);\\n\\t\\t}\\n\\t\\tuserMap.get(userId).post(tweetId);\\n\\n\\t}\\n\\n\\n\\n\\t// Best part of this.\\n\\t// first get all tweets lists from one user including itself and all people it followed.\\n\\t// Second add all heads into a max heap. Every time we poll a tweet with \\n\\t// largest time stamp from the heap, then we add its next tweet into the heap.\\n\\t// So after adding all heads we only need to add 9 tweets at most into this \\n\\t// heap before we get the 10 most recent tweet.\\n\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\t\\tList<Integer> res = new LinkedList<>();\\n\\n\\t\\tif(!userMap.containsKey(userId))   return res;\\n\\n\\t\\tSet<Integer> users = userMap.get(userId).followed;\\n\\t\\tPriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));\\n\\t\\tfor(int user: users){\\n\\t\\t\\tTweet t = userMap.get(user).tweet_head;\\n\\t\\t\\t// very imporant! If we add null to the head we are screwed.\\n\\t\\t\\tif(t!=null){\\n\\t\\t\\t\\tq.add(t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint n=0;\\n\\t\\twhile(!q.isEmpty() && n<10){\\n\\t\\t  Tweet t = q.poll();\\n\\t\\t  res.add(t.id);\\n\\t\\t  n++;\\n\\t\\t  if(t.next!=null)\\n\\t\\t\\tq.add(t.next);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\t/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n\\tpublic void follow(int followerId, int followeeId) {\\n\\t\\tif(!userMap.containsKey(followerId)){\\n\\t\\t\\tUser u = new User(followerId);\\n\\t\\t\\tuserMap.put(followerId, u);\\n\\t\\t}\\n\\t\\tif(!userMap.containsKey(followeeId)){\\n\\t\\t\\tUser u = new User(followeeId);\\n\\t\\t\\tuserMap.put(followeeId, u);\\n\\t\\t}\\n\\t\\tuserMap.get(followerId).follow(followeeId);\\n\\t}\\n\\n\\t/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n\\tpublic void unfollow(int followerId, int followeeId) {\\n\\t\\tif(!userMap.containsKey(followerId) || followerId==followeeId)\\n\\t\\t\\treturn;\\n\\t\\tuserMap.get(followerId).unfollow(followeeId);\\n\\t}\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82863,
                "title": "python-solution",
                "content": "    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.timer = itertools.count(step=-1)\\n            self.tweets = collections.defaultdict(collections.deque)\\n            self.followees = collections.defaultdict(set)\\n    \\n        def postTweet(self, userId, tweetId):\\n            self.tweets[userId].appendleft((next(self.timer), tweetId))\\n    \\n        def getNewsFeed(self, userId):\\n            tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n            return [t for _, t in itertools.islice(tweets, 10)]\\n    \\n        def follow(self, followerId, followeeId):\\n            self.followees[followerId].add(followeeId)\\n    \\n        def unfollow(self, followerId, followeeId):\\n            self.followees[followerId].discard(followeeId)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.timer = itertools.count(step=-1)\\n            self.tweets = collections.defaultdict(collections.deque)\\n            self.followees = collections.defaultdict(set)\\n    \\n        def postTweet(self, userId, tweetId):\\n            self.tweets[userId].appendleft((next(self.timer), tweetId))\\n    \\n        def getNewsFeed(self, userId):\\n            tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n            return [t for _, t in itertools.islice(tweets, 10)]\\n    \\n        def follow(self, followerId, followeeId):\\n            self.followees[followerId].add(followeeId)\\n    \\n        def unfollow(self, followerId, followeeId):\\n            self.followees[followerId].discard(followeeId)",
                "codeTag": "Java"
            },
            {
                "id": 82935,
                "title": "java-ood-solution-with-detailed-explanation",
                "content": "OOD design:\\ndata structure need in the Tweet system:\\n\\n\\t1. A data structure that save the following relationship\\n\\t2. A data structure that save the tweets posted \\n\\nBased on the requirement of method 3: we should get our followees' tweets and select the most recent 10 tweet. So there should have a timestamp inside the tweet. So we create a new class to represent a tweet\\n\\n\\t3. A class Tweet containing timestamp\\n\\n\\nThere are some tips in the system:\\n\\n\\t1. One should get the tweets of itself, which means the followee must contain itself\\n\\t2. Since the followee must contains itself, it cannot unfollow itself(unfollow add this constraint)\\n\\t3. The followees must be identical\\nAccording to the analysis above, we have these data struture in this class:\\n\\n\\t1. A inner class Tweet(tweetId, timePosted)\\n\\t2. A HashMap(follower, Set(followees))\\n\\t3. A HashMap(UserId, List(Tweet))\\n\\t4. A Static int timeStamp\\n\\t5. A int Maximum number of feed(can adjust if needed, optional)\\n\\nFor method 3, just simply use min heap to get the most recent 10.\\n\\n    public class Twitter {\\n    \\n    private static class Tweet{\\n        int tweetId;\\n        int timePosted;\\n        public Tweet(int tId, int time){\\n            tweetId = tId;\\n            timePosted = time;\\n        }\\n    }\\n    \\n    static int timeStamp;\\n    int feedMaxNum;\\n    Map<Integer, Set<Integer>> followees;\\n    Map<Integer, List<Tweet>> tweets;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        timeStamp = 0;\\n        feedMaxNum = 10;\\n        followees = new HashMap<>();\\n        tweets = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        if(!tweets.containsKey(userId)) {\\n            tweets.put(userId, new LinkedList<Tweet>());\\n            follow(userId, userId);  //follow itself\\n        }\\n        tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //min heap that the earliest tweet is on the top\\n        PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){\\n            public int compare(Tweet t1, Tweet t2){\\n                return t1.timePosted - t2.timePosted;\\n            }\\n        });\\n\\n        //add tweets of the followees\\n        Set<Integer> myFollowees = followees.get(userId);\\n        if(myFollowees != null){\\n            for(int followeeId : myFollowees){\\n                List<Tweet> followeeTweets = tweets.get(followeeId);\\n                if(followeeTweets == null) continue;\\n                for(Tweet t : followeeTweets){\\n                    if(feedHeap.size() < feedMaxNum) feedHeap.add(t);\\n                    else{\\n                        if(t.timePosted <= feedHeap.peek().timePosted) break;\\n                        else{\\n                            feedHeap.add(t);\\n                            feedHeap.poll(); //remove the oldest tweet\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> myFeed = new LinkedList<>();\\n        while(!feedHeap.isEmpty()){\\n            myFeed.add(0, feedHeap.poll().tweetId);\\n        }\\n        return myFeed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());\\n        followees.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself\\n        followees.get(followerId).remove(followeeId);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "OOD design:\\ndata structure need in the Tweet system:\\n\\n\\t1. A data structure that save the following relationship\\n\\t2. A data structure that save the tweets posted \\n\\nBased on the requirement of method 3: we should get our followees' tweets and select the most recent 10 tweet. So there should have a timestamp inside the tweet. So we create a new class to represent a tweet\\n\\n\\t3. A class Tweet containing timestamp\\n\\n\\nThere are some tips in the system:\\n\\n\\t1. One should get the tweets of itself, which means the followee must contain itself\\n\\t2. Since the followee must contains itself, it cannot unfollow itself(unfollow add this constraint)\\n\\t3. The followees must be identical\\nAccording to the analysis above, we have these data struture in this class:\\n\\n\\t1. A inner class Tweet(tweetId, timePosted)\\n\\t2. A HashMap(follower, Set(followees))\\n\\t3. A HashMap(UserId, List(Tweet))\\n\\t4. A Static int timeStamp\\n\\t5. A int Maximum number of feed(can adjust if needed, optional)\\n\\nFor method 3, just simply use min heap to get the most recent 10.\\n\\n    public class Twitter {\\n    \\n    private static class Tweet{\\n        int tweetId;\\n        int timePosted;\\n        public Tweet(int tId, int time){\\n            tweetId = tId;\\n            timePosted = time;\\n        }\\n    }\\n    \\n    static int timeStamp;\\n    int feedMaxNum;\\n    Map<Integer, Set<Integer>> followees;\\n    Map<Integer, List<Tweet>> tweets;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        timeStamp = 0;\\n        feedMaxNum = 10;\\n        followees = new HashMap<>();\\n        tweets = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        if(!tweets.containsKey(userId)) {\\n            tweets.put(userId, new LinkedList<Tweet>());\\n            follow(userId, userId);  //follow itself\\n        }\\n        tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //min heap that the earliest tweet is on the top\\n        PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){\\n            public int compare(Tweet t1, Tweet t2){\\n                return t1.timePosted - t2.timePosted;\\n            }\\n        });\\n\\n        //add tweets of the followees\\n        Set<Integer> myFollowees = followees.get(userId);\\n        if(myFollowees != null){\\n            for(int followeeId : myFollowees){\\n                List<Tweet> followeeTweets = tweets.get(followeeId);\\n                if(followeeTweets == null) continue;\\n                for(Tweet t : followeeTweets){\\n                    if(feedHeap.size() < feedMaxNum) feedHeap.add(t);\\n                    else{\\n                        if(t.timePosted <= feedHeap.peek().timePosted) break;\\n                        else{\\n                            feedHeap.add(t);\\n                            feedHeap.poll(); //remove the oldest tweet\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> myFeed = new LinkedList<>();\\n        while(!feedHeap.isEmpty()){\\n            myFeed.add(0, feedHeap.poll().tweetId);\\n        }\\n        return myFeed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());\\n        followees.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself\\n        followees.get(followerId).remove(followeeId);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 82916,
                "title": "c-solution-with-max-heap",
                "content": "Use two hash tables to keep track of the friends relationship and the tweets, respectively. For getting the news feed, first use a separate variable \"time\" to keep track of the time order when posting, then use a max heap to get the most recent ones, since the heap will do the sorting for us.\\n\\nAny suggestion is welcome!\\n\\n    class Twitter {\\n    private:    \\n       unordered_map<int, set<int>> fo;\\n       unordered_map<int, vector<pair<int, int>>> t;\\n       long long time; \\n\\n    public:\\n    /** Initialize your data structure here. */\\n    Twitter() {\\n        time = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    void postTweet(int userId, int tweetId) {\\n        t[userId].push_back({time++, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int, int>> maxHeap; \\n        for (auto it=t[userId].begin();it!=t[userId].end();++it)\\n            maxHeap.push(*it);\\n        for (auto it1=fo[userId].begin();it1!=fo[userId].end();++it1){\\n            int usr = *it1; // get target user\\n            for (auto it2=t[usr].begin();it2!=t[usr].end();++it2)\\n                maxHeap.push(*it2);\\n        }   \\n        vector<int> res;\\n        while(maxHeap.size()>0) {\\n            res.push_back(maxHeap.top().second);\\n            if (res.size()==10) break;\\n            maxHeap.pop();\\n        }\\n        return res;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId)\\n            fo[followerId].insert(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    void unfollow(int followerId, int followeeId) {\\n        fo[followerId].erase(followeeId);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "Use two hash tables to keep track of the friends relationship and the tweets, respectively. For getting the news feed, first use a separate variable \"time\" to keep track of the time order when posting, then use a max heap to get the most recent ones, since the heap will do the sorting for us.\\n\\nAny suggestion is welcome!\\n\\n    class Twitter {\\n    private:    \\n       unordered_map<int, set<int>> fo;\\n       unordered_map<int, vector<pair<int, int>>> t;\\n       long long time; \\n\\n    public:\\n    /** Initialize your data structure here. */\\n    Twitter() {\\n        time = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    void postTweet(int userId, int tweetId) {\\n        t[userId].push_back({time++, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int, int>> maxHeap; \\n        for (auto it=t[userId].begin();it!=t[userId].end();++it)\\n            maxHeap.push(*it);\\n        for (auto it1=fo[userId].begin();it1!=fo[userId].end();++it1){\\n            int usr = *it1; // get target user\\n            for (auto it2=t[usr].begin();it2!=t[usr].end();++it2)\\n                maxHeap.push(*it2);\\n        }   \\n        vector<int> res;\\n        while(maxHeap.size()>0) {\\n            res.push_back(maxHeap.top().second);\\n            if (res.size()==10) break;\\n            maxHeap.pop();\\n        }\\n        return res;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId)\\n            fo[followerId].insert(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    void unfollow(int followerId, int followeeId) {\\n        fo[followerId].erase(followeeId);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 82847,
                "title": "simple-11-lines-c-o-n-solution",
                "content": "```\\nclass Twitter {\\nprivate:\\n    vector<pair<int,int>>posts;\\n    unordered_map<int, unordered_map<int, int>>follows;\\npublic:\\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back(make_pair(userId, tweetId));\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>feed;\\n        int count = 0;\\n        for(int i = posts.size() - 1; i >= 0 && count < 10; i--)\\n            if(posts[i].first == userId || follows[userId][posts[i].first])\\n                feed.push_back(posts[i].second), count++;\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follows[followerId][followeeId] = 1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follows[followerId][followeeId] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\nprivate:\\n    vector<pair<int,int>>posts;\\n    unordered_map<int, unordered_map<int, int>>follows;\\npublic:\\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back(make_pair(userId, tweetId));\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>feed;\\n        int count = 0;\\n        for(int i = posts.size() - 1; i >= 0 && count < 10; i--)\\n            if(posts[i].first == userId || follows[userId][posts[i].first])\\n                feed.push_back(posts[i].second), count++;\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follows[followerId][followeeId] = 1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follows[followerId][followeeId] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82837,
                "title": "java-solutions-with-two-maps-and-priorityqueue",
                "content": "I use a map to track the tweets for each user. When we need to generate a news feed, I merge the news feed for all the followees and take the most recent 10. This is unlikely to perform, but the code passes the OJ. I'm sure design interviews ask for performance trade-offs and just posting this code in a design interview will not help you get an offer.\\n\\n    public class Twitter {\\n        Map<Integer, Set<Integer>> fans = new HashMap<>();\\n        Map<Integer, LinkedList<Tweet>> tweets = new HashMap<>();\\n        int cnt = 0;\\n    \\n        public void postTweet(int userId, int tweetId) {\\n            if (!fans.containsKey(userId)) fans.put(userId, new HashSet<>());\\n            fans.get(userId).add(userId);\\n            if (!tweets.containsKey(userId)) tweets.put(userId, new LinkedList<>());\\n            tweets.get(userId).addFirst(new Tweet(cnt++, tweetId));\\n        }\\n    \\n        public List<Integer> getNewsFeed(int userId) {\\n            if (!fans.containsKey(userId)) return new LinkedList<>();\\n            PriorityQueue<Tweet> feed = new PriorityQueue<>((t1, t2) -> t2.time - t1.time);\\n            fans.get(userId).stream()\\n                .filter(f -> tweets.containsKey(f))\\n                .forEach(f -> tweets.get(f).forEach(feed::add));\\n            List<Integer> res = new LinkedList<>();\\n            while (feed.size() > 0 && res.size() < 10) res.add(feed.poll().id);\\n            return res;\\n        }\\n    \\n        public void follow(int followerId, int followeeId) {\\n            if (!fans.containsKey(followerId)) fans.put(followerId, new HashSet<>());\\n            fans.get(followerId).add(followeeId);\\n        }\\n    \\n        public void unfollow(int followerId, int followeeId) {\\n            if (fans.containsKey(followerId) && followeeId != followerId) fans.get(followerId).remove(followeeId);\\n        }\\n    \\n        class Tweet {\\n            int time;\\n            int id;\\n    \\n            Tweet(int time, int id) {\\n                this.time = time;\\n                this.id = id;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I use a map to track the tweets for each user. When we need to generate a news feed, I merge the news feed for all the followees and take the most recent 10. This is unlikely to perform, but the code passes the OJ. I'm sure design interviews ask for performance trade-offs and just posting this code in a design interview will not help you get an offer.\\n\\n    public class Twitter {\\n        Map<Integer, Set<Integer>> fans = new HashMap<>();\\n        Map<Integer, LinkedList<Tweet>> tweets = new HashMap<>();\\n        int cnt = 0;\\n    \\n        public void postTweet(int userId, int tweetId) {\\n            if (!fans.containsKey(userId)) fans.put(userId, new HashSet<>());\\n            fans.get(userId).add(userId);\\n            if (!tweets.containsKey(userId)) tweets.put(userId, new LinkedList<>());\\n            tweets.get(userId).addFirst(new Tweet(cnt++, tweetId));\\n        }\\n    \\n        public List<Integer> getNewsFeed(int userId) {\\n            if (!fans.containsKey(userId)) return new LinkedList<>();\\n            PriorityQueue<Tweet> feed = new PriorityQueue<>((t1, t2) -> t2.time - t1.time);\\n            fans.get(userId).stream()\\n                .filter(f -> tweets.containsKey(f))\\n                .forEach(f -> tweets.get(f).forEach(feed::add));\\n            List<Integer> res = new LinkedList<>();\\n            while (feed.size() > 0 && res.size() < 10) res.add(feed.poll().id);\\n            return res;\\n        }\\n    \\n        public void follow(int followerId, int followeeId) {\\n            if (!fans.containsKey(followerId)) fans.put(followerId, new HashSet<>());\\n            fans.get(followerId).add(followeeId);\\n        }\\n    \\n        public void unfollow(int followerId, int followeeId) {\\n            if (fans.containsKey(followerId) && followeeId != followerId) fans.get(followerId).remove(followeeId);\\n        }\\n    \\n        class Tweet {\\n            int time;\\n            int id;\\n    \\n            Tweet(int time, int id) {\\n                this.time = time;\\n                this.id = id;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 82871,
                "title": "72ms-c-solution",
                "content": "Complexity: O(1) post/follow/unfollow, O(n + k log n) newsfeed for getting k tweets from n followed users, with the O(n) part coming from constructing the heap of followed users (see below), as correctly noted by @poligun.\\n\\nUse `std::vector` to store tweets, `std::unordered_set` to store followed users, `std::unordered_map` to associate each user with their tweets and followed users.\\n\\nUse a heap to merge most recent k tweets from followed users. `std::make/push/pop_heap` provide finer control than `std::priority_queue`.\\n\\n\\n    class Twitter\\n    {\\n        struct Tweet\\n        {\\n            int time;\\n            int id;\\n            Tweet(int time, int id) : time(time), id(id) {}\\n        };\\n    \\n        std::unordered_map<int, std::vector<Tweet>> tweets; // [u] = array of tweets by u\\n        std::unordered_map<int, std::unordered_set<int>> following; // [u] = array of users followed by u\\n    \\n        int time;\\n    \\n    public:\\n        Twitter() : time(0) {}\\n    \\n        void postTweet(int userId, int tweetId)\\n        {\\n            tweets[userId].emplace_back(time++, tweetId);\\n        }\\n    \\n        std::vector<int> getNewsFeed(int userId)\\n        {\\n            std::vector<std::pair<Tweet*, Tweet*>> h; // pair of pointers (begin, current)\\n    \\n            for (auto& u: following[userId])\\n            {\\n                auto& t = tweets[u];\\n                if (t.size() > 0)\\n                    h.emplace_back(t.data(), t.data() + t.size() - 1);\\n            }\\n            auto& t = tweets[userId]; // self\\n            if (t.size() > 0)\\n                h.emplace_back(t.data(), t.data() + t.size() - 1);\\n    \\n            auto f = [](const std::pair<Tweet*, Tweet*>& x, const std::pair<Tweet*, Tweet*>& y) {\\n                return x.second->time < y.second->time;\\n            };\\n            std::make_heap(h.begin(), h.end(), f);\\n    \\n            const int n = 10;\\n            std::vector<int> o;\\n            o.reserve(n);\\n            for (int i = 0; (i < n) && !h.empty(); ++i)\\n            {\\n                std::pop_heap(h.begin(), h.end(), f);\\n    \\n                auto& hb = h.back();\\n                o.push_back(hb.second->id);\\n    \\n                if (hb.first == hb.second--)\\n                    h.pop_back();\\n                else\\n                    std::push_heap(h.begin(), h.end(), f);\\n            }\\n            return o;\\n        }\\n    \\n        void follow(int followerId, int followeeId)\\n        {\\n            if (followerId != followeeId)\\n                following[followerId].insert(followeeId);\\n        }\\n    \\n        void unfollow(int followerId, int followeeId)\\n        {\\n            following[followerId].erase(followeeId);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "Complexity: O(1) post/follow/unfollow, O(n + k log n) newsfeed for getting k tweets from n followed users, with the O(n) part coming from constructing the heap of followed users (see below), as correctly noted by @poligun.\\n\\nUse `std::vector` to store tweets, `std::unordered_set` to store followed users, `std::unordered_map` to associate each user with their tweets and followed users.\\n\\nUse a heap to merge most recent k tweets from followed users. `std::make/push/pop_heap` provide finer control than `std::priority_queue`.\\n\\n\\n    class Twitter\\n    {\\n        struct Tweet\\n        {\\n            int time;\\n            int id;\\n            Tweet(int time, int id) : time(time), id(id) {}\\n        };\\n    \\n        std::unordered_map<int, std::vector<Tweet>> tweets; // [u] = array of tweets by u\\n        std::unordered_map<int, std::unordered_set<int>> following; // [u] = array of users followed by u\\n    \\n        int time;\\n    \\n    public:\\n        Twitter() : time(0) {}\\n    \\n        void postTweet(int userId, int tweetId)\\n        {\\n            tweets[userId].emplace_back(time++, tweetId);\\n        }\\n    \\n        std::vector<int> getNewsFeed(int userId)\\n        {\\n            std::vector<std::pair<Tweet*, Tweet*>> h; // pair of pointers (begin, current)\\n    \\n            for (auto& u: following[userId])\\n            {\\n                auto& t = tweets[u];\\n                if (t.size() > 0)\\n                    h.emplace_back(t.data(), t.data() + t.size() - 1);\\n            }\\n            auto& t = tweets[userId]; // self\\n            if (t.size() > 0)\\n                h.emplace_back(t.data(), t.data() + t.size() - 1);\\n    \\n            auto f = [](const std::pair<Tweet*, Tweet*>& x, const std::pair<Tweet*, Tweet*>& y) {\\n                return x.second->time < y.second->time;\\n            };\\n            std::make_heap(h.begin(), h.end(), f);\\n    \\n            const int n = 10;\\n            std::vector<int> o;\\n            o.reserve(n);\\n            for (int i = 0; (i < n) && !h.empty(); ++i)\\n            {\\n                std::pop_heap(h.begin(), h.end(), f);\\n    \\n                auto& hb = h.back();\\n                o.push_back(hb.second->id);\\n    \\n                if (hb.first == hb.second--)\\n                    h.pop_back();\\n                else\\n                    std::push_heap(h.begin(), h.end(), f);\\n            }\\n            return o;\\n        }\\n    \\n        void follow(int followerId, int followeeId)\\n        {\\n            if (followerId != followeeId)\\n                following[followerId].insert(followeeId);\\n        }\\n    \\n        void unfollow(int followerId, int followeeId)\\n        {\\n            following[followerId].erase(followeeId);\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 82831,
                "title": "simple-and-clean-python-code-o-logk-for-getting-news-feed",
                "content": "    import heapq\\n    \\n    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.time = 0\\n            self.tweets = {}\\n            self.followee = {}\\n            \\n    \\n        def postTweet(self, user, tweet):\\n            self.time += 1\\n            self.tweets[user] = self.tweets.get(user, []) + [(-self.time,  tweet)]\\n            \\n            \\n    \\n        def getNewsFeed(self, user):\\n            h, tweets = [], self.tweets\\n            people = self.followee.get(user, set()) | set([user])\\n            for person in people:\\n                if person in tweets and tweets[person]:\\n                    time, tweet = tweets[person][-1]\\n                    h.append((time, tweet, person, len(tweets[person]) - 1))\\n            heapq.heapify(h)\\n            news = []\\n            for _ in range(10):\\n                if h:\\n                    time, tweet, person, idx = heapq.heappop(h)\\n                    news.append(tweet)\\n                    if idx:\\n                        new_time, new_tweet = tweets[person][idx-1]\\n                        heapq.heappush(h, (new_time, new_tweet, person, idx - 1))\\n            return news\\n            \\n            \\n    \\n        def follow(self, follower, other):\\n            self.followee[follower] = self.followee.get(follower, set()) | set([other])\\n            \\n            \\n    \\n        def unfollow(self, follower, other):\\n            if follower in self.followee:\\n                self.followee[follower].discard(other)\\n \\n\\n `K` is the number of followee of `user`. We have `O(log(K))` runtime for getting news feed because we do maximum 10 extractions in a heap that holds maximum `K` elements (similar to what is done in merge `K` linked lists). The other ops are obviously `O(1)`.",
                "solutionTags": [],
                "code": "    import heapq\\n    \\n    class Twitter(object):\\n    \\n        def __init__(self):\\n            self.time = 0\\n            self.tweets = {}\\n            self.followee = {}\\n            \\n    \\n        def postTweet(self, user, tweet):\\n            self.time += 1\\n            self.tweets[user] = self.tweets.get(user, []) + [(-self.time,  tweet)]\\n            \\n            \\n    \\n        def getNewsFeed(self, user):\\n            h, tweets = [], self.tweets\\n            people = self.followee.get(user, set()) | set([user])\\n            for person in people:\\n                if person in tweets and tweets[person]:\\n                    time, tweet = tweets[person][-1]\\n                    h.append((time, tweet, person, len(tweets[person]) - 1))\\n            heapq.heapify(h)\\n            news = []\\n            for _ in range(10):\\n                if h:\\n                    time, tweet, person, idx = heapq.heappop(h)\\n                    news.append(tweet)\\n                    if idx:\\n                        new_time, new_tweet = tweets[person][idx-1]\\n                        heapq.heappush(h, (new_time, new_tweet, person, idx - 1))\\n            return news\\n            \\n            \\n    \\n        def follow(self, follower, other):\\n            self.followee[follower] = self.followee.get(follower, set()) | set([other])\\n            \\n            \\n    \\n        def unfollow(self, follower, other):\\n            if follower in self.followee:\\n                self.followee[follower].discard(other)\\n \\n\\n `K` is the number of followee of `user`. We have `O(log(K))` runtime for getting news feed because we do maximum 10 extractions in a heap that holds maximum `K` elements (similar to what is done in merge `K` linked lists). The other ops are obviously `O(1)`.",
                "codeTag": "Java"
            },
            {
                "id": 1516356,
                "title": "python-12ms-99-1-better-without-heap-and-queue",
                "content": "![image](https://assets.leetcode.com/users/images/28a8a5db-58ec-4216-a825-20a0eed8f0bf_1633967461.318094.png)\\n```\\nclass User:\\n    def __init__(self, userId):\\n        self.userId = userId\\n        self.tweets = {}\\n        self.followers = set()\\n        self.follows = set()\\n\\n\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.users = {}\\n        self.time = 0\\n\\n    def create(self, userid):\\n        \\n        if userid not in self.users:\\n            self.users[userid] = User(userid)\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(userId)\\n        self.users[userId].tweets[tweetId] = self.time\\n        self.time += 1\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        feed = []\\n        temp = []\\n        self.create(userId)\\n        for i in self.users[userId].tweets:\\n            temp.append([i, self.users[userId].tweets[i]])\\n        for i in self.users[userId].follows:\\n            print(i.tweets)\\n            for j in i.tweets:\\n                temp.append([j, i.tweets[j]])\\n        temp.sort(key=lambda x:x[1], reverse=True)\\n\\n        for i in temp:\\n            feed.append(i[0])\\n        return feed[:10]\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(followerId)\\n        self.create(followeeId)\\n        self.users[followerId].follows.add(self.users[followeeId])\\n        self.users[followeeId].followers.add(self.users[followerId])\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(followerId)\\n        self.create(followeeId)\\n        if self.users[followerId] in self.users[followeeId].followers:\\n            self.users[followeeId].followers.remove(self.users[followerId])\\n            self.users[followerId].follows.remove(self.users[followeeId])\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/28a8a5db-58ec-4216-a825-20a0eed8f0bf_1633967461.318094.png)\\n```\\nclass User:\\n    def __init__(self, userId):\\n        self.userId = userId\\n        self.tweets = {}\\n        self.followers = set()\\n        self.follows = set()\\n\\n\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.users = {}\\n        self.time = 0\\n\\n    def create(self, userid):\\n        \\n        if userid not in self.users:\\n            self.users[userid] = User(userid)\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(userId)\\n        self.users[userId].tweets[tweetId] = self.time\\n        self.time += 1\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        feed = []\\n        temp = []\\n        self.create(userId)\\n        for i in self.users[userId].tweets:\\n            temp.append([i, self.users[userId].tweets[i]])\\n        for i in self.users[userId].follows:\\n            print(i.tweets)\\n            for j in i.tweets:\\n                temp.append([j, i.tweets[j]])\\n        temp.sort(key=lambda x:x[1], reverse=True)\\n\\n        for i in temp:\\n            feed.append(i[0])\\n        return feed[:10]\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(followerId)\\n        self.create(followeeId)\\n        self.users[followerId].follows.add(self.users[followeeId])\\n        self.users[followeeId].followers.add(self.users[followerId])\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        self.create(followerId)\\n        self.create(followeeId)\\n        if self.users[followerId] in self.users[followeeId].followers:\\n            self.users[followeeId].followers.remove(self.users[followerId])\\n            self.users[followerId].follows.remove(self.users[followeeId])\\n",
                "codeTag": "Java"
            },
            {
                "id": 571821,
                "title": "python-o-following-for-getnewsfeed-faster-than-95-explained",
                "content": "I use a dict of (int, deque) to save tweets each user has posted and another dict to point to the users he\\'s following. Deque can be used because only the most recent tweets matter to us in this system.\\nI use a post counter as a time stamp to track most recent.\\nWhen getNewsFeed is called, I build a min heap of all the tweets of the user first. Then iterate over all the users he follows. \\nFor each other user a user follows, I iterate over all of his tweets from last to first since tweets array will be sorted by default, and if current element if greater than root of min heap, then I do a push if heap\\'s not full or if it\\'s full, I do a pushpop. \\nSince, we only need 10 tweets and each person can at max have only 10 tweets. All the heap operatons can be considered constant. \\nHence, the time complexity is O(Number of people a user follows).\\n\\n\\n```\\nfrom heapq import *\\nfrom collections import defaultdict, deque\\nclass Twitter:\\n\\n    # Each user has a separate min heap\\n    # if size of heap is lesser than 10 keep pushing tweets and when it\\'s full, poppush\\n    # use a defaultdict to associate user id\\'s to their heaps\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.following = defaultdict(set)\\n        self.user_tweets = defaultdict(deque)\\n        self.post = 0\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        \"\"\"\\n        self.post += 1\\n        tweets = self.user_tweets[userId]\\n        tweets.append(((self.post), tweetId))\\n        if len(tweets) > 10:\\n            tweets.popleft()\\n        \\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        \"\"\"\\n        h = []\\n        u = self.user_tweets[userId]\\n\\t\\th.extend(u)\\n        heapify(h)\\n        for user in self.following[userId]:\\n            tweets = self.user_tweets[user]\\n            for x in range(len(tweets) - 1, -1, -1):\\n                if len(h) < 10:\\n                    heappush(h, tweets[x])\\n                else:\\n                    if h[0][0] < tweets[x][0]:\\n                        heappushpop(h, tweets[x])\\n                    else:\\n                        break\\n        return [heappop(h)[1] for x in range(len(h))][::-1]\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n            self.following[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n                self.following[followerId].discard(followeeId)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nfrom collections import defaultdict, deque\\nclass Twitter:\\n\\n    # Each user has a separate min heap\\n    # if size of heap is lesser than 10 keep pushing tweets and when it\\'s full, poppush\\n    # use a defaultdict to associate user id\\'s to their heaps\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.following = defaultdict(set)\\n        self.user_tweets = defaultdict(deque)\\n        self.post = 0\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        \"\"\"\\n        self.post += 1\\n        tweets = self.user_tweets[userId]\\n        tweets.append(((self.post), tweetId))\\n        if len(tweets) > 10:\\n            tweets.popleft()\\n        \\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        \"\"\"\\n        h = []\\n        u = self.user_tweets[userId]\\n\\t\\th.extend(u)\\n        heapify(h)\\n        for user in self.following[userId]:\\n            tweets = self.user_tweets[user]\\n            for x in range(len(tweets) - 1, -1, -1):\\n                if len(h) < 10:\\n                    heappush(h, tweets[x])\\n                else:\\n                    if h[0][0] < tweets[x][0]:\\n                        heappushpop(h, tweets[x])\\n                    else:\\n                        break\\n        return [heappop(h)[1] for x in range(len(h))][::-1]\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n            self.following[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n                self.following[followerId].discard(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131998,
                "title": "python-no-heap-easy-and-clear-solution-68-ms-beats-100",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.tweets = collections.defaultdict(list)\\n        self.following = collections.defaultdict(set)\\n        self.order = 0\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: void\\n        \"\"\"\\n        self.tweets[userId] += (self.order, tweetId), \\n        self.order -= 1\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        tw = sorted(tw for i in self.following[userId] | {userId} for tw in self.tweets[i])[:10]\\n        return [news for i, news in tw]\\n    \\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        self.following[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        self.following[followerId].discard(followeeId)      \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.tweets = collections.defaultdict(list)\\n        self.following = collections.defaultdict(set)\\n        self.order = 0\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: void\\n        \"\"\"\\n        self.tweets[userId] += (self.order, tweetId), \\n        self.order -= 1\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        tw = sorted(tw for i in self.following[userId] | {userId} for tw in self.tweets[i])[:10]\\n        return [news for i, news in tw]\\n    \\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        self.following[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        self.following[followerId].discard(followeeId)      \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533031,
                "title": "python-simple-solution",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = defaultdict(set)\\n        self.tweets = []\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets.append((userId, tweetId))\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        i=len(self.tweets)-1\\n        while i>=0 and len(res)<10:\\n            if self.tweets[i][0] in self.users[userId] or self.tweets[i][0]==userId:\\n                res.append(self.tweets[i][1])\\n            i-=1\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]: self.users[followerId].remove(followeeId)\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = defaultdict(set)\\n        self.tweets = []\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets.append((userId, tweetId))\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        i=len(self.tweets)-1\\n        while i>=0 and len(res)<10:\\n            if self.tweets[i][0] in self.users[userId] or self.tweets[i][0]==userId:\\n                res.append(self.tweets[i][1])\\n            i-=1\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]: self.users[followerId].remove(followeeId)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138205,
                "title": "python-ood-solution",
                "content": "```\\nimport heapq\\n\\nclass Tweet(object):\\n    timestamp = 0\\n    def __init__(self, tid):\\n        self.id = tid\\n        self.timestamp = Tweet.timestamp\\n        Tweet.timestamp += 1\\n\\nclass User(object):\\n    def __init__(self, uid):\\n        self.id = uid\\n        self.following = set()\\n        self.tweets = []\\n        self.following.add(uid)\\n\\n    def follow(self, uid):\\n        if uid not in self.following:\\n            self.following.add(uid)\\n\\n    def unfollow(self, uid):\\n        if uid in self.following:\\n            self.following.remove(uid)\\n\\n    def post(self, tid):\\n        self.tweets.append(Tweet(tid))\\n\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.id_to_user = {}\\n        \\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: void\\n        \"\"\"\\n        if userId not in self.id_to_user:\\n            self.id_to_user[userId] = User(userId)\\n\\n        user = self.id_to_user[userId]\\n        user.post(tweetId)\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if userId not in self.id_to_user:\\n            self.id_to_user[userId] = User(userId)\\n\\n        user = self.id_to_user[userId]\\n        following_ids = user.following\\n\\n        res = self.mergeFollowingNews(following_ids)\\n        return res\\n\\n    def mergeFollowingNews(self, following_ids):\\n        heap, res, following_lists = [], [], []\\n\\n        for fid in following_ids:\\n            fuser = self.id_to_user[fid]\\n            following_lists.append(fuser.tweets)\\n\\n        for i, flist in enumerate(following_lists):\\n            if flist:\\n                tweet = flist[-1]\\n                heapq.heappush(heap, (-tweet.timestamp, i, len(flist)-1, tweet.id) )\\n\\n        n = 10\\n        while heap and n > 0:\\n            n_time, outer_i, local_i, tid = heapq.heappop(heap)\\n            res.append(tid) # tweet.id\\n            if local_i > 0: # element index\\n                tweet = following_lists[outer_i][local_i-1]\\n                heapq.heappush(heap, (-tweet.timestamp, outer_i, local_i-1, tweet.id) )\\n            n -= 1\\n\\n        return res\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        if followerId not in self.id_to_user:\\n            self.id_to_user[followerId] = User(followerId)\\n\\n        if followeeId not in self.id_to_user:\\n            self.id_to_user[followeeId] = User(followeeId)\\n\\n        follower = self.id_to_user[followerId]\\n        follower.follow(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        if followerId == followeeId:\\n            return\\n\\n        if followerId not in self.id_to_user:\\n            self.id_to_user[followerId] = User(followerId)\\n\\n        if followeeId not in self.id_to_user:\\n            self.id_to_user[followeeId] = User(followeeId)\\n\\n        follower = self.id_to_user[followerId]\\n        follower.unfollow(followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Tweet(object):\\n    timestamp = 0\\n    def __init__(self, tid):\\n        self.id = tid\\n        self.timestamp = Tweet.timestamp\\n        Tweet.timestamp += 1\\n\\nclass User(object):\\n    def __init__(self, uid):\\n        self.id = uid\\n        self.following = set()\\n        self.tweets = []\\n        self.following.add(uid)\\n\\n    def follow(self, uid):\\n        if uid not in self.following:\\n            self.following.add(uid)\\n\\n    def unfollow(self, uid):\\n        if uid in self.following:\\n            self.following.remove(uid)\\n\\n    def post(self, tid):\\n        self.tweets.append(Tweet(tid))\\n\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.id_to_user = {}\\n        \\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: void\\n        \"\"\"\\n        if userId not in self.id_to_user:\\n            self.id_to_user[userId] = User(userId)\\n\\n        user = self.id_to_user[userId]\\n        user.post(tweetId)\\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if userId not in self.id_to_user:\\n            self.id_to_user[userId] = User(userId)\\n\\n        user = self.id_to_user[userId]\\n        following_ids = user.following\\n\\n        res = self.mergeFollowingNews(following_ids)\\n        return res\\n\\n    def mergeFollowingNews(self, following_ids):\\n        heap, res, following_lists = [], [], []\\n\\n        for fid in following_ids:\\n            fuser = self.id_to_user[fid]\\n            following_lists.append(fuser.tweets)\\n\\n        for i, flist in enumerate(following_lists):\\n            if flist:\\n                tweet = flist[-1]\\n                heapq.heappush(heap, (-tweet.timestamp, i, len(flist)-1, tweet.id) )\\n\\n        n = 10\\n        while heap and n > 0:\\n            n_time, outer_i, local_i, tid = heapq.heappop(heap)\\n            res.append(tid) # tweet.id\\n            if local_i > 0: # element index\\n                tweet = following_lists[outer_i][local_i-1]\\n                heapq.heappush(heap, (-tweet.timestamp, outer_i, local_i-1, tweet.id) )\\n            n -= 1\\n\\n        return res\\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        if followerId not in self.id_to_user:\\n            self.id_to_user[followerId] = User(followerId)\\n\\n        if followeeId not in self.id_to_user:\\n            self.id_to_user[followeeId] = User(followeeId)\\n\\n        follower = self.id_to_user[followerId]\\n        follower.follow(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: void\\n        \"\"\"\\n        if followerId == followeeId:\\n            return\\n\\n        if followerId not in self.id_to_user:\\n            self.id_to_user[followerId] = User(followerId)\\n\\n        if followeeId not in self.id_to_user:\\n            self.id_to_user[followeeId] = User(followeeId)\\n\\n        follower = self.id_to_user[followerId]\\n        follower.unfollow(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82920,
                "title": "java-solution-using-hashmap-and-priorityqueue",
                "content": "\\tprivate static class Tweet {\\n\\t\\tint timestamp;\\n\\t\\tint tweetId;\\n\\n\\t\\tpublic Tweet(int tweetId, int timestamp) {\\n\\t\\t\\tthis.tweetId = tweetId;\\n\\t\\t\\tthis.timestamp = timestamp;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Map<Integer, Set<Integer>> followMap = new HashMap<Integer, Set<Integer>>();\\n\\tprivate Map<Integer, List<Tweet>> tweetMap = new HashMap<Integer, List<Tweet>>();\\n\\n\\tprivate AtomicInteger timestamp;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic Twitter() {\\n\\t\\ttimestamp = new AtomicInteger(0);\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tpublic void postTweet(int userId, int tweetId) {\\n\\t\\tTweet newTweet = new Tweet(tweetId, timestamp.getAndIncrement());\\n\\n\\t\\tif (!tweetMap.containsKey(userId)) {\\n\\t\\t\\ttweetMap.put(userId, new ArrayList<Tweet>());  //Assuming no deletion for now?\\n\\t\\t}\\n\\n\\t\\ttweetMap.get(userId).add(newTweet);\\n\\t}\\n\\n\\t/**\\n\\t * Retrieve the 10 most recent tweet ids in the user's news feed. Each item\\n\\t * in the news feed must be posted by users who the user followed or by the\\n\\t * user herself. Tweets must be ordered from most recent to least recent.\\n\\t */\\n\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>(10);\\n\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] it1, int[] it2) {\\n\\t\\t\\t\\treturn tweetMap.get(it2[0]).get(it2[1]).timestamp - tweetMap.get(it1[0]).get(it1[1]).timestamp;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tSet<Integer> followeeSet = new HashSet<Integer>();\\n\\t\\tfolloweeSet.add(userId);\\n\\t\\tif (followMap.containsKey(userId)) {\\n\\t\\t\\tfolloweeSet.addAll(followMap.get(userId));\\n\\t\\t}\\n\\n\\t\\tfor (Integer followee : followeeSet) {\\n\\t\\t\\tif (tweetMap.containsKey(followee)) {\\n\\t\\t\\t\\tList<Tweet> tweetList = tweetMap.get(followee);\\n\\t\\t\\t\\tif (tweetList.size() > 0) {\\n\\t\\t\\t\\t\\tpq.add(new int[] { followee, tweetList.size() - 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twhile (result.size() < 10 && pq.size() > 0) {\\n\\t\\t\\tint[] it = pq.poll();\\n\\n\\t\\t\\tresult.add(tweetMap.get(it[0]).get(it[1]).tweetId);\\n\\t\\t\\tit[1]--;\\n\\t\\t\\tif (it[1] >= 0) {\\n\\t\\t\\t\\tpq.add(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * Follower follows a followee. If the operation is invalid, it should be a\\n\\t * no-op.\\n\\t */\\n\\tpublic void follow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.add(followeeId);\\n\\t}\\n\\n\\t/**\\n\\t * Follower unfollows a followee. If the operation is invalid, it should be\\n\\t * a no-op.\\n\\t */\\n\\tpublic void unfollow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.remove(followeeId);\\n\\t}",
                "solutionTags": [],
                "code": "\\tprivate static class Tweet {\\n\\t\\tint timestamp;\\n\\t\\tint tweetId;\\n\\n\\t\\tpublic Tweet(int tweetId, int timestamp) {\\n\\t\\t\\tthis.tweetId = tweetId;\\n\\t\\t\\tthis.timestamp = timestamp;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Map<Integer, Set<Integer>> followMap = new HashMap<Integer, Set<Integer>>();\\n\\tprivate Map<Integer, List<Tweet>> tweetMap = new HashMap<Integer, List<Tweet>>();\\n\\n\\tprivate AtomicInteger timestamp;\\n\\n\\t/** Initialize your data structure here. */\\n\\tpublic Twitter() {\\n\\t\\ttimestamp = new AtomicInteger(0);\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tpublic void postTweet(int userId, int tweetId) {\\n\\t\\tTweet newTweet = new Tweet(tweetId, timestamp.getAndIncrement());\\n\\n\\t\\tif (!tweetMap.containsKey(userId)) {\\n\\t\\t\\ttweetMap.put(userId, new ArrayList<Tweet>());  //Assuming no deletion for now?\\n\\t\\t}\\n\\n\\t\\ttweetMap.get(userId).add(newTweet);\\n\\t}\\n\\n\\t/**\\n\\t * Retrieve the 10 most recent tweet ids in the user's news feed. Each item\\n\\t * in the news feed must be posted by users who the user followed or by the\\n\\t * user herself. Tweets must be ordered from most recent to least recent.\\n\\t */\\n\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>(10);\\n\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] it1, int[] it2) {\\n\\t\\t\\t\\treturn tweetMap.get(it2[0]).get(it2[1]).timestamp - tweetMap.get(it1[0]).get(it1[1]).timestamp;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tSet<Integer> followeeSet = new HashSet<Integer>();\\n\\t\\tfolloweeSet.add(userId);\\n\\t\\tif (followMap.containsKey(userId)) {\\n\\t\\t\\tfolloweeSet.addAll(followMap.get(userId));\\n\\t\\t}\\n\\n\\t\\tfor (Integer followee : followeeSet) {\\n\\t\\t\\tif (tweetMap.containsKey(followee)) {\\n\\t\\t\\t\\tList<Tweet> tweetList = tweetMap.get(followee);\\n\\t\\t\\t\\tif (tweetList.size() > 0) {\\n\\t\\t\\t\\t\\tpq.add(new int[] { followee, tweetList.size() - 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twhile (result.size() < 10 && pq.size() > 0) {\\n\\t\\t\\tint[] it = pq.poll();\\n\\n\\t\\t\\tresult.add(tweetMap.get(it[0]).get(it[1]).tweetId);\\n\\t\\t\\tit[1]--;\\n\\t\\t\\tif (it[1] >= 0) {\\n\\t\\t\\t\\tpq.add(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * Follower follows a followee. If the operation is invalid, it should be a\\n\\t * no-op.\\n\\t */\\n\\tpublic void follow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.add(followeeId);\\n\\t}\\n\\n\\t/**\\n\\t * Follower unfollows a followee. If the operation is invalid, it should be\\n\\t * a no-op.\\n\\t */\\n\\tpublic void unfollow(int followerId, int followeeId) {\\n\\t\\tSet<Integer> followSet = followMap.get(followerId);\\n\\t\\tif (followSet == null) {\\n\\t\\t\\tfollowSet = new HashSet<Integer>();\\n\\t\\t\\tfollowMap.put(followerId, followSet);\\n\\t\\t}\\n\\n\\t\\tfollowSet.remove(followeeId);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 476689,
                "title": "c-solution-with-explanation-beats-99-cheers-don-t-rely-on-the-runtime",
                "content": "The great problem which is quite relevant in the industry.\\nThe idea here is how you decide which data structure you are going to use. \\nIn this implementation, priority queue, deque, list have been used. \\n\\n**The first observation**\\nThere is no need to store more than 10 (maxFeed) tweets for each user because the function getNewsFeed is already bounded with that constraint.  \\n\\n**The second observation**\\nIt\\'s possible to implement functions \"follow\" and \"unfollow\" in **constant time** with the tradeoff between time and space complexity. \\nUsing the list and saving addresses of each relation all operations in these functions are constant. \\n\\n\\nAlso, there are lots of edge cases which you should clarify in an interview. The questions like:\\n1. Should tweets of a person be included in the getNewsFeed function?\\n2. Are all of the queries valid?\\n3. Is it possible that there is a query to unfollow without preceding follow function? The same values for followerId and followeeId etc. (see 2)\\n\\n```c++\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        time = 0;\\n        maxFeed = 10;     \\n    }\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time++, tweetId});\\n        if (tweets[userId].size() > maxFeed)  \\n            tweets[userId].pop_front();\\n    }\\n\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int, int> > feed;\\n        for (const auto& tweet : tweets[userId]) \\n            feed.push(tweet);\\n        \\n        for (const auto& user : subscriptions[userId]) \\n            for (const auto& tweet : tweets[user]) \\n                feed.push(tweet);\\n            \\n        vector<int> result;\\n        while (!feed.empty()) {\\n            if (result.size() == maxFeed) \\n                break;\\n            result.push_back(feed.top().second);\\n            feed.pop();\\n        }\\n        return result;\\n    }\\n\\n    void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId) {\\n            //if there is already such relation we do not need to do anything\\n            auto it = address.find(getKey(followerId, followeeId));\\n            if (it == end(address)) {\\n                subscriptions[followerId].push_front(followeeId);\\n                address[getKey(followerId, followeeId)] = begin(subscriptions[followerId]);    \\n            }\\n        }\\n    }\\n\\n    void unfollow(int followerId, int followeeId) {\\n        auto key = getKey(followerId, followeeId);\\n        \\n        //delete only if it exists\\n        auto it = address.find(key);\\n        if (it != end(address)) \\n            subscriptions[followerId].erase(address[key]);    \\n    }\\nprivate:\\n    int time, maxFeed;\\n    unordered_map<int, deque<pair<int, int>>> tweets;\\n    unordered_map<int, list<int>> subscriptions;\\n    unordered_map<long, list<int>::iterator> address;\\n    \\n    long getKey(int followerId, int followeeId) {\\n        return (long)followerId << 32 | (long)followeeId;\\n    }\\n};\\n```\\n\\n**P.S.**\\nDon\\'t rely on the runtime benchmarks. The variation with sets may give a better result however the time complexity is logarithmic O(log(n)).\\nAlso, it depends on the testcases how diverse and how many testcases there are. If you want to make this implementation 99-100% \\nplease add this portion of code in the constructor.\\n\\n```c++ \\n        tweets.reserve(64);\\n        tweets.max_load_factor(0.25);\\n       \\n        subscriptions.reserve(64);\\n        subscriptions.max_load_factor(0.25);        \\n\\t\\t\\n        address.reserve(64);\\n        address.max_load_factor(0.25);\\n```\\n",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        time = 0;\\n        maxFeed = 10;     \\n    }\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time++, tweetId});\\n        if (tweets[userId].size() > maxFeed)  \\n            tweets[userId].pop_front();\\n    }\\n\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int, int> > feed;\\n        for (const auto& tweet : tweets[userId]) \\n            feed.push(tweet);\\n        \\n        for (const auto& user : subscriptions[userId]) \\n            for (const auto& tweet : tweets[user]) \\n                feed.push(tweet);\\n            \\n        vector<int> result;\\n        while (!feed.empty()) {\\n            if (result.size() == maxFeed) \\n                break;\\n            result.push_back(feed.top().second);\\n            feed.pop();\\n        }\\n        return result;\\n    }\\n\\n    void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId) {\\n            //if there is already such relation we do not need to do anything\\n            auto it = address.find(getKey(followerId, followeeId));\\n            if (it == end(address)) {\\n                subscriptions[followerId].push_front(followeeId);\\n                address[getKey(followerId, followeeId)] = begin(subscriptions[followerId]);    \\n            }\\n        }\\n    }\\n\\n    void unfollow(int followerId, int followeeId) {\\n        auto key = getKey(followerId, followeeId);\\n        \\n        //delete only if it exists\\n        auto it = address.find(key);\\n        if (it != end(address)) \\n            subscriptions[followerId].erase(address[key]);    \\n    }\\nprivate:\\n    int time, maxFeed;\\n    unordered_map<int, deque<pair<int, int>>> tweets;\\n    unordered_map<int, list<int>> subscriptions;\\n    unordered_map<long, list<int>::iterator> address;\\n    \\n    long getKey(int followerId, int followeeId) {\\n        return (long)followerId << 32 | (long)followeeId;\\n    }\\n};\\n```\n```c++ \\n        tweets.reserve(64);\\n        tweets.max_load_factor(0.25);\\n       \\n        subscriptions.reserve(64);\\n        subscriptions.max_load_factor(0.25);        \\n\\t\\t\\n        address.reserve(64);\\n        address.max_load_factor(0.25);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82943,
                "title": "use-python-heapq-merge",
                "content": "    from collections import defaultdict\\n    from heapq import merge\\n    \\n    \\n    class Twitter(object):\\n        def __init__(self):\\n            \"\"\"\\n            Initialize your data structure here.\\n            \"\"\"\\n            self.follower_followees_map = defaultdict(set)\\n            self.user_tweets_map = defaultdict(list)\\n            self.time_stamp = 0\\n    \\n        def postTweet(self, userId, tweetId):\\n            \"\"\"\\n            Compose a new tweet.\\n            :type userId: int\\n            :type tweetId: int\\n            :rtype: void\\n            \"\"\"\\n            self.user_tweets_map[userId].append((self.time_stamp, tweetId))\\n            self.time_stamp -= 1\\n    \\n        def getNewsFeed(self, userId):\\n            \"\"\"\\n            Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n            :type userId: int\\n            :rtype: List[int]\\n            \"\"\"\\n            followees = self.follower_followees_map[userId]\\n            followees.add(userId)\\n            \\n            # reversed(.) returns a listreverseiterator, so the complexity is O(1) not O(n)\\n            candidate_tweets = [reversed(self.user_tweets_map[u]) for u in followees]\\n    \\n            tweets = []\\n            # complexity is 10lg(n), n is twitter's user number in worst case\\n            for t in merge(*candidate_tweets):\\n                tweets.append(t[1])\\n                if len(tweets) == 10:\\n                    break\\n            return tweets\\n    \\n        def follow(self, followerId, followeeId):\\n            \"\"\"\\n            Follower follows a followee. If the operation is invalid, it should be a no-op.\\n            :type followerId: int\\n            :type followeeId: int\\n            :rtype: void\\n            \"\"\"\\n            self.follower_followees_map[followerId].add(followeeId)\\n    \\n        def unfollow(self, followerId, followeeId):\\n            \"\"\"\\n            Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n            :type followerId: int\\n            :type followeeId: int\\n            :rtype: void\\n            \"\"\"\\n            self.follower_followees_map[followerId].discard(followeeId)",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "    from collections import defaultdict\\n    from heapq import merge\\n    \\n    \\n    class Twitter(object):\\n        def __init__(self):\\n            \"\"\"\\n            Initialize your data structure here.\\n            \"\"\"\\n            self.follower_followees_map = defaultdict(set)\\n            self.user_tweets_map = defaultdict(list)\\n            self.time_stamp = 0\\n    \\n        def postTweet(self, userId, tweetId):\\n            \"\"\"\\n            Compose a new tweet.\\n            :type userId: int\\n            :type tweetId: int\\n            :rtype: void\\n            \"\"\"\\n            self.user_tweets_map[userId].append((self.time_stamp, tweetId))\\n            self.time_stamp -= 1\\n    \\n        def getNewsFeed(self, userId):\\n            \"\"\"\\n            Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n            :type userId: int\\n            :rtype: List[int]\\n            \"\"\"\\n            followees = self.follower_followees_map[userId]\\n            followees.add(userId)\\n            \\n            # reversed(.) returns a listreverseiterator, so the complexity is O(1) not O(n)\\n            candidate_tweets = [reversed(self.user_tweets_map[u]) for u in followees]\\n    \\n            tweets = []\\n            # complexity is 10lg(n), n is twitter's user number in worst case\\n            for t in merge(*candidate_tweets):\\n                tweets.append(t[1])\\n                if len(tweets) == 10:\\n                    break\\n            return tweets\\n    \\n        def follow(self, followerId, followeeId):\\n            \"\"\"\\n            Follower follows a followee. If the operation is invalid, it should be a no-op.\\n            :type followerId: int\\n            :type followeeId: int\\n            :rtype: void\\n            \"\"\"\\n            self.follower_followees_map[followerId].add(followeeId)\\n    \\n        def unfollow(self, followerId, followeeId):\\n            \"\"\"\\n            Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n            :type followerId: int\\n            :type followeeId: int\\n            :rtype: void\\n            \"\"\"\\n            self.follower_followees_map[followerId].discard(followeeId)",
                "codeTag": "Java"
            },
            {
                "id": 3246417,
                "title": "355-time-94-7-and-space-95-87-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n94.7%\\n\\n- Space complexity:\\n95.87%\\n\\n# Code\\n```\\nclass Twitter:\\n  def __init__(self):\\n    # Use itertools.count to generate a decreasing sequence of integers for tweets\\n    self.timer = itertools.count(step=-1)\\n    # Use defaultdict and deque to store tweets for each user\\n    self.tweets = collections.defaultdict(deque)\\n    # Use defaultdict and set to store followees for each user\\n    self.followees = collections.defaultdict(set)\\n\\n  def postTweet(self, userId: int, tweetId: int) -> None:\\n    # Append the tweet to the left of the deque for the user, along with its timestamp\\n    self.tweets[userId].appendleft((next(self.timer), tweetId))\\n    # If the deque for the user has more than 10 tweets, remove the oldest tweet from the right\\n    if len(self.tweets[userId]) > 10:\\n      self.tweets[userId].pop()\\n\\n  def getNewsFeed(self, userId: int) -> List[int]:\\n    # Merge the tweets of the user\\'s followees (including the user) using heapq.merge\\n    tweets = list(heapq.merge(\\n        *(self.tweets[followee] for followee in self.followees[userId] | {userId})))\\n    # Return the tweet IDs of the 10 most recent tweets\\n    return [tweetId for _, tweetId in tweets[:10]]\\n\\n  def follow(self, followerId: int, followeeId: int) -> None:\\n    # Add the followee to the set of followees for the follower\\n    self.followees[followerId].add(followeeId)\\n\\n  def unfollow(self, followerId: int, followeeId: int) -> None:\\n    # Remove the followee from the set of followees for the follower (if the followee exists)\\n    self.followees[followerId].discard(followeeId)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List",
                    "Design"
                ],
                "code": "```\\nclass Twitter:\\n  def __init__(self):\\n    # Use itertools.count to generate a decreasing sequence of integers for tweets\\n    self.timer = itertools.count(step=-1)\\n    # Use defaultdict and deque to store tweets for each user\\n    self.tweets = collections.defaultdict(deque)\\n    # Use defaultdict and set to store followees for each user\\n    self.followees = collections.defaultdict(set)\\n\\n  def postTweet(self, userId: int, tweetId: int) -> None:\\n    # Append the tweet to the left of the deque for the user, along with its timestamp\\n    self.tweets[userId].appendleft((next(self.timer), tweetId))\\n    # If the deque for the user has more than 10 tweets, remove the oldest tweet from the right\\n    if len(self.tweets[userId]) > 10:\\n      self.tweets[userId].pop()\\n\\n  def getNewsFeed(self, userId: int) -> List[int]:\\n    # Merge the tweets of the user\\'s followees (including the user) using heapq.merge\\n    tweets = list(heapq.merge(\\n        *(self.tweets[followee] for followee in self.followees[userId] | {userId})))\\n    # Return the tweet IDs of the 10 most recent tweets\\n    return [tweetId for _, tweetId in tweets[:10]]\\n\\n  def follow(self, followerId: int, followeeId: int) -> None:\\n    # Add the followee to the set of followees for the follower\\n    self.followees[followerId].add(followeeId)\\n\\n  def unfollow(self, followerId: int, followeeId: int) -> None:\\n    # Remove the followee from the set of followees for the follower (if the followee exists)\\n    self.followees[followerId].discard(followeeId)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512380,
                "title": "python3-super-simple-solution-faster-than-94-61",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.users=collections.defaultdict(list)\\n        self.time=1\\n        self.followers=collections.defaultdict(set)\\n        \\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        \"\"\"\\n        Compose a new tweet.\\n        \"\"\"\\n        self.users[userId].append((self.time,tweetId))\\n        self.time += 1        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        \"\"\"\\n        news=list(self.users[userId])\\n        for user in self.followers[userId]:\\n            news.extend(self.users[user])\\n        news.sort(reverse=True,key=lambda x:x[0])\\n        res=[]\\n        for i in range(len(news)):\\n            if i == 10: break\\n            res.append(news[i][1])\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n            self.followers[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followeeId in self.followers[followerId]:\\n            self.followers[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.users=collections.defaultdict(list)\\n        self.time=1\\n        self.followers=collections.defaultdict(set)\\n        \\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        \"\"\"\\n        Compose a new tweet.\\n        \"\"\"\\n        self.users[userId].append((self.time,tweetId))\\n        self.time += 1        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        \"\"\"\\n        news=list(self.users[userId])\\n        for user in self.followers[userId]:\\n            news.extend(self.users[user])\\n        news.sort(reverse=True,key=lambda x:x[0])\\n        res=[]\\n        for i in range(len(news)):\\n            if i == 10: break\\n            res.append(news[i][1])\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followerId != followeeId:\\n            self.followers[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        \"\"\"\\n        if followeeId in self.followers[followerId]:\\n            self.followers[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523432,
                "title": "c-priority-queue-and-map",
                "content": "```\\nclass Twitter {\\nprivate:\\n    unordered_map<int, unordered_set<int>> friends;\\n    int timeStamp;\\n    priority_queue<array<int,3>>timeline;\\npublic:\\n    Twitter() {\\n        friends.clear();\\n        timeStamp = 0;\\n        timeline = priority_queue<array<int,3>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline.push({timeStamp++, tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>res;\\n        priority_queue<array<int,3>> userTimeline(timeline);\\n        int n = 0;\\n        while(!userTimeline.empty() and n < 10) {\\n            array<int,3> topfeed = userTimeline.top();\\n            if(topfeed[2] == userId || friends[userId].find(topfeed[2])!=friends[userId].end()){\\n                res.push_back(topfeed[1]);\\n                n++;\\n            }\\n            userTimeline.pop(); \\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\nprivate:\\n    unordered_map<int, unordered_set<int>> friends;\\n    int timeStamp;\\n    priority_queue<array<int,3>>timeline;\\npublic:\\n    Twitter() {\\n        friends.clear();\\n        timeStamp = 0;\\n        timeline = priority_queue<array<int,3>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline.push({timeStamp++, tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>res;\\n        priority_queue<array<int,3>> userTimeline(timeline);\\n        int n = 0;\\n        while(!userTimeline.empty() and n < 10) {\\n            array<int,3> topfeed = userTimeline.top();\\n            if(topfeed[2] == userId || friends[userId].find(topfeed[2])!=friends[userId].end()){\\n                res.push_back(topfeed[1]);\\n                n++;\\n            }\\n            userTimeline.pop(); \\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315416,
                "title": "simple-approach-with-explanation-using-priority-queues-and-unordered-maps",
                "content": "# Intuition\\nThe intuition is to maintain maps, for\\n- tweets, key will be userID, and will be mapped to a pair containing time, the time when the tweet was made, and tweetID\\n- following, key will be the userID, and value will be a vector containing the followees the user follows\\n- In getNewsFeed we use a priority queue, maxheap, of the tweets by the user or his followers, we do this using 2 loops \\n1 on his tweets, other one on the tweets of users he follows\\nand then get the tweets, all tweets if <10, or latest 10 tweets.\\n\\n# Approach\\nMaxHeap, priority queue\\nunordered_maps\\n\\n# Complexity\\n- Time complexity:\\nO(n^2), for getNewsFeed, as we iterate all the tweets of all the followees\\n\\n- Space complexity:\\nO(n)\\n\\nHope it helps!\\n\\n# Code\\n```\\nclass Twitter {\\n    long long time;\\n    unordered_map<int,set<int>>following;\\n    unordered_map<int,vector<pair<int,int>>>tweets;\\n  public:\\n  \\n    Twitter() {\\n        time=0;\\n    }\\n\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time++,tweetId});\\n    }\\n\\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>res;\\n        priority_queue<pair<int,int>>pq;\\n        for(auto it:tweets[userId])pq.push(it);\\n        for(int follower:following[userId]){\\n            for(auto it:tweets[follower])pq.push(it);\\n        }\\n        while(!pq.empty() && res.size()<10){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n\\n\\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n    }\\n\\n\\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "# Intuition\\nThe intuition is to maintain maps, for\\n- tweets, key will be userID, and will be mapped to a pair containing time, the time when the tweet was made, and tweetID\\n- following, key will be the userID, and value will be a vector containing the followees the user follows\\n- In getNewsFeed we use a priority queue, maxheap, of the tweets by the user or his followers, we do this using 2 loops \\n1 on his tweets, other one on the tweets of users he follows\\nand then get the tweets, all tweets if <10, or latest 10 tweets.\\n\\n# Approach\\nMaxHeap, priority queue\\nunordered_maps\\n\\n# Complexity\\n- Time complexity:\\nO(n^2), for getNewsFeed, as we iterate all the tweets of all the followees\\n\\n- Space complexity:\\nO(n)\\n\\nHope it helps!\\n\\n# Code\\n```\\nclass Twitter {\\n    long long time;\\n    unordered_map<int,set<int>>following;\\n    unordered_map<int,vector<pair<int,int>>>tweets;\\n  public:\\n  \\n    Twitter() {\\n        time=0;\\n    }\\n\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time++,tweetId});\\n    }\\n\\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>res;\\n        priority_queue<pair<int,int>>pq;\\n        for(auto it:tweets[userId])pq.push(it);\\n        for(int follower:following[userId]){\\n            for(auto it:tweets[follower])pq.push(it);\\n        }\\n        while(!pq.empty() && res.size()<10){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n\\n\\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n    }\\n\\n\\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 82955,
                "title": "c-simple-code-using-stl",
                "content": "    class Twitter {\\n    private:\\n        struct P {\\n            int id, ref;\\n            P(int i = 0, int j = 0) :id(i), ref(j) {}\\n            inline bool operator<(const P &a) const { return ref > a.ref; }\\n        };\\n    public:\\n        Twitter() { time = 1; }\\n        void postTweet(int userId, int tweetId) {\\n            userPost[userId].insert(P(tweetId, time++));\\n            userFollow[userId].insert(userId);\\n        }\\n        vector<int> getNewsFeed(int userId) {\\n            q.clear();\\n            vector<int> res;\\n            for(auto &r: userFollow[userId]) {\\n                int n = userPost[r].size();\\n                auto it = userPost[r].begin();\\n                n = min(n, 10);\\n                while(n--) {\\n                    if(q.size() < 10) {\\n                        q.insert(*it++);\\n                    } else {\\n                        auto c = q.end();\\n                        if(*it < *--c) {\\n                            q.erase(c);\\n                            q.insert(*it++);\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto &r: q) res.push_back(r.id);\\n            return res;\\n        }\\n        void follow(int followerId, int followeeId) {\\n            userFollow[followerId].insert(followeeId);\\n        }\\n        void unfollow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            userFollow[followerId].erase(followeeId);\\n        }\\n    private:\\n        int time;\\n        set<P> q;\\n        unordered_map<int, set<int>> userFollow;\\n        unordered_map<int, set<P>> userPost;\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class Twitter {\\n    private:\\n        struct P {\\n            int id, ref;\\n            P(int i = 0, int j = 0) :id(i), ref(j) {}\\n            inline bool operator<(const P &a) const { return ref > a.ref; }\\n        };\\n    public:\\n        Twitter() { time = 1; }\\n        void postTweet(int userId, int tweetId) {\\n            userPost[userId].insert(P(tweetId, time++));\\n            userFollow[userId].insert(userId);\\n        }\\n        vector<int> getNewsFeed(int userId) {\\n            q.clear();\\n            vector<int> res;\\n            for(auto &r: userFollow[userId]) {\\n                int n = userPost[r].size();\\n                auto it = userPost[r].begin();\\n                n = min(n, 10);\\n                while(n--) {\\n                    if(q.size() < 10) {\\n                        q.insert(*it++);\\n                    } else {\\n                        auto c = q.end();\\n                        if(*it < *--c) {\\n                            q.erase(c);\\n                            q.insert(*it++);\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto &r: q) res.push_back(r.id);\\n            return res;\\n        }\\n        void follow(int followerId, int followeeId) {\\n            userFollow[followerId].insert(followeeId);\\n        }\\n        void unfollow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            userFollow[followerId].erase(followeeId);\\n        }\\n    private:\\n        int time;\\n        set<P> q;\\n        unordered_map<int, set<int>> userFollow;\\n        unordered_map<int, set<P>> userPost;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2470828,
                "title": "c-solution-using-linked-list-simple-solution",
                "content": "```\\nstruct Node{\\n    int id;\\n    int time;\\n    Node *next=NULL;\\n    Node(int id,int time)\\n    {\\n        this->id=id;\\n        this->time=time;\\n        next=NULL;\\n    }\\n};\\nstruct str{\\n    unordered_set<int> f;\\n    Node *post;\\n    str()\\n    {\\n        post=NULL;\\n    }\\n};\\nclass Twitter {\\nprivate:\\n    Node* insert(Node *root,int key,int tm)\\n    {\\n        Node *h=new Node(key,tm);\\n        h->next=root;\\n        return h;\\n    }\\npublic:\\n    str ds[501];\\n    int cnt=1;\\n    Twitter() {\\n        cnt=1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        ds[userId].post=insert(ds[userId].post,tweetId,cnt);\\n        cnt+=1;\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,Node *>>pq;\\n        if(ds[userId].post)\\n            pq.push({ds[userId].post->time,ds[userId].post});\\n        \\n        for(auto x:ds[userId].f)\\n            if(ds[x].post)\\n                pq.push({ds[x].post->time,ds[x].post});\\n        \\n        vector<int>ans;\\n        while(!pq.empty() && ans.size()<10)\\n        {\\n            Node *curr=pq.top().second;\\n            ans.push_back(curr->id);\\n            pq.pop();\\n            curr=curr->next;\\n            if(curr)\\n                pq.push({curr->time,curr});\\n        }\\n        return ans; \\n    }\\n    void follow(int followerId, int followeeId) {\\n        ds[followerId].f.insert(followeeId);\\n    }\\n    void unfollow(int followerId, int followeeId) {\\n        if(ds[followerId].f.find(followeeId)!=ds[followerId].f.end())\\n            ds[followerId].f.erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Node{\\n    int id;\\n    int time;\\n    Node *next=NULL;\\n    Node(int id,int time)\\n    {\\n        this->id=id;\\n        this->time=time;\\n        next=NULL;\\n    }\\n};\\nstruct str{\\n    unordered_set<int> f;\\n    Node *post;\\n    str()\\n    {\\n        post=NULL;\\n    }\\n};\\nclass Twitter {\\nprivate:\\n    Node* insert(Node *root,int key,int tm)\\n    {\\n        Node *h=new Node(key,tm);\\n        h->next=root;\\n        return h;\\n    }\\npublic:\\n    str ds[501];\\n    int cnt=1;\\n    Twitter() {\\n        cnt=1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        ds[userId].post=insert(ds[userId].post,tweetId,cnt);\\n        cnt+=1;\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,Node *>>pq;\\n        if(ds[userId].post)\\n            pq.push({ds[userId].post->time,ds[userId].post});\\n        \\n        for(auto x:ds[userId].f)\\n            if(ds[x].post)\\n                pq.push({ds[x].post->time,ds[x].post});\\n        \\n        vector<int>ans;\\n        while(!pq.empty() && ans.size()<10)\\n        {\\n            Node *curr=pq.top().second;\\n            ans.push_back(curr->id);\\n            pq.pop();\\n            curr=curr->next;\\n            if(curr)\\n                pq.push({curr->time,curr});\\n        }\\n        return ans; \\n    }\\n    void follow(int followerId, int followeeId) {\\n        ds[followerId].f.insert(followeeId);\\n    }\\n    void unfollow(int followerId, int followeeId) {\\n        if(ds[followerId].f.find(followeeId)!=ds[followerId].f.end())\\n            ds[followerId].f.erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157538,
                "title": "c-solution-with-stack",
                "content": "```\\nclass Twitter {\\npublic:\\n    map<int, set<int>> friends;\\n    stack<vector<int>> timeline;\\n    Twitter() {\\n        friends.clear();\\n        timeline = stack<vector<int>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline.push({tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        stack<vector<int>> s = timeline;\\n        int n = 0;\\n        while(!s.empty() && n < 10){\\n            auto temp = s.top();\\n            s.pop();\\n            if(temp[1] == userId || friends[userId].count(temp[1])){\\n                ans.push_back(temp[0]);\\n                n++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    map<int, set<int>> friends;\\n    stack<vector<int>> timeline;\\n    Twitter() {\\n        friends.clear();\\n        timeline = stack<vector<int>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline.push({tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        stack<vector<int>> s = timeline;\\n        int n = 0;\\n        while(!s.empty() && n < 10){\\n            auto temp = s.top();\\n            s.pop();\\n            if(temp[1] == userId || friends[userId].count(temp[1])){\\n                ans.push_back(temp[0]);\\n                n++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1234948,
                "title": "java-clean-concise-optimal-code-8ms-time-100-faster-solution",
                "content": "# Solution 1: Without Map\\n```\\nclass Twitter {\\n    \\n    int time;\\n    List<int[]>[] tweets;\\n    Set<Integer>[] followees;\\n\\n    public Twitter() {\\n        \\n        time = 0;\\n        tweets = new List[501];\\n        followees = new Set[501];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n        ++time;\\n        if (tweets[userId] == null) {\\n            tweets[userId] = new ArrayList<> ();\\n            follow (userId, userId);\\n        }\\n        \\n        tweets[userId].add (new int[] {time, tweetId});\\n    }\\n   \\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        if (followees[userId] == null) {\\n            return new ArrayList<> ();\\n        }\\n        \\n        List<Integer> newsFeed = new ArrayList<> ();\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<> ((tweet1, tweet2) -> tweet2[0] - tweet1[0]);\\n        \\n        for (int followee : followees[userId]) {\\n            if (tweets[followee] == null) {\\n                continue;\\n            }\\n            \\n            for (int[] tweet : tweets[followee]) {\\n                maxHeap.offer (tweet);\\n            }\\n        }\\n        \\n        while (!maxHeap.isEmpty () && newsFeed.size () < 10) {\\n            newsFeed.add (maxHeap.poll ()[1]);\\n        }\\n        \\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        \\n        if (followees[followerId] == null) {\\n            followees[followerId] = new HashSet<> ();\\n            followees[followerId].add (followerId);\\n        }\\n        \\n        followees[followerId].add (followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n        followees[followerId].remove (followeeId);\\n    }\\n}\\n```\\n\\n# Solution 2: Using Map\\n```\\nclass Twitter {\\n\\n    int time;\\n    Map<Integer, List<int[]>> tweetMap;\\n    Map<Integer, Set<Integer>> followMap;\\n    \\n    public Twitter() {\\n        \\n        time = 0;\\n        tweetMap = new HashMap<> ();\\n        followMap = new HashMap<> ();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n        ++time;\\n        List<int[]> list = tweetMap.getOrDefault (userId, new ArrayList<> ());\\n        list.add (new int[] {time, tweetId});\\n        tweetMap.put (userId, list);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<> ((arr1, arr2) -> arr2[0] - arr1[0]);\\n        \\n        if (tweetMap.containsKey (userId)) {\\n            for (int[] arr : tweetMap.get (userId)) {\\n                maxHeap.offer (arr);\\n            }\\n        }\\n        \\n        if (followMap.containsKey (userId)) {\\n            for (int followee : followMap.get (userId)) {\\n                if (tweetMap.containsKey (followee)) {\\n                    for (int[] arr : tweetMap.get (followee)) {\\n                        maxHeap.offer (arr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> answer = new ArrayList<> ();\\n        \\n        while (!maxHeap.isEmpty () && answer.size () < 10) {\\n            int[] arr = maxHeap.poll ();\\n            answer.add (arr[1]);\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        \\n        Set<Integer> set = followMap.getOrDefault (followerId, new HashSet<> ());\\n        set.add (followeeId);\\n        followMap.put (followerId, set);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n        Set<Integer> set = followMap.getOrDefault (followerId, new HashSet<> ());\\n        set.remove (followeeId);\\n        followMap.put (followerId, set);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Twitter {\\n    \\n    int time;\\n    List<int[]>[] tweets;\\n    Set<Integer>[] followees;\\n\\n    public Twitter() {\\n        \\n        time = 0;\\n        tweets = new List[501];\\n        followees = new Set[501];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n        ++time;\\n        if (tweets[userId] == null) {\\n            tweets[userId] = new ArrayList<> ();\\n            follow (userId, userId);\\n        }\\n        \\n        tweets[userId].add (new int[] {time, tweetId});\\n    }\\n   \\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        if (followees[userId] == null) {\\n            return new ArrayList<> ();\\n        }\\n        \\n        List<Integer> newsFeed = new ArrayList<> ();\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<> ((tweet1, tweet2) -> tweet2[0] - tweet1[0]);\\n        \\n        for (int followee : followees[userId]) {\\n            if (tweets[followee] == null) {\\n                continue;\\n            }\\n            \\n            for (int[] tweet : tweets[followee]) {\\n                maxHeap.offer (tweet);\\n            }\\n        }\\n        \\n        while (!maxHeap.isEmpty () && newsFeed.size () < 10) {\\n            newsFeed.add (maxHeap.poll ()[1]);\\n        }\\n        \\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        \\n        if (followees[followerId] == null) {\\n            followees[followerId] = new HashSet<> ();\\n            followees[followerId].add (followerId);\\n        }\\n        \\n        followees[followerId].add (followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n        followees[followerId].remove (followeeId);\\n    }\\n}\\n```\n```\\nclass Twitter {\\n\\n    int time;\\n    Map<Integer, List<int[]>> tweetMap;\\n    Map<Integer, Set<Integer>> followMap;\\n    \\n    public Twitter() {\\n        \\n        time = 0;\\n        tweetMap = new HashMap<> ();\\n        followMap = new HashMap<> ();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n        ++time;\\n        List<int[]> list = tweetMap.getOrDefault (userId, new ArrayList<> ());\\n        list.add (new int[] {time, tweetId});\\n        tweetMap.put (userId, list);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<> ((arr1, arr2) -> arr2[0] - arr1[0]);\\n        \\n        if (tweetMap.containsKey (userId)) {\\n            for (int[] arr : tweetMap.get (userId)) {\\n                maxHeap.offer (arr);\\n            }\\n        }\\n        \\n        if (followMap.containsKey (userId)) {\\n            for (int followee : followMap.get (userId)) {\\n                if (tweetMap.containsKey (followee)) {\\n                    for (int[] arr : tweetMap.get (followee)) {\\n                        maxHeap.offer (arr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        List<Integer> answer = new ArrayList<> ();\\n        \\n        while (!maxHeap.isEmpty () && answer.size () < 10) {\\n            int[] arr = maxHeap.poll ();\\n            answer.add (arr[1]);\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        \\n        Set<Integer> set = followMap.getOrDefault (followerId, new HashSet<> ());\\n        set.add (followeeId);\\n        followMap.put (followerId, set);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n        Set<Integer> set = followMap.getOrDefault (followerId, new HashSet<> ());\\n        set.remove (followeeId);\\n        followMap.put (followerId, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208088,
                "title": "c-0ms-solution-less-than-98-memory-with-intuition-explanation",
                "content": "## Intuition\\n\\n#### Data Structures required:\\nWe need two types of data structures basically for this implementation task.\\n\\n1. To store the tweets, in order of when they were posted, for this we use an array of pairs, where the first number is tweetId and the second is userId.\\n\\n2. To store a graph (to implement the following and unfollowing system). As the number of users is only 500, so the implementation of the graph can be done by means of a set of pairs of followers and followees. This way, we can check if a user follows another user in O(logn), where n is the number of users in the system at that time\\n\\nI have used an additional integer to keep track of the last position in tweets array, which can be avoided easily by just adding the tweets at the start of the array, instead of the end, so that the order is most recent to least recent.\\n\\n\\n#### Initialization\\nInitially both of our data structures should be empty, and the size variable should be 0.\\n\\n#### Posting tweets\\nIn our design, the task of posting tweets can be completed in constant time, by just inserting the pair ***{tweetId, userId}*** to the tweets array, and then incrementing the size variable.\\n\\n####  Following and unfollowing users\\nThe task of following and unfollowing users is composed of just inserting ,or removing a pair ***{follower, followee}*** from the set of such pairs (following).\\n\\n#### Get news feed\\nThis is the main and most time consuming operation of the implementation. We traverse the tweets in the reverse order (i.e most recent to least recent), to get the latest (upto) 10 tweets from the user herself, or people who the user follows. To check the following, we use the set to find the pair {userId, tweetId.second}, which means we check if the user follows the user who posted that tweet.\\n\\n```\\nclass Twitter {\\n    set<pair<int, int>> following;\\n    vector<pair<int, int>> tweets;\\n    int ts;\\npublic:\\n    /** Initialize your data structure here. */\\n    Twitter() {\\n        following.clear();\\n        tweets.clear();\\n        ts = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({tweetId, userId});\\n        ts++;\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int k = 0;\\n        for(int i = ts-1; i>=0 && k<10; i--) {\\n            if(tweets[i].second == userId) {\\n                //user herself\\n                feed.push_back(tweets[i].first);\\n                k++;\\n            }\\n            else {\\n                if(following.find({userId, tweets[i].second}) != following.end()) {\\n                    feed.push_back(tweets[i].first);\\n                    k++;\\n                }\\n            }\\n        }\\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    void follow(int followerId, int followeeId) {\\n        following.insert({followerId, followeeId});\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    void unfollow(int followerId, int followeeId) {\\n        following.erase({followerId, followeeId});\\n    }\\n};\\n```\\n\\n## Complexity:\\n#### Time:\\n1. postTweet: It is **O(1)**, just a simple insert operation in an array, and housekeeping variable.\\n2. follow and unfollow: It is **O(loge)** where **e** is number of edges in the follower graph.\\n3. getNewsFeed: It is an **O(t)** operation in the worst case, where **t** is the number of tweets in the system.\\n\\n#### Space:\\nThe tweets array occupies **O(t)** space, while the following graph can occupy a space of **O(u^2)** in the worst case (complete graph). Thus the total space complexity is **O(t + u^2)**. Looking at the input constraints, the worst case for this system, would be that of use crowding, where there are 500 users (max.) and all users follow every other user (complete graph). \\n\\n\\n## Conclusion:\\nThis is a fairly good implementation if the follower graph is sparse, however if it is going to be dense, then going for a General Graph structure will prove to be better. \\nAny other improvement is welcome in the comments!\\n\\nFeel free to ask any doubts in the comments as well, and upvote if you liked this post.\\n..\\nThis is one of the longest posts I\\'ve written on this platform so far, so please upvote :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Twitter {\\n    set<pair<int, int>> following;\\n    vector<pair<int, int>> tweets;\\n    int ts;\\npublic:\\n    /** Initialize your data structure here. */\\n    Twitter() {\\n        following.clear();\\n        tweets.clear();\\n        ts = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({tweetId, userId});\\n        ts++;\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int k = 0;\\n        for(int i = ts-1; i>=0 && k<10; i--) {\\n            if(tweets[i].second == userId) {\\n                //user herself\\n                feed.push_back(tweets[i].first);\\n                k++;\\n            }\\n            else {\\n                if(following.find({userId, tweets[i].second}) != following.end()) {\\n                    feed.push_back(tweets[i].first);\\n                    k++;\\n                }\\n            }\\n        }\\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    void follow(int followerId, int followeeId) {\\n        following.insert({followerId, followeeId});\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    void unfollow(int followerId, int followeeId) {\\n        following.erase({followerId, followeeId});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135935,
                "title": "java-simple-and-easy-to-understand-solution-9-ms-faster-than-98-25-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Twitter {\\n    \\n    HashMap<Integer, User> users;\\n    int timestamp;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        users = new HashMap();\\n        timestamp = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        //add user, if not added\\n        users.putIfAbsent(userId, new User(userId));\\n        \\n        //add new tweet in this user account\\n        users.get(userId).addTweet(tweetId, timestamp++);\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //add user, if not added\\n        users.putIfAbsent(userId, new User(userId));\\n        \\n        //minheap, heapify on timestamp \\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<Tweet>((a, b) -> (a.timestamp - b.timestamp));\\n        \\n        //add all 10 recent tweet from its account\\n        addTweetsInMinHeap(minHeap, users.get(userId).tweets);\\n\\n        //add recent tweet from all user, whom this user follow\\n        for(int followee : users.get(userId).followees){\\n            addTweetsInMinHeap(minHeap, users.get(followee).tweets);\\n        }\\n        \\n        List<Integer> tweetIdList = new ArrayList();\\n        //make the tweet id list, from minheap\\n        while(!minHeap.isEmpty()){\\n            tweetIdList.add(minHeap.remove().tweetId);\\n        }\\n        \\n        //as minheap, tweetIdList is in increasing timestamp\\n        //reverse for decreasing timestamp order\\n        Collections.reverse(tweetIdList);\\n        \\n        return tweetIdList;\\n    }\\n    \\n    private void addTweetsInMinHeap(PriorityQueue<Tweet> minHeap, LinkedList<Tweet> tweets){\\n        for(Tweet tweet : tweets){\\n            //add tweet\\n            minHeap.add(tweet);\\n            \\n            //except 10 recent tweet, remove older one tweet\\n            if(minHeap.size() > 10){\\n                minHeap.remove();\\n            }\\n        }\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        //add follwer, if not added\\n        users.putIfAbsent(followerId, new User(followerId));\\n        //add followee, if not added\\n        users.putIfAbsent(followeeId, new User(followeeId));\\n        \\n        //follow\\n        users.get(followerId).follow(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        //check follower exist or not\\n        if(!users.containsKey(followerId)) return;\\n        \\n        //unfollow\\n        users.get(followerId).unfollow(followeeId);\\n    }\\n}\\n\\nclass User {\\n    //set of userId, this user follow \\n    HashSet<Integer> followees;\\n    //list of 10 recent tweet \\n    LinkedList<Tweet> tweets;\\n    int userId;\\n    \\n    public User(int userId){\\n        this.userId = userId;\\n        followees = new HashSet();\\n        tweets = new LinkedList();\\n    }\\n    \\n    public void follow(int followeeId){\\n        //add follwee in this follwer account\\n        followees.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followeeId){\\n        //remove follwee from this follwer account\\n        followees.remove(followeeId);\\n    }\\n    \\n    public void addTweet(int tweetId, int timestamp){\\n        //add new tweet\\n        tweets.addLast(new Tweet(tweetId, timestamp));\\n        \\n        //remove old tweet\\n        if(tweets.size() > 10){\\n            tweets.removeFirst();\\n        }\\n    }\\n    \\n    \\n}\\n\\nclass Tweet{\\n    int tweetId;\\n    int timestamp;\\n    \\n    public Tweet(int tweetId, int timestamp){\\n        this.tweetId = tweetId;\\n        this.timestamp = timestamp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n    \\n    HashMap<Integer, User> users;\\n    int timestamp;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        users = new HashMap();\\n        timestamp = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        //add user, if not added\\n        users.putIfAbsent(userId, new User(userId));\\n        \\n        //add new tweet in this user account\\n        users.get(userId).addTweet(tweetId, timestamp++);\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //add user, if not added\\n        users.putIfAbsent(userId, new User(userId));\\n        \\n        //minheap, heapify on timestamp \\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<Tweet>((a, b) -> (a.timestamp - b.timestamp));\\n        \\n        //add all 10 recent tweet from its account\\n        addTweetsInMinHeap(minHeap, users.get(userId).tweets);\\n\\n        //add recent tweet from all user, whom this user follow\\n        for(int followee : users.get(userId).followees){\\n            addTweetsInMinHeap(minHeap, users.get(followee).tweets);\\n        }\\n        \\n        List<Integer> tweetIdList = new ArrayList();\\n        //make the tweet id list, from minheap\\n        while(!minHeap.isEmpty()){\\n            tweetIdList.add(minHeap.remove().tweetId);\\n        }\\n        \\n        //as minheap, tweetIdList is in increasing timestamp\\n        //reverse for decreasing timestamp order\\n        Collections.reverse(tweetIdList);\\n        \\n        return tweetIdList;\\n    }\\n    \\n    private void addTweetsInMinHeap(PriorityQueue<Tweet> minHeap, LinkedList<Tweet> tweets){\\n        for(Tweet tweet : tweets){\\n            //add tweet\\n            minHeap.add(tweet);\\n            \\n            //except 10 recent tweet, remove older one tweet\\n            if(minHeap.size() > 10){\\n                minHeap.remove();\\n            }\\n        }\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        //add follwer, if not added\\n        users.putIfAbsent(followerId, new User(followerId));\\n        //add followee, if not added\\n        users.putIfAbsent(followeeId, new User(followeeId));\\n        \\n        //follow\\n        users.get(followerId).follow(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        //check follower exist or not\\n        if(!users.containsKey(followerId)) return;\\n        \\n        //unfollow\\n        users.get(followerId).unfollow(followeeId);\\n    }\\n}\\n\\nclass User {\\n    //set of userId, this user follow \\n    HashSet<Integer> followees;\\n    //list of 10 recent tweet \\n    LinkedList<Tweet> tweets;\\n    int userId;\\n    \\n    public User(int userId){\\n        this.userId = userId;\\n        followees = new HashSet();\\n        tweets = new LinkedList();\\n    }\\n    \\n    public void follow(int followeeId){\\n        //add follwee in this follwer account\\n        followees.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followeeId){\\n        //remove follwee from this follwer account\\n        followees.remove(followeeId);\\n    }\\n    \\n    public void addTweet(int tweetId, int timestamp){\\n        //add new tweet\\n        tweets.addLast(new Tweet(tweetId, timestamp));\\n        \\n        //remove old tweet\\n        if(tweets.size() > 10){\\n            tweets.removeFirst();\\n        }\\n    }\\n    \\n    \\n}\\n\\nclass Tweet{\\n    int tweetId;\\n    int timestamp;\\n    \\n    public Tweet(int tweetId, int timestamp){\\n        this.tweetId = tweetId;\\n        this.timestamp = timestamp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956692,
                "title": "easiest-approach-c",
                "content": "```\\nclass Twitter {\\npublic:\\n    \\n    vector<pair<int,int>> tweet;\\n    unordered_map<int,unordered_map<int,int>> follower;\\n    \\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet.push_back({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        int cnt=0;\\n        for(int i=tweet.size()-1;cnt<10 && i>=0;i--){\\n            if(tweet[i].first==userId || follower[userId][tweet[i].first]==1)\\n                res.push_back(tweet[i].second),cnt++;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower[followerId][followeeId]=1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower[followerId][followeeId]=0;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case,**please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    \\n    vector<pair<int,int>> tweet;\\n    unordered_map<int,unordered_map<int,int>> follower;\\n    \\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet.push_back({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        int cnt=0;\\n        for(int i=tweet.size()-1;cnt<10 && i>=0;i--){\\n            if(tweet[i].first==userId || follower[userId][tweet[i].first]==1)\\n                res.push_back(tweet[i].second),cnt++;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower[followerId][followeeId]=1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower[followerId][followeeId]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82927,
                "title": "c-80ms-unordered-map-list-priority-queue-solution",
                "content": "Time Complexity: n is number of user\\n\\npostTweet: O(1)\\n\\ngetNewsFeed: O(n log n)\\n\\nfollow: O(1)\\n\\nunfollow: O(1)\\n\\n    class Twitter {\\n    private:\\n        struct tweet{\\n            int userId;\\n            int tweetId;\\n            int timestamp;\\n            tweet(int x, int y, int z):userId(x), tweetId(y), timestamp(z){};\\n        };\\n        struct mycompare{\\n            bool operator()(pair<list<tweet>::iterator, list<tweet>::iterator> p1, pair<list<tweet>::iterator, list<tweet>::iterator> p2){\\n                return p1.first->timestamp < p2.first->timestamp;\\n            }\\n        };\\n        int timelabel = 0;\\n        unordered_map<int, unordered_set<int>> follower_dict;\\n        unordered_map<int, list<tweet>> twitter_dict;\\n    public:\\n        /** Initialize your data structure here. */\\n        Twitter() {}\\n        \\n        /** Compose a new tweet. */\\n        void postTweet(int userId, int tweetId) {\\n            follower_dict[userId].insert(userId);\\n            twitter_dict[userId].push_front(tweet(userId, tweetId, timelabel));\\n            timelabel++;\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        vector<int> getNewsFeed(int userId) {\\n            vector<int> res;\\n            if(follower_dict.find(userId) == follower_dict.end()) return res;\\n            priority_queue< pair<list<tweet>::iterator, list<tweet>::iterator>, vector<pair<list<tweet>::iterator, list<tweet>::iterator>>, mycompare> pq;\\n            for(auto it = follower_dict[userId].begin(); it != follower_dict[userId].end(); it++){\\n                if(twitter_dict[*it].begin() != twitter_dict[*it].end()){\\n                    pq.push(make_pair(twitter_dict[*it].begin(), twitter_dict[*it].end()));\\n                }\\n            }\\n            int index = 0;\\n            while(!pq.empty() && index < 10){\\n                auto tmp = pq.top();\\n                pq.pop();\\n                res.push_back(tmp.first->tweetId);\\n                if(++tmp.first != tmp.second){\\n                    pq.push(tmp);\\n                }\\n                index++;\\n            }\\n            return res;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        void follow(int followerId, int followeeId) {\\n            follower_dict[followerId].insert(followerId);\\n            follower_dict[followerId].insert(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        void unfollow(int followerId, int followeeId) {\\n            if(follower_dict.find(followerId) != follower_dict.end() && followerId != followeeId){\\n                follower_dict[followerId].erase(followeeId);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "Time Complexity: n is number of user\\n\\npostTweet: O(1)\\n\\ngetNewsFeed: O(n log n)\\n\\nfollow: O(1)\\n\\nunfollow: O(1)\\n\\n    class Twitter {\\n    private:\\n        struct tweet{\\n            int userId;\\n            int tweetId;\\n            int timestamp;\\n            tweet(int x, int y, int z):userId(x), tweetId(y), timestamp(z){};\\n        };\\n        struct mycompare{\\n            bool operator()(pair<list<tweet>::iterator, list<tweet>::iterator> p1, pair<list<tweet>::iterator, list<tweet>::iterator> p2){\\n                return p1.first->timestamp < p2.first->timestamp;\\n            }\\n        };\\n        int timelabel = 0;\\n        unordered_map<int, unordered_set<int>> follower_dict;\\n        unordered_map<int, list<tweet>> twitter_dict;\\n    public:\\n        /** Initialize your data structure here. */\\n        Twitter() {}\\n        \\n        /** Compose a new tweet. */\\n        void postTweet(int userId, int tweetId) {\\n            follower_dict[userId].insert(userId);\\n            twitter_dict[userId].push_front(tweet(userId, tweetId, timelabel));\\n            timelabel++;\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        vector<int> getNewsFeed(int userId) {\\n            vector<int> res;\\n            if(follower_dict.find(userId) == follower_dict.end()) return res;\\n            priority_queue< pair<list<tweet>::iterator, list<tweet>::iterator>, vector<pair<list<tweet>::iterator, list<tweet>::iterator>>, mycompare> pq;\\n            for(auto it = follower_dict[userId].begin(); it != follower_dict[userId].end(); it++){\\n                if(twitter_dict[*it].begin() != twitter_dict[*it].end()){\\n                    pq.push(make_pair(twitter_dict[*it].begin(), twitter_dict[*it].end()));\\n                }\\n            }\\n            int index = 0;\\n            while(!pq.empty() && index < 10){\\n                auto tmp = pq.top();\\n                pq.pop();\\n                res.push_back(tmp.first->tweetId);\\n                if(++tmp.first != tmp.second){\\n                    pq.push(tmp);\\n                }\\n                index++;\\n            }\\n            return res;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        void follow(int followerId, int followeeId) {\\n            follower_dict[followerId].insert(followerId);\\n            follower_dict[followerId].insert(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        void unfollow(int followerId, int followeeId) {\\n            if(follower_dict.find(followerId) != follower_dict.end() && followerId != followeeId){\\n                follower_dict[followerId].erase(followeeId);\\n            }\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 4023932,
                "title": "c-solution-with-explanation-and-a-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever I come across system design questions like these, I always try to go for data structures which keep a balance between time/space and code readability. That\\'s why I went for sets and hashmaps whose function often run in O(log n) time or O(1) time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor storing users and the users which they follow, I used a map with the user Id as key and a unordered set as value.\\nThis would allow me to do two things.\\n1. Perform the follow and unfollow operations in constant time as I am just inserting/removing the followee Ids to the hashset of userId in concern.\\n2. Verify whether a user follows another user during creation of news feed in constant time.\\n\\nFor storing of posts I have used a ordered set of pair of integer and pair. I store the postCount as the integer part which will used for ordering the posts in order of their creation. For this reason, I have used the inverse version of ordered set. The second part of pair which is a pair allows me to store the userId and postId. \\n\\nThis way I can iterate from the beginning of set and filter all the posts depending upon whether the post was created by the user or by the people that the user has followed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  postTweet() -> O(logn)\\n  getNewsFeed() -> O(nlogn)\\n  follow() -> O(1)\\n  unfollow() -> O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  set -> O(n)\\n  map -> depending upon users really.\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    set<pair<int, pair<int, int>>, greater<pair<int, pair<int, int>>>> s;\\n    map<int, unordered_set<int>> mp;\\n    int countOfPost;\\n\\n    Twitter() {\\n        countOfPost = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pair<int, pair<int, int>> p = {countOfPost, {userId, tweetId}};\\n        s.insert(p);\\n        countOfPost++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        unordered_set<int> st = mp[userId];\\n\\n        set<pair<int, pair<int, int>>, greater<pair<int, pair<int, int>>>>::iterator it;\\n        it = s.begin();\\n        \\n        while(res.size() != 10 && it != s.end()){\\n            pair<int, pair<int, int>> p = *it;\\n            if(st.count(p.second.first) == 1 || p.second.first == userId)\\n                res.push_back(p.second.second);\\n            it++;\\n        }\\n\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    set<pair<int, pair<int, int>>, greater<pair<int, pair<int, int>>>> s;\\n    map<int, unordered_set<int>> mp;\\n    int countOfPost;\\n\\n    Twitter() {\\n        countOfPost = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pair<int, pair<int, int>> p = {countOfPost, {userId, tweetId}};\\n        s.insert(p);\\n        countOfPost++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        unordered_set<int> st = mp[userId];\\n\\n        set<pair<int, pair<int, int>>, greater<pair<int, pair<int, int>>>>::iterator it;\\n        it = s.begin();\\n        \\n        while(res.size() != 10 && it != s.end()){\\n            pair<int, pair<int, int>> p = *it;\\n            if(st.count(p.second.first) == 1 || p.second.first == userId)\\n                res.push_back(p.second.second);\\n            it++;\\n        }\\n\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400455,
                "title": "simple-solution-for-beginners-with-step-by-step-explanation",
                "content": "# Intuition\\nHeap\\n\\n# Approach\\n1. Twitter\\n    - initialize hashmap posttweet it will contain userid with arraylist of pair of tweetid and time\\n    - initialize hashmap followers. it will contains userid with set of all the following userid (followeid) \\n    - initialize time (it will increment time after each call of postTweet)\\n2. Follow and unFollow\\n    - get HashSet of followerid from hashmap of followers\\n    - add/remove followeeId in HashSet\\n    - add hashset into hashmap with followerid\\n3. PostTweet \\n    - Make new Pair consisting of tweetid and time \\n    - get arraylist of userid then add pair to the arraylist\\n    - add arraylist in hashmap for userid\\n    - increment time value by 1\\n4. getFeedNews (Most important)\\n    - get list of followers of userid including userid in set\\n    - make a HashMap for the tweets of all the followers and user by using pair which consists of tweetid and timestamp\\n    -  Make PriorityQueue (MinHeap) of the hashMap\\n    - if size of priorityqueue is less than 10 skip this step. while size of priorityQueue in more 10 remove one element from PriorityQueue till it is 10. \\n    - add all the remaining tweetid in PriorityQueue into ArrayList\\n    - return reverse of arraylist  \\n\\n# Complexity\\n- twitter\\n    - Time complexity - O(1)\\n    - space Complexity - O(1)\\n- postTweet\\n    - Time complexity - O(1)\\n    - space Complexity - O(1)\\n- gwtNewsFeed\\n    - Time complexity - O(followers*tweets)\\n    - space Complexity - O(n)\\n- follow\\n    - Time complexity - O(1)\\n    - space Complexity - O(n)\\n- unfollow\\n    - Time complexity - O(1)\\n    - space Complexity - O(n)\\n\\n# Code\\n```\\nclass Twitter {\\n\\n    HashMap<Integer,ArrayList<Pair<Integer,Integer>>> posttweet ; // map<userid, < tweetId, time>>\\n    HashMap<Integer,Set<Integer>> followers ;\\n    int time;\\n\\n    public Twitter() {\\n        posttweet = new HashMap<>();\\n        followers = new HashMap<>();\\n        time=0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        Pair<Integer,Integer> pair = new Pair<>(tweetId,time);\\n        ArrayList temp = posttweet.getOrDefault(userId,new ArrayList<>());\\n        temp.add(pair);\\n        posttweet.put(userId,temp);\\n        time++;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = followers.getOrDefault(userId,new HashSet<>());\\n        set.add(userId);\\n        list.addAll(set);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i : list){\\n            if(posttweet.get(i)!=null)\\n                for(Pair<Integer,Integer> j : posttweet.get(i)){\\n                    map.put(j.getKey(),j.getValue());\\n                }\\n        }\\n        \\n        PriorityQueue<Map.Entry<Integer,Integer>> pq = new PriorityQueue<>(((x,y)->x.getValue()-y.getValue()));\\n        pq.addAll(map.entrySet());\\n        while(pq.size()>10){\\n            pq.poll();\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(pq.size()!=0){\\n            ans.add(pq.poll().getKey());\\n        }Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> set = followers.getOrDefault(followerId, new HashSet<>());\\n        set.add(followeeId);\\n        followers.put(followerId,set);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        Set<Integer> set = followers.getOrDefault(followerId, new HashSet<>());\\n        if(set.contains(followeeId))\\n        set.remove(followeeId);\\n        followers.put(followerId,set);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n\\n    HashMap<Integer,ArrayList<Pair<Integer,Integer>>> posttweet ; // map<userid, < tweetId, time>>\\n    HashMap<Integer,Set<Integer>> followers ;\\n    int time;\\n\\n    public Twitter() {\\n        posttweet = new HashMap<>();\\n        followers = new HashMap<>();\\n        time=0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        Pair<Integer,Integer> pair = new Pair<>(tweetId,time);\\n        ArrayList temp = posttweet.getOrDefault(userId,new ArrayList<>());\\n        temp.add(pair);\\n        posttweet.put(userId,temp);\\n        time++;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = followers.getOrDefault(userId,new HashSet<>());\\n        set.add(userId);\\n        list.addAll(set);\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i : list){\\n            if(posttweet.get(i)!=null)\\n                for(Pair<Integer,Integer> j : posttweet.get(i)){\\n                    map.put(j.getKey(),j.getValue());\\n                }\\n        }\\n        \\n        PriorityQueue<Map.Entry<Integer,Integer>> pq = new PriorityQueue<>(((x,y)->x.getValue()-y.getValue()));\\n        pq.addAll(map.entrySet());\\n        while(pq.size()>10){\\n            pq.poll();\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        while(pq.size()!=0){\\n            ans.add(pq.poll().getKey());\\n        }Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> set = followers.getOrDefault(followerId, new HashSet<>());\\n        set.add(followeeId);\\n        followers.put(followerId,set);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        Set<Integer> set = followers.getOrDefault(followerId, new HashSet<>());\\n        if(set.contains(followeeId))\\n        set.remove(followeeId);\\n        followers.put(followerId,set);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190865,
                "title": "c-solution",
                "content": "```\\nclass Twitter {\\npublic:\\n    vector<pair<int,int>> tweets;  //userId, tweetId\\n    unordered_map<int,unordered_set<int>> map; //man: following who\\n    \\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({userId, tweetId});\\n    }\\n    \\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(int i= tweets.size()-1 ; ans.size() < 10 && i>=0  ;i--){\\n            if(map[userId].count(tweets[i].first) || tweets[i].first==userId)\\n                ans.push_back(tweets[i].second);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    void follow(int followerId, int followeeId) {\\n        map[followerId].insert(followeeId);\\n    }\\n    \\n    \\n    void unfollow(int followerId, int followeeId) {\\n        map[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    vector<pair<int,int>> tweets;  //userId, tweetId\\n    unordered_map<int,unordered_set<int>> map; //man: following who\\n    \\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({userId, tweetId});\\n    }\\n    \\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(int i= tweets.size()-1 ; ans.size() < 10 && i>=0  ;i--){\\n            if(map[userId].count(tweets[i].first) || tweets[i].first==userId)\\n                ans.push_back(tweets[i].second);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    void follow(int followerId, int followeeId) {\\n        map[followerId].insert(followeeId);\\n    }\\n    \\n    \\n    void unfollow(int followerId, int followeeId) {\\n        map[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297795,
                "title": "java-two-maps-and-priorityqueue",
                "content": "```java\\nimport java.util.*;\\n\\nclass Twitter {\\n    \\n    private class Tweet {\\n        int id;\\n        int time;\\n\\n        Tweet(int id, int time) {\\n            this.id = id;\\n            this.time = time;\\n        }\\n    }\\n\\n    private class Iter {\\n        int i;\\n        List<Tweet> list;\\n\\n        Iter(List<Tweet> list) {\\n            i = 0;\\n            this.list = list;\\n        }\\n        \\n        Tweet peek() {\\n            return list.get(i);\\n        }\\n        \\n        boolean hasNext() {\\n            return i < list.size();\\n        }\\n        \\n        Tweet next() {\\n            return list.get(i++);\\n        }\\n    }\\n\\n    private Map<Integer, Set<Integer>> follows;\\n    private Map<Integer, List<Tweet>> tweets;\\n    private int time;\\n\\n    public Twitter() {\\n        follows = new HashMap<>();\\n        tweets = new HashMap<>();\\n        time = 0;\\n    }\\n\\n    public void postTweet(int userId, int tweetId) {\\n        validateUser(userId);\\n        Tweet tweet = new Tweet(tweetId, time++);\\n        tweets.get(userId).add(0, tweet);\\n    }\\n\\n    public List<Integer> getNewsFeed(int userId) {\\n        validateUser(userId);\\n\\n        PriorityQueue<Iter> queue = new PriorityQueue<>((x, y) -> {\\n            return -(x.peek().time - y.peek().time);\\n        });\\n\\n        if (tweets.get(userId).size() > 0) {\\n            queue.add(new Iter(tweets.get(userId)));\\n        }\\n\\n        for (int followee : follows.get(userId)) {\\n            if (tweets.get(followee).size() > 0) {\\n                queue.add(new Iter(tweets.get(followee)));\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        while (queue.size() > 0 && ans.size() < 10) {\\n            Iter item = queue.remove();\\n            ans.add(item.next().id);\\n            if (item.hasNext()) queue.add(item);\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void follow(int followerId, int followeeId) {\\n        validateUser(followerId);\\n        validateUser(followeeId);\\n        if (followerId == followeeId) return;\\n        follows.get(followerId).add(followeeId);\\n    }\\n\\n    public void unfollow(int followerId, int followeeId) {\\n        validateUser(followerId);\\n        validateUser(followeeId);\\n        follows.get(followerId).remove(followeeId);\\n    }\\n\\n    private void validateUser(int userID) {\\n        tweets.putIfAbsent(userID, new LinkedList<>());\\n        follows.putIfAbsent(userID, new HashSet<>());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.*;\\n\\nclass Twitter {\\n    \\n    private class Tweet {\\n        int id;\\n        int time;\\n\\n        Tweet(int id, int time) {\\n            this.id = id;\\n            this.time = time;\\n        }\\n    }\\n\\n    private class Iter {\\n        int i;\\n        List<Tweet> list;\\n\\n        Iter(List<Tweet> list) {\\n            i = 0;\\n            this.list = list;\\n        }\\n        \\n        Tweet peek() {\\n            return list.get(i);\\n        }\\n        \\n        boolean hasNext() {\\n            return i < list.size();\\n        }\\n        \\n        Tweet next() {\\n            return list.get(i++);\\n        }\\n    }\\n\\n    private Map<Integer, Set<Integer>> follows;\\n    private Map<Integer, List<Tweet>> tweets;\\n    private int time;\\n\\n    public Twitter() {\\n        follows = new HashMap<>();\\n        tweets = new HashMap<>();\\n        time = 0;\\n    }\\n\\n    public void postTweet(int userId, int tweetId) {\\n        validateUser(userId);\\n        Tweet tweet = new Tweet(tweetId, time++);\\n        tweets.get(userId).add(0, tweet);\\n    }\\n\\n    public List<Integer> getNewsFeed(int userId) {\\n        validateUser(userId);\\n\\n        PriorityQueue<Iter> queue = new PriorityQueue<>((x, y) -> {\\n            return -(x.peek().time - y.peek().time);\\n        });\\n\\n        if (tweets.get(userId).size() > 0) {\\n            queue.add(new Iter(tweets.get(userId)));\\n        }\\n\\n        for (int followee : follows.get(userId)) {\\n            if (tweets.get(followee).size() > 0) {\\n                queue.add(new Iter(tweets.get(followee)));\\n            }\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n        while (queue.size() > 0 && ans.size() < 10) {\\n            Iter item = queue.remove();\\n            ans.add(item.next().id);\\n            if (item.hasNext()) queue.add(item);\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void follow(int followerId, int followeeId) {\\n        validateUser(followerId);\\n        validateUser(followeeId);\\n        if (followerId == followeeId) return;\\n        follows.get(followerId).add(followeeId);\\n    }\\n\\n    public void unfollow(int followerId, int followeeId) {\\n        validateUser(followerId);\\n        validateUser(followeeId);\\n        follows.get(followerId).remove(followeeId);\\n    }\\n\\n    private void validateUser(int userID) {\\n        tweets.putIfAbsent(userID, new LinkedList<>());\\n        follows.putIfAbsent(userID, new HashSet<>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921603,
                "title": "2ms-don-t-ask-me-how-it-works-but-it-works-c",
                "content": "### So n\\xE4ive approach :)\\n* **Use your brain to understand the code  (\\u2022\\u25E1\\u2022)**\\n\\n```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    // mapping follower with followee\\n    map<int,set<int>>follower_followee;\\n    \\n    // used list of pair<userId,tweetId> just because of push_front. For getting most recent tweets;\\n    list<pair<int,int>>tweets;\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_front({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        auto itr = tweets.begin();\\n        int count = 0;\\n        vector<int>ans;\\n        while(count<10 and itr!=tweets.end())\\n        {\\n            pair<int,int>temp = *itr;\\n            int user = temp.first;\\n            int tweet = temp.second;\\n            // cout<<user<<\" \"<<tweet<<\"\\\\n\";\\n            if(user == userId)\\n            {\\n                // adding own feed\\n                ans.push_back(tweet);\\n                count++;\\n            }\\n            else if(follower_followee[userId].find(user) != follower_followee[userId].end())\\n            {\\n                // adding followee\\'s feed\\n                ans.push_back(tweet);\\n                count++;\\n            }\\n            itr++;\\n        }\\n        // cout<<\"\\\\n\";\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower_followee[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower_followee[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```\\n**And Upvote if you find it useful  (\\u2022\\u25E1\\u2022)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    // mapping follower with followee\\n    map<int,set<int>>follower_followee;\\n    \\n    // used list of pair<userId,tweetId> just because of push_front. For getting most recent tweets;\\n    list<pair<int,int>>tweets;\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_front({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        auto itr = tweets.begin();\\n        int count = 0;\\n        vector<int>ans;\\n        while(count<10 and itr!=tweets.end())\\n        {\\n            pair<int,int>temp = *itr;\\n            int user = temp.first;\\n            int tweet = temp.second;\\n            // cout<<user<<\" \"<<tweet<<\"\\\\n\";\\n            if(user == userId)\\n            {\\n                // adding own feed\\n                ans.push_back(tweet);\\n                count++;\\n            }\\n            else if(follower_followee[userId].find(user) != follower_followee[userId].end())\\n            {\\n                // adding followee\\'s feed\\n                ans.push_back(tweet);\\n                count++;\\n            }\\n            itr++;\\n        }\\n        // cout<<\"\\\\n\";\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower_followee[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower_followee[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2375772,
                "title": "c-100-faster-0ms-easy-code-with-comments-heap-and-map",
                "content": "Please Upvote :)\\n\\n```\\nclass Twitter {\\npublic:\\n    map<int,priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>> user;\\n    map<int,set<int>> connect;\\n    int time=0;\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        user[userId].push({time,tweetId});// stores as (time,tweet) pair to min heap\\n        time++;\\n        if(user[userId].size()>10)// keeping max 10 recents post of a user\\n            user[userId].pop();\\n    }\\n    void fun(priority_queue<pair<int,int>>& pq,int id)//add elements from min heap(id) to max heap(pq)\\n    {\\n        vector<vector<int>> temp;\\n        while(!user[id].empty())\\n        {\\n            int a=user[id].top().first;\\n            int b=user[id].top().second;\\n            user[id].pop();\\n            pq.push({a,b});\\n            temp.push_back({a,b});\\n        }\\n        for(auto x:temp)\\n        {\\n            user[id].push({x[0],x[1]});\\n        }\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> v;\\n        priority_queue<pair<int,int>> pq;\\n        fun(pq,userId);// user itself\\n        for(auto x:connect[userId])// posts by followers\\n        {\\n            fun(pq,x);\\n        }\\n        int i=0;\\n        while(!pq.empty())\\n        {\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n            i++;\\n            if(i==10)\\n                break;\\n        }\\n        return v;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        connect[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        connect[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    map<int,priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>> user;\\n    map<int,set<int>> connect;\\n    int time=0;\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        user[userId].push({time,tweetId});// stores as (time,tweet) pair to min heap\\n        time++;\\n        if(user[userId].size()>10)// keeping max 10 recents post of a user\\n            user[userId].pop();\\n    }\\n    void fun(priority_queue<pair<int,int>>& pq,int id)//add elements from min heap(id) to max heap(pq)\\n    {\\n        vector<vector<int>> temp;\\n        while(!user[id].empty())\\n        {\\n            int a=user[id].top().first;\\n            int b=user[id].top().second;\\n            user[id].pop();\\n            pq.push({a,b});\\n            temp.push_back({a,b});\\n        }\\n        for(auto x:temp)\\n        {\\n            user[id].push({x[0],x[1]});\\n        }\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> v;\\n        priority_queue<pair<int,int>> pq;\\n        fun(pq,userId);// user itself\\n        for(auto x:connect[userId])// posts by followers\\n        {\\n            fun(pq,x);\\n        }\\n        int i=0;\\n        while(!pq.empty())\\n        {\\n            v.push_back(pq.top().second);\\n            pq.pop();\\n            i++;\\n            if(i==10)\\n                break;\\n        }\\n        return v;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        connect[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        connect[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481833,
                "title": "java-with-explanation-minheap-way",
                "content": "```\\nclass Twitter {\\n    class Tweet{\\n        int  id;\\n        int createdAt;\\n        public Tweet(int id, int createdAt){\\n            this.id = id;\\n            this.createdAt = createdAt;\\n        }\\n    }\\n    \\n    HashMap<Integer, Set<Integer>> followed;// <key,Value< : <UserId, List of followee id (means person user is following)>\\n    HashMap<Integer, List<Tweet>> tweets; //<Key,Value> : <UserId, List of TweetObject tweeted by that person>\\n    int timeStamp = 0;\\n    int feedSize = 10;\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        followed = new HashMap<>();\\n        tweets = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n            \\n        //Adding it to UserTweet Map \\n        if(!tweets.containsKey(userId))\\n            tweets.put(userId, new ArrayList<>());\\n        tweets.get(userId).add(new Tweet(tweetId, timeStamp++));\\n\\n        //Need put that person to follow himself so as to get feeds\\n        if(!followed.containsKey(userId))\\n            followed.put(userId, new HashSet<>());\\n        followed.get(userId).add(userId);\\n            \\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //MinHeap will give us 10 latest tweets from the tweets he follows\\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<>((t1, t2)-> t1.createdAt-t2.createdAt);\\n        \\n        // We need to get all  people that userId follows.\\n        Set<Integer> followedByCurrentUserId = followed.get(userId);\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(followedByCurrentUserId !=null && followedByCurrentUserId.size()>0){\\n            \\n            //iterate these users tweets and send to minheap to get the latest 10 tweets overall\\n            for(int f : followedByCurrentUserId ){ \\n                List<Tweet> fTweets = tweets.get(f);\\n                if(fTweets == null)  // go to next user\\n                    continue;\\n                //else iterate over that person\\'s tweets\\n                for(Tweet t : fTweets){\\n                    if(minHeap.size()< feedSize)\\n                        minHeap.add(t);\\n                    else {\\n                       if(t.createdAt > minHeap.peek().createdAt){\\n                            minHeap.poll();\\n                            minHeap.add(t);\\n                        } \\n                    }\\n                }\\n\\n            }\\n            \\n            while(!minHeap.isEmpty()) \\n                result.add(0, minHeap.poll().id);\\n            return result;\\n        }\\n        return result;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(!followed.containsKey(followerId)) \\n            followed.put(followerId, new HashSet<>());\\n      followed.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(followed.containsKey(followerId) && followerId != followeeId)\\n            followed.get(followerId).remove(followeeId);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Twitter {\\n    class Tweet{\\n        int  id;\\n        int createdAt;\\n        public Tweet(int id, int createdAt){\\n            this.id = id;\\n            this.createdAt = createdAt;\\n        }\\n    }\\n    \\n    HashMap<Integer, Set<Integer>> followed;// <key,Value< : <UserId, List of followee id (means person user is following)>\\n    HashMap<Integer, List<Tweet>> tweets; //<Key,Value> : <UserId, List of TweetObject tweeted by that person>\\n    int timeStamp = 0;\\n    int feedSize = 10;\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        followed = new HashMap<>();\\n        tweets = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n            \\n        //Adding it to UserTweet Map \\n        if(!tweets.containsKey(userId))\\n            tweets.put(userId, new ArrayList<>());\\n        tweets.get(userId).add(new Tweet(tweetId, timeStamp++));\\n\\n        //Need put that person to follow himself so as to get feeds\\n        if(!followed.containsKey(userId))\\n            followed.put(userId, new HashSet<>());\\n        followed.get(userId).add(userId);\\n            \\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        //MinHeap will give us 10 latest tweets from the tweets he follows\\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<>((t1, t2)-> t1.createdAt-t2.createdAt);\\n        \\n        // We need to get all  people that userId follows.\\n        Set<Integer> followedByCurrentUserId = followed.get(userId);\\n        \\n        List<Integer> result = new ArrayList<>();\\n        if(followedByCurrentUserId !=null && followedByCurrentUserId.size()>0){\\n            \\n            //iterate these users tweets and send to minheap to get the latest 10 tweets overall\\n            for(int f : followedByCurrentUserId ){ \\n                List<Tweet> fTweets = tweets.get(f);\\n                if(fTweets == null)  // go to next user\\n                    continue;\\n                //else iterate over that person\\'s tweets\\n                for(Tweet t : fTweets){\\n                    if(minHeap.size()< feedSize)\\n                        minHeap.add(t);\\n                    else {\\n                       if(t.createdAt > minHeap.peek().createdAt){\\n                            minHeap.poll();\\n                            minHeap.add(t);\\n                        } \\n                    }\\n                }\\n\\n            }\\n            \\n            while(!minHeap.isEmpty()) \\n                result.add(0, minHeap.poll().id);\\n            return result;\\n        }\\n        return result;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(!followed.containsKey(followerId)) \\n            followed.put(followerId, new HashSet<>());\\n      followed.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(followed.containsKey(followerId) && followerId != followeeId)\\n            followed.get(followerId).remove(followeeId);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154945,
                "title": "javascript-hashmap-hashset-array-sort-based-on-timestamp-76ms-91-09",
                "content": "```\\nfunction Twitter() {\\n    let um = new Map(); // user map:  {userId: [tweetId, timestamp]}\\n    let fm = new Map();  // user/follower map: {followerId: Set {followeeId, .....} }\\n    let t = 0; // timestamp to maintain the most recent\\n    return {\\n        postTweet,\\n        getNewsFeed,\\n        follow,\\n        unfollow\\n    }\\n\\n    function postTweet(userId, tweetId) {\\n        t++; // if post, record the timestamp move on\\n        if (!um.has(userId)) um.set(userId, []);\\n        um.get(userId).push([tweetId, t]);\\n    }\\n\\n    function getNewsFeed(userId) { // || means set a default if not exists,\\n        let res = um.get(userId) || []; // collect this user personal tweets\\n        let fe = fm.get(userId) || new Set(); // this user\\'s all followee\\n        for (const e of fe) { // collect this user\\'s all followee\\'s tweets\\n            res = res.concat(um.get(e) || []);\\n        }\\n        res.sort((x, y) => y[1] - x[1]); // sort based on timestamp in descending order, larger timestamp means most recent\\n        return res.slice(0, 10).map(x => x[0]);\\n    }\\n\\n    function follow(followerId, followeeId) {\\n\\t    // add followeeId to followerId\\'s Set, use Set here is easy to remove compared to Array\\n        if (!fm.has(followerId)) fm.set(followerId, new Set());\\n        fm.get(followerId).add(followeeId);\\n    }\\n\\n    function unfollow(followerId, followeeId) {\\n        if (fm.has(followerId)) fm.get(followerId).delete(followeeId); // remove followeeId in follower map\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction Twitter() {\\n    let um = new Map(); // user map:  {userId: [tweetId, timestamp]}\\n    let fm = new Map();  // user/follower map: {followerId: Set {followeeId, .....} }\\n    let t = 0; // timestamp to maintain the most recent\\n    return {\\n        postTweet,\\n        getNewsFeed,\\n        follow,\\n        unfollow\\n    }\\n\\n    function postTweet(userId, tweetId) {\\n        t++; // if post, record the timestamp move on\\n        if (!um.has(userId)) um.set(userId, []);\\n        um.get(userId).push([tweetId, t]);\\n    }\\n\\n    function getNewsFeed(userId) { // || means set a default if not exists,\\n        let res = um.get(userId) || []; // collect this user personal tweets\\n        let fe = fm.get(userId) || new Set(); // this user\\'s all followee\\n        for (const e of fe) { // collect this user\\'s all followee\\'s tweets\\n            res = res.concat(um.get(e) || []);\\n        }\\n        res.sort((x, y) => y[1] - x[1]); // sort based on timestamp in descending order, larger timestamp means most recent\\n        return res.slice(0, 10).map(x => x[0]);\\n    }\\n\\n    function follow(followerId, followeeId) {\\n\\t    // add followeeId to followerId\\'s Set, use Set here is easy to remove compared to Array\\n        if (!fm.has(followerId)) fm.set(followerId, new Set());\\n        fm.get(followerId).add(followeeId);\\n    }\\n\\n    function unfollow(followerId, followeeId) {\\n        if (fm.has(followerId)) fm.get(followerId).delete(followeeId); // remove followeeId in follower map\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324111,
                "title": "108ms-javascript-solution-es6",
                "content": "Faster than 100% JavaScript results~\\n\\n```javascript\\nclass Twitter {\\n  constructor() {\\n      this.userTweets = new Map();\\n      this.userFollowing = new Map();\\n      this.lastIndex = 1;\\n  }\\n\\n  postTweet(userId, tweetId) {\\n      let tweets = this.userTweets.get(userId);\\n      if (!tweets) {\\n          tweets = [];\\n          this.userTweets.set(userId, tweets);\\n      }\\n      tweets.unshift({ id: tweetId, index: this.lastIndex });\\n      this.lastIndex = this.lastIndex + 1;\\n  }\\n\\n  getNewsFeed(userId) {\\n      const followings = this.userFollowing.get(userId);\\n      let tweets = (this.userTweets.get(userId) || []).slice(0, 10);\\n\\n      followings &&\\n          followings.forEach(uid => {\\n              if (uid === userId) return\\n        \\n              const userTweets = this.userTweets.get(uid);\\n              if (userTweets) {\\n                tweets = tweets.concat(userTweets);\\n              }\\n          });\\n\\n      return tweets\\n          .sort((a, b) => b.index - a.index)\\n          .map(tweet => tweet.id)\\n          .slice(0, 10);\\n  }\\n\\n  follow(followerId, followeeId) {\\n      let followings = this.userFollowing.get(followerId);\\n      if (!followings) {\\n          followings = new Set();\\n          this.userFollowing.set(followerId, followings);\\n      }\\n      followings.add(followeeId);\\n  }\\n\\n  unfollow(follower, followee) {\\n      const followings = this.userFollowing.get(follower);\\n      followings && followings.delete(followee);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass Twitter {\\n  constructor() {\\n      this.userTweets = new Map();\\n      this.userFollowing = new Map();\\n      this.lastIndex = 1;\\n  }\\n\\n  postTweet(userId, tweetId) {\\n      let tweets = this.userTweets.get(userId);\\n      if (!tweets) {\\n          tweets = [];\\n          this.userTweets.set(userId, tweets);\\n      }\\n      tweets.unshift({ id: tweetId, index: this.lastIndex });\\n      this.lastIndex = this.lastIndex + 1;\\n  }\\n\\n  getNewsFeed(userId) {\\n      const followings = this.userFollowing.get(userId);\\n      let tweets = (this.userTweets.get(userId) || []).slice(0, 10);\\n\\n      followings &&\\n          followings.forEach(uid => {\\n              if (uid === userId) return\\n        \\n              const userTweets = this.userTweets.get(uid);\\n              if (userTweets) {\\n                tweets = tweets.concat(userTweets);\\n              }\\n          });\\n\\n      return tweets\\n          .sort((a, b) => b.index - a.index)\\n          .map(tweet => tweet.id)\\n          .slice(0, 10);\\n  }\\n\\n  follow(followerId, followeeId) {\\n      let followings = this.userFollowing.get(followerId);\\n      if (!followings) {\\n          followings = new Set();\\n          this.userFollowing.set(followerId, followings);\\n      }\\n      followings.add(followeeId);\\n  }\\n\\n  unfollow(follower, followee) {\\n      const followings = this.userFollowing.get(follower);\\n      followings && followings.delete(followee);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82834,
                "title": "a-simple-javascript-solution-with-some-map",
                "content": "while `getNewsFeed `, we merge our tweets with our followee's tweets. After that we just sort it and take 10 most recent tweets.\\n```js\\nvar Twitter = function() {\\n    this.followMap = {};    // userId => [followeeId, ...]\\n    this.tweetMap = {};     // userId => [tweetId, ...]\\n    \\n    this.time = 0;\\n    this.tweetTimeMap = {}; // tweetId => postTime\\n    \\n    this.newArrayForKey = function(map, key){\\n        if(!map[key])\\n            map[key] = [];\\n    }\\n};\\n\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n    this.newArrayForKey(this.tweetMap, userId);\\n    \\n    if(this.tweetMap[userId].indexOf(tweetId) === -1){\\n        this.tweetMap[userId].push(tweetId);\\n        this.tweetTimeMap[tweetId] = this.time ++;\\n    }\\n};\\n\\nTwitter.prototype.getNewsFeed = function(userId) {\\n    var list = [];\\n    \\n    if(this.tweetMap[userId])\\n        list = list.concat(this.tweetMap[userId]);\\n    for(var followeeKey in this.followMap[userId]){\\n        var followeeId = this.followMap[userId][followeeKey];\\n        \\n        if(followeeId != userId && this.tweetMap[followeeId])\\n            list = list.concat(this.tweetMap[followeeId]);\\n    }\\n    \\n    that = this;\\n    return list.sort(function (a, b){\\n        return that.tweetTimeMap[b] - that.tweetTimeMap[a];\\n    }).slice(0, 10);\\n};\\n\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n    this.newArrayForKey(this.followMap, followerId);\\n    \\n    if(this.followMap[followerId].indexOf(followeeId) === -1)\\n        this.followMap[followerId].push(followeeId);\\n};\\n\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n    this.newArrayForKey(this.followMap, followerId);\\n    \\n    var index = this.followMap[followerId].indexOf(followeeId);\\n    if(index !== -1)\\n        this.followMap[followerId].splice(index, 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar Twitter = function() {\\n    this.followMap = {};    // userId => [followeeId, ...]\\n    this.tweetMap = {};     // userId => [tweetId, ...]\\n    \\n    this.time = 0;\\n    this.tweetTimeMap = {}; // tweetId => postTime\\n    \\n    this.newArrayForKey = function(map, key){\\n        if(!map[key])\\n            map[key] = [];\\n    }\\n};\\n\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n    this.newArrayForKey(this.tweetMap, userId);\\n    \\n    if(this.tweetMap[userId].indexOf(tweetId) === -1){\\n        this.tweetMap[userId].push(tweetId);\\n        this.tweetTimeMap[tweetId] = this.time ++;\\n    }\\n};\\n\\nTwitter.prototype.getNewsFeed = function(userId) {\\n    var list = [];\\n    \\n    if(this.tweetMap[userId])\\n        list = list.concat(this.tweetMap[userId]);\\n    for(var followeeKey in this.followMap[userId]){\\n        var followeeId = this.followMap[userId][followeeKey];\\n        \\n        if(followeeId != userId && this.tweetMap[followeeId])\\n            list = list.concat(this.tweetMap[followeeId]);\\n    }\\n    \\n    that = this;\\n    return list.sort(function (a, b){\\n        return that.tweetTimeMap[b] - that.tweetTimeMap[a];\\n    }).slice(0, 10);\\n};\\n\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n    this.newArrayForKey(this.followMap, followerId);\\n    \\n    if(this.followMap[followerId].indexOf(followeeId) === -1)\\n        this.followMap[followerId].push(followeeId);\\n};\\n\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n    this.newArrayForKey(this.followMap, followerId);\\n    \\n    var index = this.followMap[followerId].indexOf(followeeId);\\n    if(index !== -1)\\n        this.followMap[followerId].splice(index, 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 82912,
                "title": "146-ms-java-solution-treat-getnewsfeed-as-merge-k-sorted-lists-problem",
                "content": "This the best and most efficient solution I can come up with. I use two HashMap to store important information. `tweetMap` stores the list of tweets by a given user, and `followeeMap` stores the set of users who are followed by a given user.\\n\\nThe best part of this solution is that we can treat getNewsFeed as the classic problem -  [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/). Instead of using well-known priority queue to solve this problem, I use `indices` array to track the index of each tweet list stored in `listOfTweetList`. This is because we only need to return at most 10 tweets, I do not think the cost of priority queue worth it.\\n\\n```java\\npublic class Twitter {\\n    private class Tweet {\\n        int time;\\n        int tweetId;\\n        public Tweet(int time, int tweetId) {\\n            this.time = time;\\n            this.tweetId = tweetId;\\n        }\\n    }\\n    \\n    int currentTime = 0;\\n    HashMap<Integer, List<Tweet>> tweetMap;  // (userId, tweetList)\\n    HashMap<Integer, Set<Integer>> followeeMap;  // (userId, followeeSet)\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        tweetMap = new HashMap<>();\\n        followeeMap = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        Tweet tweet = new Tweet(currentTime++, tweetId);\\n        if (tweetMap.containsKey(userId)) {\\n            tweetMap.get(userId).add(0, tweet);\\n        } else {\\n            List<Tweet> list = new ArrayList<>();\\n            list.add(tweet);\\n            tweetMap.put(userId, list);\\n        }\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        // Treat this problem as merging k sorted lists\\n        List<Integer> idList = new ArrayList<>();\\n        Set<Integer> followeeSet = followeeMap.get(userId);\\n        // k sorted tweet list\\n        List<List<Tweet>> listOfTweetList = new ArrayList<>();\\n        // add tweet list of current user\\n        if (tweetMap.containsKey(userId)) {\\n            listOfTweetList.add(tweetMap.get(userId));\\n        }\\n        \\n        // add tweet list of followed users\\n        if (followeeMap.containsKey(userId)) {\\n            for (Integer followeeId : followeeSet) {\\n                if (tweetMap.containsKey(followeeId)) {\\n                    listOfTweetList.add(tweetMap.get(followeeId));\\n                }\\n            }\\n        }\\n        \\n        if (listOfTweetList.size() == 0) {\\n            return idList;\\n        }\\n\\n        // tracking the index of each list\\n        int[] indices = new int[listOfTweetList.size()];\\n        for (int i = 0; i < 10; i++) {\\n            Tweet nextTweet = null;\\n            int nextId = 0;\\n            // choose the nextTweet which has the max id (means it is the newest one)\\n            for (int j = 0; j < listOfTweetList.size(); j++) {\\n                if (indices[j] < listOfTweetList.get(j).size()) {\\n                    if (nextTweet == null || listOfTweetList.get(j).get(indices[j]).time > nextTweet.time) {\\n                        nextTweet = listOfTweetList.get(j).get(indices[j]);\\n                        nextId = j;\\n                    }\\n                }\\n            }\\n            if (nextTweet == null) {\\n                break;\\n            } else {\\n                idList.add(nextTweet.tweetId);\\n                indices[nextId]++;\\n            }\\n        }\\n        return idList;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (followerId == followeeId) {\\n            return;\\n        }\\n        if (followeeMap.containsKey(followerId)) {\\n            followeeMap.get(followerId).add(followeeId);\\n        } else {\\n            Set<Integer> set = new HashSet<>();\\n            set.add(followeeId);\\n            followeeMap.put(followerId, set);\\n        }\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId) {\\n            return;\\n        }\\n        if (followeeMap.containsKey(followerId)) {\\n            Set<Integer> set = followeeMap.get(followerId);\\n            if (set.contains(followeeId)) {\\n                set.remove(followeeId);\\n                if (set.size() == 0) {\\n                    followeeMap.remove(followerId);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Twitter {\\n    private class Tweet {\\n        int time;\\n        int tweetId;\\n        public Tweet(int time, int tweetId) {\\n            this.time = time;\\n            this.tweetId = tweetId;\\n        }\\n    }\\n    \\n    int currentTime = 0;\\n    HashMap<Integer, List<Tweet>> tweetMap;  // (userId, tweetList)\\n    HashMap<Integer, Set<Integer>> followeeMap;  // (userId, followeeSet)\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        tweetMap = new HashMap<>();\\n        followeeMap = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        Tweet tweet = new Tweet(currentTime++, tweetId);\\n        if (tweetMap.containsKey(userId)) {\\n            tweetMap.get(userId).add(0, tweet);\\n        } else {\\n            List<Tweet> list = new ArrayList<>();\\n            list.add(tweet);\\n            tweetMap.put(userId, list);\\n        }\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        // Treat this problem as merging k sorted lists\\n        List<Integer> idList = new ArrayList<>();\\n        Set<Integer> followeeSet = followeeMap.get(userId);\\n        // k sorted tweet list\\n        List<List<Tweet>> listOfTweetList = new ArrayList<>();\\n        // add tweet list of current user\\n        if (tweetMap.containsKey(userId)) {\\n            listOfTweetList.add(tweetMap.get(userId));\\n        }\\n        \\n        // add tweet list of followed users\\n        if (followeeMap.containsKey(userId)) {\\n            for (Integer followeeId : followeeSet) {\\n                if (tweetMap.containsKey(followeeId)) {\\n                    listOfTweetList.add(tweetMap.get(followeeId));\\n                }\\n            }\\n        }\\n        \\n        if (listOfTweetList.size() == 0) {\\n            return idList;\\n        }\\n\\n        // tracking the index of each list\\n        int[] indices = new int[listOfTweetList.size()];\\n        for (int i = 0; i < 10; i++) {\\n            Tweet nextTweet = null;\\n            int nextId = 0;\\n            // choose the nextTweet which has the max id (means it is the newest one)\\n            for (int j = 0; j < listOfTweetList.size(); j++) {\\n                if (indices[j] < listOfTweetList.get(j).size()) {\\n                    if (nextTweet == null || listOfTweetList.get(j).get(indices[j]).time > nextTweet.time) {\\n                        nextTweet = listOfTweetList.get(j).get(indices[j]);\\n                        nextId = j;\\n                    }\\n                }\\n            }\\n            if (nextTweet == null) {\\n                break;\\n            } else {\\n                idList.add(nextTweet.tweetId);\\n                indices[nextId]++;\\n            }\\n        }\\n        return idList;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (followerId == followeeId) {\\n            return;\\n        }\\n        if (followeeMap.containsKey(followerId)) {\\n            followeeMap.get(followerId).add(followeeId);\\n        } else {\\n            Set<Integer> set = new HashSet<>();\\n            set.add(followeeId);\\n            followeeMap.put(followerId, set);\\n        }\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId) {\\n            return;\\n        }\\n        if (followeeMap.containsKey(followerId)) {\\n            Set<Integer> set = followeeMap.get(followerId);\\n            if (set.contains(followeeId)) {\\n                set.remove(followeeId);\\n                if (set.size() == 0) {\\n                    followeeMap.remove(followerId);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82849,
                "title": "short-c-solution",
                "content": "    class Twitter {\\n\\tunordered_map<int, unordered_set<int>> following;\\t// follower, followee\\n\\tunordered_map<int, map<int, int>> tweets;\\t\\t\\t// userId, [sn, tweetId]\\n\\tlong long sn;\\n\\n    public:\\n\\t/** Initialize your data structure here. */\\n\\tTwitter() {\\n\\t\\tsn = 0;\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tvoid postTweet(int userId, int tweetId) {\\n\\t\\tfollow(userId, userId);\\n\\t\\ttweets[userId].insert(make_pair(sn++, tweetId));\\n\\t}\\n\\n\\t/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n\\tvector<int> getNewsFeed(int userId) {\\n\\t\\tvector<int> res;\\n\\t\\tmap<int, int> top10;\\n\\t\\tfor (auto iter = following[userId].begin(); iter != following[userId].end(); ++iter) {\\n\\t\\t\\tint followee = *iter;\\n\\t\\t\\tfor (auto iter = tweets[followee].begin(); iter != tweets[followee].end(); ++iter) {\\n\\n\\t\\t\\t\\tif (top10.size() > 0 && top10.begin()->first > iter->first && top10.size() > 10)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\ttop10.insert(make_pair(iter->first, iter->second));\\n\\t\\t\\t\\tif (top10.size() > 10)\\n\\t\\t\\t\\t\\ttop10.erase(top10.begin());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (auto iter = top10.rbegin(); iter != top10.rend(); ++iter)\\n\\t\\t\\tres.push_back(iter->second);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n\\tvoid follow(int followerId, int followeeId) {\\n\\t\\tfollowing[followerId].insert(followeeId);\\n\\t}\\n\\n\\t/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n\\tvoid unfollow(int followerId, int followeeId) {\\n\\t\\tif(followerId != followeeId)\\n\\t\\t\\tfollowing[followerId].erase(followeeId);\\n\\t }\\n    };",
                "solutionTags": [],
                "code": "    class Twitter {\\n\\tunordered_map<int, unordered_set<int>> following;\\t// follower, followee\\n\\tunordered_map<int, map<int, int>> tweets;\\t\\t\\t// userId, [sn, tweetId]\\n\\tlong long sn;\\n\\n    public:\\n\\t/** Initialize your data structure here. */\\n\\tTwitter() {\\n\\t\\tsn = 0;\\n\\t}\\n\\n\\t/** Compose a new tweet. */\\n\\tvoid postTweet(int userId, int tweetId) {\\n\\t\\tfollow(userId, userId);\\n\\t\\ttweets[userId].insert(make_pair(sn++, tweetId));\\n\\t}\\n\\n\\t/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n\\tvector<int> getNewsFeed(int userId) {\\n\\t\\tvector<int> res;\\n\\t\\tmap<int, int> top10;\\n\\t\\tfor (auto iter = following[userId].begin(); iter != following[userId].end(); ++iter) {\\n\\t\\t\\tint followee = *iter;\\n\\t\\t\\tfor (auto iter = tweets[followee].begin(); iter != tweets[followee].end(); ++iter) {\\n\\n\\t\\t\\t\\tif (top10.size() > 0 && top10.begin()->first > iter->first && top10.size() > 10)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\ttop10.insert(make_pair(iter->first, iter->second));\\n\\t\\t\\t\\tif (top10.size() > 10)\\n\\t\\t\\t\\t\\ttop10.erase(top10.begin());\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (auto iter = top10.rbegin(); iter != top10.rend(); ++iter)\\n\\t\\t\\tres.push_back(iter->second);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n\\tvoid follow(int followerId, int followeeId) {\\n\\t\\tfollowing[followerId].insert(followeeId);\\n\\t}\\n\\n\\t/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n\\tvoid unfollow(int followerId, int followeeId) {\\n\\t\\tif(followerId != followeeId)\\n\\t\\t\\tfollowing[followerId].erase(followeeId);\\n\\t }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3827309,
                "title": "impress-your-interviewer-xd",
                "content": "**Intuition and Workflow:**\\n\\nThe `Twitter` class is designed to simulate a simplified version of the Twitter social media platform. It allows users to post tweets, follow/unfollow other users, and view the 10 most recent tweets from the user\\'s news feed.\\n\\n**Explanation:**\\n\\n1. **Constructor (`Twitter()`):** The class is initialized with an empty `user_tweets` map to store tweets of each user and an empty `followers` map to store the follow relationships.\\n\\n2. **`postTweet(int userId, int tweetId)`:** This function is used to post a new tweet by a user. The tweet is stored in the `user_tweets` map for the corresponding user with the current timestamp. If the user has more than 10 tweets, the oldest tweet is removed to maintain a maximum of 10 recent tweets for each user.\\n\\n3. **`copyToMaxHeap(priority_queue<pair<int, int>>& maxHeap, int userId)`:** This function is a utility function that takes a user\\'s ID and copies their tweets from the `user_tweets` map to a max heap (`maxHeap`). It is used to merge the tweets of a user and the users they follow to find the latest 10 tweets for the news feed.\\n\\n4. **`getNewsFeed(int userId)`:** This function retrieves the 10 most recent tweets from the user\\'s news feed, including the user\\'s own tweets and tweets from the users they follow. It uses a max heap (`maxHeap`) to keep track of the latest tweets and utilizes the `copyToMaxHeap` function to merge the tweets from the user and their followees. The final 10 tweets are then added to the `result` vector and returned.\\n\\n5. **`follow(int followerId, int followeeId)`:** This function is used to establish a follow relationship between two users. The `followerId` is the ID of the user who is following, and `followeeId` is the ID of the user being followed. If the follower is trying to follow themselves, nothing happens.\\n\\n6. **`unfollow(int followerId, int followeeId)`:** This function is used to remove a follow relationship between two users. The `followerId` is the ID of the user who is following, and `followeeId` is the ID of the user being unfollowed. If the follower is trying to unfollow themselves, nothing happens.\\n\\n**Example Walkthrough:**\\n\\nLet\\'s walk through an example from LeetCode:\\n\\n```cpp\\nTwitter twitter;\\n\\n// User 1 posts tweets with tweetIds 5, 101, 2, 94, 333, 11, 205, 201, 200, and 204\\ntwitter.postTweet(1, 5);\\ntwitter.postTweet(1, 101);\\ntwitter.postTweet(1, 2);\\ntwitter.postTweet(1, 94);\\ntwitter.postTweet(1, 333);\\ntwitter.postTweet(1, 11);\\ntwitter.postTweet(1, 205);\\ntwitter.postTweet(1, 201);\\ntwitter.postTweet(1, 200);\\ntwitter.postTweet(1, 204);\\n\\n// User 2 posts tweets with tweetIds 3, 13, 10, 505, and 22\\ntwitter.postTweet(2, 3);\\ntwitter.postTweet(2, 13);\\ntwitter.postTweet(2, 10);\\ntwitter.postTweet(2, 505);\\ntwitter.postTweet(2, 22);\\n\\n// User 1 follows User 2\\ntwitter.follow(1, 2);\\n\\n// User 2 posts tweets with tweetIds 11 and 213\\ntwitter.postTweet(2, 11);\\ntwitter.postTweet(2, 213);\\n\\n// User 1 posts tweets with tweetIds 205, 201, and 203\\ntwitter.postTweet(1, 205);\\ntwitter.postTweet(1, 203);\\n\\n// User 2 posts tweets with tweetIds 200 and 202\\ntwitter.postTweet(2, 200);\\ntwitter.postTweet(2, 202);\\n\\n// Get news feed of User 1 (recent tweets from User 1 and User 2)\\ntwitter.getNewsFeed(1); // Output: [205, 11, 22, 333, 505, 94, 2, 10, 13, 101]\\n\\n// User 1 unfollows User 2\\ntwitter.unfollow(1, 2);\\n\\n// Get news feed of User 1 (only recent tweets from User 1)\\ntwitter.getNewsFeed(1); // Output: [222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n```\\n\\n**Time Complexity:**\\n\\n1. Posting a tweet takes constant time: O(1).\\n2. Retrieving the news feed involves merging and retrieving the latest 10 tweets from the heap, which takes O(k log n) time, where k is the number of tweets (10 in this case) and n is the total number of tweets across users.\\n3. Following/unfollowing a user takes constant time: O(1).\\n\\n**Space Complexity:**\\n\\n1. The space complexity of the `user_tweets` map is O(n), where n is the total number of tweets.\\n2. The space complexity of the `followers` map is also O(n).\\n3. The space complexity of the max heap used in the `getNewsFeed` function is O(k), where k is the number of tweets (10 in this case).\\n4. Overall, the space complexity of the Twitter class is O(n).\\n\\n# Code\\n```\\nclass Twitter\\n{\\npublic:\\n    map<int, priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>> user_tweets; // userId -> min heap of (timestamp, tweetId) pairs\\n    map<int, set<int>> followers;                                                                          // followerId -> set of followeeIds\\n    int timestamp = 0;\\n\\n    Twitter() {}\\n\\n    void postTweet(int userId, int tweetId)\\n    {\\n        user_tweets[userId].push({timestamp, tweetId}); // stores the tweet with (timestamp, tweetId) pair in min heap\\n        timestamp++;\\n        if (user_tweets[userId].size() > 10) // keeping a maximum of 10 recent posts of a user\\n            user_tweets[userId].pop();\\n    }\\n\\n    void copyToMaxHeap(priority_queue<pair<int, int>> &maxHeap, int userId)\\n    {\\n        vector<pair<int, int>> temp;\\n        while (!user_tweets[userId].empty())\\n        {\\n            int time = user_tweets[userId].top().first;\\n            int tweetId = user_tweets[userId].top().second;\\n            user_tweets[userId].pop();\\n            maxHeap.push({time, tweetId});\\n            temp.push_back({time, tweetId});\\n        }\\n        for (auto entry : temp)\\n        {\\n            user_tweets[userId].push({entry.first, entry.second});\\n        }\\n    }\\n\\n    vector<int> getNewsFeed(int userId)\\n    {\\n        vector<int> result;\\n        priority_queue<pair<int, int>> maxHeap;\\n\\n        // Add tweets from the user itself\\n        copyToMaxHeap(maxHeap, userId);\\n\\n        // Add posts by followers\\n        for (auto followeeId : followers[userId])\\n        {\\n            copyToMaxHeap(maxHeap, followeeId);\\n        }\\n\\n        // Retrieve the 10 most recent tweets\\n        int count = 0;\\n        while (!maxHeap.empty() && count < 10)\\n        {\\n            result.push_back(maxHeap.top().second);\\n            maxHeap.pop();\\n            count++;\\n        }\\n\\n        return result;\\n    }\\n\\n    void follow(int followerId, int followeeId)\\n    {\\n        followers[followerId].insert(followeeId);\\n    }\\n\\n    void unfollow(int followerId, int followeeId)\\n    {\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nTwitter twitter;\\n\\n// User 1 posts tweets with tweetIds 5, 101, 2, 94, 333, 11, 205, 201, 200, and 204\\ntwitter.postTweet(1, 5);\\ntwitter.postTweet(1, 101);\\ntwitter.postTweet(1, 2);\\ntwitter.postTweet(1, 94);\\ntwitter.postTweet(1, 333);\\ntwitter.postTweet(1, 11);\\ntwitter.postTweet(1, 205);\\ntwitter.postTweet(1, 201);\\ntwitter.postTweet(1, 200);\\ntwitter.postTweet(1, 204);\\n\\n// User 2 posts tweets with tweetIds 3, 13, 10, 505, and 22\\ntwitter.postTweet(2, 3);\\ntwitter.postTweet(2, 13);\\ntwitter.postTweet(2, 10);\\ntwitter.postTweet(2, 505);\\ntwitter.postTweet(2, 22);\\n\\n// User 1 follows User 2\\ntwitter.follow(1, 2);\\n\\n// User 2 posts tweets with tweetIds 11 and 213\\ntwitter.postTweet(2, 11);\\ntwitter.postTweet(2, 213);\\n\\n// User 1 posts tweets with tweetIds 205, 201, and 203\\ntwitter.postTweet(1, 205);\\ntwitter.postTweet(1, 203);\\n\\n// User 2 posts tweets with tweetIds 200 and 202\\ntwitter.postTweet(2, 200);\\ntwitter.postTweet(2, 202);\\n\\n// Get news feed of User 1 (recent tweets from User 1 and User 2)\\ntwitter.getNewsFeed(1); // Output: [205, 11, 22, 333, 505, 94, 2, 10, 13, 101]\\n\\n// User 1 unfollows User 2\\ntwitter.unfollow(1, 2);\\n\\n// Get news feed of User 1 (only recent tweets from User 1)\\ntwitter.getNewsFeed(1); // Output: [222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n```\n```\\nclass Twitter\\n{\\npublic:\\n    map<int, priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>> user_tweets; // userId -> min heap of (timestamp, tweetId) pairs\\n    map<int, set<int>> followers;                                                                          // followerId -> set of followeeIds\\n    int timestamp = 0;\\n\\n    Twitter() {}\\n\\n    void postTweet(int userId, int tweetId)\\n    {\\n        user_tweets[userId].push({timestamp, tweetId}); // stores the tweet with (timestamp, tweetId) pair in min heap\\n        timestamp++;\\n        if (user_tweets[userId].size() > 10) // keeping a maximum of 10 recent posts of a user\\n            user_tweets[userId].pop();\\n    }\\n\\n    void copyToMaxHeap(priority_queue<pair<int, int>> &maxHeap, int userId)\\n    {\\n        vector<pair<int, int>> temp;\\n        while (!user_tweets[userId].empty())\\n        {\\n            int time = user_tweets[userId].top().first;\\n            int tweetId = user_tweets[userId].top().second;\\n            user_tweets[userId].pop();\\n            maxHeap.push({time, tweetId});\\n            temp.push_back({time, tweetId});\\n        }\\n        for (auto entry : temp)\\n        {\\n            user_tweets[userId].push({entry.first, entry.second});\\n        }\\n    }\\n\\n    vector<int> getNewsFeed(int userId)\\n    {\\n        vector<int> result;\\n        priority_queue<pair<int, int>> maxHeap;\\n\\n        // Add tweets from the user itself\\n        copyToMaxHeap(maxHeap, userId);\\n\\n        // Add posts by followers\\n        for (auto followeeId : followers[userId])\\n        {\\n            copyToMaxHeap(maxHeap, followeeId);\\n        }\\n\\n        // Retrieve the 10 most recent tweets\\n        int count = 0;\\n        while (!maxHeap.empty() && count < 10)\\n        {\\n            result.push_back(maxHeap.top().second);\\n            maxHeap.pop();\\n            count++;\\n        }\\n\\n        return result;\\n    }\\n\\n    void follow(int followerId, int followeeId)\\n    {\\n        followers[followerId].insert(followeeId);\\n    }\\n\\n    void unfollow(int followerId, int followeeId)\\n    {\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541979,
                "title": "355-design-twitter",
                "content": "class Twitter {\\npublic:\\n    vector<pair<int,int>> feeds;\\n    unordered_map<int,vector<int>> followee;\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        feeds.push_back({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        vector<int> followees = followee[userId];\\n        unordered_map<int,bool>check;\\n        for(int i=0; i<followees.size();i++){\\n            check[followees[i]]=true;\\n        }\\n        check[userId]=true;\\n        int c=0;\\n        int i=feeds.size()-1; \\n        while(c<10 && i>=0){\\n            if(check[feeds[i].first]){\\n                ans.push_back(feeds[i].second);\\n                c++;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followee[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        vector<int>&followees = followee[followerId];\\n        for(int i=0; i<followees.size();i++){\\n            if(followees[i]==followeeId){\\n                followees.erase(followees.begin()+i);\\n                break;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Twitter {\\npublic:\\n    vector<pair<int,int>> feeds;\\n    unordered_map<int,vector<int>> followee;\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        feeds.push_back({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        vector<int> followees = followee[userId];\\n        unordered_map<int,bool>check;\\n        for(int i=0; i<followees.size();i++){\\n            check[followees[i]]=true;\\n        }\\n        check[userId]=true;\\n        int c=0;\\n        int i=feeds.size()-1; \\n        while(c<10 && i>=0){\\n            if(check[feeds[i].first]){\\n                ans.push_back(feeds[i].second);\\n                c++;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followee[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        vector<int>&followees = followee[followerId];\\n        for(int i=0; i<followees.size();i++){\\n            if(followees[i]==followeeId){\\n                followees.erase(followees.begin()+i);\\n                break;\\n            }\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3177016,
                "title": "c-max-heap-easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Max Heap and hashmap\\n\\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    unordered_map<int,set<int>>mp;\\n    int count;\\n    priority_queue<vector<int>>pq;\\n    Twitter() {\\n        count=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({count,userId,tweetId});\\n        count++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        int i=0;\\n        priority_queue<vector<int>>tweet=pq;\\n        while(i!=10 && tweet.size()!=0){\\n            int user=tweet.top()[1];\\n            int message=tweet.top()[2];\\n            tweet.pop();\\n            if(user==userId || mp[userId].find(user)!=mp[userId].end()){\\n                ans.push_back(message);\\n                  i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int,set<int>>mp;\\n    int count;\\n    priority_queue<vector<int>>pq;\\n    Twitter() {\\n        count=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({count,userId,tweetId});\\n        count++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        int i=0;\\n        priority_queue<vector<int>>tweet=pq;\\n        while(i!=10 && tweet.size()!=0){\\n            int user=tweet.top()[1];\\n            int message=tweet.top()[2];\\n            tweet.pop();\\n            if(user==userId || mp[userId].find(user)!=mp[userId].end()){\\n                ans.push_back(message);\\n                  i++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113508,
                "title": "0ms-runtime-beats-100-min-heap-of-size-10",
                "content": "\\n# Code\\n```\\nclass myCmp{\\n    public:\\n    bool operator()(pair<int,int>p1,pair<int,int>p2){\\n        return p1.first>p2.first;\\n    }\\n};\\n\\nclass Twitter {\\npublic:\\n    map<int,vector<pair<int,int>>>mp;\\n    map<int,set<int>>adj;\\n    int time;\\n    Twitter() {\\n        time=1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        mp[userId].push_back({time++,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,myCmp>q;\\n        vector<int>res;\\n        for(auto x:mp[userId]){\\n            q.push({x.first,x.second});\\n            if(q.size()>10)q.pop();\\n        }\\n\\n        for(auto x:adj[userId]){\\n            for(auto y:mp[x]){\\n                q.push({y.first,y.second});\\n                if(q.size()>10)q.pop();\\n            }\\n        }\\n        while(!q.empty()){\\n            res.push_back(q.top().second);\\n            q.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n\\n        \\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        adj[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        adj[followerId].erase(followeeId);\\n        \\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass myCmp{\\n    public:\\n    bool operator()(pair<int,int>p1,pair<int,int>p2){\\n        return p1.first>p2.first;\\n    }\\n};\\n\\nclass Twitter {\\npublic:\\n    map<int,vector<pair<int,int>>>mp;\\n    map<int,set<int>>adj;\\n    int time;\\n    Twitter() {\\n        time=1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        mp[userId].push_back({time++,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,myCmp>q;\\n        vector<int>res;\\n        for(auto x:mp[userId]){\\n            q.push({x.first,x.second});\\n            if(q.size()>10)q.pop();\\n        }\\n\\n        for(auto x:adj[userId]){\\n            for(auto y:mp[x]){\\n                q.push({y.first,y.second});\\n                if(q.size()>10)q.pop();\\n            }\\n        }\\n        while(!q.empty()){\\n            res.push_back(q.top().second);\\n            q.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n\\n        \\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        adj[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        adj[followerId].erase(followeeId);\\n        \\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720611,
                "title": "java-simple-hashmap-stack",
                "content": "This is a very simple approach that works quite well. (16s execution, 42MB storage)\\nCan someone please suggest improvements or highlight issues with this solution?\\nWhy do we prefer linkedlists for tweets?\\n\\n```\\nclass Twitter {\\n    Stack<Pair<Integer,Integer>> tweets;\\n    HashMap<Integer, Set<Integer>> network;\\n\\n    public Twitter() {\\n\\t\\ttweets = new Stack<>();\\n\\t\\tnetwork = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets.push(new Pair(userId, tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        Stack<Pair<Integer, Integer>> store = new Stack<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Set<Integer> following = network.getOrDefault(userId, new HashSet<>());\\n        \\n        while(tweets.size()!=0 && ans.size()!=10){\\n            Pair<Integer, Integer> curr = tweets.pop();\\n            if((following.contains(curr.getKey()) || curr.getKey()==userId)\\n               && ans.size()!=10) ans.add(curr.getValue());\\n            store.push(curr);\\n        }\\n        while(store.size()!=0) tweets.push(store.pop());\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> following = network.getOrDefault(followerId, new HashSet<>());\\n        following.add(followeeId);\\n        network.put(followerId, following);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        Set<Integer> following = network.get(followerId);\\n        if(following == null) return;\\n        following.remove(followeeId);\\n        network.put(followerId, following);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Twitter {\\n    Stack<Pair<Integer,Integer>> tweets;\\n    HashMap<Integer, Set<Integer>> network;\\n\\n    public Twitter() {\\n\\t\\ttweets = new Stack<>();\\n\\t\\tnetwork = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets.push(new Pair(userId, tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        Stack<Pair<Integer, Integer>> store = new Stack<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Set<Integer> following = network.getOrDefault(userId, new HashSet<>());\\n        \\n        while(tweets.size()!=0 && ans.size()!=10){\\n            Pair<Integer, Integer> curr = tweets.pop();\\n            if((following.contains(curr.getKey()) || curr.getKey()==userId)\\n               && ans.size()!=10) ans.add(curr.getValue());\\n            store.push(curr);\\n        }\\n        while(store.size()!=0) tweets.push(store.pop());\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> following = network.getOrDefault(followerId, new HashSet<>());\\n        following.add(followeeId);\\n        network.put(followerId, following);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        Set<Integer> following = network.get(followerId);\\n        if(following == null) return;\\n        following.remove(followeeId);\\n        network.put(followerId, following);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058855,
                "title": "c-0ms-with-clear-explanation",
                "content": "1. Use a hash table(followList) to maintain each user\\'s followee, so this way we can finish function follow and unfollow.\\n2. Use a 2D vector(v) to record user\\'s tweetId.\\n3. We also need a hash table(time) to maintain tweetId and time, because the problem requests we need to retrieve 10 most recent tweetId.\\n4. Function postTweet we just update vector(v), and record the time about the tweetId.\\n5. Function getNewsFeed we use a max heap to retrieve 10 most recent tweetId according to variable(t).\\n\\n```\\nclass Twitter {\\n    unordered_map<int,unordered_set<int>> followList; //(user,followee)\\n    vector<vector<int>> v; //(tweetId)\\n    unordered_map<int,int> time; //(tweetId,time)\\n    int t = 0;\\npublic:\\n    Twitter() {\\n        for (int i = 1; i <= 500; ++i)\\n            followList[i].insert(i);\\n        v.resize(501);\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        v[userId].push_back(tweetId);\\n        time[tweetId] = t++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>> pq; //max heap, (time,tweetId)\\n        for (auto &user : followList[userId]) {\\n            for (auto &post : v[user]) {\\n                pq.push({time[post], post});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            res.push_back(pq.top().second);\\n            if (res.size() == 10) return res; //retrieve the 10 most recent tweetId\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followList[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followList[followerId].erase(followeeId);\\n    }\\n};\\n```\\n**If this post help you, please upvote it!**",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n    unordered_map<int,unordered_set<int>> followList; //(user,followee)\\n    vector<vector<int>> v; //(tweetId)\\n    unordered_map<int,int> time; //(tweetId,time)\\n    int t = 0;\\npublic:\\n    Twitter() {\\n        for (int i = 1; i <= 500; ++i)\\n            followList[i].insert(i);\\n        v.resize(501);\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        v[userId].push_back(tweetId);\\n        time[tweetId] = t++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>> pq; //max heap, (time,tweetId)\\n        for (auto &user : followList[userId]) {\\n            for (auto &post : v[user]) {\\n                pq.push({time[post], post});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            res.push_back(pq.top().second);\\n            if (res.size() == 10) return res; //retrieve the 10 most recent tweetId\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followList[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followList[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817073,
                "title": "0-ms-no-heap-only-hashmap-and-list-o-n-time-c",
                "content": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int, unordered_set<int>> followed; //users following set\\n    unordered_map<int, int> tweetedBy; // tweeted by which user\\n    list<int> tweet; // list of all tweets : new tweets are append at start\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int uid, int tid) {\\n        tweetedBy[tid] = uid;\\n        tweet.push_front(tid);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> answer;\\n        \\n        for(auto it:tweet)\\n        {\\n            int uid = tweetedBy[it];\\n            if(uid == userId || followed[userId].find(uid) != followed[userId].end())\\n            {\\n                answer.push_back(it);\\n                if(answer.size() == 10) return answer;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    void follow(int id1, int id2) {\\n        followed[id1].insert(id2);\\n    }\\n    \\n    void unfollow(int id1, int id2) {\\n        followed[id1].erase(id2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int, unordered_set<int>> followed; //users following set\\n    unordered_map<int, int> tweetedBy; // tweeted by which user\\n    list<int> tweet; // list of all tweets : new tweets are append at start\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int uid, int tid) {\\n        tweetedBy[tid] = uid;\\n        tweet.push_front(tid);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> answer;\\n        \\n        for(auto it:tweet)\\n        {\\n            int uid = tweetedBy[it];\\n            if(uid == userId || followed[userId].find(uid) != followed[userId].end())\\n            {\\n                answer.push_back(it);\\n                if(answer.size() == 10) return answer;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    void follow(int id1, int id2) {\\n        followed[id1].insert(id2);\\n    }\\n    \\n    void unfollow(int id1, int id2) {\\n        followed[id1].erase(id2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832259,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nuse std::collections::{BinaryHeap, HashMap, HashSet};\\n\\n#[derive(Debug, Default)]\\nstruct Twitter {\\n    time: i32,\\n    tweets: HashMap<i32, Vec<(i32, i32)>>,\\n    fans: HashMap<i32, HashSet<i32>>,\\n}\\n\\nconst FEED_MAX_LEN: usize = 10;\\n\\nimpl Twitter {\\n    /** Initialize your data structure here. */\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    /** Compose a new tweet. */\\n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\\n        if !self.tweets.contains_key(&user_id) {\\n            self.tweets.insert(user_id, Default::default());\\n            self.follow(user_id, user_id);\\n        }\\n        self.tweets.get_mut(&user_id).unwrap()\\n             .insert(0, (self.time, tweet_id));\\n        self.time -= 1;\\n    }\\n\\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    fn get_news_feed(&self, user_id: i32) -> Vec<i32> {\\n        let mut heap = BinaryHeap::<(i32, i32)>::new();\\n        if let Some(set) = self.fans.get(&user_id) {\\n            for f in set {\\n                if let Some(tweets) = self.tweets.get(f) {\\n                    for t in tweets {\\n                        if heap.len() < FEED_MAX_LEN {\\n                            heap.push(*t);\\n                        } else {\\n                            if t.0 >= heap.peek().unwrap().0 {\\n                                break;\\n                            } else {\\n                                heap.push(*t);\\n                                heap.pop();\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n//        println!(\"{:?}\", heap);\\n        let mut ans = vec![];\\n        while let Some(x) = heap.pop() {\\n            ans.insert(0, x.1);\\n         }\\n        ans\\n    }\\n\\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.fans\\n            .entry(follower_id)\\n            .or_default()\\n            .insert(followee_id);\\n    }\\n\\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\\n        if followee_id != follower_id {\\n            self.fans\\n                .entry(follower_id)\\n                .or_default()\\n                .remove(&followee_id);\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_twitter() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n        twitter.follow(1, 2);\\n        twitter.post_tweet(2, 6);\\n        //        println!(\"{:?}\", twitter);\\n        assert_eq!(twitter.get_news_feed(1), vec![6, 5]);\\n        twitter.unfollow(1, 2);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n    }\\n\\n    #[test]\\n    fn test_twitter_02() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        twitter.unfollow(1, 1);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n    }\\n\\n    #[test]\\n    fn test_twitter_03() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        twitter.post_tweet(2, 3);\\n        twitter.post_tweet(1, 101);\\n        twitter.post_tweet(2, 13);\\n        twitter.post_tweet(2, 10);\\n        twitter.post_tweet(1, 2);\\n        twitter.post_tweet(1, 94);\\n        twitter.post_tweet(2, 505);\\n        twitter.post_tweet(1, 333);\\n        twitter.post_tweet(2, 22);\\n        twitter.post_tweet(1, 11);\\n        twitter.post_tweet(1, 205);\\n        twitter.post_tweet(2, 203);\\n        twitter.post_tweet(1, 201);\\n        twitter.post_tweet(2, 213);\\n        twitter.post_tweet(1, 200);\\n        twitter.post_tweet(2, 202);\\n        twitter.post_tweet(1, 204);\\n        twitter.post_tweet(2, 208);\\n        twitter.post_tweet(2, 233);\\n        twitter.post_tweet(1, 222);\\n        twitter.post_tweet(2, 211);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n        );\\n        twitter.follow(1, 2);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![211, 222, 233, 208, 204, 202, 200, 213, 201, 203]\\n        );\\n        twitter.unfollow(1, 2);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::{BinaryHeap, HashMap, HashSet};\\n\\n#[derive(Debug, Default)]\\nstruct Twitter {\\n    time: i32,\\n    tweets: HashMap<i32, Vec<(i32, i32)>>,\\n    fans: HashMap<i32, HashSet<i32>>,\\n}\\n\\nconst FEED_MAX_LEN: usize = 10;\\n\\nimpl Twitter {\\n    /** Initialize your data structure here. */\\n    fn new() -> Self {\\n        Default::default()\\n    }\\n\\n    /** Compose a new tweet. */\\n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\\n        if !self.tweets.contains_key(&user_id) {\\n            self.tweets.insert(user_id, Default::default());\\n            self.follow(user_id, user_id);\\n        }\\n        self.tweets.get_mut(&user_id).unwrap()\\n             .insert(0, (self.time, tweet_id));\\n        self.time -= 1;\\n    }\\n\\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    fn get_news_feed(&self, user_id: i32) -> Vec<i32> {\\n        let mut heap = BinaryHeap::<(i32, i32)>::new();\\n        if let Some(set) = self.fans.get(&user_id) {\\n            for f in set {\\n                if let Some(tweets) = self.tweets.get(f) {\\n                    for t in tweets {\\n                        if heap.len() < FEED_MAX_LEN {\\n                            heap.push(*t);\\n                        } else {\\n                            if t.0 >= heap.peek().unwrap().0 {\\n                                break;\\n                            } else {\\n                                heap.push(*t);\\n                                heap.pop();\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n//        println!(\"{:?}\", heap);\\n        let mut ans = vec![];\\n        while let Some(x) = heap.pop() {\\n            ans.insert(0, x.1);\\n         }\\n        ans\\n    }\\n\\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.fans\\n            .entry(follower_id)\\n            .or_default()\\n            .insert(followee_id);\\n    }\\n\\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\\n        if followee_id != follower_id {\\n            self.fans\\n                .entry(follower_id)\\n                .or_default()\\n                .remove(&followee_id);\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_twitter() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n        twitter.follow(1, 2);\\n        twitter.post_tweet(2, 6);\\n        //        println!(\"{:?}\", twitter);\\n        assert_eq!(twitter.get_news_feed(1), vec![6, 5]);\\n        twitter.unfollow(1, 2);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n    }\\n\\n    #[test]\\n    fn test_twitter_02() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        twitter.unfollow(1, 1);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(twitter.get_news_feed(1), vec![5]);\\n    }\\n\\n    #[test]\\n    fn test_twitter_03() {\\n        let mut twitter = Twitter::new();\\n        twitter.post_tweet(1, 5);\\n        twitter.post_tweet(2, 3);\\n        twitter.post_tweet(1, 101);\\n        twitter.post_tweet(2, 13);\\n        twitter.post_tweet(2, 10);\\n        twitter.post_tweet(1, 2);\\n        twitter.post_tweet(1, 94);\\n        twitter.post_tweet(2, 505);\\n        twitter.post_tweet(1, 333);\\n        twitter.post_tweet(2, 22);\\n        twitter.post_tweet(1, 11);\\n        twitter.post_tweet(1, 205);\\n        twitter.post_tweet(2, 203);\\n        twitter.post_tweet(1, 201);\\n        twitter.post_tweet(2, 213);\\n        twitter.post_tweet(1, 200);\\n        twitter.post_tweet(2, 202);\\n        twitter.post_tweet(1, 204);\\n        twitter.post_tweet(2, 208);\\n        twitter.post_tweet(2, 233);\\n        twitter.post_tweet(1, 222);\\n        twitter.post_tweet(2, 211);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n        );\\n        twitter.follow(1, 2);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![211, 222, 233, 208, 204, 202, 200, 213, 201, 203]\\n        );\\n        twitter.unfollow(1, 2);\\n        println!(\"{:?}\", twitter);\\n        assert_eq!(\\n            twitter.get_news_feed(1),\\n            vec![222, 204, 200, 201, 205, 11, 333, 94, 2, 101]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747492,
                "title": "simple-easy-to-understand-c-solution-xd",
                "content": "```\\nclass Twitter {\\nprivate: \\n    int counter=1; /*tweet number*/\\n    unordered_map<int,unordered_set<int>>fl; /*follow List*/\\n    unordered_map<int,vector<vector<int>>>tw; /*{tweet, counter}*/\\n    \\n    struct comp{\\n      bool operator()(vector<int>& a, vector<int>& b) {\\n          return a[1]<b[1];\\n      }\\n    };\\n    \\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tw[userId].push_back({tweetId,counter});\\n        counter++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<vector<int>,vector<vector<int>>,comp> pq;\\n        for(auto& a : tw[userId]) \\n            pq.push({a[0],a[1]});\\n        for(auto& a : fl[userId]) {\\n            for(auto& b : tw[a]) \\n                pq.push({b[0],b[1]});\\n        }\\n        vector<int>list;\\n        int size=(pq.size()<10)?pq.size():10;\\n        while(size-->0) {\\n            int tweet=pq.top()[0];\\n            pq.pop();\\n            list.push_back(tweet);\\n        }\\n        return list;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(followerId!=followeeId)\\n            fl[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        fl[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Twitter {\\nprivate: \\n    int counter=1; /*tweet number*/\\n    unordered_map<int,unordered_set<int>>fl; /*follow List*/\\n    unordered_map<int,vector<vector<int>>>tw; /*{tweet, counter}*/\\n    \\n    struct comp{\\n      bool operator()(vector<int>& a, vector<int>& b) {\\n          return a[1]<b[1];\\n      }\\n    };\\n    \\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tw[userId].push_back({tweetId,counter});\\n        counter++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<vector<int>,vector<vector<int>>,comp> pq;\\n        for(auto& a : tw[userId]) \\n            pq.push({a[0],a[1]});\\n        for(auto& a : fl[userId]) {\\n            for(auto& b : tw[a]) \\n                pq.push({b[0],b[1]});\\n        }\\n        vector<int>list;\\n        int size=(pq.size()<10)?pq.size():10;\\n        while(size-->0) {\\n            int tweet=pq.top()[0];\\n            pq.pop();\\n            list.push_back(tweet);\\n        }\\n        return list;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(followerId!=followeeId)\\n            fl[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        fl[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741965,
                "title": "java-solution",
                "content": "``` java\\nclass Twitter {\\n\\n    Map<Integer, Set<Integer>> userFollowMap;\\n    List<Integer> postUser;\\n    List<Integer> post;\\n    \\n    public Twitter() {\\n        userFollowMap = new HashMap<>();\\n        postUser = new ArrayList<>();\\n        post = new ArrayList<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        postUser.add(userId);\\n        post.add(tweetId);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = userFollowMap.get(userId);\\n        int i = 0, j = post.size() - 1;\\n        while(i < 10 && j >= 0) {\\n            if(postUser.get(j) == userId || (set != null && set.contains(postUser.get(j)))){\\n                list.add(post.get(j));\\n                i++;\\n            }\\n            j--;\\n        }\\n        return list;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(userFollowMap.get(followerId) == null){\\n            userFollowMap.put(followerId, new HashSet<>());\\n        }\\n        userFollowMap.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(userFollowMap.get(followerId) != null) userFollowMap.get(followerId).remove(followeeId);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Twitter {\\n\\n    Map<Integer, Set<Integer>> userFollowMap;\\n    List<Integer> postUser;\\n    List<Integer> post;\\n    \\n    public Twitter() {\\n        userFollowMap = new HashMap<>();\\n        postUser = new ArrayList<>();\\n        post = new ArrayList<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        postUser.add(userId);\\n        post.add(tweetId);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> list = new ArrayList<>();\\n        Set<Integer> set = userFollowMap.get(userId);\\n        int i = 0, j = post.size() - 1;\\n        while(i < 10 && j >= 0) {\\n            if(postUser.get(j) == userId || (set != null && set.contains(postUser.get(j)))){\\n                list.add(post.get(j));\\n                i++;\\n            }\\n            j--;\\n        }\\n        return list;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(userFollowMap.get(followerId) == null){\\n            userFollowMap.put(followerId, new HashSet<>());\\n        }\\n        userFollowMap.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(userFollowMap.get(followerId) != null) userFollowMap.get(followerId).remove(followeeId);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82875,
                "title": "java-164ms-solution-97-using-head-for-merging-one-tweet-at-a-time-instead-of-sorting-the-entire-tweets",
                "content": "Key points: \\n 1. Maintaining a sorted tweets list of each user with O(1) time by adding to the tail each time.\\n 2. Customized a comparator class which traverses a list from its tail to its head.\\n 3. The heap, first, store all the tail of those tweet lists followed by a user.\\n 4. Poll the list contains the latest tweet and then moves its index to the next tweet. If this list has next tweet, put it back to the heap.\\n\\n\\n    public class Twitter {\\n        Map<Integer, Set<Integer>> follows; // store one user's follows\\n        Map<Integer, List<Integer>> userTweets; // store index of one user's tweets \\n        List<Integer> tweets; // store every tweets and use its index as the sequence id or timestamp \\n        \\n        // the wrapper class of one user's tweets, which is similar to an itertor to read from backward \\n        class UserTweetList{\\n            List<Integer> list;\\n            int idx;\\n            UserTweetList(List<Integer> list) {\\n                this.list = list;\\n                if (list == null || list.isEmpty() ) idx = -1;\\n                else idx = list.size()-1; // initial the index from the tail of a list\\n            }\\n            // check the timestamp of current index\\n            Integer peek(){ \\n                if (idx < 0) return null;\\n                return list.get(idx);\\n            }\\n            // get the tweet ID from the tweet list and then move the index to the next one\\n            Integer getVal(){\\n                if (idx < 0) return null;\\n                int id = list.get(idx--); \\n                return tweets.get(id);\\n            }\\n        }\\n        // Comparator class for max-heap ordered by timestamp\\n        class UTLComp implements Comparator<UserTweetList>{ \\n            public int compare(UserTweetList ut1, UserTweetList ut2) {\\n                if (ut1.peek()==null && ut2.peek()==null) return 0;\\n                if (ut1.peek()==null) return 1;\\n                if (ut2.peek()==null) return -1;\\n                return ut2.peek()-ut1.peek();\\n            }\\n        }\\n    \\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            follows = new HashMap<Integer, Set<Integer>>();\\n            userTweets = new HashMap<Integer, List<Integer>>();\\n            tweets = new ArrayList<Integer>();\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) { // O(1)\\n            tweets.add(tweetId);\\n            if (! follows.containsKey(userId) ) {\\n                follows.put(userId, new HashSet<Integer>() );\\n            }\\n            follows.get(userId).add(userId);\\n            if (! userTweets.containsKey(userId) ) { \\n                userTweets.put(userId, new ArrayList<Integer>());\\n            }\\n            // add to the end of user's tweet list so it is also sorted\\n            userTweets.get(userId).add(tweets.size()-1);\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            PriorityQueue<UserTweetList> heap = new PriorityQueue<UserTweetList>(1, new UTLComp() );\\n            if (! follows.containsKey(userId) ) return ret;\\n            // gather the following users' list. k*O(k), k is the number of follows\\n            for(int follow: follows.get(userId)) {   \\n                if (userTweets.containsKey(follow)) {\\n                    List<Integer> list = userTweets.get(follow);\\n                    if (! list.isEmpty() )\\n                        heap.offer( new UserTweetList(list));\\n                }\\n            }\\n            // similar to merge sort, \\n            // take the largest one from a list and then poll the next one in this list into the queue\\n            while ( (ret.size() < 10) && ! heap.isEmpty() ) { // O ( 10*2*log(k)) \\n                UserTweetList ut = heap.poll(); // poll the list containing the latest tweet\\n                ret.add(ut.getVal()); // add the latest tweet to returning list\\n                // if the list has next one, put back to the heap\\n                if (ut.peek() != null) heap.offer(ut); // \\n            }\\n            return ret;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) { // O(1)\\n            if (! follows.containsKey(followerId) ) {\\n                follows.put(followerId, new HashSet<Integer>());\\n            }\\n            follows.get(followerId).add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) { //O(1)\\n            if ( (followerId != followeeId) && (follows.containsKey(followerId)  ) ) {\\n                follows.get(followerId).remove(followeeId);\\n            } \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Key points: \\n 1. Maintaining a sorted tweets list of each user with O(1) time by adding to the tail each time.\\n 2. Customized a comparator class which traverses a list from its tail to its head.\\n 3. The heap, first, store all the tail of those tweet lists followed by a user.\\n 4. Poll the list contains the latest tweet and then moves its index to the next tweet. If this list has next tweet, put it back to the heap.\\n\\n\\n    public class Twitter {\\n        Map<Integer, Set<Integer>> follows; // store one user's follows\\n        Map<Integer, List<Integer>> userTweets; // store index of one user's tweets \\n        List<Integer> tweets; // store every tweets and use its index as the sequence id or timestamp \\n        \\n        // the wrapper class of one user's tweets, which is similar to an itertor to read from backward \\n        class UserTweetList{\\n            List<Integer> list;\\n            int idx;\\n            UserTweetList(List<Integer> list) {\\n                this.list = list;\\n                if (list == null || list.isEmpty() ) idx = -1;\\n                else idx = list.size()-1; // initial the index from the tail of a list\\n            }\\n            // check the timestamp of current index\\n            Integer peek(){ \\n                if (idx < 0) return null;\\n                return list.get(idx);\\n            }\\n            // get the tweet ID from the tweet list and then move the index to the next one\\n            Integer getVal(){\\n                if (idx < 0) return null;\\n                int id = list.get(idx--); \\n                return tweets.get(id);\\n            }\\n        }\\n        // Comparator class for max-heap ordered by timestamp\\n        class UTLComp implements Comparator<UserTweetList>{ \\n            public int compare(UserTweetList ut1, UserTweetList ut2) {\\n                if (ut1.peek()==null && ut2.peek()==null) return 0;\\n                if (ut1.peek()==null) return 1;\\n                if (ut2.peek()==null) return -1;\\n                return ut2.peek()-ut1.peek();\\n            }\\n        }\\n    \\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            follows = new HashMap<Integer, Set<Integer>>();\\n            userTweets = new HashMap<Integer, List<Integer>>();\\n            tweets = new ArrayList<Integer>();\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) { // O(1)\\n            tweets.add(tweetId);\\n            if (! follows.containsKey(userId) ) {\\n                follows.put(userId, new HashSet<Integer>() );\\n            }\\n            follows.get(userId).add(userId);\\n            if (! userTweets.containsKey(userId) ) { \\n                userTweets.put(userId, new ArrayList<Integer>());\\n            }\\n            // add to the end of user's tweet list so it is also sorted\\n            userTweets.get(userId).add(tweets.size()-1);\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            List<Integer> ret = new ArrayList<Integer>();\\n            PriorityQueue<UserTweetList> heap = new PriorityQueue<UserTweetList>(1, new UTLComp() );\\n            if (! follows.containsKey(userId) ) return ret;\\n            // gather the following users' list. k*O(k), k is the number of follows\\n            for(int follow: follows.get(userId)) {   \\n                if (userTweets.containsKey(follow)) {\\n                    List<Integer> list = userTweets.get(follow);\\n                    if (! list.isEmpty() )\\n                        heap.offer( new UserTweetList(list));\\n                }\\n            }\\n            // similar to merge sort, \\n            // take the largest one from a list and then poll the next one in this list into the queue\\n            while ( (ret.size() < 10) && ! heap.isEmpty() ) { // O ( 10*2*log(k)) \\n                UserTweetList ut = heap.poll(); // poll the list containing the latest tweet\\n                ret.add(ut.getVal()); // add the latest tweet to returning list\\n                // if the list has next one, put back to the heap\\n                if (ut.peek() != null) heap.offer(ut); // \\n            }\\n            return ret;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) { // O(1)\\n            if (! follows.containsKey(followerId) ) {\\n                follows.put(followerId, new HashSet<Integer>());\\n            }\\n            follows.get(followerId).add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) { //O(1)\\n            if ( (followerId != followeeId) && (follows.containsKey(followerId)  ) ) {\\n                follows.get(followerId).remove(followeeId);\\n            } \\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3962016,
                "title": "see-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        // 10 tweets\\n        int count = 10;\\n        vector<int> result;\\n        \\n        // since postTweet pushes to the back, looping from back gets most recent\\n        for (int i = posts.size() - 1; i >= 0; i--) {\\n            if (count == 0) {\\n                break;\\n            }\\n            \\n            int followingId = posts[i].first;\\n            int tweetId = posts[i].second;\\n            unordered_set<int> following = followMap[userId];\\n            // add to result if they\\'re following them or it\\'s a tweet from themself\\n            if (following.find(followingId) != following.end() || followingId == userId) {\\n                result.push_back(tweetId);\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followMap[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followMap[followerId].erase(followeeId);\\n    }\\nprivate:\\n    // pairs: [user, tweet]\\n    vector<pair<int, int>> posts;\\n    // hash map: {user -> people they follow}\\n    unordered_map<int, unordered_set<int>> followMap;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        // 10 tweets\\n        int count = 10;\\n        vector<int> result;\\n        \\n        // since postTweet pushes to the back, looping from back gets most recent\\n        for (int i = posts.size() - 1; i >= 0; i--) {\\n            if (count == 0) {\\n                break;\\n            }\\n            \\n            int followingId = posts[i].first;\\n            int tweetId = posts[i].second;\\n            unordered_set<int> following = followMap[userId];\\n            // add to result if they\\'re following them or it\\'s a tweet from themself\\n            if (following.find(followingId) != following.end() || followingId == userId) {\\n                result.push_back(tweetId);\\n                count--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followMap[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followMap[followerId].erase(followeeId);\\n    }\\nprivate:\\n    // pairs: [user, tweet]\\n    vector<pair<int, int>> posts;\\n    // hash map: {user -> people they follow}\\n    unordered_map<int, unordered_set<int>> followMap;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869194,
                "title": "beats-100-8ms-java",
                "content": "# Code\\n```\\nclass Twitter {\\n\\n    ArrayList<Tweet> tweets;\\n    HashMap<Integer, User> users; \\n\\n    public Twitter() {\\n        tweets = new ArrayList<>();\\n        users = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(!users.containsKey(userId))\\n            users.put(userId, new User(userId));\\n        tweets.add(new Tweet(tweetId, userId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        if(!users.containsKey(userId))\\n            users.put(userId, new User(userId));\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int i = tweets.size()-1;\\n        while(ans.size()<10 && i>=0) {\\n            if(tweets.get(i).userId==userId || users.get(userId).follows.contains(tweets.get(i).userId))\\n                ans.add(tweets.get(i).tweetId);\\n            i--;\\n        }\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!users.containsKey(followerId))\\n            users.put(followerId, new User(followerId));\\n        if(!users.containsKey(followeeId))\\n            users.put(followeeId, new User(followeeId));\\n        User user = users.get(followerId);\\n        user.follows.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(!users.containsKey(followerId))\\n            users.put(followerId, new User(followerId));\\n        if(!users.containsKey(followeeId))\\n            users.put(followeeId, new User(followeeId));\\n        User user = users.get(followerId);\\n        user.follows.remove(followeeId);\\n    }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int userId;\\n    Tweet(int t, int u) {\\n        tweetId = t;\\n        userId = u;\\n    }\\n}\\n\\nclass User {\\n    int userId;\\n    HashSet<Integer> follows;\\n    User(int u) {\\n        userId = u;\\n        follows = new HashSet<>();\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Twitter {\\n\\n    ArrayList<Tweet> tweets;\\n    HashMap<Integer, User> users; \\n\\n    public Twitter() {\\n        tweets = new ArrayList<>();\\n        users = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(!users.containsKey(userId))\\n            users.put(userId, new User(userId));\\n        tweets.add(new Tweet(tweetId, userId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        if(!users.containsKey(userId))\\n            users.put(userId, new User(userId));\\n        List<Integer> ans = new ArrayList<Integer>();\\n        int i = tweets.size()-1;\\n        while(ans.size()<10 && i>=0) {\\n            if(tweets.get(i).userId==userId || users.get(userId).follows.contains(tweets.get(i).userId))\\n                ans.add(tweets.get(i).tweetId);\\n            i--;\\n        }\\n        return ans;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!users.containsKey(followerId))\\n            users.put(followerId, new User(followerId));\\n        if(!users.containsKey(followeeId))\\n            users.put(followeeId, new User(followeeId));\\n        User user = users.get(followerId);\\n        user.follows.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(!users.containsKey(followerId))\\n            users.put(followerId, new User(followerId));\\n        if(!users.containsKey(followeeId))\\n            users.put(followeeId, new User(followeeId));\\n        User user = users.get(followerId);\\n        user.follows.remove(followeeId);\\n    }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int userId;\\n    Tweet(int t, int u) {\\n        tweetId = t;\\n        userId = u;\\n    }\\n}\\n\\nclass User {\\n    int userId;\\n    HashSet<Integer> follows;\\n    User(int u) {\\n        userId = u;\\n        follows = new HashSet<>();\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633987,
                "title": "c-best-explanation-0ms-easy-solution",
                "content": "# Approach\\n- postTweet(int userId, int tweetId):\\n1) Simply append the pair of user ID and tweet ID to the post vector.\\n\\n\\n---\\n\\n\\n- getNewsFeed(int userId):\\n1) Iterate from the post vector in reverse order and check if it was posted by the given user or if the user follows the author of the tweet (according to the followerList map).\\n2) If the tweet satisfies the above condition, its tweet ID is added to the feed vector.\\n3) The iteration continues until either 10 tweets are added to the feed vector or there are no more tweets to consider.\\n4) Return the feed vector.\\n\\n---\\n\\n\\n- follow(int followerId, int followedId):\\n1) Update the followerList unordered_map by setting the value of followedId for the key followerId to 1, indicating that followerId is following followedId.\\n\\n---\\n\\n\\n- unfollow(int followerId, int followedId):\\n1) Update the followerList unordered_map by setting the value of followedId for the key followerId to 0, indicating that followerId is not following followedId.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n1) postTweet(int userId, int tweetId): O(1)\\n2) getNewsFeed(int userId): O(n) where n is the number of tweets.\\n3) follow(int followerId, int followedId): O(1)\\n4) unfollow(int followerId, int followedId): O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n1) post vector: O(n) where n is the number of tweets.\\n2) unordered map: O(n) where n is total number of followers of all people.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_map<int,int>> followerList;\\n    vector<pair<int,int>> post;\\n\\n    void postTweet(int userId, int tweetId) {\\n        post.push_back({userId,tweetId});    \\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int i=post.size()-1,count=10;\\n        while(i>=0 && count>0){\\n            if(post[i].first==userId || followerList[userId][post[i].first]){\\n                feed.push_back(post[i].second);\\n                count--;\\n            }\\n            i--;\\n        }\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followedId) {\\n        followerList[followerId][followedId]=1;\\n    }\\n    \\n    void unfollow(int followerId, int followedId) {\\n        followerList[followerId][followedId]=0;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_map<int,int>> followerList;\\n    vector<pair<int,int>> post;\\n\\n    void postTweet(int userId, int tweetId) {\\n        post.push_back({userId,tweetId});    \\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int i=post.size()-1,count=10;\\n        while(i>=0 && count>0){\\n            if(post[i].first==userId || followerList[userId][post[i].first]){\\n                feed.push_back(post[i].second);\\n                count--;\\n            }\\n            i--;\\n        }\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followedId) {\\n        followerList[followerId][followedId]=1;\\n    }\\n    \\n    void unfollow(int followerId, int followedId) {\\n        followerList[followerId][followedId]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536377,
                "title": "java-2-simple-solutions-o-n-100-and-o-nlogn-85-94",
                "content": "This solution is 85.94% in runtime. It\\'s an O(nlogn) solution.\\n\\n```java\\nclass Twitter {\\n    private final Map<Integer, User> userMap;\\n\\n    public Twitter() {\\n        this.userMap = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        this.userMap.get(userId).postTweet(new Tweet(tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        \\n        Set<Integer> following = this.userMap.get(userId).following;\\n\\n        PriorityQueue<Tweet> maxHeap = new PriorityQueue<>(following.size(), (a, b) -> b.time - a.time);\\n\\n        for(int id : following)\\n            if(userMap.get(id).tweets.head() != null)\\n                maxHeap.offer(userMap.get(id).tweets.head());\\n\\n        int n = 0;\\n\\n        while(maxHeap.size() > 0 && n < 10) {\\n            Tweet tweet = maxHeap.poll();\\n\\n            result.add(tweet.id);\\n\\n            if(tweet.next != null)\\n                maxHeap.offer(tweet.next);\\n\\n            n++;\\n        }\\n\\n        return result;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).follow(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).unfollow(followeeId);\\n    }\\n\\n    private class User {\\n        public final Set<Integer> following;\\n        public final TweetList tweets;\\n        \\n        private int n;\\n\\n        public User(final int id) {\\n            this.following = new HashSet<>();\\n            this.tweets = new TweetList();\\n            this.n = 0;\\n            this.follow(id);\\n        }\\n\\n        public void postTweet(final Tweet tweet) {\\n            this.tweets.add(tweet);\\n        }\\n\\n        public void follow(final int id) {\\n            this.following.add(id);\\n        }\\n\\n        public void unfollow(final int id) {\\n            this.following.remove(id);\\n        }\\n    }\\n\\n    private class Tweet {\\n        private static int timeStamp = 0;\\n        public final int id;\\n        public final int time;\\n        public Tweet next;\\n        public Tweet prev;\\n\\n        public Tweet(final int id) {\\n            this.id = id;\\n            this.prev = null;\\n            this.next = null;\\n            time = timeStamp++;\\n        }\\n    }\\n\\n    private class TweetList {\\n        private Tweet dummyHead;\\n        private Tweet tail;\\n        private int size;\\n\\n        public TweetList() {\\n            this.size = 0;\\n            this.dummyHead = new Tweet(-1);\\n        }\\n\\n        public void add(Tweet tweet) {\\n            if(this.size == 0) {\\n                this.dummyHead.next = tweet;\\n                tweet.prev = this.dummyHead;\\n                tail = tweet;\\n            } else {\\n                tweet.next = this.dummyHead.next;\\n                tweet.prev = this.dummyHead;\\n                this.dummyHead.next.prev = tweet;\\n                this.dummyHead.next = tweet;\\n            }\\n\\n            this.size++;\\n\\n            if(this.size > 10)\\n                this.remove();\\n        }\\n\\n        public Tweet head() {\\n            return this.dummyHead.next;\\n        }\\n\\n        private Tweet remove() {\\n            if(this.size == 0)            \\n                return null;\\n\\n            this.tail.prev.next = null;\\n            this.tail = this.tail.prev;\\n\\n            this.size--;\\n\\n            if(this.size == 0)\\n                this.tail = null;\\n\\n            return this.tail;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```\\n\\nThis one is 100% in runtime. It\\'s an O(n) solution.\\n\\n```java\\nclass Twitter {\\n    private final Map<Integer, User> userMap;\\n\\n    public Twitter() {\\n        this.userMap = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        this.userMap.get(userId).postTweet(new Tweet(tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        \\n        Set<Integer> following = this.userMap.get(userId).following;\\n\\n        Tweet[] tweets = new Tweet[following.size()];\\n\\n        int i = 0;\\n\\n        for(int id : following)\\n            if(userMap.get(id).tweets.head() != null)\\n                tweets[i++] = userMap.get(id).tweets.head();\\n\\n        int n = 0;\\n        Tweet added = null;\\n\\n        do {\\n            added = null;\\n            int index = 0;\\n\\n            for(int j = 0; j < tweets.length; ++j) {\\n                if(added == null && tweets[j] != null)\\n                    added = tweets[j];\\n\\n                if(added != null && tweets[j] != null && added.time < tweets[j].time) {\\n                    added = tweets[j];\\n                    index = j;\\n                }\\n            }\\n\\n            if(added != null) {\\n                result.add(added.id);\\n                tweets[index] = added.next;\\n            }\\n            \\n            n++;\\n        } while(added != null && n < 10);\\n\\n        return result;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).follow(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).unfollow(followeeId);\\n    }\\n\\n    private class User {\\n        public final Set<Integer> following;\\n        public final TweetList tweets;\\n        \\n        private int n;\\n\\n        public User(final int id) {\\n            this.following = new HashSet<>();\\n            this.tweets = new TweetList();\\n            this.n = 0;\\n            this.follow(id);\\n        }\\n\\n        public void postTweet(final Tweet tweet) {\\n            this.tweets.add(tweet);\\n        }\\n\\n        public void follow(final int id) {\\n            this.following.add(id);\\n        }\\n\\n        public void unfollow(final int id) {\\n            this.following.remove(id);\\n        }\\n    }\\n\\n    private class Tweet {\\n        private static int timeStamp = 0;\\n        public final int id;\\n        public final int time;\\n        public Tweet next;\\n        public Tweet prev;\\n\\n        public Tweet(final int id) {\\n            this.id = id;\\n            this.prev = null;\\n            this.next = null;\\n            time = timeStamp++;\\n        }\\n    }\\n\\n    private class TweetList {\\n        private Tweet dummyHead;\\n        private Tweet tail;\\n        private int size;\\n\\n        public TweetList() {\\n            this.size = 0;\\n            this.dummyHead = new Tweet(-1);\\n        }\\n\\n        public void add(Tweet tweet) {\\n            if(this.size == 0) {\\n                this.dummyHead.next = tweet;\\n                tweet.prev = this.dummyHead;\\n                tail = tweet;\\n            } else {\\n                tweet.next = this.dummyHead.next;\\n                tweet.prev = this.dummyHead;\\n                this.dummyHead.next.prev = tweet;\\n                this.dummyHead.next = tweet;\\n            }\\n\\n            this.size++;\\n\\n            if(this.size > 10)\\n                this.remove();\\n        }\\n\\n        public Tweet head() {\\n            return this.dummyHead.next;\\n        }\\n\\n        private Tweet remove() {\\n            if(this.size == 0)            \\n                return null;\\n\\n            this.tail.prev.next = null;\\n            this.tail = this.tail.prev;\\n\\n            this.size--;\\n\\n            if(this.size == 0)\\n                this.tail = null;\\n\\n            return this.tail;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Twitter {\\n    private final Map<Integer, User> userMap;\\n\\n    public Twitter() {\\n        this.userMap = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        this.userMap.get(userId).postTweet(new Tweet(tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        \\n        Set<Integer> following = this.userMap.get(userId).following;\\n\\n        PriorityQueue<Tweet> maxHeap = new PriorityQueue<>(following.size(), (a, b) -> b.time - a.time);\\n\\n        for(int id : following)\\n            if(userMap.get(id).tweets.head() != null)\\n                maxHeap.offer(userMap.get(id).tweets.head());\\n\\n        int n = 0;\\n\\n        while(maxHeap.size() > 0 && n < 10) {\\n            Tweet tweet = maxHeap.poll();\\n\\n            result.add(tweet.id);\\n\\n            if(tweet.next != null)\\n                maxHeap.offer(tweet.next);\\n\\n            n++;\\n        }\\n\\n        return result;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).follow(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).unfollow(followeeId);\\n    }\\n\\n    private class User {\\n        public final Set<Integer> following;\\n        public final TweetList tweets;\\n        \\n        private int n;\\n\\n        public User(final int id) {\\n            this.following = new HashSet<>();\\n            this.tweets = new TweetList();\\n            this.n = 0;\\n            this.follow(id);\\n        }\\n\\n        public void postTweet(final Tweet tweet) {\\n            this.tweets.add(tweet);\\n        }\\n\\n        public void follow(final int id) {\\n            this.following.add(id);\\n        }\\n\\n        public void unfollow(final int id) {\\n            this.following.remove(id);\\n        }\\n    }\\n\\n    private class Tweet {\\n        private static int timeStamp = 0;\\n        public final int id;\\n        public final int time;\\n        public Tweet next;\\n        public Tweet prev;\\n\\n        public Tweet(final int id) {\\n            this.id = id;\\n            this.prev = null;\\n            this.next = null;\\n            time = timeStamp++;\\n        }\\n    }\\n\\n    private class TweetList {\\n        private Tweet dummyHead;\\n        private Tweet tail;\\n        private int size;\\n\\n        public TweetList() {\\n            this.size = 0;\\n            this.dummyHead = new Tweet(-1);\\n        }\\n\\n        public void add(Tweet tweet) {\\n            if(this.size == 0) {\\n                this.dummyHead.next = tweet;\\n                tweet.prev = this.dummyHead;\\n                tail = tweet;\\n            } else {\\n                tweet.next = this.dummyHead.next;\\n                tweet.prev = this.dummyHead;\\n                this.dummyHead.next.prev = tweet;\\n                this.dummyHead.next = tweet;\\n            }\\n\\n            this.size++;\\n\\n            if(this.size > 10)\\n                this.remove();\\n        }\\n\\n        public Tweet head() {\\n            return this.dummyHead.next;\\n        }\\n\\n        private Tweet remove() {\\n            if(this.size == 0)            \\n                return null;\\n\\n            this.tail.prev.next = null;\\n            this.tail = this.tail.prev;\\n\\n            this.size--;\\n\\n            if(this.size == 0)\\n                this.tail = null;\\n\\n            return this.tail;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```\n```java\\nclass Twitter {\\n    private final Map<Integer, User> userMap;\\n\\n    public Twitter() {\\n        this.userMap = new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        this.userMap.get(userId).postTweet(new Tweet(tweetId));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        this.userMap.putIfAbsent(userId, new User(userId));\\n        \\n        Set<Integer> following = this.userMap.get(userId).following;\\n\\n        Tweet[] tweets = new Tweet[following.size()];\\n\\n        int i = 0;\\n\\n        for(int id : following)\\n            if(userMap.get(id).tweets.head() != null)\\n                tweets[i++] = userMap.get(id).tweets.head();\\n\\n        int n = 0;\\n        Tweet added = null;\\n\\n        do {\\n            added = null;\\n            int index = 0;\\n\\n            for(int j = 0; j < tweets.length; ++j) {\\n                if(added == null && tweets[j] != null)\\n                    added = tweets[j];\\n\\n                if(added != null && tweets[j] != null && added.time < tweets[j].time) {\\n                    added = tweets[j];\\n                    index = j;\\n                }\\n            }\\n\\n            if(added != null) {\\n                result.add(added.id);\\n                tweets[index] = added.next;\\n            }\\n            \\n            n++;\\n        } while(added != null && n < 10);\\n\\n        return result;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).follow(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        this.userMap.putIfAbsent(followerId, new User(followerId));\\n        this.userMap.putIfAbsent(followeeId, new User(followeeId));\\n\\n        this.userMap.get(followerId).unfollow(followeeId);\\n    }\\n\\n    private class User {\\n        public final Set<Integer> following;\\n        public final TweetList tweets;\\n        \\n        private int n;\\n\\n        public User(final int id) {\\n            this.following = new HashSet<>();\\n            this.tweets = new TweetList();\\n            this.n = 0;\\n            this.follow(id);\\n        }\\n\\n        public void postTweet(final Tweet tweet) {\\n            this.tweets.add(tweet);\\n        }\\n\\n        public void follow(final int id) {\\n            this.following.add(id);\\n        }\\n\\n        public void unfollow(final int id) {\\n            this.following.remove(id);\\n        }\\n    }\\n\\n    private class Tweet {\\n        private static int timeStamp = 0;\\n        public final int id;\\n        public final int time;\\n        public Tweet next;\\n        public Tweet prev;\\n\\n        public Tweet(final int id) {\\n            this.id = id;\\n            this.prev = null;\\n            this.next = null;\\n            time = timeStamp++;\\n        }\\n    }\\n\\n    private class TweetList {\\n        private Tweet dummyHead;\\n        private Tweet tail;\\n        private int size;\\n\\n        public TweetList() {\\n            this.size = 0;\\n            this.dummyHead = new Tweet(-1);\\n        }\\n\\n        public void add(Tweet tweet) {\\n            if(this.size == 0) {\\n                this.dummyHead.next = tweet;\\n                tweet.prev = this.dummyHead;\\n                tail = tweet;\\n            } else {\\n                tweet.next = this.dummyHead.next;\\n                tweet.prev = this.dummyHead;\\n                this.dummyHead.next.prev = tweet;\\n                this.dummyHead.next = tweet;\\n            }\\n\\n            this.size++;\\n\\n            if(this.size > 10)\\n                this.remove();\\n        }\\n\\n        public Tweet head() {\\n            return this.dummyHead.next;\\n        }\\n\\n        private Tweet remove() {\\n            if(this.size == 0)            \\n                return null;\\n\\n            this.tail.prev.next = null;\\n            this.tail = this.tail.prev;\\n\\n            this.size--;\\n\\n            if(this.size == 0)\\n                this.tail = null;\\n\\n            return this.tail;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312443,
                "title": "only-hasmap-solution-with-timer-variable-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs our normal map sort the data in asscending order, wo we will use the timer variable initially it will be INT_MAX so, the upcoming tweets will be at starting.\\n\\nWhen fetching the tweets we simply check is the tweet id belongs to the userId or any of its friend if yes add it to answer and do, it till we fetch the top 10 recent tweets by the user or its friend\\n# Code\\n```\\nclass Twitter {\\n    int timer = INT_MAX;\\n    map<int, map<int, bool>> friends;\\n    // map user id with user friends map\\n    map<int, pair<int, int>> tweets;\\n    // time {userId, tweetId}\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets[timer--] = {userId, tweetId};\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(auto it: tweets){\\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\\n                ans.push_back(it.second.second);\\n            if(ans.size() == 10) break;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\n    int timer = INT_MAX;\\n    map<int, map<int, bool>> friends;\\n    // map user id with user friends map\\n    map<int, pair<int, int>> tweets;\\n    // time {userId, tweetId}\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets[timer--] = {userId, tweetId};\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(auto it: tweets){\\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\\n                ans.push_back(it.second.second);\\n            if(ans.size() == 10) break;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260620,
                "title": "intuitive-hashmap-approach",
                "content": "# Complexity\\n- Time complexity: \\n    - As each user\\'s tweet has a max length of 10, `postTweet` time complexity is O(1).\\n    - `follow` and `unfollow` time complexity is O(1).\\n    - `getNewsFeed` uses priority_queue, which has O(nlogn) complexity to build, where N is the number of followers the user follows \\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    struct Tweet {\\n        int tweetId;\\n        int timestamp;\\n        Tweet(int tweetId, int timestamp): tweetId(tweetId), timestamp(timestamp) {}\\n    };\\n\\n    class MyComparator {\\n    public:\\n        bool operator() (const Tweet* tweet1, const Tweet* tweet2) {\\n            return tweet1->timestamp < tweet2->timestamp;\\n        }\\n    };\\n\\n    unordered_map<int, vector<Tweet*>> userTweets;\\n    unordered_map<int, unordered_set<int>> userFollowings;\\n    int counter = 0;\\n\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        Tweet* tweet = new Tweet(tweetId, counter);\\n        counter++;\\n\\n        if (userTweets.count(userId)) {\\n            if (userTweets[userId].size() == 10) {\\n                userTweets[userId].erase(userTweets[userId].begin());\\n                userTweets[userId].push_back(tweet);\\n            } else {\\n                userTweets[userId].push_back(tweet);\\n            }\\n        } else {\\n            userTweets[userId].push_back(tweet);\\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<Tweet*, vector<Tweet*>, MyComparator> tweets;\\n        unordered_set<int> followers = userFollowings[userId];\\n        for (auto it = followers.begin(); it != followers.end(); it++) {\\n            for (Tweet* tweet : userTweets[*it]) {\\n                tweets.push(tweet);\\n            }\\n        }\\n        for (Tweet* tweet : userTweets[userId]) {\\n            tweets.push(tweet);\\n        }\\n        int count = 0;\\n        vector<int> res;\\n        while (count < 10 && !tweets.empty()) {\\n            Tweet* tweet = tweets.top(); tweets.pop();\\n            res.push_back(tweet->tweetId);\\n            count++;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        userFollowings[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        userFollowings[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    struct Tweet {\\n        int tweetId;\\n        int timestamp;\\n        Tweet(int tweetId, int timestamp): tweetId(tweetId), timestamp(timestamp) {}\\n    };\\n\\n    class MyComparator {\\n    public:\\n        bool operator() (const Tweet* tweet1, const Tweet* tweet2) {\\n            return tweet1->timestamp < tweet2->timestamp;\\n        }\\n    };\\n\\n    unordered_map<int, vector<Tweet*>> userTweets;\\n    unordered_map<int, unordered_set<int>> userFollowings;\\n    int counter = 0;\\n\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        Tweet* tweet = new Tweet(tweetId, counter);\\n        counter++;\\n\\n        if (userTweets.count(userId)) {\\n            if (userTweets[userId].size() == 10) {\\n                userTweets[userId].erase(userTweets[userId].begin());\\n                userTweets[userId].push_back(tweet);\\n            } else {\\n                userTweets[userId].push_back(tweet);\\n            }\\n        } else {\\n            userTweets[userId].push_back(tweet);\\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<Tweet*, vector<Tweet*>, MyComparator> tweets;\\n        unordered_set<int> followers = userFollowings[userId];\\n        for (auto it = followers.begin(); it != followers.end(); it++) {\\n            for (Tweet* tweet : userTweets[*it]) {\\n                tweets.push(tweet);\\n            }\\n        }\\n        for (Tweet* tweet : userTweets[userId]) {\\n            tweets.push(tweet);\\n        }\\n        int count = 0;\\n        vector<int> res;\\n        while (count < 10 && !tweets.empty()) {\\n            Tweet* tweet = tweets.top(); tweets.pop();\\n            res.push_back(tweet->tweetId);\\n            count++;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        userFollowings[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        userFollowings[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196210,
                "title": "clean-and-simple-implementation-heap-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.followMap = collections.defaultdict(set)\\n        self.postMap = collections.defaultdict(list)\\n        self.count = 0\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.postMap[userId].append([self.count, tweetId])\\n        self.count-=1 #Just for creating the max-heap \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        heap = []\\n        self.followMap[userId].add(userId)\\n        for user in self.followMap[userId]:\\n            for post in self.postMap[user][::-1]:\\n                heap.append(post)\\n        heapq.heapify(heap)\\n        while heap and len(res)<10:\\n            count, tweet = heapq.heappop(heap)\\n            res.append(tweet)\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followMap[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followMap[followerId]:\\n            self.followMap[followerId].remove(followeeId)\\n\\n        \\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.followMap = collections.defaultdict(set)\\n        self.postMap = collections.defaultdict(list)\\n        self.count = 0\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.postMap[userId].append([self.count, tweetId])\\n        self.count-=1 #Just for creating the max-heap \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        heap = []\\n        self.followMap[userId].add(userId)\\n        for user in self.followMap[userId]:\\n            for post in self.postMap[user][::-1]:\\n                heap.append(post)\\n        heapq.heapify(heap)\\n        while heap and len(res)<10:\\n            count, tweet = heapq.heappop(heap)\\n            res.append(tweet)\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followMap[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followMap[followerId]:\\n            self.followMap[followerId].remove(followeeId)\\n\\n        \\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967811,
                "title": "java-10ms-solution-beats-97",
                "content": "\\n# Upvote if you like it and if you get into any problem then do comment below:-\\n# Details:-\\n- The hashmap \"following\" contains all the userId that are followed by the particular userId.\\n- The hashmap \"followers\" contains all the userId that follows the particular userId.\\n- The hashmap \"mp\" contains the linkedlist of pair<Integer,Integer> type and in every pair i am storing the tweetId and the UserId.\\n- The hashmap \"time\" stores the tweetId and time.\\n- The hashmap \"time2\" stores the time and tweetId.\\n- The count variable basically is used to store at which time the tweet is posted.\\n- The count variable increases each time whenever an tweet is posted and this count variable is to check which tweetId comes first and which tweetId comes second and so on.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Twitter {\\n\\n    HashMap<Integer,Set<Integer>>following;\\n    HashMap<Integer,Set<Integer>>followers;\\n    HashMap<Integer,LinkedList<Pair<Integer,Integer>>>mp;\\n    HashMap<Integer,Integer>time;\\n    HashMap<Integer,Integer>time2;\\n    int clock=0;\\n\\n    public Twitter() {\\n\\n    followers=new HashMap<>();\\n    following=new HashMap<>();\\n    mp=new HashMap<>();\\n    time=new HashMap<>();\\n    time2=new HashMap<>();\\n\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n    if(!mp.containsKey(userId)){\\n\\n    mp.put(userId,new LinkedList<Pair<Integer,Integer>>());\\n\\n    }\\n\\n    mp.get(userId).addFirst(new Pair<Integer,Integer>(tweetId,userId));\\n\\n    if(followers.containsKey(userId)){\\n\\n    for(int m:followers.get(userId)){\\n\\n    mp.get(m).addFirst(new Pair<Integer,Integer>(tweetId,userId));\\n\\n    }\\n\\n    }\\n\\n    time.put(tweetId,clock);\\n\\n    time2.put(clock,tweetId);\\n\\n    clock++;\\n\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n\\n    List<Integer>ans=new ArrayList<Integer>();\\n\\n    List<Integer>temp=new ArrayList<Integer>();\\n\\n    if(!mp.containsKey(userId))return ans;\\n\\n    for(Pair<Integer,Integer>p:mp.get(userId)){\\n\\n    if(p.getValue()==userId||following.get(userId).contains(p.getValue())){\\n\\n    temp.add(time.get(p.getKey()));\\n\\n    }\\n\\n    }\\n\\n    Collections.sort(temp);\\n\\n    int count=0;\\n\\n    for(int i=temp.size()-1;i>=0&&count<10;i--,count++){\\n\\n    ans.add(time2.get(temp.get(i)));\\n\\n    }\\n\\n    return ans;\\n        \\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n\\n    if(following.containsKey(followerId)&&following.get(followerId).contains(followeeId))return;\\n\\n\\n    if(!following.containsKey(followerId)){\\n\\n    following.put(followerId,new HashSet<Integer>());\\n\\n    }\\n\\n    following.get(followerId).add(followeeId);\\n\\n    if(!followers.containsKey(followeeId)){\\n\\n    followers.put(followeeId,new HashSet<Integer>());\\n\\n    }\\n\\n    followers.get(followeeId).add(followerId);\\n\\n\\n    if(!mp.containsKey(followerId)){\\n\\n    mp.put(followerId,new LinkedList<Pair<Integer,Integer>>());\\n    \\n    }\\n\\n    if(mp.containsKey(followeeId)){\\n\\n      Iterator<Pair<Integer,Integer>>iterator = mp.get(followeeId).descendingIterator();\\n\\n      while (iterator.hasNext()) \\n        {\\n        \\n        Pair<Integer,Integer>p=iterator.next();\\n\\n        if(p.getValue()==followeeId){\\n\\n    mp.get(followerId).addFirst(new Pair<Integer,Integer>(p.getKey(),p.getValue()));\\n\\n    }\\n\\n        }\\n    }\\n\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n    if(following.containsKey(followerId))\\n    following.get(followerId).remove(followeeId);\\n    \\n\\n    if(followers.containsKey(followeeId))\\n    followers.get(followeeId).remove(followerId);\\n\\n    }\\n}\\n\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n\\n    HashMap<Integer,Set<Integer>>following;\\n    HashMap<Integer,Set<Integer>>followers;\\n    HashMap<Integer,LinkedList<Pair<Integer,Integer>>>mp;\\n    HashMap<Integer,Integer>time;\\n    HashMap<Integer,Integer>time2;\\n    int clock=0;\\n\\n    public Twitter() {\\n\\n    followers=new HashMap<>();\\n    following=new HashMap<>();\\n    mp=new HashMap<>();\\n    time=new HashMap<>();\\n    time2=new HashMap<>();\\n\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        \\n    if(!mp.containsKey(userId)){\\n\\n    mp.put(userId,new LinkedList<Pair<Integer,Integer>>());\\n\\n    }\\n\\n    mp.get(userId).addFirst(new Pair<Integer,Integer>(tweetId,userId));\\n\\n    if(followers.containsKey(userId)){\\n\\n    for(int m:followers.get(userId)){\\n\\n    mp.get(m).addFirst(new Pair<Integer,Integer>(tweetId,userId));\\n\\n    }\\n\\n    }\\n\\n    time.put(tweetId,clock);\\n\\n    time2.put(clock,tweetId);\\n\\n    clock++;\\n\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n\\n    List<Integer>ans=new ArrayList<Integer>();\\n\\n    List<Integer>temp=new ArrayList<Integer>();\\n\\n    if(!mp.containsKey(userId))return ans;\\n\\n    for(Pair<Integer,Integer>p:mp.get(userId)){\\n\\n    if(p.getValue()==userId||following.get(userId).contains(p.getValue())){\\n\\n    temp.add(time.get(p.getKey()));\\n\\n    }\\n\\n    }\\n\\n    Collections.sort(temp);\\n\\n    int count=0;\\n\\n    for(int i=temp.size()-1;i>=0&&count<10;i--,count++){\\n\\n    ans.add(time2.get(temp.get(i)));\\n\\n    }\\n\\n    return ans;\\n        \\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n\\n    if(following.containsKey(followerId)&&following.get(followerId).contains(followeeId))return;\\n\\n\\n    if(!following.containsKey(followerId)){\\n\\n    following.put(followerId,new HashSet<Integer>());\\n\\n    }\\n\\n    following.get(followerId).add(followeeId);\\n\\n    if(!followers.containsKey(followeeId)){\\n\\n    followers.put(followeeId,new HashSet<Integer>());\\n\\n    }\\n\\n    followers.get(followeeId).add(followerId);\\n\\n\\n    if(!mp.containsKey(followerId)){\\n\\n    mp.put(followerId,new LinkedList<Pair<Integer,Integer>>());\\n    \\n    }\\n\\n    if(mp.containsKey(followeeId)){\\n\\n      Iterator<Pair<Integer,Integer>>iterator = mp.get(followeeId).descendingIterator();\\n\\n      while (iterator.hasNext()) \\n        {\\n        \\n        Pair<Integer,Integer>p=iterator.next();\\n\\n        if(p.getValue()==followeeId){\\n\\n    mp.get(followerId).addFirst(new Pair<Integer,Integer>(p.getKey(),p.getValue()));\\n\\n    }\\n\\n        }\\n    }\\n\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n    if(following.containsKey(followerId))\\n    following.get(followerId).remove(followeeId);\\n    \\n\\n    if(followers.containsKey(followeeId))\\n    followers.get(followeeId).remove(followerId);\\n\\n    }\\n}\\n\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959808,
                "title": "python-solution-with-very-detailed-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 entities/objects in this probelm: user, post, and the system. These entities have their own properties and ther are related in some ways. So I create the 3 classes for them.\\nA user object has a unique UserId, a collection of the user\\'s posts, and a list of ther user\\'s followees. The post list is stored in a linkedlist where a post is a node. The newly created post will be insterted at the head of the linkedlist so the linkedlist is sorted by the timestamp. Why I use a linkedlist here is because I want to transform the getNewsFeed() into the *merge k sorted lists* problem. The user\\'s followees are stored in a set, because doing intertions and deletions in a set takes O(1) time.\\nA tweet(post) object has a unique postId, a timestamp, and a next pointer pointing to the next post object. \\nInside the Twitter class, I create a global time variable which acts as a clock. Every time a function is called, the time would increment by 1. In this way every post can have a proper timestamp. I also create a hashmap(dictionary) to store the userID and the corresponding user object so that I can quickly retrieve the user object by the given userId.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the classes being set up, the algorithms get clear. The most complex one is getNewsFeed(). As I said before, I have degenerated it into the *merge k sorted lists* problem. More specifically, we need a heap(or priority queue), always push the heads of the linkedlists into the heap and pop out the 10 most recent posts (or less). \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ngetNewsFeed(): O(10logN) where N is the maximum number of users a user can follow\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass User:\\n    def __init__(self, userId, next=None) -> None:\\n        self.id=userId\\n        self.posts=None   ### a head node: post2 -> post1\\n        self.following={self}\\n\\nclass Tweet:\\n    def __init__(self, postId, time, next=None) -> None:\\n        self.id=postId\\n        self.timestamp=time\\n        self.next=None\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time=0\\n        self.users={}  # {userId: User}\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.time+=1\\n        self.users[userId] = self.users.get(userId, User(userId))\\n        user=self.users[userId]\\n        tweet = Tweet(tweetId, self.time)\\n        tweet.next=user.posts\\n        user.posts=tweet\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.time+=1\\n        self.users[userId] = self.users.get(userId, User(userId))\\n        user=self.users[userId]\\n        heap=[] # min heap\\n        for u in user.following:\\n            if u.posts:\\n                heapq.heappush(heap, (-u.posts.timestamp, u.posts))\\n        i=0\\n        res=[]\\n        while i<10 and heap:\\n            _, post=heapq.heappop(heap)\\n            res.append(post.id)\\n            if post.next:\\n                heapq.heappush(heap, (-post.next.timestamp, post.next))\\n            i+=1\\n        return res\\n\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.time+=1\\n        self.users[followerId]=self.users.get(followerId, User(followerId))\\n        follower= self.users[followerId]\\n        self.users[followeeId]=self.users.get(followeeId, User(followeeId))\\n        followee= self.users[followeeId]\\n        follower.following.add(followee)\\n\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.time+=1\\n        self.users[followerId]=self.users.get(followerId, User(followerId))\\n        follower= self.users[followerId]\\n        self.users[followeeId]=self.users.get(followeeId, User(followeeId))\\n        followee= self.users[followeeId]\\n        follower.following.discard(followee)\\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass User:\\n    def __init__(self, userId, next=None) -> None:\\n        self.id=userId\\n        self.posts=None   ### a head node: post2 -> post1\\n        self.following={self}\\n\\nclass Tweet:\\n    def __init__(self, postId, time, next=None) -> None:\\n        self.id=postId\\n        self.timestamp=time\\n        self.next=None\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time=0\\n        self.users={}  # {userId: User}\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.time+=1\\n        self.users[userId] = self.users.get(userId, User(userId))\\n        user=self.users[userId]\\n        tweet = Tweet(tweetId, self.time)\\n        tweet.next=user.posts\\n        user.posts=tweet\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.time+=1\\n        self.users[userId] = self.users.get(userId, User(userId))\\n        user=self.users[userId]\\n        heap=[] # min heap\\n        for u in user.following:\\n            if u.posts:\\n                heapq.heappush(heap, (-u.posts.timestamp, u.posts))\\n        i=0\\n        res=[]\\n        while i<10 and heap:\\n            _, post=heapq.heappop(heap)\\n            res.append(post.id)\\n            if post.next:\\n                heapq.heappush(heap, (-post.next.timestamp, post.next))\\n            i+=1\\n        return res\\n\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.time+=1\\n        self.users[followerId]=self.users.get(followerId, User(followerId))\\n        follower= self.users[followerId]\\n        self.users[followeeId]=self.users.get(followeeId, User(followeeId))\\n        followee= self.users[followeeId]\\n        follower.following.add(followee)\\n\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.time+=1\\n        self.users[followerId]=self.users.get(followerId, User(followerId))\\n        follower= self.users[followerId]\\n        self.users[followeeId]=self.users.get(followeeId, User(followeeId))\\n        followee= self.users[followeeId]\\n        follower.following.discard(followee)\\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694978,
                "title": "go-solution-using-a-heap-by-someone-who-writes-go-for-work",
                "content": "```\\ntype Twitter struct {\\n    // Following is a map of (followerId -> set of followeeId)\\n    following map[int]map[int]struct{}\\n    \\n    // Tweets is a map of (authorId -> list of tweets)\\n    tweets map[int][]tweet\\n    \\n    // latestTimestamp tracks the time so that tweets can be \\n    // ordered across authors, given that we do not store\\n    // all tweets in a single list.\\n    latestTimestamp int\\n}\\n\\ntype tweet struct {\\n    tweetId int\\n    timestamp int\\n}\\n\\ntype TweetMaxHeap struct {\\n    items []heapTweet\\n}\\n\\nfunc (h *TweetMaxHeap) Push(value interface{}) {\\n    h.items = append(h.items, value.(heapTweet))\\n}\\n\\nfunc (h *TweetMaxHeap) Pop() interface{} {\\n    last := h.items[len(h.items)-1]\\n    h.items = h.items[:len(h.items)-1]\\n    \\n    return last\\n}\\n\\nfunc (h *TweetMaxHeap) Swap(i, j int) {\\n    h.items[i], h.items[j] = h.items[j], h.items[i]\\n}\\n\\nfunc (h *TweetMaxHeap) Less(i, j int) bool {\\n    // Returning time[i] > time[j] makes it a max heap based on time.\\n    // This allows us to pop the latest tweets.\\n    return h.items[i].tweet.timestamp > h.items[j].tweet.timestamp\\n}\\n\\nfunc (h *TweetMaxHeap) Len() int {\\n    return len(h.items)\\n}\\n\\ntype heapTweet struct {\\n    // idx tracks the index of the tweet in the author\\'s tweet list.\\n    idx int\\n    \\n    // userId tracks the user the tweet came from, so that it can be\\n    // backfilled when added to the response.\\n    userId int\\n    \\n    // The tweet containing the timestamp to sort by and the tweetId\\n    // to return.\\n    tweet tweet\\n}\\n\\nfunc Constructor() Twitter {\\n    return Twitter{\\n        following: make(map[int]map[int]struct{}),\\n        tweets: make(map[int][]tweet),\\n    }\\n}\\n\\n\\nfunc (this *Twitter) PostTweet(userId int, tweetId int)  {\\n    userTweets, ok := this.tweets[userId]\\n    if !ok {\\n        userTweets = make([]tweet, 0)\\n        \\n    }\\n    \\n    // Track a timestamp across tweets so that the heap\\n    // in the user news feed can sort.\\n    this.latestTimestamp++\\n    \\n    userTweets = append(userTweets, tweet{\\n        tweetId: tweetId, \\n        timestamp: this.latestTimestamp,\\n    })\\n    this.tweets[userId] = userTweets\\n}\\n\\n\\nfunc (this *Twitter) GetNewsFeed(userId int) []int {\\n    followees, ok := this.following[userId] \\n    if !ok {\\n        followees = make(map[int]struct{})\\n    }\\n    \\n    // Ensure users follow themselves since users can see their\\n    // own tweets in their feed.\\n    if _, ok := followees[userId]; !ok {\\n        followees[userId] = struct{}{}\\n    }\\n    this.following[userId] = followees\\n    \\n    // The tweetHeap will contain O(len(followees)) elements.\\n    // For each followee who has tweeted, it will contain the latest\\n    // tweet from that followee, and the index of the tweet in the\\n    // followees tweet list.\\n    tweetHeap := &TweetMaxHeap{items: make([]heapTweet, 0)}\\n    \\n    for followee := range followees {\\n        tweets := this.tweets[followee]\\n        \\n        if len(tweets) == 0 {\\n            // This followee has not tweeted yet.\\n            continue\\n        }\\n        \\n        // The heap can bubble up tweets based on latest timestamp.\\n        // We keep the index of the current element in the tweet list\\n        // so that we can know which is the next item to grab from this\\n        // user when backfilling the heap after this tweet is used.\\n        heap.Push(tweetHeap, heapTweet{\\n            tweet: tweets[len(tweets)-1],\\n            idx: len(tweets)-1,\\n            userId: followee,\\n        })\\n    }\\n    \\n    var result []int\\n    for tweetHeap.Len() > 0 && len(result) < 10 {\\n        \\n        // Pop the most recent tweet from the heap,\\n        // since we need to return the result in order.\\n        popped := heap.Pop(tweetHeap).(heapTweet)\\n        result = append(result, popped.tweet.tweetId)\\n        \\n        // We then need to push a new tweet to the heap\\n        // from the user who tweeted the tweet we just added.\\n        // This allows for a case where the author had multiple\\n        // of the most recent tweets.\\n        //\\n        // The nextIdx is going to be popped.idx-1 because the list of\\n        // tweets appends the latest on the right, so we traverse\\n        // backwards when we need to add the next most-recent tweet.\\n        nextIdx := popped.idx - 1\\n        \\n        if nextIdx >= 0 {\\n            tweets := this.tweets[popped.userId]\\n            \\n            heap.Push(tweetHeap, heapTweet{\\n                tweet: tweets[nextIdx],\\n                idx: nextIdx,\\n                userId: popped.userId,\\n            })\\n        }\\n       \\n    }\\n    return result\\n}\\n\\n\\nfunc (this *Twitter) Follow(followerId int, followeeId int)  {\\n    // Initialize map of followees for the given follower if needed.\\n    followees, ok := this.following[followerId] \\n    if !ok {\\n        followees = make(map[int]struct{})\\n        this.following[followerId] = followees\\n    }\\n    \\n    // Track the follow in a set.\\n    followees[followeeId] = struct{}{}\\n}\\n\\n\\nfunc (this *Twitter) Unfollow(followerId int, followeeId int)  {\\n    followees, ok := this.following[followerId] \\n    if !ok {\\n        // If there are no followees tracked for the follower\\n        // then there\\'s nothing to do.\\n        return\\n    }\\n    delete(followees, followeeId)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype Twitter struct {\\n    // Following is a map of (followerId -> set of followeeId)\\n    following map[int]map[int]struct{}\\n    \\n    // Tweets is a map of (authorId -> list of tweets)\\n    tweets map[int][]tweet\\n    \\n    // latestTimestamp tracks the time so that tweets can be \\n    // ordered across authors, given that we do not store\\n    // all tweets in a single list.\\n    latestTimestamp int\\n}\\n\\ntype tweet struct {\\n    tweetId int\\n    timestamp int\\n}\\n\\ntype TweetMaxHeap struct {\\n    items []heapTweet\\n}\\n\\nfunc (h *TweetMaxHeap) Push(value interface{}) {\\n    h.items = append(h.items, value.(heapTweet))\\n}\\n\\nfunc (h *TweetMaxHeap) Pop() interface{} {\\n    last := h.items[len(h.items)-1]\\n    h.items = h.items[:len(h.items)-1]\\n    \\n    return last\\n}\\n\\nfunc (h *TweetMaxHeap) Swap(i, j int) {\\n    h.items[i], h.items[j] = h.items[j], h.items[i]\\n}\\n\\nfunc (h *TweetMaxHeap) Less(i, j int) bool {\\n    // Returning time[i] > time[j] makes it a max heap based on time.\\n    // This allows us to pop the latest tweets.\\n    return h.items[i].tweet.timestamp > h.items[j].tweet.timestamp\\n}\\n\\nfunc (h *TweetMaxHeap) Len() int {\\n    return len(h.items)\\n}\\n\\ntype heapTweet struct {\\n    // idx tracks the index of the tweet in the author\\'s tweet list.\\n    idx int\\n    \\n    // userId tracks the user the tweet came from, so that it can be\\n    // backfilled when added to the response.\\n    userId int\\n    \\n    // The tweet containing the timestamp to sort by and the tweetId\\n    // to return.\\n    tweet tweet\\n}\\n\\nfunc Constructor() Twitter {\\n    return Twitter{\\n        following: make(map[int]map[int]struct{}),\\n        tweets: make(map[int][]tweet),\\n    }\\n}\\n\\n\\nfunc (this *Twitter) PostTweet(userId int, tweetId int)  {\\n    userTweets, ok := this.tweets[userId]\\n    if !ok {\\n        userTweets = make([]tweet, 0)\\n        \\n    }\\n    \\n    // Track a timestamp across tweets so that the heap\\n    // in the user news feed can sort.\\n    this.latestTimestamp++\\n    \\n    userTweets = append(userTweets, tweet{\\n        tweetId: tweetId, \\n        timestamp: this.latestTimestamp,\\n    })\\n    this.tweets[userId] = userTweets\\n}\\n\\n\\nfunc (this *Twitter) GetNewsFeed(userId int) []int {\\n    followees, ok := this.following[userId] \\n    if !ok {\\n        followees = make(map[int]struct{})\\n    }\\n    \\n    // Ensure users follow themselves since users can see their\\n    // own tweets in their feed.\\n    if _, ok := followees[userId]; !ok {\\n        followees[userId] = struct{}{}\\n    }\\n    this.following[userId] = followees\\n    \\n    // The tweetHeap will contain O(len(followees)) elements.\\n    // For each followee who has tweeted, it will contain the latest\\n    // tweet from that followee, and the index of the tweet in the\\n    // followees tweet list.\\n    tweetHeap := &TweetMaxHeap{items: make([]heapTweet, 0)}\\n    \\n    for followee := range followees {\\n        tweets := this.tweets[followee]\\n        \\n        if len(tweets) == 0 {\\n            // This followee has not tweeted yet.\\n            continue\\n        }\\n        \\n        // The heap can bubble up tweets based on latest timestamp.\\n        // We keep the index of the current element in the tweet list\\n        // so that we can know which is the next item to grab from this\\n        // user when backfilling the heap after this tweet is used.\\n        heap.Push(tweetHeap, heapTweet{\\n            tweet: tweets[len(tweets)-1],\\n            idx: len(tweets)-1,\\n            userId: followee,\\n        })\\n    }\\n    \\n    var result []int\\n    for tweetHeap.Len() > 0 && len(result) < 10 {\\n        \\n        // Pop the most recent tweet from the heap,\\n        // since we need to return the result in order.\\n        popped := heap.Pop(tweetHeap).(heapTweet)\\n        result = append(result, popped.tweet.tweetId)\\n        \\n        // We then need to push a new tweet to the heap\\n        // from the user who tweeted the tweet we just added.\\n        // This allows for a case where the author had multiple\\n        // of the most recent tweets.\\n        //\\n        // The nextIdx is going to be popped.idx-1 because the list of\\n        // tweets appends the latest on the right, so we traverse\\n        // backwards when we need to add the next most-recent tweet.\\n        nextIdx := popped.idx - 1\\n        \\n        if nextIdx >= 0 {\\n            tweets := this.tweets[popped.userId]\\n            \\n            heap.Push(tweetHeap, heapTweet{\\n                tweet: tweets[nextIdx],\\n                idx: nextIdx,\\n                userId: popped.userId,\\n            })\\n        }\\n       \\n    }\\n    return result\\n}\\n\\n\\nfunc (this *Twitter) Follow(followerId int, followeeId int)  {\\n    // Initialize map of followees for the given follower if needed.\\n    followees, ok := this.following[followerId] \\n    if !ok {\\n        followees = make(map[int]struct{})\\n        this.following[followerId] = followees\\n    }\\n    \\n    // Track the follow in a set.\\n    followees[followeeId] = struct{}{}\\n}\\n\\n\\nfunc (this *Twitter) Unfollow(followerId int, followeeId int)  {\\n    followees, ok := this.following[followerId] \\n    if !ok {\\n        // If there are no followees tracked for the follower\\n        // then there\\'s nothing to do.\\n        return\\n    }\\n    delete(followees, followeeId)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511307,
                "title": "easy-python-solution",
                "content": "```\\nfrom typing import List\\nimport heapq\\nfrom collections import defaultdict, deque\\n\\n\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = defaultdict(set) # map: userId -> {followeeId, ...}\\n        self.tweets = defaultdict(deque) # map: userId -> deque of size 10\\n        self.time = 0\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.time += 1\\n        self.tweets[userId].appendleft((self.time, tweetId))\\n        while len(self.tweets[userId]) > 10:\\n            self.tweets[userId].pop()\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        allfeeds = []\\n        allfeeds.extend(self.tweets[userId])\\n        for followee in self.users[userId]:\\n            allfeeds.extend(self.tweets[followee])\\n        return [tweetId for _, tweetId in heapq.nlargest(10, allfeeds)]\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]:\\n            self.users[followerId].remove(followeeId)\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom typing import List\\nimport heapq\\nfrom collections import defaultdict, deque\\n\\n\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = defaultdict(set) # map: userId -> {followeeId, ...}\\n        self.tweets = defaultdict(deque) # map: userId -> deque of size 10\\n        self.time = 0\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.time += 1\\n        self.tweets[userId].appendleft((self.time, tweetId))\\n        while len(self.tweets[userId]) > 10:\\n            self.tweets[userId].pop()\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        allfeeds = []\\n        allfeeds.extend(self.tweets[userId])\\n        for followee in self.users[userId]:\\n            allfeeds.extend(self.tweets[followee])\\n        return [tweetId for _, tweetId in heapq.nlargest(10, allfeeds)]\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]:\\n            self.users[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481218,
                "title": "python-heap-solution-based-on-tweet-time-records",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time = 0\\n        self.user_tweet = {}\\n        self.user_followed = {}\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_tweet[userId] = self.user_tweet.get(userId, [])\\n        heapq.heappush(self.user_tweet[userId], [self.time, tweetId])\\n        self.time -= 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        all_tweet = []\\n        if userId in self.user_followed:\\n            for followedId in self.user_followed[userId]:\\n                print(userId, followedId)\\n                if followedId in self.user_tweet:\\n                    for tweet in self.user_tweet[followedId]:\\n                        heapq.heappush(all_tweet, tweet)\\n        if userId in self.user_tweet:\\n            for tweet in self.user_tweet[userId]:\\n                heapq.heappush(all_tweet, tweet)\\n        res = []\\n        #print(all_tweet)\\n        while all_tweet and len(res) < 10:\\n            res.append(heapq.heappop(all_tweet)[1])\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.user_followed[followerId] = self.user_followed.get(followerId, [])\\n        if followeeId in self.user_followed[followerId]:\\n            return\\n        self.user_followed[followerId].append(followeeId)\\n        print(self.user_followed)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followerId in self.user_followed:\\n            self.user_followed[followerId].remove(followeeId)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time = 0\\n        self.user_tweet = {}\\n        self.user_followed = {}\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_tweet[userId] = self.user_tweet.get(userId, [])\\n        heapq.heappush(self.user_tweet[userId], [self.time, tweetId])\\n        self.time -= 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        all_tweet = []\\n        if userId in self.user_followed:\\n            for followedId in self.user_followed[userId]:\\n                print(userId, followedId)\\n                if followedId in self.user_tweet:\\n                    for tweet in self.user_tweet[followedId]:\\n                        heapq.heappush(all_tweet, tweet)\\n        if userId in self.user_tweet:\\n            for tweet in self.user_tweet[userId]:\\n                heapq.heappush(all_tweet, tweet)\\n        res = []\\n        #print(all_tweet)\\n        while all_tweet and len(res) < 10:\\n            res.append(heapq.heappop(all_tweet)[1])\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.user_followed[followerId] = self.user_followed.get(followerId, [])\\n        if followeeId in self.user_followed[followerId]:\\n            return\\n        self.user_followed[followerId].append(followeeId)\\n        print(self.user_followed)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followerId in self.user_followed:\\n            self.user_followed[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373273,
                "title": "design-twitter-solution-java",
                "content": "class Tweet {\\n  public int id;\\n  public int time;\\n  public Tweet next = null;\\n  public Tweet(int id, int time) {\\n    this.id = id;\\n    this.time = time;\\n  }\\n}\\n\\nclass User {\\n  private int id;\\n  public Set<Integer> followeeIds = new HashSet<>();\\n  public Tweet tweetHead = null;\\n\\n  public User(int id) {\\n    this.id = id;\\n    follow(id); // follow himself\\n  }\\n\\n  public void follow(int followeeId) {\\n    followeeIds.add(followeeId);\\n  }\\n\\n  public void unfollow(int followeeId) {\\n    followeeIds.remove(followeeId);\\n  }\\n\\n  public void post(int tweetId, int time) {\\n    final Tweet oldTweetHead = tweetHead;\\n    tweetHead = new Tweet(tweetId, time);\\n    tweetHead.next = oldTweetHead;\\n  }\\n}\\n\\nclass Twitter {\\n  /** Compose a new tweet. */\\n  public void postTweet(int userId, int tweetId) {\\n    users.putIfAbsent(userId, new User(userId));\\n    users.get(userId).post(tweetId, time++);\\n  }\\n\\n  /**\\n   * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in\\n   * the news feed must be posted by users who the user followed or by the user\\n   * herself. Tweets must be ordered from most recent to least recent.\\n   */\\n  public List<Integer> getNewsFeed(int userId) {\\n    if (!users.containsKey(userId))\\n      return new ArrayList<>();\\n\\n    List<Integer> newsFeed = new ArrayList<>();\\n    Queue<Tweet> maxHeap = new PriorityQueue<>((a, b) -> b.time - a.time);\\n\\n    for (final int followeeId : users.get(userId).followeeIds) {\\n      Tweet tweetHead = users.get(followeeId).tweetHead;\\n      if (tweetHead != null)\\n        maxHeap.offer(tweetHead);\\n    }\\n\\n    int count = 0;\\n    while (!maxHeap.isEmpty() && count++ < 10) {\\n      Tweet tweet = maxHeap.poll();\\n      newsFeed.add(tweet.id);\\n      if (tweet.next != null)\\n        maxHeap.offer(tweet.next);\\n    }\\n\\n    return newsFeed;\\n  }\\n\\n  /**\\n   * Follower follows a followee.\\n   * If the operation is invalid, it should be a no-op.\\n   */\\n  public void follow(int followerId, int followeeId) {\\n    if (followerId == followeeId)\\n      return;\\n    users.putIfAbsent(followerId, new User(followerId));\\n    users.putIfAbsent(followeeId, new User(followeeId));\\n    users.get(followerId).follow(followeeId);\\n  }\\n\\n  /**\\n   * Follower unfollows a followee.\\n   * If the operation is invalid, it should be a no-op.\\n   */\\n  public void unfollow(int followerId, int followeeId) {\\n    if (followerId == followeeId)\\n      return;\\n    if (users.containsKey(followerId) && users.containsKey(followeeId))\\n      users.get(followerId).unfollow(followeeId);\\n  }\\n\\n  private int time = 0;\\n  private Map<Integer, User> users = new HashMap<>(); // {userId: User}\\n}\\n",
                "solutionTags": [
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "class Tweet {\\n  public int id;\\n  public int time;\\n  public Tweet next = null;\\n  public Tweet(int id, int time) {\\n    this.id = id;\\n    this.time = time;\\n  }\\n}\\n\\nclass User {\\n  private int id;\\n  public Set<Integer> followeeIds = new HashSet<>();\\n  public Tweet tweetHead = null;\\n\\n  public User(int id) {\\n    this.id = id;\\n    follow(id); // follow himself\\n  }\\n\\n  public void follow(int followeeId) {\\n    followeeIds.add(followeeId);\\n  }\\n\\n  public void unfollow(int followeeId) {\\n    followeeIds.remove(followeeId);\\n  }\\n\\n  public void post(int tweetId, int time) {\\n    final Tweet oldTweetHead = tweetHead;\\n    tweetHead = new Tweet(tweetId, time);\\n    tweetHead.next = oldTweetHead;\\n  }\\n}\\n\\nclass Twitter {\\n  /** Compose a new tweet. */\\n  public void postTweet(int userId, int tweetId) {\\n    users.putIfAbsent(userId, new User(userId));\\n    users.get(userId).post(tweetId, time++);\\n  }\\n\\n  /**\\n   * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in\\n   * the news feed must be posted by users who the user followed or by the user\\n   * herself. Tweets must be ordered from most recent to least recent.\\n   */\\n  public List<Integer> getNewsFeed(int userId) {\\n    if (!users.containsKey(userId))\\n      return new ArrayList<>();\\n\\n    List<Integer> newsFeed = new ArrayList<>();\\n    Queue<Tweet> maxHeap = new PriorityQueue<>((a, b) -> b.time - a.time);\\n\\n    for (final int followeeId : users.get(userId).followeeIds) {\\n      Tweet tweetHead = users.get(followeeId).tweetHead;\\n      if (tweetHead != null)\\n        maxHeap.offer(tweetHead);\\n    }\\n\\n    int count = 0;\\n    while (!maxHeap.isEmpty() && count++ < 10) {\\n      Tweet tweet = maxHeap.poll();\\n      newsFeed.add(tweet.id);\\n      if (tweet.next != null)\\n        maxHeap.offer(tweet.next);\\n    }\\n\\n    return newsFeed;\\n  }\\n\\n  /**\\n   * Follower follows a followee.\\n   * If the operation is invalid, it should be a no-op.\\n   */\\n  public void follow(int followerId, int followeeId) {\\n    if (followerId == followeeId)\\n      return;\\n    users.putIfAbsent(followerId, new User(followerId));\\n    users.putIfAbsent(followeeId, new User(followeeId));\\n    users.get(followerId).follow(followeeId);\\n  }\\n\\n  /**\\n   * Follower unfollows a followee.\\n   * If the operation is invalid, it should be a no-op.\\n   */\\n  public void unfollow(int followerId, int followeeId) {\\n    if (followerId == followeeId)\\n      return;\\n    if (users.containsKey(followerId) && users.containsKey(followeeId))\\n      users.get(followerId).unfollow(followeeId);\\n  }\\n\\n  private int time = 0;\\n  private Map<Integer, User> users = new HashMap<>(); // {userId: User}\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2338151,
                "title": "c-easy-using-linked-list-and-2d-bool-array",
                "content": "```\\nclass Twitter {\\nprivate:\\n\\t\\n\\t// Structure of List Node\\n    struct ListNode {\\n      // Contains user id and tweet id\\n\\t  int uid, tid;\\n      ListNode *next;\\n      ListNode(int x, int y) : uid(x), tid(y), next(NULL) {}\\n    };\\n    \\n\\t// A DP that signify the relation between two user\\n    bool dp[501][501] = {false};\\n    \\n\\t// Linked-List of Tweets\\n    ListNode *head;\\npublic:\\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        \\n\\t\\t// First Tweet ever\\n\\t\\tif(!head) head = new ListNode(userId, tweetId);\\n        \\n\\t\\t// Add new node ahead of curretn head\\n        else{\\n            ListNode *tp = new ListNode(userId, tweetId);\\n            tp->next = head;\\n            head = tp;    \\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        ListNode *cur = head;\\n        \\n        vector<int> ans;\\n        \\n\\t\\t// Iterate through the linked-list till either the ans size become 10 or it reaches the end\\n        while((cur != NULL) && (ans.size() < 10)){\\n\\t\\t\\n\\t\\t\\t// The feed posted by ther user himself and the peopele he follow will only be visible\\n            if((userId == cur->uid) || (dp[userId][cur->uid])) ans.push_back(cur->tid);\\n     \\n            cur = cur->next;\\n        }\\n        return ans;\\n    }\\n    \\n\\t// If a follows b then dp[a][b] = true\\n    void follow(int followerId, int followeeId) {\\n        dp[followerId][followeeId] = true;\\n    }\\n    \\n\\t// If a unfollow b then dp[a][b] = false\\n    void unfollow(int followerId, int followeeId) {\\n        dp[followerId][followeeId] = false;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Twitter {\\nprivate:\\n\\t\\n\\t// Structure of List Node\\n    struct ListNode {\\n      // Contains user id and tweet id\\n\\t  int uid, tid;\\n      ListNode *next;\\n      ListNode(int x, int y) : uid(x), tid(y), next(NULL) {}\\n    };\\n    \\n\\t// A DP that signify the relation between two user\\n    bool dp[501][501] = {false};\\n    \\n\\t// Linked-List of Tweets\\n    ListNode *head;\\npublic:\\n    Twitter() {}\\n    \\n    void postTweet(int userId, int tweetId) {\\n        \\n\\t\\t// First Tweet ever\\n\\t\\tif(!head) head = new ListNode(userId, tweetId);\\n        \\n\\t\\t// Add new node ahead of curretn head\\n        else{\\n            ListNode *tp = new ListNode(userId, tweetId);\\n            tp->next = head;\\n            head = tp;    \\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        ListNode *cur = head;\\n        \\n        vector<int> ans;\\n        \\n\\t\\t// Iterate through the linked-list till either the ans size become 10 or it reaches the end\\n        while((cur != NULL) && (ans.size() < 10)){\\n\\t\\t\\n\\t\\t\\t// The feed posted by ther user himself and the peopele he follow will only be visible\\n            if((userId == cur->uid) || (dp[userId][cur->uid])) ans.push_back(cur->tid);\\n     \\n            cur = cur->next;\\n        }\\n        return ans;\\n    }\\n    \\n\\t// If a follows b then dp[a][b] = true\\n    void follow(int followerId, int followeeId) {\\n        dp[followerId][followeeId] = true;\\n    }\\n    \\n\\t// If a unfollow b then dp[a][b] = false\\n    void unfollow(int followerId, int followeeId) {\\n        dp[followerId][followeeId] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128309,
                "title": "c-hash-map-min-heap-0ms-beats-100",
                "content": "\\n```\\nclass Twitter {\\npublic:\\n    unordered_map<int,set<int>>fol;\\n    unordered_map<int,vector<pair<int,int>>>tweet;\\n    long long time;\\n    Twitter() {\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet[userId].push_back({time++,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<int>ans;\\n        for(auto it:tweet[userId]){\\n            if(pq.size()<10){\\n                pq.push(it);\\n            }else{\\n                if(pq.top().first<it.first){\\n                    pq.pop();\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        for(auto it:fol[userId]){\\n            for(auto i:tweet[it]){\\n                if(pq.size()<10){\\n                    pq.push(i);\\n                }else{\\n                    if(pq.top().first<i.first){\\n                        pq.pop();\\n                        pq.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(followerId!=followeeId){\\n            fol[followerId].insert(followeeId);\\n        }\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        fol[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int,set<int>>fol;\\n    unordered_map<int,vector<pair<int,int>>>tweet;\\n    long long time;\\n    Twitter() {\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet[userId].push_back({time++,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        vector<int>ans;\\n        for(auto it:tweet[userId]){\\n            if(pq.size()<10){\\n                pq.push(it);\\n            }else{\\n                if(pq.top().first<it.first){\\n                    pq.pop();\\n                    pq.push(it);\\n                }\\n            }\\n        }\\n        for(auto it:fol[userId]){\\n            for(auto i:tweet[it]){\\n                if(pq.size()<10){\\n                    pq.push(i);\\n                }else{\\n                    if(pq.top().first<i.first){\\n                        pq.pop();\\n                        pq.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(followerId!=followeeId){\\n            fol[followerId].insert(followeeId);\\n        }\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        fol[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2001835,
                "title": "beats-100-c-explanation",
                "content": "The solution is a bit complex. But it is very fast.\\nThe solution lies in how you store the data.\\n\\nTo store every user\\'s following list. Use unordered_set for fast insert and remove:\\n**unordered_map<int, unordered_set< int>>**\\n\\nSince tweetIds can be any value, the time at which it is posted is important. We store tweet info in vector for fast access:\\n**vector<int> tweetData;**\\n**int tweetTime;**\\n\\nTo store every user\\'s tweets, we keep a map with Tweet*. Every new tweet will be added at the front for recent tweet retrieval\\n**unordered_map<int, Tweet\\\\*> userTweets;**\\n\\n**follow** and **unfollow** api are pretty straightforward. Just insert and erase in the unordered_set of follower\\n\\n**postTweet:**\\nEverytime a user post a tweets, we push its value in the vector. The index(tweetTime) of vector is stored in user Tweets data. We create a new tweet with the index and add it the front of Tweet Linked List of user.\\n\\n**getNewsFeed:**\\nRemember we only need 10 recent tweets.\\nCases:\\n1. All 10 tweets are of same user/followee id.\\n2. There are less than 10 tweets.\\n3. All recent tweets are distributed across user and followees.\\n\\nWe take a priority queue(maxHeap) and push all head pointers of user\\'s Tweet linked list and all followees\\' Tweet linked lists. This is very similar to \"Merge K sorted lists\" problem.\\n\\nWe start popping from priority queue and stop if 10 count is reached or priority queue has no more tweets left.\\n\\nEverytime we pop, we take tweet value from Tweet vector (tweetData) for the index popped and if there exists a next pointer in that Linked List, we push it to priority queue, thereby ensuring the conditions that there can be multiple recent tweets from same person.\\n\\n***Note:** There is still optimization scope as we are storing more than 10 tweets for each user in the Linked List. Suggestions are welcome. And yes, I am not freeing the memory taken for each Tweet.*\\n```\\nstruct Tweet {\\n    int id;\\n    Tweet* next;\\n};\\nstruct cmp {\\n    bool operator() (Tweet* t1, Tweet* t2) {\\n        return t1->id < t2->id;\\n    }\\n};\\nclass Twitter {\\nprivate:\\n    unordered_map<int,unordered_set<int>> following;\\n    vector<int> tweetData;\\n    int tweetTime;\\n    unordered_map<int, Tweet*> userTweets;\\npublic:\\n    Twitter() {\\n        tweetTime = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {        \\n        tweetData.push_back(tweetId);\\n        Tweet* t = new Tweet();\\n        t->id = tweetTime;\\n        t->next = userTweets[userId];\\n        userTweets[userId] = t;\\n        tweetTime++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        priority_queue<Tweet*, vector<Tweet*>, cmp> pq; \\n        if(userTweets[userId] != NULL) {\\n            pq.push(userTweets[userId]);\\n        }\\n        for(auto it = following[userId].begin(); it != following[userId].end(); it++) {\\n            if(userTweets[*it] != NULL) {\\n                pq.push(userTweets[*it]);\\n            }\\n        }\\n        int count = 0;\\n        while(count < 10 && !pq.empty()) {\\n            Tweet* t = pq.top();\\n            pq.pop();\\n            if(t->next) pq.push(t->next);\\n            ans.push_back(tweetData[t->id]);\\n            ++count;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n        \\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Tweet {\\n    int id;\\n    Tweet* next;\\n};\\nstruct cmp {\\n    bool operator() (Tweet* t1, Tweet* t2) {\\n        return t1->id < t2->id;\\n    }\\n};\\nclass Twitter {\\nprivate:\\n    unordered_map<int,unordered_set<int>> following;\\n    vector<int> tweetData;\\n    int tweetTime;\\n    unordered_map<int, Tweet*> userTweets;\\npublic:\\n    Twitter() {\\n        tweetTime = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {        \\n        tweetData.push_back(tweetId);\\n        Tweet* t = new Tweet();\\n        t->id = tweetTime;\\n        t->next = userTweets[userId];\\n        userTweets[userId] = t;\\n        tweetTime++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        priority_queue<Tweet*, vector<Tweet*>, cmp> pq; \\n        if(userTweets[userId] != NULL) {\\n            pq.push(userTweets[userId]);\\n        }\\n        for(auto it = following[userId].begin(); it != following[userId].end(); it++) {\\n            if(userTweets[*it] != NULL) {\\n                pq.push(userTweets[*it]);\\n            }\\n        }\\n        int count = 0;\\n        while(count < 10 && !pq.empty()) {\\n            Tweet* t = pq.top();\\n            pq.pop();\\n            if(t->next) pq.push(t->next);\\n            ans.push_back(tweetData[t->id]);\\n            ++count;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n        \\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838593,
                "title": "c-deque-hashmap-clean-and-concise-explained",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions**\\n\\n**Approach :**\\n\\n* We can either a doubly linked list or a C++ Deque. \\n* We can push the latest tweet to the front of the deque or linked list\\ndepending on which data structure you have used.\\n* Then while retrieving the tweets we could hash the followerIDs of the followers of a particular member.\\n* Then we can iterate over Doubly Linked List / Deque to find the most recent tweetIDs corresponding to that user.\\n\\n```\\nclass Twitter {\\nprivate:\\n   deque<pair<int,int>>dq,tmp;\\n    map<int,vector<int>>ma;\\npublic:\\n    \\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        dq.push_front({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        tmp=dq;\\n        int k=10;\\n        auto x=ma[userId];\\n        map<int,int>hash;\\n        for(auto i:x){\\n        \\n            hash[i]=1;\\n        }\\n        while(!tmp.empty() and k!=0)\\n        {\\n       \\n            auto x=tmp.front();\\n            if(x.first==userId or hash[x.first]){\\n                ans.push_back(x.second);\\n                k--;\\n            }\\n            tmp.pop_front();\\n        \\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        ma[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        \\n        vector<int>followers=ma[followerId];\\n        auto it=find(followers.begin(),followers.end(),followeeId);\\n        if(it==followers.end())\\n            return;\\n        followers.erase(it);\\n        ma[followerId]=followers;\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Design",
                    "Queue"
                ],
                "code": "```\\nclass Twitter {\\nprivate:\\n   deque<pair<int,int>>dq,tmp;\\n    map<int,vector<int>>ma;\\npublic:\\n    \\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        dq.push_front({userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int>ans;\\n        tmp=dq;\\n        int k=10;\\n        auto x=ma[userId];\\n        map<int,int>hash;\\n        for(auto i:x){\\n        \\n            hash[i]=1;\\n        }\\n        while(!tmp.empty() and k!=0)\\n        {\\n       \\n            auto x=tmp.front();\\n            if(x.first==userId or hash[x.first]){\\n                ans.push_back(x.second);\\n                k--;\\n            }\\n            tmp.pop_front();\\n        \\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        ma[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        \\n        vector<int>followers=ma[followerId];\\n        auto it=find(followers.begin(),followers.end(),followeeId);\\n        if(it==followers.end())\\n            return;\\n        followers.erase(it);\\n        ma[followerId]=followers;\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715907,
                "title": "easy-java-solution-using-hashset-and-linkedlist",
                "content": "class Twitter {\\n    \\n\\tHashSet[] followers; // store follower details\\n    LinkedList<int[]> feed; // store feed\\n    \\n    public Twitter() {\\n        followers = new HashSet[501]; //max id could be 500\\n        feed = new LinkedList<>();\\n        \\n        for(int i = 1 ; i < 501 ; i++)\\n            followers[i] = new HashSet<>();\\n        \\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        feed.addFirst(new int[]{userId , tweetId}); // keep adding each feed at start of linked list\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        Iterator<int[]> it = feed.iterator();\\n        int count = 0;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        while(it.hasNext() && count < 10){\\n            int[] f = it.next();\\n            if(f[0] == userId || followers[userId].contains(f[0])){ //if post is by user itself or any friend add it to feed\\n                res.add(f[1]);\\n                count++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        followers[followerId].add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        followers[followerId].remove(followeeId);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Twitter {\\n    \\n\\tHashSet[] followers; // store follower details\\n    LinkedList<int[]> feed; // store feed\\n    \\n    public Twitter() {\\n        followers = new HashSet[501]; //max id could be 500\\n        feed = new LinkedList<>();\\n        \\n        for(int i = 1 ; i < 501 ; i++)\\n            followers[i] = new HashSet<>();\\n        \\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        feed.addFirst(new int[]{userId , tweetId}); // keep adding each feed at start of linked list\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        Iterator<int[]> it = feed.iterator();\\n        int count = 0;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        while(it.hasNext() && count < 10){\\n            int[] f = it.next();\\n            if(f[0] == userId || followers[userId].contains(f[0])){ //if post is by user itself or any friend add it to feed\\n                res.add(f[1]);\\n                count++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        followers[followerId].add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        followers[followerId].remove(followeeId);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1665193,
                "title": "java-100-simple-and-clean-solution-linkedlist-hashmap",
                "content": "Explanation: \\nThe idea behind my solution was to have a doubly linkedlist to store all the tweets which will allow us to add the new tweets to the front of the linkedlist in constant O(1) time. By doing this, we have the newest tweets in the front of the list, so in the getNewsFeed function, we will populate the newest tweets first. To store the followers of each user, I decided to create a HashMap with values of HashSets. Since each user has a unique userId, using a HashMap and HashSet will allow us to search for certain users in constant O(1) time which is essential when getting the newsFeed. I created an extra function \\'initUser\\' to initialize a user inside the followers list before posting a tweet or following another user to avoid getting null pointer exceptions. (A user that doesn\\'t exist can\\'t follow people). \\n\\nCreated a TweetEntry \\n\\nclass Twitter {\\n    \\n    static class TweetEntry {\\n        int tweetId;\\n        int userId;\\n        \\n        public TweetEntry(int tweetId, int userId) {\\n            this.tweetId = tweetId;\\n            this.userId = userId;\\n        }\\n    }\\n    \\n    LinkedList<TweetEntry> allTweets;\\n    HashMap<Integer, HashSet<Integer>> followers;\\n\\n    public Twitter() {\\n        allTweets = new LinkedList<>();\\n        followers = new HashMap<>();\\n    }\\n    \\n    private void initUser(int userId) {\\n        if(!followers.containsKey(userId)) {\\n            HashSet<Integer> listOfFollowers = new HashSet<>();\\n            listOfFollowers.add(userId);\\n            followers.put(userId, listOfFollowers);\\n        }\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        initUser(userId);\\n        TweetEntry newPost = new TweetEntry(tweetId, userId);\\n        allTweets.addFirst(newPost);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        HashSet<Integer> userFollowList = followers.get(userId);\\n        if(userFollowList == null || userFollowList.size() == 0) return new ArrayList<>();\\n        List<Integer> newsFeed = new ArrayList<>();\\n        for(TweetEntry tweet : allTweets) {\\n            if(userFollowList.contains(tweet.userId)) {\\n                newsFeed.add(tweet.tweetId);\\n            }\\n            if(newsFeed.size() == 10) break;\\n        }\\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        initUser(followerId);\\n        if(followers.containsKey(followerId)) {\\n            followers.get(followerId).add(followeeId);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(followers.containsKey(followerId)) {\\n            followers.get(followerId).remove(followeeId);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "Explanation: \\nThe idea behind my solution was to have a doubly linkedlist to store all the tweets which will allow us to add the new tweets to the front of the linkedlist in constant O(1) time. By doing this, we have the newest tweets in the front of the list, so in the getNewsFeed function, we will populate the newest tweets first. To store the followers of each user, I decided to create a HashMap with values of HashSets. Since each user has a unique userId, using a HashMap and HashSet will allow us to search for certain users in constant O(1) time which is essential when getting the newsFeed. I created an extra function \\'initUser\\' to initialize a user inside the followers list before posting a tweet or following another user to avoid getting null pointer exceptions. (A user that doesn\\'t exist can\\'t follow people). \\n\\nCreated a TweetEntry \\n\\nclass Twitter {\\n    \\n    static class TweetEntry {\\n        int tweetId;\\n        int userId;\\n        \\n        public TweetEntry(int tweetId, int userId) {\\n            this.tweetId = tweetId;\\n            this.userId = userId;\\n        }\\n    }\\n    \\n    LinkedList<TweetEntry> allTweets;\\n    HashMap<Integer, HashSet<Integer>> followers;\\n\\n    public Twitter() {\\n        allTweets = new LinkedList<>();\\n        followers = new HashMap<>();\\n    }\\n    \\n    private void initUser(int userId) {\\n        if(!followers.containsKey(userId)) {\\n            HashSet<Integer> listOfFollowers = new HashSet<>();\\n            listOfFollowers.add(userId);\\n            followers.put(userId, listOfFollowers);\\n        }\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        initUser(userId);\\n        TweetEntry newPost = new TweetEntry(tweetId, userId);\\n        allTweets.addFirst(newPost);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        HashSet<Integer> userFollowList = followers.get(userId);\\n        if(userFollowList == null || userFollowList.size() == 0) return new ArrayList<>();\\n        List<Integer> newsFeed = new ArrayList<>();\\n        for(TweetEntry tweet : allTweets) {\\n            if(userFollowList.contains(tweet.userId)) {\\n                newsFeed.add(tweet.tweetId);\\n            }\\n            if(newsFeed.size() == 10) break;\\n        }\\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        initUser(followerId);\\n        if(followers.containsKey(followerId)) {\\n            followers.get(followerId).add(followeeId);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(followers.containsKey(followerId)) {\\n            followers.get(followerId).remove(followeeId);\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1507996,
                "title": "c-4ms-priority-q-map-short-and-simple",
                "content": "1. Push tweets into priority queue with current time as priority.\\n2. Maintain a map to store all people a user follows.\\n3. To get feed, pop the queue and see if the popped user is being followed by the userID.\\n\\n```\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_set<int>> friends;\\n    priority_queue<vector<int>> feed;\\n    int time;\\n    Twitter() {\\n        friends.clear();\\n        feed=priority_queue<vector<int>>();\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        feed.push({time++,userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ret;\\n        priority_queue<vector<int>> feeds=feed;\\n        int n=0;\\n        while(!feeds.empty() && n<10)\\n        {\\n            auto it=feeds.top();\\n            if(it[1]==userId || friends[userId].find(it[1])!=friends[userId].end())\\n            {\\n                n++;\\n                ret.push_back(it[2]);\\n            }\\n            feeds.pop();\\n        }\\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_set<int>> friends;\\n    priority_queue<vector<int>> feed;\\n    int time;\\n    Twitter() {\\n        friends.clear();\\n        feed=priority_queue<vector<int>>();\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        feed.push({time++,userId,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ret;\\n        priority_queue<vector<int>> feeds=feed;\\n        int n=0;\\n        while(!feeds.empty() && n<10)\\n        {\\n            auto it=feeds.top();\\n            if(it[1]==userId || friends[userId].find(it[1])!=friends[userId].end())\\n            {\\n                n++;\\n                ret.push_back(it[2]);\\n            }\\n            feeds.pop();\\n        }\\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435996,
                "title": "java-hashmap-priorityqueue-solution",
                "content": "```\\n// HashMap + PriorityQueue + Set + Queue\\nclass Twitter {\\n    private long globalTimestamp;\\n    private Map<Integer, Queue<Tweet>> tweetDB;\\n    private Map<Integer, Set<Integer>> followingDB;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        globalTimestamp = Integer.MIN_VALUE;\\n        tweetDB = new HashMap<>();\\n        followingDB = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        Queue<Tweet> tweets = tweetDB.getOrDefault(userId, new ArrayDeque<>());\\n        if (tweets.isEmpty()) {\\n            tweetDB.put(userId, tweets);\\n        }\\n        if (tweets.size() >= 10) {\\n            tweets.poll();  // remove old tweet\\n        }\\n        tweets.add(new Tweet(tweetId));\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        PriorityQueue<Tweet> pq = new PriorityQueue<>(11, (t1, t2) -> Long.compare(t1.timestamp, t2.timestamp));\\n        Set<Integer> followees = followingDB.getOrDefault(userId, new HashSet<>());\\n        if (followees.isEmpty()) {\\n            followees.add(userId);\\n        }\\n        for (Integer followee : followees) {\\n            Queue<Tweet> tweets = tweetDB.get(followee);\\n            if (tweets == null) continue;\\n            for (Tweet tweet : tweets) {\\n                pq.add(tweet);\\n                if (pq.size() > 10) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        List<Integer> feed = new ArrayList<>(pq.size());\\n        while (!pq.isEmpty()) {\\n            feed.add(pq.poll().tweetId);\\n        }\\n        Collections.reverse(feed);\\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> followees = followingDB.getOrDefault(followerId, new HashSet<>());\\n        if (followees.isEmpty()) {\\n            followingDB.put(followerId, followees);\\n            followees.add(followerId);\\n        }\\n        followees.add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId) return;\\n        Set<Integer> followees = followingDB.get(followerId);\\n        if (followees == null) return;\\n        followees.remove(followeeId);\\n    }\\n    \\n    class Tweet {\\n        int tweetId;\\n        long timestamp;\\n        Tweet(int tweetId) {\\n            this.tweetId = tweetId;\\n            this.timestamp = globalTimestamp++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// HashMap + PriorityQueue + Set + Queue\\nclass Twitter {\\n    private long globalTimestamp;\\n    private Map<Integer, Queue<Tweet>> tweetDB;\\n    private Map<Integer, Set<Integer>> followingDB;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        globalTimestamp = Integer.MIN_VALUE;\\n        tweetDB = new HashMap<>();\\n        followingDB = new HashMap<>();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        Queue<Tweet> tweets = tweetDB.getOrDefault(userId, new ArrayDeque<>());\\n        if (tweets.isEmpty()) {\\n            tweetDB.put(userId, tweets);\\n        }\\n        if (tweets.size() >= 10) {\\n            tweets.poll();  // remove old tweet\\n        }\\n        tweets.add(new Tweet(tweetId));\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        PriorityQueue<Tweet> pq = new PriorityQueue<>(11, (t1, t2) -> Long.compare(t1.timestamp, t2.timestamp));\\n        Set<Integer> followees = followingDB.getOrDefault(userId, new HashSet<>());\\n        if (followees.isEmpty()) {\\n            followees.add(userId);\\n        }\\n        for (Integer followee : followees) {\\n            Queue<Tweet> tweets = tweetDB.get(followee);\\n            if (tweets == null) continue;\\n            for (Tweet tweet : tweets) {\\n                pq.add(tweet);\\n                if (pq.size() > 10) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n        List<Integer> feed = new ArrayList<>(pq.size());\\n        while (!pq.isEmpty()) {\\n            feed.add(pq.poll().tweetId);\\n        }\\n        Collections.reverse(feed);\\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        Set<Integer> followees = followingDB.getOrDefault(followerId, new HashSet<>());\\n        if (followees.isEmpty()) {\\n            followingDB.put(followerId, followees);\\n            followees.add(followerId);\\n        }\\n        followees.add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId) return;\\n        Set<Integer> followees = followingDB.get(followerId);\\n        if (followees == null) return;\\n        followees.remove(followeeId);\\n    }\\n    \\n    class Tweet {\\n        int tweetId;\\n        long timestamp;\\n        Tweet(int tweetId) {\\n            this.tweetId = tweetId;\\n            this.timestamp = globalTimestamp++;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434664,
                "title": "c-8ms-optimized-solution-cleanest-code-with-inline-comments-minheap-ood",
                "content": "```\\nclass Twitter {\\npublic:\\n    \\n    unordered_map<int, vector<pair<int,int>> > tweets;          // --> map of { userId, vector of ({time, tweetId}) }\\n    unordered_map<int, set<int>> followList;                    // --> map of {userId, set of followers}\\n    int time;                                                   // --> timestamp\\n    \\n    \\n    Twitter() {\\n        time = 0;\\n        \\n    }\\n    \\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time, tweetId});\\n        time++;\\n    }\\n    \\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> t;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > minheap;\\n        \\n        /* Since user is follower of himself hence we will push his tweets in minheap */\\n        \\n        for(auto tweet : tweets[userId]){\\n            minheap.push(tweet);\\n            \\n            if(minheap.size()>10)\\n                minheap.pop();\\n        }\\n        \\n        /* pushing followee\\'s tweets in minheap */\\n        \\n        for(int flw : followList[userId]){\\n            \\n            for(auto tweet : tweets[flw]){\\n                minheap.push(tweet);\\n\\n                if(minheap.size()>10)\\n                    minheap.pop();\\n            }\\n        }\\n        \\n        /* pop recent 10 tweets */\\n        \\n        while(!minheap.empty()){\\n            t.push_back(minheap.top().second);\\n            minheap.pop();\\n        }\\n        \\n        reverse(t.begin(), t.end());\\n        return t;\\n    }\\n    \\n    \\n    void follow(int followerId, int followeeId) {\\n        followList[followerId].insert(followeeId);              // --> logn time to insert\\n    }\\n    \\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followList[followerId].erase(followeeId);               // --> logn time to erase\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    \\n    unordered_map<int, vector<pair<int,int>> > tweets;          // --> map of { userId, vector of ({time, tweetId}) }\\n    unordered_map<int, set<int>> followList;                    // --> map of {userId, set of followers}\\n    int time;                                                   // --> timestamp\\n    \\n    \\n    Twitter() {\\n        time = 0;\\n        \\n    }\\n    \\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets[userId].push_back({time, tweetId});\\n        time++;\\n    }\\n    \\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> t;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > minheap;\\n        \\n        /* Since user is follower of himself hence we will push his tweets in minheap */\\n        \\n        for(auto tweet : tweets[userId]){\\n            minheap.push(tweet);\\n            \\n            if(minheap.size()>10)\\n                minheap.pop();\\n        }\\n        \\n        /* pushing followee\\'s tweets in minheap */\\n        \\n        for(int flw : followList[userId]){\\n            \\n            for(auto tweet : tweets[flw]){\\n                minheap.push(tweet);\\n\\n                if(minheap.size()>10)\\n                    minheap.pop();\\n            }\\n        }\\n        \\n        /* pop recent 10 tweets */\\n        \\n        while(!minheap.empty()){\\n            t.push_back(minheap.top().second);\\n            minheap.pop();\\n        }\\n        \\n        reverse(t.begin(), t.end());\\n        return t;\\n    }\\n    \\n    \\n    void follow(int followerId, int followeeId) {\\n        followList[followerId].insert(followeeId);              // --> logn time to insert\\n    }\\n    \\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followList[followerId].erase(followeeId);               // --> logn time to erase\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386188,
                "title": "java-solution-using-hashmap-and-dequeue-with-o-n-time-complexity-for-getnewsfeed-function",
                "content": "Use a HashMap to store follower and followee relations \\n```HashMap<Integer, HashSet<Integer>>```\\nIn the above set we can store all the users which are followed by the key user\\n\\nFor storing the tweet we can take a simple Dequeue and append the new tweet at the head. \\n\\n\\nNow the tricky part (Which is actually simple)\\n```getNewsFeed```\\nThis can be done by simply iterating through the dqueue and check if the tweet is belongs to one of the followed user if yes then insert in out list if not go to next.\\n\\n\\nHere is the full code\\n```\\nclass Twitter {\\n    \\n    HashMap<Integer, HashSet<Integer>> followerMap = null;\\n    Deque<Integer[]> post = null;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        followerMap = new HashMap<Integer, HashSet<Integer>>();\\n        post = new ArrayDeque<Integer[]>();\\n        \\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        post.addFirst(new Integer[]{userId, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        Iterator<Integer[]> it = post.iterator();\\n        List<Integer> news = new ArrayList<Integer>();\\n        HashSet<Integer> followee = null;\\n        \\n        if(followerMap.containsKey(userId)) {\\n            followee = followerMap.get(userId);\\n        } else {\\n            followee = new HashSet<Integer>();\\n        }\\n        \\n        while(it.hasNext()) {\\n            if(news.size() == 10) {\\n                break;\\n            }\\n            Integer[] post = it.next();\\n            if(post[0] == userId || followee.contains(post[0])) {\\n                news.add(post[1]);\\n            }\\n        }\\n        return news;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(followerMap.containsKey(followerId)) {\\n            followerMap.get(followerId).add(followeeId);\\n        } else {\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            set.add(followerId);\\n            set.add(followeeId);\\n            followerMap.put(followerId, set);\\n        }\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(followerId != followeeId) {\\n            if(followerMap.containsKey(followerId)) {\\n                followerMap.get(followerId).remove(followeeId);\\n            } \\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [],
                "code": "```HashMap<Integer, HashSet<Integer>>```\n```getNewsFeed```\n```\\nclass Twitter {\\n    \\n    HashMap<Integer, HashSet<Integer>> followerMap = null;\\n    Deque<Integer[]> post = null;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        followerMap = new HashMap<Integer, HashSet<Integer>>();\\n        post = new ArrayDeque<Integer[]>();\\n        \\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        post.addFirst(new Integer[]{userId, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        \\n        Iterator<Integer[]> it = post.iterator();\\n        List<Integer> news = new ArrayList<Integer>();\\n        HashSet<Integer> followee = null;\\n        \\n        if(followerMap.containsKey(userId)) {\\n            followee = followerMap.get(userId);\\n        } else {\\n            followee = new HashSet<Integer>();\\n        }\\n        \\n        while(it.hasNext()) {\\n            if(news.size() == 10) {\\n                break;\\n            }\\n            Integer[] post = it.next();\\n            if(post[0] == userId || followee.contains(post[0])) {\\n                news.add(post[1]);\\n            }\\n        }\\n        return news;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if(followerMap.containsKey(followerId)) {\\n            followerMap.get(followerId).add(followeeId);\\n        } else {\\n            HashSet<Integer> set = new HashSet<Integer>();\\n            set.add(followerId);\\n            set.add(followeeId);\\n            followerMap.put(followerId, set);\\n        }\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if(followerId != followeeId) {\\n            if(followerMap.containsKey(followerId)) {\\n                followerMap.get(followerId).remove(followeeId);\\n            } \\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215883,
                "title": "java-hashmap-priorityqueue-8ms-beats-99-in-both-time-and-memory",
                "content": "\\n\\n\\tclass Tweet {\\n\\n\\t\\tint idx;\\n\\t\\tint userId;\\n\\t\\tint tweetId;\\n\\t\\tint time;\\n\\n\\t\\tpublic Tweet(int tweetId, int time, int idx, int userId) {\\n\\n\\t\\t\\tthis.tweetId = tweetId;\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.userId = userId;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass Twitter {\\n\\n\\t\\tint time;\\n\\t\\tHashMap<Integer, HashSet<Integer>> followerMap;\\n\\t\\tHashMap<Integer, List<Tweet>> tweetMap;\\n\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\t// O(1)\\n\\t\\tpublic Twitter() {\\n\\n\\t\\t\\ttime = 0;\\n\\t\\t\\tfollowerMap = new HashMap<>();\\n\\t\\t\\ttweetMap = new HashMap<>();\\n\\t\\t}\\n\\n\\t\\t/** Compose a new tweet. */\\n\\t\\t// O(1)\\n\\t\\tpublic void postTweet(int userId, int tweetId) {\\n\\n\\t\\t\\tList<Tweet> tweets = tweetMap.get(userId);\\n\\t\\t\\tif (tweets == null) {\\n\\t\\t\\t\\ttweets = new ArrayList<>();\\n\\t\\t\\t\\tTweet tweet = new Tweet(tweetId, time++, 0, userId);\\n\\t\\t\\t\\ttweets.add(tweet);\\n\\t\\t\\t\\ttweetMap.put(userId, tweets);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tTweet tweet = new Tweet(tweetId, time++, tweets.size(), userId);\\n\\t\\t\\t\\ttweets.add(tweet);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in\\n\\t\\t * the news feed must be posted by users who the user followed or by the user\\n\\t\\t * herself. Tweets must be ordered from most recent to least recent.\\n\\t\\t */\\n\\t\\t// O(logn)\\n\\t\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\n\\t\\t\\tPriorityQueue<Tweet> heap = new PriorityQueue<>(new Comparator<Tweet>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic int compare(Tweet o1, Tweet o2) {\\n\\t\\t\\t\\t\\treturn o2.time - o1.time;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tList<Tweet> tweets = tweetMap.get(userId);\\n\\t\\t\\tif (tweets != null)\\n\\t\\t\\t\\theap.offer(tweets.get(tweets.size() - 1));\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.getOrDefault(userId, new HashSet<>());\\n\\t\\t\\tfor (int followee : followees) {\\n\\t\\t\\t\\ttweets = tweetMap.get(followee);\\n\\t\\t\\t\\tif (tweets != null)\\n\\t\\t\\t\\t\\theap.add(tweets.get(tweets.size() - 1));\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint size = 0;\\n\\t\\t\\twhile (!heap.isEmpty() && size < 10) {\\n\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t\\tTweet tweet = heap.poll();\\n\\t\\t\\t\\tint idx = tweet.idx, followeeId = tweet.userId;\\n\\t\\t\\t\\tans.add(tweet.tweetId);\\n\\t\\t\\t\\ttweets = tweetMap.get(followeeId);\\n\\t\\t\\t\\tif (tweets != null && idx - 1 >= 0)\\n\\t\\t\\t\\t\\theap.add(tweets.get(idx - 1));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Follower follows a followee. If the operation is invalid, it should be a\\n\\t\\t * no-op.\\n\\t\\t */\\n\\t\\t// O(1)\\n\\t\\tpublic void follow(int followerId, int followeeId) {\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.get(followerId);\\n\\t\\t\\tif (followees == null) {\\n\\t\\t\\t\\tfollowees = new HashSet<>();\\n\\t\\t\\t\\tfollowees.add(followeeId);\\n\\t\\t\\t\\tfollowerMap.put(followerId, followees);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tfollowees.add(followeeId);\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Follower unfollows a followee. If the operation is invalid, it should be a\\n\\t\\t * no-op.\\n\\t\\t */\\n\\t\\t// O(1)\\n\\t\\tpublic void unfollow(int followerId, int followeeId) {\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.get(followerId);\\n\\t\\t\\tif (followees == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tfollowees.remove(followeeId);\\n\\t\\t\\tif (followees.size() == 0)\\n\\t\\t\\t\\tfollowerMap.remove(followerId);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\tclass Tweet {\\n\\n\\t\\tint idx;\\n\\t\\tint userId;\\n\\t\\tint tweetId;\\n\\t\\tint time;\\n\\n\\t\\tpublic Tweet(int tweetId, int time, int idx, int userId) {\\n\\n\\t\\t\\tthis.tweetId = tweetId;\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.userId = userId;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass Twitter {\\n\\n\\t\\tint time;\\n\\t\\tHashMap<Integer, HashSet<Integer>> followerMap;\\n\\t\\tHashMap<Integer, List<Tweet>> tweetMap;\\n\\n\\t\\t/** Initialize your data structure here. */\\n\\t\\t// O(1)\\n\\t\\tpublic Twitter() {\\n\\n\\t\\t\\ttime = 0;\\n\\t\\t\\tfollowerMap = new HashMap<>();\\n\\t\\t\\ttweetMap = new HashMap<>();\\n\\t\\t}\\n\\n\\t\\t/** Compose a new tweet. */\\n\\t\\t// O(1)\\n\\t\\tpublic void postTweet(int userId, int tweetId) {\\n\\n\\t\\t\\tList<Tweet> tweets = tweetMap.get(userId);\\n\\t\\t\\tif (tweets == null) {\\n\\t\\t\\t\\ttweets = new ArrayList<>();\\n\\t\\t\\t\\tTweet tweet = new Tweet(tweetId, time++, 0, userId);\\n\\t\\t\\t\\ttweets.add(tweet);\\n\\t\\t\\t\\ttweetMap.put(userId, tweets);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tTweet tweet = new Tweet(tweetId, time++, tweets.size(), userId);\\n\\t\\t\\t\\ttweets.add(tweet);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in\\n\\t\\t * the news feed must be posted by users who the user followed or by the user\\n\\t\\t * herself. Tweets must be ordered from most recent to least recent.\\n\\t\\t */\\n\\t\\t// O(logn)\\n\\t\\tpublic List<Integer> getNewsFeed(int userId) {\\n\\n\\t\\t\\tPriorityQueue<Tweet> heap = new PriorityQueue<>(new Comparator<Tweet>() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic int compare(Tweet o1, Tweet o2) {\\n\\t\\t\\t\\t\\treturn o2.time - o1.time;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tList<Tweet> tweets = tweetMap.get(userId);\\n\\t\\t\\tif (tweets != null)\\n\\t\\t\\t\\theap.offer(tweets.get(tweets.size() - 1));\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.getOrDefault(userId, new HashSet<>());\\n\\t\\t\\tfor (int followee : followees) {\\n\\t\\t\\t\\ttweets = tweetMap.get(followee);\\n\\t\\t\\t\\tif (tweets != null)\\n\\t\\t\\t\\t\\theap.add(tweets.get(tweets.size() - 1));\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint size = 0;\\n\\t\\t\\twhile (!heap.isEmpty() && size < 10) {\\n\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t\\tTweet tweet = heap.poll();\\n\\t\\t\\t\\tint idx = tweet.idx, followeeId = tweet.userId;\\n\\t\\t\\t\\tans.add(tweet.tweetId);\\n\\t\\t\\t\\ttweets = tweetMap.get(followeeId);\\n\\t\\t\\t\\tif (tweets != null && idx - 1 >= 0)\\n\\t\\t\\t\\t\\theap.add(tweets.get(idx - 1));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Follower follows a followee. If the operation is invalid, it should be a\\n\\t\\t * no-op.\\n\\t\\t */\\n\\t\\t// O(1)\\n\\t\\tpublic void follow(int followerId, int followeeId) {\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.get(followerId);\\n\\t\\t\\tif (followees == null) {\\n\\t\\t\\t\\tfollowees = new HashSet<>();\\n\\t\\t\\t\\tfollowees.add(followeeId);\\n\\t\\t\\t\\tfollowerMap.put(followerId, followees);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tfollowees.add(followeeId);\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t * Follower unfollows a followee. If the operation is invalid, it should be a\\n\\t\\t * no-op.\\n\\t\\t */\\n\\t\\t// O(1)\\n\\t\\tpublic void unfollow(int followerId, int followeeId) {\\n\\n\\t\\t\\tHashSet<Integer> followees = followerMap.get(followerId);\\n\\t\\t\\tif (followees == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tfollowees.remove(followeeId);\\n\\t\\t\\tif (followees.size() == 0)\\n\\t\\t\\t\\tfollowerMap.remove(followerId);\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1164560,
                "title": "python-python-3-and-hashmap",
                "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.users = {}\\n        self.global_tweets = []\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(userId) == None:\\n            self.users[userId] = {\"tweets\" : [tweetId], \"followers\":[]}\\n        else:\\n            self.users[userId][\"tweets\"].insert(0, tweetId)\\n        self.global_tweets.insert(0,tweetId)\\n        # print(self.users[userId])\\n        \\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        user = self.users.get(userId)\\n        if user != None:\\n\\n            feed = []\\n            for i in user[\"tweets\"]:\\n                feed.append(i)\\n            for i in user[\"followers\"]:\\n                if self.users.get(i)!=None:\\n                    for j in self.users[i][\"tweets\"]:\\n                        feed.append(j)\\n            ans = []    \\n            for i in self.global_tweets:\\n                if i in feed:\\n                    ans.append(i)\\n            return ans[:10]\\n        else:\\n            return []\\n        \\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(followerId) == None:\\n            self.users[followerId] = {\"tweets\" : [], \"followers\":[followeeId]}\\n        else:\\n            self.users[followerId][\"followers\"].append(followeeId)\\n\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(followerId) == None:\\n            self.users[followerId] = {\"tweets\" : [], \"followers\":[]}\\n        else:\\n            if followeeId in self.users[followerId][\"followers\"]:\\n                self.users[followerId][\"followers\"].remove(followeeId)\\n            else:\\n                pass\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.users = {}\\n        self.global_tweets = []\\n\\n    def postTweet(self, userId, tweetId):\\n        \"\"\"\\n        Compose a new tweet.\\n        :type userId: int\\n        :type tweetId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(userId) == None:\\n            self.users[userId] = {\"tweets\" : [tweetId], \"followers\":[]}\\n        else:\\n            self.users[userId][\"tweets\"].insert(0, tweetId)\\n        self.global_tweets.insert(0,tweetId)\\n        # print(self.users[userId])\\n        \\n\\n    def getNewsFeed(self, userId):\\n        \"\"\"\\n        Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n        :type userId: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        user = self.users.get(userId)\\n        if user != None:\\n\\n            feed = []\\n            for i in user[\"tweets\"]:\\n                feed.append(i)\\n            for i in user[\"followers\"]:\\n                if self.users.get(i)!=None:\\n                    for j in self.users[i][\"tweets\"]:\\n                        feed.append(j)\\n            ans = []    \\n            for i in self.global_tweets:\\n                if i in feed:\\n                    ans.append(i)\\n            return ans[:10]\\n        else:\\n            return []\\n        \\n\\n    def follow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower follows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(followerId) == None:\\n            self.users[followerId] = {\"tweets\" : [], \"followers\":[followeeId]}\\n        else:\\n            self.users[followerId][\"followers\"].append(followeeId)\\n\\n\\n    def unfollow(self, followerId, followeeId):\\n        \"\"\"\\n        Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n        :type followerId: int\\n        :type followeeId: int\\n        :rtype: None\\n        \"\"\"\\n        if self.users.get(followerId) == None:\\n            self.users[followerId] = {\"tweets\" : [], \"followers\":[]}\\n        else:\\n            if followeeId in self.users[followerId][\"followers\"]:\\n                self.users[followerId][\"followers\"].remove(followeeId)\\n            else:\\n                pass\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147539,
                "title": "javascript-solution",
                "content": "```\\nclass Twitter {\\n    constructor() {\\n        this.tweets = [];\\n        this.following = new Map();\\n    }\\n    \\n    postTweet(userId, tweetId) {\\n        this.tweets.push({ authorId: userId, id: tweetId });\\n    }\\n    \\n    getNewsFeed(userId) {\\n        const n = this.tweets.length;\\n        const newsIDs = [];\\n        \\n        for (let i = n - 1; i >= 0 && newsIDs.length < 10; i--) {\\n            const tweet = this.tweets[i];\\n            const isFollowing = this.following.has(userId) && this.following.get(userId).has(tweet.authorId);\\n            \\n            if (tweet.authorId === userId || isFollowing) newsIDs.push(tweet.id);\\n        }\\n        \\n        return newsIDs;\\n    }\\n    \\n    follow(followerId, followeeId) {\\n        if (!this.following.has(followerId)) this.following.set(followerId, new Set());\\n        this.following.get(followerId).add(followeeId);\\n    }\\n    \\n    unfollow(followerId, followeeId) {\\n        if (this.following.has(followerId)) this.following.get(followerId).delete(followeeId);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Twitter {\\n    constructor() {\\n        this.tweets = [];\\n        this.following = new Map();\\n    }\\n    \\n    postTweet(userId, tweetId) {\\n        this.tweets.push({ authorId: userId, id: tweetId });\\n    }\\n    \\n    getNewsFeed(userId) {\\n        const n = this.tweets.length;\\n        const newsIDs = [];\\n        \\n        for (let i = n - 1; i >= 0 && newsIDs.length < 10; i--) {\\n            const tweet = this.tweets[i];\\n            const isFollowing = this.following.has(userId) && this.following.get(userId).has(tweet.authorId);\\n            \\n            if (tweet.authorId === userId || isFollowing) newsIDs.push(tweet.id);\\n        }\\n        \\n        return newsIDs;\\n    }\\n    \\n    follow(followerId, followeeId) {\\n        if (!this.following.has(followerId)) this.following.set(followerId, new Set());\\n        this.following.get(followerId).add(followeeId);\\n    }\\n    \\n    unfollow(followerId, followeeId) {\\n        if (this.following.has(followerId)) this.following.get(followerId).delete(followeeId);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144276,
                "title": "shortest-c-beats-100-time-space",
                "content": "```\\nclass Twitter {\\nprivate:\\n    unordered_map<int, unordered_set<int>> users;\\n    forward_list<pair<int,int>> tweets;\\npublic:\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_front({userId, tweetId});\\n        users[userId].insert(userId);  //user sees his own tweet\\n    }\\n    \\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        unordered_set<int> &s = users[userId];\\n        for(auto &tweet : tweets){\\n            if(s.find(tweet.first) != s.end())\\n                feed.push_back(tweet.second);\\n            if(feed.size() == 10)\\n                return feed;\\n        }\\n        return feed;\\n    }\\n    \\n\\n    void follow(int followerId, int followeeId) {\\n        users[followerId].insert(followeeId);\\n    }\\n    \\n\\n    void unfollow(int followerId, int followeeId) {\\n        users[followerId].erase(followeeId);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\nprivate:\\n    unordered_map<int, unordered_set<int>> users;\\n    forward_list<pair<int,int>> tweets;\\npublic:\\n\\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_front({userId, tweetId});\\n        users[userId].insert(userId);  //user sees his own tweet\\n    }\\n    \\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        unordered_set<int> &s = users[userId];\\n        for(auto &tweet : tweets){\\n            if(s.find(tweet.first) != s.end())\\n                feed.push_back(tweet.second);\\n            if(feed.size() == 10)\\n                return feed;\\n        }\\n        return feed;\\n    }\\n    \\n\\n    void follow(int followerId, int followeeId) {\\n        users[followerId].insert(followeeId);\\n    }\\n    \\n\\n    void unfollow(int followerId, int followeeId) {\\n        users[followerId].erase(followeeId);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919814,
                "title": "python3-concise-commented-defaultdict-set-heapq-deque",
                "content": "Nice concise way to write it but still feels suboptimal - unnessesary to heapify all posts by all followees. Is there a way to only look at the 10 posts required to fill the feed? Perhaps via individual pointers over each followee?\\n\\n```\\nfrom collections import deque, defaultdict\\nimport heapq\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        # O(1)\\n        # use an incremented int to order posts\\n        self.time = 0\\n        \\n        # key: userId, value: set of followeees\\n        self.followers = defaultdict(lambda: set()) \\n        \\n        # only ever need to remember max 10 posts from any given user\\n        # key: userId, value: Deque of posts\\n        self.posted = defaultdict(lambda: deque([], maxlen=10)) \\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        # O(1)\\n        # record posts latest -> oldest (heapq is a min heap), indexed by time\\n        self.posted[userId].appendleft((self.time, tweetId))\\n        \\n        # increment counter\\n        self.time += 1\\n        \\n        # only need to consider yourself in feed if you\\'ve posted something\\n        # O(1) existence check\\n        self.followers[userId].add(userId) \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        # O(N) - N is total number of posts in feed \\n        # merge all followed user\\'s posts into single feed \\n        feed = heapq.merge(*[self.posted[u] for u in self.followers[userId]])\\n        \\n        # get the top 10\\n        latest_posts = heapq.nlargest(10, feed)\\n        \\n        # strip the time index and return\\n        return [p[1] for p in latest_posts]\\n                                                                                      \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        # O(1)\\n        self.followers[followerId].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        # O(1)\\n        # can\\'t unfollow yourself\\n        if followerId != followeeId:\\n            self.followers[followerId].discard(followeeId)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque, defaultdict\\nimport heapq\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        # O(1)\\n        # use an incremented int to order posts\\n        self.time = 0\\n        \\n        # key: userId, value: set of followeees\\n        self.followers = defaultdict(lambda: set()) \\n        \\n        # only ever need to remember max 10 posts from any given user\\n        # key: userId, value: Deque of posts\\n        self.posted = defaultdict(lambda: deque([], maxlen=10)) \\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        # O(1)\\n        # record posts latest -> oldest (heapq is a min heap), indexed by time\\n        self.posted[userId].appendleft((self.time, tweetId))\\n        \\n        # increment counter\\n        self.time += 1\\n        \\n        # only need to consider yourself in feed if you\\'ve posted something\\n        # O(1) existence check\\n        self.followers[userId].add(userId) \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        # O(N) - N is total number of posts in feed \\n        # merge all followed user\\'s posts into single feed \\n        feed = heapq.merge(*[self.posted[u] for u in self.followers[userId]])\\n        \\n        # get the top 10\\n        latest_posts = heapq.nlargest(10, feed)\\n        \\n        # strip the time index and return\\n        return [p[1] for p in latest_posts]\\n                                                                                      \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        # O(1)\\n        self.followers[followerId].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        # O(1)\\n        # can\\'t unfollow yourself\\n        if followerId != followeeId:\\n            self.followers[followerId].discard(followeeId)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 880115,
                "title": "kotlin-faster-than-85-7-with-detailed-explanation",
                "content": "```\\nclass Twitter() {\\n\\n    // A Hashmap of the list of the tweets for each user\\n    // Each tweet is stored as a pair: The running number of the tweet and the tweet itself \\n    private val tweets = HashMap<Int, MutableList<Pair<Int, Int>>>(0)\\n    // Hashmap of follower to list of followees\\n    private val followers = HashMap<Int, MutableSet<Int>>()\\n    // Running number of tweet\\n    private var tweetOrder = 0\\n\\n    fun postTweet(userId: Int, tweetId: Int) {\\n        // Add the tweet to the userId\\'s list of tweets.\\n        \\n        // The list of the userId\\'s tweets is fetched from the map.\\n        // If this is the userId\\'s first tweet then an empty list is created.\\n        // Then \"also\" performs the add to the list and, finally, the entry is placed in the Hashmap. This placing in the Hashmap is to cover the case where this is the first. \\n        \\n        tweets[userId] =  tweets.getOrDefault(userId, mutableListOf()).also{it.add(Pair(tweetOrder++,tweetId))}\\n    }\\n\\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. \\n     * Tweets must be ordered from most recent to least recent. */\\n    fun getNewsFeed(userId: Int): List<Int> {\\n        // Here we will create a list of the last 10 of the userId\\'s tweets plus the last 10 of each of the userId\\'s followees.\\n        // This will ensure we always get the last 10 in total.\\n        \\n        val result = mutableListOf<Pair<Int, Int>>()\\n        \\n        // First add to the result list the last 10 tweets by this userId.\\n        // To do this, we sort the list in descending order by the first field in the pair which is the running id of the tweet and take the first 10 entries\\n        // Get or default ensures that we will get a list even if the userId does not have any tweets.\\n        result.addAll(tweets.getOrDefault(userId, mutableListOf()).sortedByDescending { it.first }.take(10))\\n        \\n        // Now do the same for all the users that this userId is following\\n        followers[userId]?.forEach { result.addAll(tweets.getOrDefault(it, mutableListOf()).sortedByDescending { it.first }.take(10))}\\n        \\n        // Finally, take the list we have. It is a list of Pairs of all the last 10 tweets of the userId\\'s and the userid\\'s followees. \\n        // First field is running number of tweet and second is the tweet id itself.\\n        // Sort it by the running number id in descending order and take the first 10.\\n        // Using map we tell it to replace each entry of the list with the value within the {}. In this case, the second field .\\n        return result.sortedByDescending{it.first}.take(10).map{it.second}\\n    }\\n\\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    fun follow(followerId: Int, followeeId: Int) {\\n        // Don\\'t add follow to self!\\n        if (followerId != followeeId) {\\n            // Add the followee to the followers set. \\n            // \"getOrDefault\" ensures that we have at least an empty set\\n            followers[followerId] = followers.getOrDefault(followerId, mutableSetOf()).also { it.add(followeeId) }\\n        }\\n\\n    }\\n\\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    fun unfollow(followerId: Int, followeeId: Int) {\\n        // Remove the followee from the followers list. \\n        // \"getOrDefault\" ensures that we have at least an empty set. This way we don\\'t need to check if the user already has some followees\\n        followers.getOrDefault(followerId, mutableSetOf()).also {it.remove(followeeId)}\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "```\\nclass Twitter() {\\n\\n    // A Hashmap of the list of the tweets for each user\\n    // Each tweet is stored as a pair: The running number of the tweet and the tweet itself \\n    private val tweets = HashMap<Int, MutableList<Pair<Int, Int>>>(0)\\n    // Hashmap of follower to list of followees\\n    private val followers = HashMap<Int, MutableSet<Int>>()\\n    // Running number of tweet\\n    private var tweetOrder = 0\\n\\n    fun postTweet(userId: Int, tweetId: Int) {\\n        // Add the tweet to the userId\\'s list of tweets.\\n        \\n        // The list of the userId\\'s tweets is fetched from the map.\\n        // If this is the userId\\'s first tweet then an empty list is created.\\n        // Then \"also\" performs the add to the list and, finally, the entry is placed in the Hashmap. This placing in the Hashmap is to cover the case where this is the first. \\n        \\n        tweets[userId] =  tweets.getOrDefault(userId, mutableListOf()).also{it.add(Pair(tweetOrder++,tweetId))}\\n    }\\n\\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. \\n     * Tweets must be ordered from most recent to least recent. */\\n    fun getNewsFeed(userId: Int): List<Int> {\\n        // Here we will create a list of the last 10 of the userId\\'s tweets plus the last 10 of each of the userId\\'s followees.\\n        // This will ensure we always get the last 10 in total.\\n        \\n        val result = mutableListOf<Pair<Int, Int>>()\\n        \\n        // First add to the result list the last 10 tweets by this userId.\\n        // To do this, we sort the list in descending order by the first field in the pair which is the running id of the tweet and take the first 10 entries\\n        // Get or default ensures that we will get a list even if the userId does not have any tweets.\\n        result.addAll(tweets.getOrDefault(userId, mutableListOf()).sortedByDescending { it.first }.take(10))\\n        \\n        // Now do the same for all the users that this userId is following\\n        followers[userId]?.forEach { result.addAll(tweets.getOrDefault(it, mutableListOf()).sortedByDescending { it.first }.take(10))}\\n        \\n        // Finally, take the list we have. It is a list of Pairs of all the last 10 tweets of the userId\\'s and the userid\\'s followees. \\n        // First field is running number of tweet and second is the tweet id itself.\\n        // Sort it by the running number id in descending order and take the first 10.\\n        // Using map we tell it to replace each entry of the list with the value within the {}. In this case, the second field .\\n        return result.sortedByDescending{it.first}.take(10).map{it.second}\\n    }\\n\\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    fun follow(followerId: Int, followeeId: Int) {\\n        // Don\\'t add follow to self!\\n        if (followerId != followeeId) {\\n            // Add the followee to the followers set. \\n            // \"getOrDefault\" ensures that we have at least an empty set\\n            followers[followerId] = followers.getOrDefault(followerId, mutableSetOf()).also { it.add(followeeId) }\\n        }\\n\\n    }\\n\\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    fun unfollow(followerId: Int, followeeId: Int) {\\n        // Remove the followee from the followers list. \\n        // \"getOrDefault\" ensures that we have at least an empty set. This way we don\\'t need to check if the user already has some followees\\n        followers.getOrDefault(followerId, mutableSetOf()).also {it.remove(followeeId)}\\n    }\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 822195,
                "title": "python-short-twitter-app",
                "content": "```\\nclass Twitter(object):\\n    \\n    def __init__(self):\\n        self.users = defaultdict(set)\\n        self.followers = defaultdict(set)\\n        self.reputation = 0\\n        \\n\\t\\t\\n    def postTweet(self, userId, tweetId):\\n        self.reputation += 1\\n        self.users[userId].add((tweetId, self.reputation))\\n        \\n        \\n    def getNewsFeed(self, userId):\\n        tweets = list(self.users[userId])\\n        followees = self.followers[userId]\\n         \\n        for user_id in followees:\\n            tweets += self.users[user_id]\\n            \\n        most_recent_Tweets = sorted(tweets, key = lambda posts: posts[1],reverse=True)[:10]\\n        \\n        return [post[0] for post in most_recent_Tweets] \\n    \\n\\n    def follow(self, followerId, followeeId):\\n\\t\\tself.followers[followerId].add(followeeId if followerId != followeeId else None)\\n         \\n\\n    def unfollow(self, followerId, followeeId):\\n\\t\\tself.followers[followerId] -= {followeeId}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter(object):\\n    \\n    def __init__(self):\\n        self.users = defaultdict(set)\\n        self.followers = defaultdict(set)\\n        self.reputation = 0\\n        \\n\\t\\t\\n    def postTweet(self, userId, tweetId):\\n        self.reputation += 1\\n        self.users[userId].add((tweetId, self.reputation))\\n        \\n        \\n    def getNewsFeed(self, userId):\\n        tweets = list(self.users[userId])\\n        followees = self.followers[userId]\\n         \\n        for user_id in followees:\\n            tweets += self.users[user_id]\\n            \\n        most_recent_Tweets = sorted(tweets, key = lambda posts: posts[1],reverse=True)[:10]\\n        \\n        return [post[0] for post in most_recent_Tweets] \\n    \\n\\n    def follow(self, followerId, followeeId):\\n\\t\\tself.followers[followerId].add(followeeId if followerId != followeeId else None)\\n         \\n\\n    def unfollow(self, followerId, followeeId):\\n\\t\\tself.followers[followerId] -= {followeeId}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726651,
                "title": "java-two-hashmaps-priorityqueue",
                "content": "```\\nclass Tweet {\\n    int tweetId;\\n    int timeStamp;\\n    \\n    public Tweet(int tweetId, int timeStamp) {\\n        this.tweetId = tweetId;\\n        this.timeStamp = timeStamp;\\n    }\\n    \\n    public int getTweetId() {\\n        return this.tweetId;\\n    }\\n    \\n    public int getTimeStamp() {\\n        return this.timeStamp;\\n    }\\n}\\n\\nclass Twitter {\\n    \\n    HashMap<Integer, Set<Tweet>> tweetMap; // userId, Set<Tweet> \\n    HashMap<Integer, Set<Integer>> fanMap; // userId, Set<Followers> \\n    int timeStamp;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        this.tweetMap = new HashMap<>();\\n        this.fanMap = new HashMap<>();\\n        this.timeStamp = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        if (!tweetMap.containsKey(userId)) tweetMap.put(userId, new HashSet<>());\\n        Tweet newTweet = new Tweet(tweetId, timeStamp++);\\n        tweetMap.get(userId).add(newTweet);\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> res = new ArrayList<>();\\n        PriorityQueue<Tweet> recentTweets = new PriorityQueue<>(Comparator.comparingInt(Tweet::getTimeStamp).reversed());\\n        \\n        // Get user\\'s tweets and put in recentTweets\\n        if (tweetMap.containsKey(userId)) {\\n            recentTweets.addAll(tweetMap.get(userId));\\n        }\\n        \\n        // Get user\\'s follower tweets and put in recentTweets\\n        if (fanMap.containsKey(userId)) {\\n            for (int follower: fanMap.get(userId)) {\\n                if (tweetMap.containsKey(follower)) {\\n                    recentTweets.addAll(tweetMap.get(follower));\\n                }\\n            }\\n        }\\n        \\n        while (!recentTweets.isEmpty()) {\\n            res.add(recentTweets.poll().getTweetId());\\n            if (res.size() == 10) break;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (followerId == followeeId) return;\\n        if (!fanMap.containsKey(followerId)) fanMap.put(followerId, new HashSet<>());\\n        fanMap.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId || !fanMap.containsKey(followerId)) return;\\n        fanMap.get(followerId).remove(followeeId);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Tweet {\\n    int tweetId;\\n    int timeStamp;\\n    \\n    public Tweet(int tweetId, int timeStamp) {\\n        this.tweetId = tweetId;\\n        this.timeStamp = timeStamp;\\n    }\\n    \\n    public int getTweetId() {\\n        return this.tweetId;\\n    }\\n    \\n    public int getTimeStamp() {\\n        return this.timeStamp;\\n    }\\n}\\n\\nclass Twitter {\\n    \\n    HashMap<Integer, Set<Tweet>> tweetMap; // userId, Set<Tweet> \\n    HashMap<Integer, Set<Integer>> fanMap; // userId, Set<Followers> \\n    int timeStamp;\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        this.tweetMap = new HashMap<>();\\n        this.fanMap = new HashMap<>();\\n        this.timeStamp = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        if (!tweetMap.containsKey(userId)) tweetMap.put(userId, new HashSet<>());\\n        Tweet newTweet = new Tweet(tweetId, timeStamp++);\\n        tweetMap.get(userId).add(newTweet);\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> res = new ArrayList<>();\\n        PriorityQueue<Tweet> recentTweets = new PriorityQueue<>(Comparator.comparingInt(Tweet::getTimeStamp).reversed());\\n        \\n        // Get user\\'s tweets and put in recentTweets\\n        if (tweetMap.containsKey(userId)) {\\n            recentTweets.addAll(tweetMap.get(userId));\\n        }\\n        \\n        // Get user\\'s follower tweets and put in recentTweets\\n        if (fanMap.containsKey(userId)) {\\n            for (int follower: fanMap.get(userId)) {\\n                if (tweetMap.containsKey(follower)) {\\n                    recentTweets.addAll(tweetMap.get(follower));\\n                }\\n            }\\n        }\\n        \\n        while (!recentTweets.isEmpty()) {\\n            res.add(recentTweets.poll().getTweetId());\\n            if (res.size() == 10) break;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (followerId == followeeId) return;\\n        if (!fanMap.containsKey(followerId)) fanMap.put(followerId, new HashSet<>());\\n        fanMap.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (followerId == followeeId || !fanMap.containsKey(followerId)) return;\\n        fanMap.get(followerId).remove(followeeId);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569543,
                "title": "priority-queue-hashmap",
                "content": "```\\nclass Twitter {\\n\\n    private Map<Integer, Deque<Integer[]>> tweets;\\n    private Map<Integer, Set<Integer>> users;\\n    private int nextTweetID;\\n    \\n    public Twitter() {\\n        this.tweets = new HashMap<>();\\n        this.users = new HashMap<>();\\n        this.nextTweetID = 1;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets.putIfAbsent(userId, new LinkedList<>());\\n        tweets.get(userId).add(new Integer[] {tweetId, nextTweetID++});\\n        if (tweets.get(userId).size() > 10) {\\n            tweets.get(userId).pollFirst();\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        addTweetsByUserId(pq, userId);\\n        \\n        for (Integer followeeId : users.getOrDefault(userId, new HashSet<>())) {\\n            addTweetsByUserId(pq, followeeId);\\n        }\\n        \\n        int size = pq.size();\\n        List<Integer> feed = new ArrayList<>();\\n        while (!pq.isEmpty()) {\\n            feed.add(pq.poll()[0]);\\n        }\\n        Collections.reverse(feed);\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId) {\\n            users.putIfAbsent(followerId, new HashSet<>());\\n            users.get(followerId).add(followeeId);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if (users.containsKey(followerId)) {\\n            users.get(followerId).remove(followeeId);\\n        }\\n    }\\n    \\n    private void addTweetsByUserId(PriorityQueue<Integer[]> pq, int userId) {\\n        LinkedList<Integer[]> tweetList = (LinkedList<Integer[]>)tweets.getOrDefault(userId, new LinkedList<>());\\n        for (Integer[] tweet : tweetList) {\\n            pq.add(tweet);\\n            if (pq.size() > 10) {\\n                pq.poll();\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n\\n    private Map<Integer, Deque<Integer[]>> tweets;\\n    private Map<Integer, Set<Integer>> users;\\n    private int nextTweetID;\\n    \\n    public Twitter() {\\n        this.tweets = new HashMap<>();\\n        this.users = new HashMap<>();\\n        this.nextTweetID = 1;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets.putIfAbsent(userId, new LinkedList<>());\\n        tweets.get(userId).add(new Integer[] {tweetId, nextTweetID++});\\n        if (tweets.get(userId).size() > 10) {\\n            tweets.get(userId).pollFirst();\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        addTweetsByUserId(pq, userId);\\n        \\n        for (Integer followeeId : users.getOrDefault(userId, new HashSet<>())) {\\n            addTweetsByUserId(pq, followeeId);\\n        }\\n        \\n        int size = pq.size();\\n        List<Integer> feed = new ArrayList<>();\\n        while (!pq.isEmpty()) {\\n            feed.add(pq.poll()[0]);\\n        }\\n        Collections.reverse(feed);\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if (followerId != followeeId) {\\n            users.putIfAbsent(followerId, new HashSet<>());\\n            users.get(followerId).add(followeeId);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if (users.containsKey(followerId)) {\\n            users.get(followerId).remove(followeeId);\\n        }\\n    }\\n    \\n    private void addTweetsByUserId(PriorityQueue<Integer[]> pq, int userId) {\\n        LinkedList<Integer[]> tweetList = (LinkedList<Integer[]>)tweets.getOrDefault(userId, new LinkedList<>());\\n        for (Integer[] tweet : tweetList) {\\n            pq.add(tweet);\\n            if (pq.size() > 10) {\\n                pq.poll();\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402646,
                "title": "clean-javascript-solution",
                "content": "```\\nfunction Heap(cmp) {\\n  this._heap = [];\\n  if (typeof cmp === \"function\") {\\n    this._cmp = cmp;\\n  } else {\\n    this._cmp = function(a, b) {\\n      return a - b;\\n    };\\n  }\\n}\\n\\nHeap.prototype._heapify = function(idx) {\\n  let exc = idx;\\n  const leftIdx = 2 * idx + 1;\\n  const rightIdx = 2 * idx + 2;\\n\\n  if (\\n    leftIdx < this._heap.length &&\\n    this._cmp(this._heap[leftIdx], this._heap[idx]) > 0\\n  ) {\\n    exc = leftIdx;\\n  }\\n\\n  if (\\n    rightIdx < this._heap.length &&\\n    this._cmp(this._heap[rightIdx], this._heap[idx]) > 0 &&\\n    this._cmp(this._heap[rightIdx], this._heap[leftIdx]) > 0\\n  ) {\\n    exc = rightIdx;\\n  }\\n\\n  if (idx !== exc) {\\n    const tmp = this._heap[exc];\\n    this._heap[exc] = this._heap[idx];\\n    this._heap[idx] = tmp;\\n    this._heapify(exc);\\n  }\\n};\\n\\nHeap.prototype._update = function(idx, val) {\\n  this._heap[idx] = val;\\n  let parent = Math.floor((idx - 1) / 2);\\n  while (parent >= 0 && this._cmp(this._heap[idx], this._heap[parent]) > 0) {\\n    var tmp = this._heap[parent];\\n    this._heap[parent] = this._heap[idx];\\n    this._heap[idx] = tmp;\\n    idx = parent;\\n    parent = Math.floor((parent - 1) / 2);\\n  }\\n\\n  this._heapify(idx);\\n};\\n\\nHeap.prototype.add = function(val) {\\n  this._heap.push(val);\\n  this._update(this._heap.length - 1, val);\\n};\\n\\nHeap.prototype.top = function() {\\n  return this._heap[0];\\n};\\n\\nHeap.prototype.poll = function() {\\n  if (this._heap.length <= 1) {\\n    return this._heap.pop();\\n  }\\n  const t = this.top();\\n  this._heap[0] = this._heap.pop();\\n  this._heapify(0);\\n  return t;\\n};\\n\\nHeap.prototype.size = function() {\\n  return this._heap.length;\\n};\\n\\nHeap.prototype.remove = function(val) {\\n  const size = this.size();\\n  if (size <= 0) return;\\n  const idx = this._heap.findIndex(a => this._cmp(a, val) === 0);\\n  if (idx == size - 1) {\\n    this._heap.pop();\\n  } else if (idx >= 0) {\\n    this._update(idx, this._heap.pop());\\n  }\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar Twitter = function() {\\n  this.seq = 0;\\n  this.net = {};\\n  this.tweets = {};\\n};\\n\\n/**\\n * Compose a new tweet.\\n * @param {number} userId\\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n  this.tweets[userId] = this.tweets[userId] || [];\\n  this.tweets[userId].unshift({ tweetId, seq: this.seq++ });\\n};\\n\\n/**\\n * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function(userId) {\\n  const cmp = (a, b) => b.seq - a.seq;\\n  const minHeap = new Heap(cmp);\\n  const users = [userId].concat(this.net[userId] || []);\\n  const K = 10;\\n  for (const u of users) {\\n    const tweets = this.tweets[u];\\n    if (!tweets) continue;\\n    for (let i = 0; i < Math.min(K, tweets.length); i++) {\\n      const t = tweets[i];\\n      if (minHeap.size() < K) {\\n        minHeap.add(t);\\n      } else if (minHeap.top().seq > t.seq) {\\n        break;\\n      } else {\\n        minHeap.add(t);\\n        minHeap.poll();\\n      }\\n    }\\n  }\\n\\n  const ret = [];\\n  while (minHeap.size()) {\\n    ret.unshift(minHeap.poll().tweetId);\\n  }\\n\\n  return ret;\\n};\\n\\n/**\\n * Follower follows a followee. If the operation is invalid, it should be a no-op.\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n  if (followerId === followeeId) return;\\n  this.net[followerId] = this.net[followerId] || [];\\n  if (!this.net[followerId].includes(followeeId)) {\\n    this.net[followerId].push(followeeId);\\n  }\\n};\\n\\n/**\\n * Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n  this.net[followerId] = this.net[followerId] || [];\\n  const idx = this.net[followerId].indexOf(followeeId);\\n  if (idx >= 0) {\\n    this.net[followerId].splice(idx, 1);\\n  }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * var obj = new Twitter()\\n * obj.postTweet(userId,tweetId)\\n * var param_2 = obj.getNewsFeed(userId)\\n * obj.follow(followerId,followeeId)\\n * obj.unfollow(followerId,followeeId)\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunction Heap(cmp) {\\n  this._heap = [];\\n  if (typeof cmp === \"function\") {\\n    this._cmp = cmp;\\n  } else {\\n    this._cmp = function(a, b) {\\n      return a - b;\\n    };\\n  }\\n}\\n\\nHeap.prototype._heapify = function(idx) {\\n  let exc = idx;\\n  const leftIdx = 2 * idx + 1;\\n  const rightIdx = 2 * idx + 2;\\n\\n  if (\\n    leftIdx < this._heap.length &&\\n    this._cmp(this._heap[leftIdx], this._heap[idx]) > 0\\n  ) {\\n    exc = leftIdx;\\n  }\\n\\n  if (\\n    rightIdx < this._heap.length &&\\n    this._cmp(this._heap[rightIdx], this._heap[idx]) > 0 &&\\n    this._cmp(this._heap[rightIdx], this._heap[leftIdx]) > 0\\n  ) {\\n    exc = rightIdx;\\n  }\\n\\n  if (idx !== exc) {\\n    const tmp = this._heap[exc];\\n    this._heap[exc] = this._heap[idx];\\n    this._heap[idx] = tmp;\\n    this._heapify(exc);\\n  }\\n};\\n\\nHeap.prototype._update = function(idx, val) {\\n  this._heap[idx] = val;\\n  let parent = Math.floor((idx - 1) / 2);\\n  while (parent >= 0 && this._cmp(this._heap[idx], this._heap[parent]) > 0) {\\n    var tmp = this._heap[parent];\\n    this._heap[parent] = this._heap[idx];\\n    this._heap[idx] = tmp;\\n    idx = parent;\\n    parent = Math.floor((parent - 1) / 2);\\n  }\\n\\n  this._heapify(idx);\\n};\\n\\nHeap.prototype.add = function(val) {\\n  this._heap.push(val);\\n  this._update(this._heap.length - 1, val);\\n};\\n\\nHeap.prototype.top = function() {\\n  return this._heap[0];\\n};\\n\\nHeap.prototype.poll = function() {\\n  if (this._heap.length <= 1) {\\n    return this._heap.pop();\\n  }\\n  const t = this.top();\\n  this._heap[0] = this._heap.pop();\\n  this._heapify(0);\\n  return t;\\n};\\n\\nHeap.prototype.size = function() {\\n  return this._heap.length;\\n};\\n\\nHeap.prototype.remove = function(val) {\\n  const size = this.size();\\n  if (size <= 0) return;\\n  const idx = this._heap.findIndex(a => this._cmp(a, val) === 0);\\n  if (idx == size - 1) {\\n    this._heap.pop();\\n  } else if (idx >= 0) {\\n    this._update(idx, this._heap.pop());\\n  }\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar Twitter = function() {\\n  this.seq = 0;\\n  this.net = {};\\n  this.tweets = {};\\n};\\n\\n/**\\n * Compose a new tweet.\\n * @param {number} userId\\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n  this.tweets[userId] = this.tweets[userId] || [];\\n  this.tweets[userId].unshift({ tweetId, seq: this.seq++ });\\n};\\n\\n/**\\n * Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function(userId) {\\n  const cmp = (a, b) => b.seq - a.seq;\\n  const minHeap = new Heap(cmp);\\n  const users = [userId].concat(this.net[userId] || []);\\n  const K = 10;\\n  for (const u of users) {\\n    const tweets = this.tweets[u];\\n    if (!tweets) continue;\\n    for (let i = 0; i < Math.min(K, tweets.length); i++) {\\n      const t = tweets[i];\\n      if (minHeap.size() < K) {\\n        minHeap.add(t);\\n      } else if (minHeap.top().seq > t.seq) {\\n        break;\\n      } else {\\n        minHeap.add(t);\\n        minHeap.poll();\\n      }\\n    }\\n  }\\n\\n  const ret = [];\\n  while (minHeap.size()) {\\n    ret.unshift(minHeap.poll().tweetId);\\n  }\\n\\n  return ret;\\n};\\n\\n/**\\n * Follower follows a followee. If the operation is invalid, it should be a no-op.\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n  if (followerId === followeeId) return;\\n  this.net[followerId] = this.net[followerId] || [];\\n  if (!this.net[followerId].includes(followeeId)) {\\n    this.net[followerId].push(followeeId);\\n  }\\n};\\n\\n/**\\n * Follower unfollows a followee. If the operation is invalid, it should be a no-op.\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n  this.net[followerId] = this.net[followerId] || [];\\n  const idx = this.net[followerId].indexOf(followeeId);\\n  if (idx >= 0) {\\n    this.net[followerId].splice(idx, 1);\\n  }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * var obj = new Twitter()\\n * obj.postTweet(userId,tweetId)\\n * var param_2 = obj.getNewsFeed(userId)\\n * obj.follow(followerId,followeeId)\\n * obj.unfollow(followerId,followeeId)\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375189,
                "title": "c-clean",
                "content": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int, unordered_set<int>> followMap; // userId -> userId\\n    unordered_map<int, vector<pair<int, int>>> tweetMap; // userId -> <tweetId, timeStamp>\\n    int time;\\n    Twitter() : time(0) {}\\n    void postTweet(int userId, int tweetId)\\n    {\\n        tweetMap[userId].push_back({tweetId, time++});\\n    }\\n    vector<int> getNewsFeed(int userId)\\n    {\\n        priority_queue<pair<int, int>> heap;\\n        for(auto & tweet : tweetMap[userId])\\n                heap.push({tweet.second, tweet.first});\\n        for(auto & id : followMap[userId])\\n            for(auto & tweet : tweetMap[id])\\n                heap.push({tweet.second, tweet.first});\\n        vector<int> tweets; tweets.reserve(10);\\n        while(tweets.size() < 10 && !heap.empty())\\n        {\\n            auto front = heap.top(); heap.pop();\\n            tweets.push_back(front.second);\\n        }\\n        return tweets;\\n    }\\n    void follow(int followerId, int followeeId)\\n    {\\n        if(followerId == followeeId)\\n            return;\\n        followMap[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId)\\n    {\\n        if(followerId == followeeId)\\n            return;\\n        followMap[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\npublic:\\n    unordered_map<int, unordered_set<int>> followMap; // userId -> userId\\n    unordered_map<int, vector<pair<int, int>>> tweetMap; // userId -> <tweetId, timeStamp>\\n    int time;\\n    Twitter() : time(0) {}\\n    void postTweet(int userId, int tweetId)\\n    {\\n        tweetMap[userId].push_back({tweetId, time++});\\n    }\\n    vector<int> getNewsFeed(int userId)\\n    {\\n        priority_queue<pair<int, int>> heap;\\n        for(auto & tweet : tweetMap[userId])\\n                heap.push({tweet.second, tweet.first});\\n        for(auto & id : followMap[userId])\\n            for(auto & tweet : tweetMap[id])\\n                heap.push({tweet.second, tweet.first});\\n        vector<int> tweets; tweets.reserve(10);\\n        while(tweets.size() < 10 && !heap.empty())\\n        {\\n            auto front = heap.top(); heap.pop();\\n            tweets.push_back(front.second);\\n        }\\n        return tweets;\\n    }\\n    void follow(int followerId, int followeeId)\\n    {\\n        if(followerId == followeeId)\\n            return;\\n        followMap[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId)\\n    {\\n        if(followerId == followeeId)\\n            return;\\n        followMap[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323083,
                "title": "very-fast-javascript-solution-using-classes-with-private-properties",
                "content": "In my solution, I used a `Map` to connect users to the people they follow and a Set to keep track of all of the users. On each individual user is an array of their posts, these posts each have their own timestamp (really just a counter that goes up).\\n\\nTo get the feed for a user I first grab their first ten posts, I then go over each of the people that they follow and I grab each of their first ten posts. I then sort the array I now have by their timestamps (highest to lowest). Once they\\'re sorted, I grab the first ten and return them.\\n\\nThis could probably be made faster for larger datasets by ensuring that after the array\\'s size has hit ten you only add a post if it happened more recently than the others and you also remove the one that happened least recently.\\n\\nThis solution has a runtime of **112 ms** (faster than **99.28%**) and a memory usage of **46.2 MB** (better than **91.04%**)\\n\\n\\n```js\\nclass TimestampCounter {\\n  #counter = 0;\\n  now() {\\n    return this.#counter++;\\n  }\\n}\\nconst timestamp = new TimestampCounter();\\n\\nclass Post {\\n  #id;\\n  #timestamp = timestamp.now();\\n\\n  constructor(id) {\\n    this.#id = id;\\n  }\\n\\n  get id() {\\n    return this.#id;\\n  }\\n\\n  get timestamp() {\\n    return this.#timestamp;\\n  }\\n}\\n\\nclass User {\\n  #id;\\n  posts = [];\\n\\n  constructor(id) {\\n    this.#id = id;\\n  }\\n\\n  get id() {\\n    return this.#id;\\n  }\\n\\n  addPost(id) {\\n    this.posts.unshift(new Post(id));\\n  }\\n}\\n\\nclass Twitter {\\n  #users = new Map();\\n  #getUser = id => {\\n    let user = this.#users.get(id);\\n\\n    if (!user) {\\n      user = new User();\\n      this.#users.set(id, user);\\n    }\\n\\n    return user;\\n  };\\n\\n  #followings = new Map();\\n  #getFollowing = user => {\\n    let following = this.#followings.get(user);\\n\\n    if (!following) {\\n      following = new Set();\\n      this.#followings.set(user, following);\\n    }\\n\\n    return following;\\n  };\\n\\n  postTweet(user, tweet) {\\n    this.#getUser(user).addPost(tweet);\\n  }\\n  getNewsFeed(user) {\\n    const posts = this.#getUser(user).posts.slice(0, 10);\\n    const following = this.#getFollowing(user);\\n\\n    for (const id of following) {\\n      const followedUser = this.#getUser(id);\\n      posts.push(...followedUser.posts.slice(0, 10));\\n    }\\n\\n    return posts\\n      .sort((a, b) => {\\n        return b.timestamp - a.timestamp;\\n      })\\n      .slice(0, 10)\\n      .map(post => post.id);\\n  }\\n  follow(user, userToFollow) {\\n    if (user === userToFollow) return;\\n    this.#getFollowing(user).add(userToFollow);\\n  }\\n  unfollow(user, userToUnfollow) {\\n    this.#getFollowing(user).delete(userToUnfollow);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nclass TimestampCounter {\\n  #counter = 0;\\n  now() {\\n    return this.#counter++;\\n  }\\n}\\nconst timestamp = new TimestampCounter();\\n\\nclass Post {\\n  #id;\\n  #timestamp = timestamp.now();\\n\\n  constructor(id) {\\n    this.#id = id;\\n  }\\n\\n  get id() {\\n    return this.#id;\\n  }\\n\\n  get timestamp() {\\n    return this.#timestamp;\\n  }\\n}\\n\\nclass User {\\n  #id;\\n  posts = [];\\n\\n  constructor(id) {\\n    this.#id = id;\\n  }\\n\\n  get id() {\\n    return this.#id;\\n  }\\n\\n  addPost(id) {\\n    this.posts.unshift(new Post(id));\\n  }\\n}\\n\\nclass Twitter {\\n  #users = new Map();\\n  #getUser = id => {\\n    let user = this.#users.get(id);\\n\\n    if (!user) {\\n      user = new User();\\n      this.#users.set(id, user);\\n    }\\n\\n    return user;\\n  };\\n\\n  #followings = new Map();\\n  #getFollowing = user => {\\n    let following = this.#followings.get(user);\\n\\n    if (!following) {\\n      following = new Set();\\n      this.#followings.set(user, following);\\n    }\\n\\n    return following;\\n  };\\n\\n  postTweet(user, tweet) {\\n    this.#getUser(user).addPost(tweet);\\n  }\\n  getNewsFeed(user) {\\n    const posts = this.#getUser(user).posts.slice(0, 10);\\n    const following = this.#getFollowing(user);\\n\\n    for (const id of following) {\\n      const followedUser = this.#getUser(id);\\n      posts.push(...followedUser.posts.slice(0, 10));\\n    }\\n\\n    return posts\\n      .sort((a, b) => {\\n        return b.timestamp - a.timestamp;\\n      })\\n      .slice(0, 10)\\n      .map(post => post.id);\\n  }\\n  follow(user, userToFollow) {\\n    if (user === userToFollow) return;\\n    this.#getFollowing(user).add(userToFollow);\\n  }\\n  unfollow(user, userToUnfollow) {\\n    this.#getFollowing(user).delete(userToUnfollow);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188257,
                "title": "java-oop-d-solution-guaranteed-job-offer",
                "content": "I do not think this problem is about performance as much as it is about design, hence \"**DESIGN** Twitter\".\\n\\nSure, there are plenty of solutions available utilizing `PriorityQueue` and multiple `Maps` but with little focus on design and structure. I don\\'t think the main point of this excercise is about stuffing everything into one class and using primitive values as output, but rather being able to pick apart a problem and effectively structure the solution.\\n\\nNow, I am not saying that the idea of performance should be thrown out the window. I am simply saying that in a an interview scenario that I don\\'t think this would be the proper question to flex efficiency over design.\\n\\n# My approach\\n\\nI thought of the three main things that we will need, of course the self-evident `Twitter` but we are also told:\\n\\n> \"...users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user\\'s news feed...\"\\n\\nwhich leads to me to add `User` and `Post` objects as part of my construction.\\n\\nI considered `Twitter` to be the main entry point, or interface, for my solution. Ideally, it should hold as little state as possible and mainly focus more on composition.\\n\\n```java\\nclass Twitter {\\n    Map<Integer, User> users;\\n    int postId;\\n    // ...\\n```\\n\\nAs you can see, there is only one `Map` for user lookup and `postId` to mimic the idea of a timestamp or infer the \\'age\\' of a `post` (or colloquially `Tweet`).\\n\\nThe rest of class contains very small methods similar to this example below.\\n\\n```java\\n// Class Twitter\\npublic void postTweet(int userId, int tweetId) {\\n    User user = this.searchUser(userId);\\n    user.postTweet(tweetId, postId);\\n    this.postId += 1;\\n}\\n```\\nThere is no reason for `Twitter` to have to expend resources on mapping data as that is outside of it\\'s responsibility. Although it does have access into locating specfic users (see: `searchUser`), it should not have to then access more specifics *in relation* to any other user. Ideally, the moment it can locate a user, it should be able to simply retrieve the information (that is based on the user) *through* the user itself. This is a core concept in OOP known as abstraction.\\n\\nMoving forward onto `User`, this is where most of the underlying implementations exist. \\n\\n```java\\nclass User {\\n    int id;\\n    Set<User> following;\\n    List<Post> posts;\\n    // ...\\n```\\nHere we have a `User` containing it\\'s `id`, it\\'s `following` (people they follow), and their `posts`. A user should own their posts (i.e. any post who\\'s `fromId` matches the user\\'s `id` is held here). This concept of ownership allows for responsibility to be properly managed versus having all posts universally available in one global shared map. \\n\\nApart from performance (which I will get into), it doesn\\'t make sense for a user to not have direct access to their own data which makes mapping not only more intuitive, but more *logical* as well.\\n\\nI chose to keep `following` in a Set not for duplication (see: `searchUser` in `Twitter` for how that is handled), but rather the ease of use in cases of `following` and `unfollowing`.\\n```java\\n// Class User\\npublic void follow(User followee) {\\n    if (this.equals(followee)) return;\\n    this.following.add(followee);\\n}\\n\\npublic void unfollow(User followee) {\\n    this.following.remove(followee);\\n}\\n```\\nThe `no-op` checking is close to minimal with a `Set` as the only real check is in the case of `following` where a user shouldn\\'t be following themself. Consider using a `List`, in the case of `follow` I would need to see if the `follower` is pre-existing (you cannot follow the same person twice) and in the case of `unfollow` I would also need to check if they are pre-existing (you cannot unfollow someone you do not follow. Using a `Set` makes the most logical case outside of it\\'s implicit use (duplication).\\n\\nNow my implementation of `getNewsFeed` might bring up some concerns but as I will reiterate, I believe the focus is more on **design** v.s. performance.\\n\\n```java\\n// Class User\\npublic List<Post> getNewsFeed() {\\n    List<Post> followingPosts = this.following.stream()\\n\\t.flatMap(user -> user.posts.stream())\\n\\t.collect(Collectors.toList());\\n    List<Post> newsFeed = Stream.of(this.posts, followingPosts)\\n\\t.flatMap(list -> list.stream())\\n\\t.sorted((a, b) -> b.postId - a.postId)\\n\\t.limit(10)\\n\\t.collect(Collectors.toList());\\n    return newsFeed;\\n}\\n```\\nIt is quite evident that if this were a case where performance would be a critical point, then we would implement a concurrent solution way beyond the scope of this problem as well as this platform. Ideally, a `MapReduce` or similar parallel distributed algorithm would be much more preferable.\\n\\nIn this implementation, the core idea is to utilize [Intermediate Operations](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps) but the argument behind `Stateful and Stateless ops` is well founded thus this implementation may not provide as much efficiency in comparison to the other implementations found in other solutions. However, as stated previously, if performance were to be the top priority, then we must look much further beyond in terms of architecture.\\n\\nThe last and final `Post` class is small, but it is mainly geared toward `extension`.\\n```java\\nclass Post {\\n    int fromId;\\n    int toId;\\n    int postId;\\n    // ...\\n```\\nWhat is provided in this class is self-explanatory, but the design decision to work with `Post` class instead of raw `Integers` is the ability to further extend beyond simple metadata. Consider `Post` to be a stub of what would be a more fleshed out version consisting of `Body`, `Replies`, `Favorites`, etc. It would be very easy to add in this information than to first work with integers and restructure. Plus, looking through how posts are handled in this solution improves clarity and readibility where brevity would hurt in the long-term.\\n\\n# Conclusion\\nI think this would be a good approach to this question that could have easily been whiteboarded within 5 minutes (of course omitting syntax). If this were to have been given in a job-interview, there is no doubt this would fall into a `System/Design Scenario` question where overall composition would triumph over detailed intricacies.\\n\\nOf course, I would recommend you to be familiar with how a specific implementation would work better over a much larger scaled system, but that is something that should come up during review of the answer and not something to immediately start out with.\\n# Full Solution\\n```java\\nclass Twitter {\\n    Map<Integer, User> users;\\n    int postId;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        this.users = new HashMap<>();\\n        this.postId = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        User user = this.searchUser(userId);\\n        user.postTweet(tweetId, postId);\\n        this.postId += 1;\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        User user = this.searchUser(userId);\\n        List<Integer> newsFeed = user.getNewsFeed().stream().map(post -> post.toId).collect(Collectors.toList());\\n        return newsFeed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        User follower = this.searchUser(followerId);\\n        User followee = this.searchUser(followeeId);\\n        follower.follow(followee);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        User follower = this.searchUser(followerId);\\n        User followee = this.searchUser(followeeId);\\n        follower.unfollow(followee);\\n    }\\n    \\n    public User searchUser(int id) {\\n        return users.computeIfAbsent(id, k -> new User(k));\\n    }\\n}\\n\\nclass User {\\n    int id;\\n    Set<User> following;\\n    List<Post> posts;\\n    \\n    public User(int id) {\\n        this.id = id;\\n        this.following = new HashSet<>();\\n        this.posts = new ArrayList<>();\\n    }\\n    \\n    public void postTweet(int toId, int postId) {\\n        this.posts.add(new Post(this.id, toId, postId));\\n    }\\n    \\n    public void follow(User followee) {\\n        if (this.equals(followee)) return;\\n        this.following.add(followee);\\n    }\\n    \\n    public void unfollow(User followee) {\\n        this.following.remove(followee);\\n    }\\n    \\n    public List<Post> getNewsFeed() {\\n        List<Post> followingPosts = this.following.stream().flatMap(user -> user.posts.stream()).collect(Collectors.toList());\\n        List<Post> newsFeed = Stream.of(this.posts, followingPosts)\\n            .flatMap(list -> list.stream())\\n            .sorted((a, b) -> b.postId - a.postId)\\n            .limit(10)\\n            .collect(Collectors.toList());\\n        return newsFeed;\\n    }\\n}\\n\\nclass Post {\\n    int fromId;\\n    int toId;\\n    int postId;\\n    \\n    public Post(int fromId, int toId, int postId) {\\n        this.fromId = fromId;\\n        this.toId = toId;\\n        this.postId = postId;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Twitter {\\n    Map<Integer, User> users;\\n    int postId;\\n    // ...\\n```\n```java\\n// Class Twitter\\npublic void postTweet(int userId, int tweetId) {\\n    User user = this.searchUser(userId);\\n    user.postTweet(tweetId, postId);\\n    this.postId += 1;\\n}\\n```\n```java\\nclass User {\\n    int id;\\n    Set<User> following;\\n    List<Post> posts;\\n    // ...\\n```\n```java\\n// Class User\\npublic void follow(User followee) {\\n    if (this.equals(followee)) return;\\n    this.following.add(followee);\\n}\\n\\npublic void unfollow(User followee) {\\n    this.following.remove(followee);\\n}\\n```\n```java\\n// Class User\\npublic List<Post> getNewsFeed() {\\n    List<Post> followingPosts = this.following.stream()\\n\\t.flatMap(user -> user.posts.stream())\\n\\t.collect(Collectors.toList());\\n    List<Post> newsFeed = Stream.of(this.posts, followingPosts)\\n\\t.flatMap(list -> list.stream())\\n\\t.sorted((a, b) -> b.postId - a.postId)\\n\\t.limit(10)\\n\\t.collect(Collectors.toList());\\n    return newsFeed;\\n}\\n```\n```java\\nclass Post {\\n    int fromId;\\n    int toId;\\n    int postId;\\n    // ...\\n```\n```java\\nclass Twitter {\\n    Map<Integer, User> users;\\n    int postId;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        this.users = new HashMap<>();\\n        this.postId = 0;\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        User user = this.searchUser(userId);\\n        user.postTweet(tweetId, postId);\\n        this.postId += 1;\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        User user = this.searchUser(userId);\\n        List<Integer> newsFeed = user.getNewsFeed().stream().map(post -> post.toId).collect(Collectors.toList());\\n        return newsFeed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        User follower = this.searchUser(followerId);\\n        User followee = this.searchUser(followeeId);\\n        follower.follow(followee);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        User follower = this.searchUser(followerId);\\n        User followee = this.searchUser(followeeId);\\n        follower.unfollow(followee);\\n    }\\n    \\n    public User searchUser(int id) {\\n        return users.computeIfAbsent(id, k -> new User(k));\\n    }\\n}\\n\\nclass User {\\n    int id;\\n    Set<User> following;\\n    List<Post> posts;\\n    \\n    public User(int id) {\\n        this.id = id;\\n        this.following = new HashSet<>();\\n        this.posts = new ArrayList<>();\\n    }\\n    \\n    public void postTweet(int toId, int postId) {\\n        this.posts.add(new Post(this.id, toId, postId));\\n    }\\n    \\n    public void follow(User followee) {\\n        if (this.equals(followee)) return;\\n        this.following.add(followee);\\n    }\\n    \\n    public void unfollow(User followee) {\\n        this.following.remove(followee);\\n    }\\n    \\n    public List<Post> getNewsFeed() {\\n        List<Post> followingPosts = this.following.stream().flatMap(user -> user.posts.stream()).collect(Collectors.toList());\\n        List<Post> newsFeed = Stream.of(this.posts, followingPosts)\\n            .flatMap(list -> list.stream())\\n            .sorted((a, b) -> b.postId - a.postId)\\n            .limit(10)\\n            .collect(Collectors.toList());\\n        return newsFeed;\\n    }\\n}\\n\\nclass Post {\\n    int fromId;\\n    int toId;\\n    int postId;\\n    \\n    public Post(int fromId, int toId, int postId) {\\n        this.fromId = fromId;\\n        this.toId = toId;\\n        this.postId = postId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82853,
                "title": "fast-getnewsfeed",
                "content": "The idea is to maintain a newsFeed set for each user. The assumption is that getNewsFeed() is called much more frequently than the other functions. I guess most users expect fast loading of home page, but can tolerate reasonable delays in tweeting / following / unfollowing (they can be ajax with some tricks anyway). Not sure whether it is the case for Twitter though.\\n\\n\\n    public class Twitter {\\n    \\n        int seed = 0;\\n        Map<Integer, Deque<Tweet>> tweetMap;\\n        Map<Integer, Set<Integer>> followerMap;\\n        Map<Integer, Set<Tweet>> newsFeedMap;\\n        \\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            tweetMap = new HashMap<>();\\n            followerMap = new HashMap<>();\\n            newsFeedMap = new HashMap<>();\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            Tweet tweet = new Tweet(seed++, tweetId);\\n            Deque<Tweet> tweets = tweetMap.get(userId);\\n            if (tweets == null) {\\n                tweets = new ArrayDeque<>();\\n                tweetMap.put(userId, tweets);\\n            }\\n            tweets.push(tweet);\\n            \\n            Set<Tweet> selfNews = newsFeedMap.get(userId);\\n            if (selfNews == null) {\\n                selfNews = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                newsFeedMap.put(userId, selfNews);\\n            }\\n            selfNews.add(tweet);\\n    \\n            Set<Integer> followers = followerMap.get(userId);\\n            if (followers != null) {\\n                for (Integer follower : followers) {\\n                    Set<Tweet> news = newsFeedMap.get(follower);\\n                    if (news == null) {\\n                        news = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                        newsFeedMap.put(follower, news);\\n                    }\\n                    news.add(tweet);\\n                }\\n            }\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            \\n            Set<Tweet> news = newsFeedMap.get(userId);\\n            List<Integer> res = new ArrayList<>();\\n            if (news == null || news.isEmpty()) {\\n                return res;\\n            }\\n            \\n            int i = 0;\\n            Iterator<Tweet> it = news.iterator();\\n            while (it.hasNext() && i < 10) {\\n                res.add(it.next().tweetId);\\n                i++;\\n            }\\n            return res;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            \\n            if (followerId == followeeId) {\\n                return;\\n            }\\n            \\n            Set<Integer> followers = followerMap.get(followeeId);\\n            if (followers == null) {\\n                followers = new HashSet<>();\\n                followerMap.put(followeeId, followers);\\n            } else if (followers.contains(followerId)) {\\n                return;\\n            }\\n            followers.add(followerId);\\n    \\n            Deque<Tweet> tweets = tweetMap.get(followeeId);\\n            if (tweets == null || tweets.isEmpty()) {\\n                return;\\n            }\\n    \\n            Set<Tweet> news = newsFeedMap.get(followerId);\\n            if (news == null) {\\n                news = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                newsFeedMap.put(followerId, news);\\n            }\\n            for (Tweet t : tweets) {\\n                news.add(t);\\n            }\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            \\n            Set<Integer> followers = followerMap.get(followeeId);\\n            if (followers == null || followers.isEmpty()\\n                || !followers.contains(followerId)) {\\n                return;\\n            }\\n            followers.remove(Integer.valueOf(followerId));\\n    \\n            Deque<Tweet> tweets = tweetMap.get(followeeId);\\n            if (tweets == null || tweets.isEmpty()) {\\n                return;\\n            }\\n    \\n            Set<Tweet> news = newsFeedMap.get(followerId);\\n            for (Tweet t : tweets) {\\n                news.remove(t);\\n            }\\n        }\\n    }\\n    \\n    class Tweet {\\n        int seq;\\n        int tweetId;\\n        Tweet(int seq, int tweetId) {\\n            this.seq = seq;\\n            this.tweetId = tweetId;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is to maintain a newsFeed set for each user. The assumption is that getNewsFeed() is called much more frequently than the other functions. I guess most users expect fast loading of home page, but can tolerate reasonable delays in tweeting / following / unfollowing (they can be ajax with some tricks anyway). Not sure whether it is the case for Twitter though.\\n\\n\\n    public class Twitter {\\n    \\n        int seed = 0;\\n        Map<Integer, Deque<Tweet>> tweetMap;\\n        Map<Integer, Set<Integer>> followerMap;\\n        Map<Integer, Set<Tweet>> newsFeedMap;\\n        \\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            tweetMap = new HashMap<>();\\n            followerMap = new HashMap<>();\\n            newsFeedMap = new HashMap<>();\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            Tweet tweet = new Tweet(seed++, tweetId);\\n            Deque<Tweet> tweets = tweetMap.get(userId);\\n            if (tweets == null) {\\n                tweets = new ArrayDeque<>();\\n                tweetMap.put(userId, tweets);\\n            }\\n            tweets.push(tweet);\\n            \\n            Set<Tweet> selfNews = newsFeedMap.get(userId);\\n            if (selfNews == null) {\\n                selfNews = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                newsFeedMap.put(userId, selfNews);\\n            }\\n            selfNews.add(tweet);\\n    \\n            Set<Integer> followers = followerMap.get(userId);\\n            if (followers != null) {\\n                for (Integer follower : followers) {\\n                    Set<Tweet> news = newsFeedMap.get(follower);\\n                    if (news == null) {\\n                        news = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                        newsFeedMap.put(follower, news);\\n                    }\\n                    news.add(tweet);\\n                }\\n            }\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            \\n            Set<Tweet> news = newsFeedMap.get(userId);\\n            List<Integer> res = new ArrayList<>();\\n            if (news == null || news.isEmpty()) {\\n                return res;\\n            }\\n            \\n            int i = 0;\\n            Iterator<Tweet> it = news.iterator();\\n            while (it.hasNext() && i < 10) {\\n                res.add(it.next().tweetId);\\n                i++;\\n            }\\n            return res;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            \\n            if (followerId == followeeId) {\\n                return;\\n            }\\n            \\n            Set<Integer> followers = followerMap.get(followeeId);\\n            if (followers == null) {\\n                followers = new HashSet<>();\\n                followerMap.put(followeeId, followers);\\n            } else if (followers.contains(followerId)) {\\n                return;\\n            }\\n            followers.add(followerId);\\n    \\n            Deque<Tweet> tweets = tweetMap.get(followeeId);\\n            if (tweets == null || tweets.isEmpty()) {\\n                return;\\n            }\\n    \\n            Set<Tweet> news = newsFeedMap.get(followerId);\\n            if (news == null) {\\n                news = new TreeSet<>((t1, t2) -> t2.seq - t1.seq);\\n                newsFeedMap.put(followerId, news);\\n            }\\n            for (Tweet t : tweets) {\\n                news.add(t);\\n            }\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            \\n            Set<Integer> followers = followerMap.get(followeeId);\\n            if (followers == null || followers.isEmpty()\\n                || !followers.contains(followerId)) {\\n                return;\\n            }\\n            followers.remove(Integer.valueOf(followerId));\\n    \\n            Deque<Tweet> tweets = tweetMap.get(followeeId);\\n            if (tweets == null || tweets.isEmpty()) {\\n                return;\\n            }\\n    \\n            Set<Tweet> news = newsFeedMap.get(followerId);\\n            for (Tweet t : tweets) {\\n                news.remove(t);\\n            }\\n        }\\n    }\\n    \\n    class Tweet {\\n        int seq;\\n        int tweetId;\\n        Tweet(int seq, int tweetId) {\\n            this.seq = seq;\\n            this.tweetId = tweetId;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 82932,
                "title": "a-java-solution-similar-to-merging-k-sorted-list",
                "content": "    //This solution avoids all posts being added into the priority queue.\\n    public class Twitter {\\n        private class Post{\\n            public int tweetId;\\n            public int sequence;\\n            public Post next;\\n            public Post(int id, int seq, Post nxt){\\n                tweetId = id;\\n                sequence = seq;\\n                next = nxt;\\n            }\\n        }\\n        private class Com implements Comparator<Post>{\\n            public int compare(Post p1, Post p2){\\n                return -(p1.sequence - p2.sequence);\\n            }\\n        }\\n        private int seq;\\n        private Map<Integer, Set<Integer>> fls;\\n        private Map<Integer, Post> posts;\\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            fls = new HashMap<Integer, Set<Integer>>();\\n            posts = new HashMap<Integer, Post>();\\n            seq = 0;\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            if(!posts.containsKey(userId)){\\n                posts.put(userId, null);\\n            }\\n            if(!fls.containsKey(userId)){\\n                fls.put(userId, new HashSet<Integer>());\\n            }\\n            posts.put(userId, new Post(tweetId, seq++, posts.get(userId)));\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            List<Integer> list = new ArrayList<Integer>();\\n            if(!fls.containsKey(userId)) return list;\\n            PriorityQueue<Post> set = new PriorityQueue<Post>(new Com());\\n            if(posts.containsKey(userId)){\\n                set.add(posts.get(userId));\\n            }\\n            for(int id: fls.get(userId)){\\n                if(posts.containsKey(id)){\\n                    set.add(posts.get(id));\\n                }\\n            }\\n            for(int i = 0; i < 10 && !set.isEmpty(); i++){\\n                Post tmp = set.poll();\\n                list.add(tmp.tweetId);\\n                if(tmp.next != null) set.add(tmp.next);\\n            }\\n            return list;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            if(!fls.containsKey(followerId)) fls.put(followerId, new HashSet<Integer>());\\n            fls.get(followerId).add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            if(!fls.containsKey(followerId)) return;\\n            fls.get(followerId).remove(followeeId);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Merge Sort"
                ],
                "code": "    //This solution avoids all posts being added into the priority queue.\\n    public class Twitter {\\n        private class Post{\\n            public int tweetId;\\n            public int sequence;\\n            public Post next;\\n            public Post(int id, int seq, Post nxt){\\n                tweetId = id;\\n                sequence = seq;\\n                next = nxt;\\n            }\\n        }\\n        private class Com implements Comparator<Post>{\\n            public int compare(Post p1, Post p2){\\n                return -(p1.sequence - p2.sequence);\\n            }\\n        }\\n        private int seq;\\n        private Map<Integer, Set<Integer>> fls;\\n        private Map<Integer, Post> posts;\\n        /** Initialize your data structure here. */\\n        public Twitter() {\\n            fls = new HashMap<Integer, Set<Integer>>();\\n            posts = new HashMap<Integer, Post>();\\n            seq = 0;\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            if(!posts.containsKey(userId)){\\n                posts.put(userId, null);\\n            }\\n            if(!fls.containsKey(userId)){\\n                fls.put(userId, new HashSet<Integer>());\\n            }\\n            posts.put(userId, new Post(tweetId, seq++, posts.get(userId)));\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        public List<Integer> getNewsFeed(int userId) {\\n            List<Integer> list = new ArrayList<Integer>();\\n            if(!fls.containsKey(userId)) return list;\\n            PriorityQueue<Post> set = new PriorityQueue<Post>(new Com());\\n            if(posts.containsKey(userId)){\\n                set.add(posts.get(userId));\\n            }\\n            for(int id: fls.get(userId)){\\n                if(posts.containsKey(id)){\\n                    set.add(posts.get(id));\\n                }\\n            }\\n            for(int i = 0; i < 10 && !set.isEmpty(); i++){\\n                Post tmp = set.poll();\\n                list.add(tmp.tweetId);\\n                if(tmp.next != null) set.add(tmp.next);\\n            }\\n            return list;\\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            if(!fls.containsKey(followerId)) fls.put(followerId, new HashSet<Integer>());\\n            fls.get(followerId).add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            if(followerId == followeeId) return;\\n            if(!fls.containsKey(followerId)) return;\\n            fls.get(followerId).remove(followeeId);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 82938,
                "title": "object-oriented-solution",
                "content": "    public static class User{\\n    \\t\\tint userID;\\n    \\t\\tSet<Integer> userIFollow;\\n    \\t\\tList<Tweet> myTweets;\\n    \\t\\tpublic User(int userID) {\\n    \\t\\t\\tthis.userID = userID;\\n    \\t\\t\\tthis.myTweets = new ArrayList<Tweet>();\\n    \\t\\t\\tthis.userIFollow = new HashSet<>();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t/**Always add tweet to the zeroth position.\\n    \\t\\t * Since we need a maximum of 10 tweets in the news feed. Remove others.\\n    \\t\\t */\\n    \\t\\tpublic void postTweet(int tweetID, int clock){\\n    \\t\\t\\tif(this.myTweets.size() == 10) myTweets.remove(9);\\n    \\t\\t\\tmyTweets.add(0,new Tweet(this.userID, tweetID, clock));\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tpublic static class Tweet{\\n    \\t\\tint user;\\n    \\t\\tint tweetID;\\n    \\t\\tint clock;\\n    \\t\\tpublic Tweet(int user, int tweetID, int clock) {\\n    \\t\\t\\tsuper();\\n    \\t\\t\\tthis.user = user;\\n    \\t\\t\\tthis.tweetID = tweetID;\\n    \\t\\t\\tthis.clock = clock;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n        /** Initialize your data structure here. */\\n    \\t//Map userID vs User\\n    \\tMap<Integer, User> mapUsers;\\n    \\t//Time each tweet arrives\\n    \\tint clock;\\n        public Twitter() {\\n        \\tmapUsers = new HashMap<>();\\n        \\tclock = 0;\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            if(!mapUsers.containsKey(userId)) mapUsers.put(userId, new User(userId));\\n            mapUsers.get(userId).postTweet(tweetId, this.clock++);\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        /**Work similar to merge K sorted list and stop when result size == 10.\\n         * @param userId\\n         * @return\\n         */\\n        public List<Integer> getNewsFeed(int userId) {\\n            if(!mapUsers.containsKey(userId)) return Collections.emptyList();\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> folUsers = new ArrayList<>(mapUsers.get(userId).userIFollow);\\n            folUsers.add(userId);\\n            \\n            Queue<Tweet> top10 = new PriorityQueue<>(10, (a,b) -> Integer.compare(b.clock, a.clock));\\n            Map<Integer,Integer> usIndex = new HashMap<>();\\n            IntStream.range(0, folUsers.size()).forEach(i -> usIndex.put(folUsers.get(i),0));\\n            \\n            for(Integer user : folUsers){\\n            \\tif(mapUsers.get(user).myTweets.size() != 0){\\n            \\t\\ttop10.add(mapUsers.get(user).myTweets.get(usIndex.get(user)));\\n            \\t\\tusIndex.put(user,usIndex.get(user)+1);\\n            \\t}\\n            }\\n            \\n            while(!top10.isEmpty() && result.size() < 10){\\n            \\tTweet topTw = top10.poll();\\n            \\tresult.add(topTw.tweetID);\\n            \\tif(mapUsers.get(topTw.user).myTweets.size() > usIndex.get(topTw.user)){\\n            \\t\\ttop10.add(mapUsers.get(topTw.user).myTweets.get(usIndex.get(topTw.user)));\\n            \\t\\tusIndex.put(topTw.user,usIndex.get(topTw.user)+1);\\n            \\t}\\n            }\\n            return result;\\n            \\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            if(followeeId == followerId) return;\\n            if(!mapUsers.containsKey(followerId)) mapUsers.put(followerId, new User(followerId));\\n            if(!mapUsers.containsKey(followeeId)) mapUsers.put(followeeId, new User(followeeId));\\n            \\n            mapUsers.get(followerId).userIFollow.add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            if(!mapUsers.containsKey(followeeId) || !mapUsers.containsKey(followerId))return;\\n        \\tmapUsers.get(followerId).userIFollow.remove(followeeId);\\n        }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static class User{\\n    \\t\\tint userID;\\n    \\t\\tSet<Integer> userIFollow;\\n    \\t\\tList<Tweet> myTweets;\\n    \\t\\tpublic User(int userID) {\\n    \\t\\t\\tthis.userID = userID;\\n    \\t\\t\\tthis.myTweets = new ArrayList<Tweet>();\\n    \\t\\t\\tthis.userIFollow = new HashSet<>();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t/**Always add tweet to the zeroth position.\\n    \\t\\t * Since we need a maximum of 10 tweets in the news feed. Remove others.\\n    \\t\\t */\\n    \\t\\tpublic void postTweet(int tweetID, int clock){\\n    \\t\\t\\tif(this.myTweets.size() == 10) myTweets.remove(9);\\n    \\t\\t\\tmyTweets.add(0,new Tweet(this.userID, tweetID, clock));\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tpublic static class Tweet{\\n    \\t\\tint user;\\n    \\t\\tint tweetID;\\n    \\t\\tint clock;\\n    \\t\\tpublic Tweet(int user, int tweetID, int clock) {\\n    \\t\\t\\tsuper();\\n    \\t\\t\\tthis.user = user;\\n    \\t\\t\\tthis.tweetID = tweetID;\\n    \\t\\t\\tthis.clock = clock;\\n    \\t\\t}\\n    \\t\\t\\n    \\t}\\n        /** Initialize your data structure here. */\\n    \\t//Map userID vs User\\n    \\tMap<Integer, User> mapUsers;\\n    \\t//Time each tweet arrives\\n    \\tint clock;\\n        public Twitter() {\\n        \\tmapUsers = new HashMap<>();\\n        \\tclock = 0;\\n        }\\n        \\n        /** Compose a new tweet. */\\n        public void postTweet(int userId, int tweetId) {\\n            if(!mapUsers.containsKey(userId)) mapUsers.put(userId, new User(userId));\\n            mapUsers.get(userId).postTweet(tweetId, this.clock++);\\n        }\\n        \\n        /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n        /**Work similar to merge K sorted list and stop when result size == 10.\\n         * @param userId\\n         * @return\\n         */\\n        public List<Integer> getNewsFeed(int userId) {\\n            if(!mapUsers.containsKey(userId)) return Collections.emptyList();\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> folUsers = new ArrayList<>(mapUsers.get(userId).userIFollow);\\n            folUsers.add(userId);\\n            \\n            Queue<Tweet> top10 = new PriorityQueue<>(10, (a,b) -> Integer.compare(b.clock, a.clock));\\n            Map<Integer,Integer> usIndex = new HashMap<>();\\n            IntStream.range(0, folUsers.size()).forEach(i -> usIndex.put(folUsers.get(i),0));\\n            \\n            for(Integer user : folUsers){\\n            \\tif(mapUsers.get(user).myTweets.size() != 0){\\n            \\t\\ttop10.add(mapUsers.get(user).myTweets.get(usIndex.get(user)));\\n            \\t\\tusIndex.put(user,usIndex.get(user)+1);\\n            \\t}\\n            }\\n            \\n            while(!top10.isEmpty() && result.size() < 10){\\n            \\tTweet topTw = top10.poll();\\n            \\tresult.add(topTw.tweetID);\\n            \\tif(mapUsers.get(topTw.user).myTweets.size() > usIndex.get(topTw.user)){\\n            \\t\\ttop10.add(mapUsers.get(topTw.user).myTweets.get(usIndex.get(topTw.user)));\\n            \\t\\tusIndex.put(topTw.user,usIndex.get(topTw.user)+1);\\n            \\t}\\n            }\\n            return result;\\n            \\n        }\\n        \\n        /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n        public void follow(int followerId, int followeeId) {\\n            if(followeeId == followerId) return;\\n            if(!mapUsers.containsKey(followerId)) mapUsers.put(followerId, new User(followerId));\\n            if(!mapUsers.containsKey(followeeId)) mapUsers.put(followeeId, new User(followeeId));\\n            \\n            mapUsers.get(followerId).userIFollow.add(followeeId);\\n        }\\n        \\n        /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n        public void unfollow(int followerId, int followeeId) {\\n            if(!mapUsers.containsKey(followeeId) || !mapUsers.containsKey(followerId))return;\\n        \\tmapUsers.get(followerId).userIFollow.remove(followeeId);\\n        }\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 82966,
                "title": "my-accepted-python-code",
                "content": "class Twitter(object):\\n\\n    def __init__(self):\\n\\n        # Global timestamp\\n        self.timestamp = 1  \\n        # Users table\\n        self.user_data = {}\\n\\n    def postTweet(self, userId, tweetId):\\n\\n        if userId not in self.user_data:         \\n            # Each userId has a tweets list (10 items at most) and a set of followees (include itself)\\n            self.user_data[userId] = collections.deque(), {userId} \\n        \\n        # Discard outdated tweet    \\n        if len(self.user_data[userId][0]) == 10:\\n            self.user_data[userId][0].pop()\\n            \\n        self.user_data[userId][0].appendleft((-self.timestamp, tweetId))\\n        self.timestamp += 1\\n\\n    def getNewsFeed(self, userId):\\n       \\n        # Use a heap to store all tweets from followees and pick the 10 most recent ones\\n        if userId not in self.user_data:\\n            return []\\n            \\n        heap = []\\n        for uid in self.user_data[userId][1]:\\n            if uid in self.user_data:\\n                for tweet in self.user_data[uid][0]:\\n                    heapq.heappush(heap, tweet)\\n                    \\n        res = []\\n        while len(res) < 10 and heap:\\n            res.append(heapq.heappop(heap)[1])\\n        return res\\n        \\n\\n    def follow(self, followerId, followeeId):\\n\\n        if followerId not in self.user_data:\\n            self.user_data[followerId] = collections.deque(), {followerId} \\n            \\n        self.user_data[followerId][1].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId, followeeId):\\n\\n        if followerId not in self.user_data:\\n            return\\n        \\n        if followerId != followeeId:\\n            self.user_data[followerId][1].discard(followeeId)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Twitter(object):\\n\\n    def __init__(self):\\n\\n        # Global timestamp\\n        self.timestamp = 1  \\n        # Users table\\n        self.user_data = {}\\n\\n    def postTweet(self, userId, tweetId):\\n\\n        if userId not in self.user_data:         \\n            # Each userId has a tweets list (10 items at most) and a set of followees (include itself)\\n            self.user_data[userId] = collections.deque(), {userId} \\n        \\n        # Discard outdated tweet    \\n        if len(self.user_data[userId][0]) == 10:\\n            self.user_data[userId][0].pop()\\n            \\n        self.user_data[userId][0].appendleft((-self.timestamp, tweetId))\\n        self.timestamp += 1\\n\\n    def getNewsFeed(self, userId):\\n       \\n        # Use a heap to store all tweets from followees and pick the 10 most recent ones\\n        if userId not in self.user_data:\\n            return []\\n            \\n        heap = []\\n        for uid in self.user_data[userId][1]:\\n            if uid in self.user_data:\\n                for tweet in self.user_data[uid][0]:\\n                    heapq.heappush(heap, tweet)\\n                    \\n        res = []\\n        while len(res) < 10 and heap:\\n            res.append(heapq.heappop(heap)[1])\\n        return res\\n        \\n\\n    def follow(self, followerId, followeeId):\\n\\n        if followerId not in self.user_data:\\n            self.user_data[followerId] = collections.deque(), {followerId} \\n            \\n        self.user_data[followerId][1].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId, followeeId):\\n\\n        if followerId not in self.user_data:\\n            return\\n        \\n        if followerId != followeeId:\\n            self.user_data[followerId][1].discard(followeeId)",
                "codeTag": "Java"
            },
            {
                "id": 4066315,
                "title": "java-treeset-no-heap-simple-approach-easy-to-understand-short-beats-90",
                "content": "```\\nclass Twitter {\\n    int time;\\n    int[] tweets; // all the tweets posted belongs to which user\\n    User[] user; //all users\\n    class User{\\n        Set<Integer> following, followers; \\n        Set<int[]> selfPosted, posts; // all posts and selfposts //posts sorted in descending order 0-tweetId 1-time\\n        User(int userId){\\n            this.posts = new TreeSet<>((a,b) -> (b[1] - a[1]));\\n            this.selfPosted = new HashSet<>();\\n            this.following = new HashSet<>();\\n            this.followers = new HashSet<>();\\n            this.following.add(userId);\\n        }\\n    }\\n    public Twitter() {\\n        this.tweets = new int[10001];\\n        this.user = new User[501];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets[tweetId] = userId;\\n        \\n        if(user[userId] == null)\\n            user[userId] = new User(userId);\\n        \\n        User currUser = user[userId];\\n        int[] posted = new int[]{tweetId, time++};\\n        currUser.posts.add(posted);        // adding to all post\\n        currUser.selfPosted.add(posted); // adding to self post\\n        \\n        for(int follower : currUser.followers)// adding for all followers\\n            user[follower].posts.add(posted);\\n\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> feed = new ArrayList<>(10);\\n        if(user[userId] == null)\\n            return feed;\\n        \\n        for(int[] post : user[userId].posts){\\n            int currUser = tweets[post[0]]; //get user who posted\\n            if(user[userId].following.contains(currUser)) // see if following that user\\n                feed.add(post[0]);\\n            if(feed.size() == 10)\\n                break;\\n        }\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        User follow = user[followeeId], follower = user[followerId];\\n        if(follower == null)\\n            follower = new User(followerId);\\n            user[followerId] = follower;\\n        if(follow == null){\\n            follow = new User(followeeId);\\n            user[followeeId] = follow;\\n        }\\n        \\n        follower.following.add(followeeId);\\n        follower.posts.addAll(follow.selfPosted); // new follower so all selfposted in followers post\\n        follow.followers.add(followerId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        User follow = user[followeeId], follower = user[followerId];\\n        follower.following.remove(followeeId);\\n        follow.followers.remove(followerId);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Twitter {\\n    int time;\\n    int[] tweets; // all the tweets posted belongs to which user\\n    User[] user; //all users\\n    class User{\\n        Set<Integer> following, followers; \\n        Set<int[]> selfPosted, posts; // all posts and selfposts //posts sorted in descending order 0-tweetId 1-time\\n        User(int userId){\\n            this.posts = new TreeSet<>((a,b) -> (b[1] - a[1]));\\n            this.selfPosted = new HashSet<>();\\n            this.following = new HashSet<>();\\n            this.followers = new HashSet<>();\\n            this.following.add(userId);\\n        }\\n    }\\n    public Twitter() {\\n        this.tweets = new int[10001];\\n        this.user = new User[501];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        tweets[tweetId] = userId;\\n        \\n        if(user[userId] == null)\\n            user[userId] = new User(userId);\\n        \\n        User currUser = user[userId];\\n        int[] posted = new int[]{tweetId, time++};\\n        currUser.posts.add(posted);        // adding to all post\\n        currUser.selfPosted.add(posted); // adding to self post\\n        \\n        for(int follower : currUser.followers)// adding for all followers\\n            user[follower].posts.add(posted);\\n\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> feed = new ArrayList<>(10);\\n        if(user[userId] == null)\\n            return feed;\\n        \\n        for(int[] post : user[userId].posts){\\n            int currUser = tweets[post[0]]; //get user who posted\\n            if(user[userId].following.contains(currUser)) // see if following that user\\n                feed.add(post[0]);\\n            if(feed.size() == 10)\\n                break;\\n        }\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        User follow = user[followeeId], follower = user[followerId];\\n        if(follower == null)\\n            follower = new User(followerId);\\n            user[followerId] = follower;\\n        if(follow == null){\\n            follow = new User(followeeId);\\n            user[followeeId] = follow;\\n        }\\n        \\n        follower.following.add(followeeId);\\n        follower.posts.addAll(follow.selfPosted); // new follower so all selfposted in followers post\\n        follow.followers.add(followerId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        User follow = user[followeeId], follower = user[followerId];\\n        follower.following.remove(followeeId);\\n        follow.followers.remove(followerId);\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3696273,
                "title": "c-with-93-55-157ms",
                "content": "# Intuition\\nWe want to map tweets for each user. We also want to map each user with their followees. Keep track of tweet order using a property (I called it \\'date\\') that depends on a global counter. Use a priority queue to order them based on that \\'date\\' property per tweet. Limiting the query to just getting at most 10 tweets per follower (and the user) can help with performance.\\n\\n# Approach\\nStart by storing all user mappings and data when we call PostTweet, Follow, and Unfollow.\\n\\nI used a LinkedList since I felt like using AddFirst, and using the Linq call to take the first 10 items. You can also approach this with any other collection like a List, and get the 10 last things added.\\n\\nGetNewsFeed is the more complex call here:\\n    - First, get all the followee of that user (if any). \\n    - Get at most 10 tweets from each followee (if any), and pool them\\n    - After pooling all tweets from the followees, place them in the pq based on the \\'date\\'. which is just based on a simple global counter. Multiply the priority by -1 if you want the most recent to show up at the top of the pq.\\n    - Now, add the user\\'s 10 most recent tweets (if any) to the priority queue.\\n    - Now, iterate over the priority queue at most 10 times.\\n    - At each iteration, dequeue and add the item to the list.\\n\\n# Code\\n```\\nusing System.Linq;\\n\\npublic class Twitter {\\n\\n    internal class Tweet {\\n        public int id {get;set;}\\n        public int date {get;set;}\\n    }\\n\\n    private Dictionary<int, LinkedList<Tweet>> UserTweets {get;set;}\\n    private Dictionary<int, HashSet<int>> UserFollowees {get;set;}\\n    private int GlobalTweetOrder {get;set;}\\n\\n    private const int TWEET_COUNT_PER_USER = 10;\\n\\n    public Twitter() {\\n        UserTweets = new Dictionary<int, LinkedList<Tweet>>();\\n        UserFollowees = new Dictionary<int, HashSet<int>>();\\n        GlobalTweetOrder = 0;\\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        if (!UserTweets.ContainsKey(userId)) {\\n            var list = new LinkedList<Tweet>();\\n            var tweet = new Tweet() {\\n                id = tweetId,\\n                date = GlobalTweetOrder\\n            };\\n            list.AddFirst(tweet);\\n            UserTweets.Add(userId, list);\\n        } else {\\n            UserTweets[userId].AddFirst(new Tweet() {\\n                id = tweetId,\\n                date = GlobalTweetOrder\\n            });\\n            \\n        }\\n        GlobalTweetOrder++;\\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n\\n        var pq = new PriorityQueue<int, int>();\\n\\n        if (UserFollowees.ContainsKey(userId)) {\\n            var followees = UserFollowees[userId];\\n            var tweetPool = new List<Tweet>();\\n\\n            foreach (var followee in followees) {\\n                if (UserTweets.ContainsKey(followee)) {\\n                    var followeeTweets = UserTweets[followee].Take(TWEET_COUNT_PER_USER);\\n                    tweetPool.AddRange(followeeTweets);     \\n                }               \\n            } \\n\\n            foreach (var followeeTweet in tweetPool) {\\n                pq.Enqueue(followeeTweet.id, followeeTweet.date * -1);\\n            }\\n        }\\n\\n        if (UserTweets.ContainsKey(userId)) {\\n            var userTweets = UserTweets[userId].Take(TWEET_COUNT_PER_USER);\\n            foreach (var tweet in userTweets) {\\n                pq.Enqueue(tweet.id, tweet.date * -1);\\n            }\\n        }\\n        var finalList = new List<int>();\\n\\n        while (pq.Count > 0 && finalList.Count < 10) {\\n            finalList.Add(pq.Dequeue());\\n        }\\n\\n        return finalList;\\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if (!UserFollowees.ContainsKey(followerId)) {\\n            UserFollowees.Add(followerId, new HashSet<int>() {followeeId});\\n        } else {\\n            UserFollowees[followerId].Add(followeeId);\\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if (UserFollowees.ContainsKey(followerId)) {\\n            UserFollowees[followerId].Remove(followeeId);\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing System.Linq;\\n\\npublic class Twitter {\\n\\n    internal class Tweet {\\n        public int id {get;set;}\\n        public int date {get;set;}\\n    }\\n\\n    private Dictionary<int, LinkedList<Tweet>> UserTweets {get;set;}\\n    private Dictionary<int, HashSet<int>> UserFollowees {get;set;}\\n    private int GlobalTweetOrder {get;set;}\\n\\n    private const int TWEET_COUNT_PER_USER = 10;\\n\\n    public Twitter() {\\n        UserTweets = new Dictionary<int, LinkedList<Tweet>>();\\n        UserFollowees = new Dictionary<int, HashSet<int>>();\\n        GlobalTweetOrder = 0;\\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        if (!UserTweets.ContainsKey(userId)) {\\n            var list = new LinkedList<Tweet>();\\n            var tweet = new Tweet() {\\n                id = tweetId,\\n                date = GlobalTweetOrder\\n            };\\n            list.AddFirst(tweet);\\n            UserTweets.Add(userId, list);\\n        } else {\\n            UserTweets[userId].AddFirst(new Tweet() {\\n                id = tweetId,\\n                date = GlobalTweetOrder\\n            });\\n            \\n        }\\n        GlobalTweetOrder++;\\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n\\n        var pq = new PriorityQueue<int, int>();\\n\\n        if (UserFollowees.ContainsKey(userId)) {\\n            var followees = UserFollowees[userId];\\n            var tweetPool = new List<Tweet>();\\n\\n            foreach (var followee in followees) {\\n                if (UserTweets.ContainsKey(followee)) {\\n                    var followeeTweets = UserTweets[followee].Take(TWEET_COUNT_PER_USER);\\n                    tweetPool.AddRange(followeeTweets);     \\n                }               \\n            } \\n\\n            foreach (var followeeTweet in tweetPool) {\\n                pq.Enqueue(followeeTweet.id, followeeTweet.date * -1);\\n            }\\n        }\\n\\n        if (UserTweets.ContainsKey(userId)) {\\n            var userTweets = UserTweets[userId].Take(TWEET_COUNT_PER_USER);\\n            foreach (var tweet in userTweets) {\\n                pq.Enqueue(tweet.id, tweet.date * -1);\\n            }\\n        }\\n        var finalList = new List<int>();\\n\\n        while (pq.Count > 0 && finalList.Count < 10) {\\n            finalList.Add(pq.Dequeue());\\n        }\\n\\n        return finalList;\\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if (!UserFollowees.ContainsKey(followerId)) {\\n            UserFollowees.Add(followerId, new HashSet<int>() {followeeId});\\n        } else {\\n            UserFollowees[followerId].Add(followeeId);\\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if (UserFollowees.ContainsKey(followerId)) {\\n            UserFollowees[followerId].Remove(followeeId);\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594479,
                "title": "simple-javascript-solution-using-map-and-array",
                "content": "# Approach\\nUsers are stored in a Map, each key is a userId and the value is a Set of followees. Tweets are stored in an array, so when a user post a new tweet it will be placed at the end as a recent one, so we can filter tweets from the end and return a subset with 10 recent tweets.\\n\\n\\n# Code\\n```\\nvar Twitter = function () {\\n    this.users = new Map();\\n    this.tweets = [];\\n};\\n\\n/**\\n * @param {number} userId\\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function (userId, tweetId) {\\n    if (!this.users.has(userId)) this.users.set(userId, new Set());\\n    this.tweets.push({userId, tweetId});\\n};\\n\\n/**\\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function (userId) {\\n    const user = this.users.get(userId);\\n    const recentTweets = [];\\n    for (let i = this.tweets.length - 1; i >= 0 && recentTweets.length < 10; i--) {\\n        if (user.has(this.tweets[i].userId) || this.tweets[i].userId === userId) {\\n            recentTweets.push(this.tweets[i].tweetId);\\n        }\\n    }\\n    return recentTweets;\\n};\\n\\n/**\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function (followerId, followeeId) {\\n    const user = this.users.get(followerId) || new Set();\\n    user.add(followeeId);\\n    this.users.set(followerId, user);\\n};\\n\\n/**\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function (followerId, followeeId) {\\n    this.users.get(followerId)?.delete(followeeId);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar Twitter = function () {\\n    this.users = new Map();\\n    this.tweets = [];\\n};\\n\\n/**\\n * @param {number} userId\\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function (userId, tweetId) {\\n    if (!this.users.has(userId)) this.users.set(userId, new Set());\\n    this.tweets.push({userId, tweetId});\\n};\\n\\n/**\\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function (userId) {\\n    const user = this.users.get(userId);\\n    const recentTweets = [];\\n    for (let i = this.tweets.length - 1; i >= 0 && recentTweets.length < 10; i--) {\\n        if (user.has(this.tweets[i].userId) || this.tweets[i].userId === userId) {\\n            recentTweets.push(this.tweets[i].tweetId);\\n        }\\n    }\\n    return recentTweets;\\n};\\n\\n/**\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function (followerId, followeeId) {\\n    const user = this.users.get(followerId) || new Set();\\n    user.add(followeeId);\\n    this.users.set(followerId, user);\\n};\\n\\n/**\\n * @param {number} followerId\\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function (followerId, followeeId) {\\n    this.users.get(followerId)?.delete(followeeId);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575691,
                "title": "easy-explanation-beats-100-c",
                "content": "# Intuition\\n<!--a Describe your first thoughts on how to solve this problem. -->\\nYou have to keep track of when a tweet was posted as well as the user who posted it along with the ID of the tweet posted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a set for each user to store the followers that he has, and store the collective information in a map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    map<int,set<int>> mp;\\n    int time=0;\\n    priority_queue<vector<int>> pq;\\n    Twitter() {\\n        time=0;\\n        mp.clear();\\n        pq= priority_queue<vector<int>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({time++,tweetId,userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        priority_queue<vector<int>> npq=pq;\\n        int n=9;\\n        while(!npq.empty() && n >= 0)\\n        {\\n            auto it=npq.top();\\n            npq.pop();\\n            int user=it[2];\\n            int tweet=it[1];\\n            if(user==userId || mp[userId].find(user)!=mp[userId].end())\\n            {\\n                ans.push_back(tweet);\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    map<int,set<int>> mp;\\n    int time=0;\\n    priority_queue<vector<int>> pq;\\n    Twitter() {\\n        time=0;\\n        mp.clear();\\n        pq= priority_queue<vector<int>>();\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({time++,tweetId,userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        priority_queue<vector<int>> npq=pq;\\n        int n=9;\\n        while(!npq.empty() && n >= 0)\\n        {\\n            auto it=npq.top();\\n            npq.pop();\\n            int user=it[2];\\n            int tweet=it[1];\\n            if(user==userId || mp[userId].find(user)!=mp[userId].end())\\n            {\\n                ans.push_back(tweet);\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296205,
                "title": "python-simple-python-solution-using-hashmap-hash-table",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 47.64% of Python3 online submissions for Design Twitter.\\n# Memory Usage: 14 MB, less than 95.67% of Python3 online submissions for Design Twitter.\\n\\n\\tclass Twitter:\\n\\n\\t\\t\\tdef __init__(self):\\n\\n\\t\\t\\t\\tself.followers = {}\\n\\t\\t\\t\\tself.tweets = []\\n\\n\\t\\t\\tdef postTweet(self, userId: int, tweetId: int) -> None:\\n\\n\\t\\t\\t\\tif not userId in self.followers:\\n\\t\\t\\t\\t\\tself.followers[userId] = [userId]\\n\\n\\t\\t\\t\\tself.tweets.append([userId, tweetId])\\n\\n\\t\\t\\tdef getNewsFeed(self, userId: int) -> List[int]:\\n\\n\\t\\t\\t\\tresult = []\\n\\t\\t\\t\\tcount = 1      \\n\\t\\t\\t\\tindex = len(self.tweets) - 1\\n\\n\\t\\t\\t\\twhile count < 11 and index > -1:\\n\\n\\t\\t\\t\\t\\tif self.tweets[index][0] in self.followers[userId]:\\n\\t\\t\\t\\t\\t\\tresult.append(self.tweets[index][1])\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\t\\t\\t\\t\\tindex = index - 1\\n\\n\\t\\t\\t\\treturn result\\n\\n\\t\\t\\tdef follow(self, followerId: int, followeeId: int) -> None:\\n\\n\\t\\t\\t\\tif not followerId in self.followers:\\n\\t\\t\\t\\t\\tself.followers[followerId] = [followerId]\\n\\n\\t\\t\\t\\tself.followers[followerId].append(followeeId)\\n\\n\\t\\t\\tdef unfollow(self, followerId: int, followeeId: int) -> None:\\n\\n\\t\\t\\t\\tif followeeId in self.followers[followerId]:\\n\\t\\t\\t\\t\\tself.followers[followerId].remove(followeeId)\\n\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 35 ms, faster than 47.64% of Python3 online submissions for Design Twitter.\\n# Memory Usage: 14 MB, less than 95.67% of Python3 online submissions for Design Twitter.\\n\\n\\tclass Twitter:\\n\\n\\t\\t\\tdef __init__(self):\\n\\n\\t\\t\\t\\tself.followers = {}\\n\\t\\t\\t\\tself.tweets = []\\n\\n\\t\\t\\tdef postTweet(self, userId: int, tweetId: int) -> None:\\n\\n\\t\\t\\t\\tif not userId in self.followers:\\n\\t\\t\\t\\t\\tself.followers[userId] = [userId]\\n\\n\\t\\t\\t\\tself.tweets.append([userId, tweetId])\\n\\n\\t\\t\\tdef getNewsFeed(self, userId: int) -> List[int]:\\n\\n\\t\\t\\t\\tresult = []\\n\\t\\t\\t\\tcount = 1      \\n\\t\\t\\t\\tindex = len(self.tweets) - 1\\n\\n\\t\\t\\t\\twhile count < 11 and index > -1:\\n\\n\\t\\t\\t\\t\\tif self.tweets[index][0] in self.followers[userId]:\\n\\t\\t\\t\\t\\t\\tresult.append(self.tweets[index][1])\\n\\t\\t\\t\\t\\t\\tcount = count + 1\\n\\t\\t\\t\\t\\tindex = index - 1\\n\\n\\t\\t\\t\\treturn result\\n\\n\\t\\t\\tdef follow(self, followerId: int, followeeId: int) -> None:\\n\\n\\t\\t\\t\\tif not followerId in self.followers:\\n\\t\\t\\t\\t\\tself.followers[followerId] = [followerId]\\n\\n\\t\\t\\t\\tself.followers[followerId].append(followeeId)\\n\\n\\t\\t\\tdef unfollow(self, followerId: int, followeeId: int) -> None:\\n\\n\\t\\t\\t\\tif followeeId in self.followers[followerId]:\\n\\t\\t\\t\\t\\tself.followers[followerId].remove(followeeId)\\n\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3237391,
                "title": "java-using-hashmap-hashset-and-priorityqueue",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Twitter {\\n\\n    private Map<Integer, Set<Integer>> followers;\\n    private Map<Integer, PriorityQueue<int[]>> newsFeed;\\n    private Map<Integer, Set<int[]>> post;\\n    private Comparator<int[]> com;\\n    private int time;\\n\\n    public Twitter() {\\n        time = 0;\\n        followers = new HashMap<>();\\n        newsFeed = new HashMap<>();\\n        post = new HashMap<>();\\n        com = (a, b) -> b[1] - a[1];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        int[] arr = new int[]{tweetId, time++};\\n        post.computeIfAbsent(userId, l -> new HashSet<>()).add(arr);\\n        newsFeed.computeIfAbsent(userId, pq -> new PriorityQueue<>(com)).add(arr);\\n        for(int follower : followers.getOrDefault(userId, new HashSet<>())){\\n            newsFeed.computeIfAbsent(follower, pq -> new PriorityQueue<>(com)).add(arr);\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> res = new ArrayList<>();\\n        List<int[]> list = new ArrayList<>();\\n        PriorityQueue<int[]> pq = newsFeed.getOrDefault(userId, new PriorityQueue<>(com));\\n        int i = 0;\\n        int[] arr;\\n        while(res.size() < 10 && !pq.isEmpty()){\\n            arr = pq.remove();\\n            res.add(arr[0]);\\n            list.add(arr);\\n        }\\n        pq.addAll(list);\\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(followers.computeIfAbsent(followeeId, s -> new HashSet<>()).add(followerId)){\\n            Set<int[]> set = post.getOrDefault(followeeId, new HashSet<>());\\n            newsFeed.computeIfAbsent(followerId, pq -> new PriorityQueue(com)).addAll(set);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        followers.getOrDefault(followeeId, new HashSet<>()).remove(followerId);\\n        Set<int[]> set = post.getOrDefault(followeeId, new HashSet<>());\\n        PriorityQueue<int[]> pq = newsFeed.getOrDefault(followerId, new PriorityQueue<>(com));\\n        pq.removeIf(e -> set.contains(e));\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n\\n    private Map<Integer, Set<Integer>> followers;\\n    private Map<Integer, PriorityQueue<int[]>> newsFeed;\\n    private Map<Integer, Set<int[]>> post;\\n    private Comparator<int[]> com;\\n    private int time;\\n\\n    public Twitter() {\\n        time = 0;\\n        followers = new HashMap<>();\\n        newsFeed = new HashMap<>();\\n        post = new HashMap<>();\\n        com = (a, b) -> b[1] - a[1];\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        int[] arr = new int[]{tweetId, time++};\\n        post.computeIfAbsent(userId, l -> new HashSet<>()).add(arr);\\n        newsFeed.computeIfAbsent(userId, pq -> new PriorityQueue<>(com)).add(arr);\\n        for(int follower : followers.getOrDefault(userId, new HashSet<>())){\\n            newsFeed.computeIfAbsent(follower, pq -> new PriorityQueue<>(com)).add(arr);\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> res = new ArrayList<>();\\n        List<int[]> list = new ArrayList<>();\\n        PriorityQueue<int[]> pq = newsFeed.getOrDefault(userId, new PriorityQueue<>(com));\\n        int i = 0;\\n        int[] arr;\\n        while(res.size() < 10 && !pq.isEmpty()){\\n            arr = pq.remove();\\n            res.add(arr[0]);\\n            list.add(arr);\\n        }\\n        pq.addAll(list);\\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(followers.computeIfAbsent(followeeId, s -> new HashSet<>()).add(followerId)){\\n            Set<int[]> set = post.getOrDefault(followeeId, new HashSet<>());\\n            newsFeed.computeIfAbsent(followerId, pq -> new PriorityQueue(com)).addAll(set);\\n        }\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        followers.getOrDefault(followeeId, new HashSet<>()).remove(followerId);\\n        Set<int[]> set = post.getOrDefault(followeeId, new HashSet<>());\\n        PriorityQueue<int[]> pq = newsFeed.getOrDefault(followerId, new PriorityQueue<>(com));\\n        pq.removeIf(e -> set.contains(e));\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229803,
                "title": "simple-and-self-explanatory-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have maintained a list to store the tweets and then I have maintained a dictionary with key as users whose value will contain the users it follows.\\nWe can append the userId of the account in the value of the user(in the dictionary)which wants to follow the account.\\nWe can delete the userId of the person using remove function when using unfollow fuction.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Twitter(object):\\n    def __init__(self):\\n        self.followlt={}\\n        self.tweets=[]\\n    def postTweet(self, userId, tweetId):\\n        if not userId in self.followlt:\\n            self.followlt[userId]=[userId]\\n        self.tweets.append([userId,tweetId])\\n    def getNewsFeed(self, userId):\\n        lt=[]\\n        i=len(self.tweets)-1\\n        while len(lt)<10 and i>=0:\\n            if self.tweets[i][0] in self.followlt[userId]:\\n                lt.append(self.tweets[i][1])\\n            i=i-1\\n        return lt\\n    def follow(self, followerId, followeeId):\\n        if not followerId in self.followlt:\\n            self.followlt[followerId]=[followerId]\\n        self.followlt[followerId].append(followeeId)\\n    def unfollow(self, followerId, followeeId):\\n        if followeeId in self.followlt[followerId]:\\n            self.followlt[followerId].remove(followeeId)\\n\\n\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Twitter(object):\\n    def __init__(self):\\n        self.followlt={}\\n        self.tweets=[]\\n    def postTweet(self, userId, tweetId):\\n        if not userId in self.followlt:\\n            self.followlt[userId]=[userId]\\n        self.tweets.append([userId,tweetId])\\n    def getNewsFeed(self, userId):\\n        lt=[]\\n        i=len(self.tweets)-1\\n        while len(lt)<10 and i>=0:\\n            if self.tweets[i][0] in self.followlt[userId]:\\n                lt.append(self.tweets[i][1])\\n            i=i-1\\n        return lt\\n    def follow(self, followerId, followeeId):\\n        if not followerId in self.followlt:\\n            self.followlt[followerId]=[followerId]\\n        self.followlt[followerId].append(followeeId)\\n    def unfollow(self, followerId, followeeId):\\n        if followeeId in self.followlt[followerId]:\\n            self.followlt[followerId].remove(followeeId)\\n\\n\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163183,
                "title": "simple-explained-solution",
                "content": "\\n```\\npublic class Twitter {\\n\\nprivate static class Tweet{\\n    int tweetId;\\n    int timePosted;\\n    public Tweet(int tId, int time){\\n        tweetId = tId;\\n        timePosted = time;\\n    }\\n}\\n\\nstatic int timeStamp;\\nint feedMaxNum;\\nMap<Integer, Set<Integer>> followees;\\nMap<Integer, List<Tweet>> tweets;\\n\\n/** Initialize your data structure here. */\\npublic Twitter() {\\n    timeStamp = 0;\\n    feedMaxNum = 10;\\n    followees = new HashMap<>();\\n    tweets = new HashMap<>();\\n}\\n\\n/** Compose a new tweet. */\\npublic void postTweet(int userId, int tweetId) {\\n    if(!tweets.containsKey(userId)) {\\n        tweets.put(userId, new LinkedList<Tweet>());\\n        follow(userId, userId);  //follow itself\\n    }\\n    tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place\\n}\\n\\n/** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\npublic List<Integer> getNewsFeed(int userId) {\\n    //min heap that the earliest tweet is on the top\\n    PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){\\n        public int compare(Tweet t1, Tweet t2){\\n            return t1.timePosted - t2.timePosted;\\n        }\\n    });\\n\\n    //add tweets of the followees\\n    Set<Integer> myFollowees = followees.get(userId);\\n    if(myFollowees != null){\\n        for(int followeeId : myFollowees){\\n            List<Tweet> followeeTweets = tweets.get(followeeId);\\n            if(followeeTweets == null) continue;\\n            for(Tweet t : followeeTweets){\\n                if(feedHeap.size() < feedMaxNum) feedHeap.add(t);\\n                else{\\n                    if(t.timePosted <= feedHeap.peek().timePosted) break;\\n                    else{\\n                        feedHeap.add(t);\\n                        feedHeap.poll(); //remove the oldest tweet\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    List<Integer> myFeed = new LinkedList<>();\\n    while(!feedHeap.isEmpty()){\\n        myFeed.add(0, feedHeap.poll().tweetId);\\n    }\\n    return myFeed;\\n}\\n\\n/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\npublic void follow(int followerId, int followeeId) {\\n    if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());\\n    followees.get(followerId).add(followeeId);\\n}\\n\\n/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\npublic void unfollow(int followerId, int followeeId) {\\n    if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself\\n    followees.get(followerId).remove(followeeId);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ruby",
                    "Bash",
                    "Swift",
                    "Go"
                ],
                "code": "```\\npublic class Twitter {\\n\\nprivate static class Tweet{\\n    int tweetId;\\n    int timePosted;\\n    public Tweet(int tId, int time){\\n        tweetId = tId;\\n        timePosted = time;\\n    }\\n}\\n\\nstatic int timeStamp;\\nint feedMaxNum;\\nMap<Integer, Set<Integer>> followees;\\nMap<Integer, List<Tweet>> tweets;\\n\\n/** Initialize your data structure here. */\\npublic Twitter() {\\n    timeStamp = 0;\\n    feedMaxNum = 10;\\n    followees = new HashMap<>();\\n    tweets = new HashMap<>();\\n}\\n\\n/** Compose a new tweet. */\\npublic void postTweet(int userId, int tweetId) {\\n    if(!tweets.containsKey(userId)) {\\n        tweets.put(userId, new LinkedList<Tweet>());\\n        follow(userId, userId);  //follow itself\\n    }\\n    tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place\\n}\\n\\n/** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\npublic List<Integer> getNewsFeed(int userId) {\\n    //min heap that the earliest tweet is on the top\\n    PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){\\n        public int compare(Tweet t1, Tweet t2){\\n            return t1.timePosted - t2.timePosted;\\n        }\\n    });\\n\\n    //add tweets of the followees\\n    Set<Integer> myFollowees = followees.get(userId);\\n    if(myFollowees != null){\\n        for(int followeeId : myFollowees){\\n            List<Tweet> followeeTweets = tweets.get(followeeId);\\n            if(followeeTweets == null) continue;\\n            for(Tweet t : followeeTweets){\\n                if(feedHeap.size() < feedMaxNum) feedHeap.add(t);\\n                else{\\n                    if(t.timePosted <= feedHeap.peek().timePosted) break;\\n                    else{\\n                        feedHeap.add(t);\\n                        feedHeap.poll(); //remove the oldest tweet\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    List<Integer> myFeed = new LinkedList<>();\\n    while(!feedHeap.isEmpty()){\\n        myFeed.add(0, feedHeap.poll().tweetId);\\n    }\\n    return myFeed;\\n}\\n\\n/** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\npublic void follow(int followerId, int followeeId) {\\n    if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());\\n    followees.get(followerId).add(followeeId);\\n}\\n\\n/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\npublic void unfollow(int followerId, int followeeId) {\\n    if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself\\n    followees.get(followerId).remove(followeeId);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970065,
                "title": "map-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMap + Priority Queue\\n\\n\\n# Code\\n```\\nvar Twitter = function() {\\n    this.tweetsByUser = new Map();\\n    this.followList = new Map();\\n    this.time = 0\\n};\\n\\n/** \\n * @param {number} userId \\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n    let tweet = this.tweetsByUser.get(userId) || []\\n    tweet.push([tweetId,++this.time])\\n    this.tweetsByUser.set(userId,tweet)\\n\\n\\n};\\n\\n/** \\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function(userId) {\\n   \\n    let feed = [ ],final = [],count = 0\\n\\n    let heap = new MaxPriorityQueue()\\n\\n\\n\\n    for(let [key,value] of this.tweetsByUser)\\n    {\\n        for(v of value)\\n        {\\n             heap.enqueue([key,v],v[1])\\n        }\\n    }\\n    \\n    while(heap.size() > 0)\\n    {\\n        let tweet = heap.dequeue()\\n        let list = String(this.followList.get(userId)).split(\\',\\').map(Number)\\n        if((list.includes(tweet.element[0]) || tweet.element[0] == userId) && count < 10)\\n           {\\n          \\n                feed.push(tweet.element[1][0])\\n                count++\\n            }\\n    }\\n    \\n    return feed\\n    \\n};\\n\\n/** \\n * @param {number} followerId \\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n    let following = this.followList.get(followerId) || []\\n    if(!following.includes(followeeId)) following.push(followeeId)\\n    this.followList.set(followerId,following)\\n};\\n\\n/** \\n * @param {number} followerId \\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n    const userFollowById = this.followList.get(followerId);\\n  if (!userFollowById) return;\\n  this.followList.delete(followerId);\\n    \\n};\\n\\n/** \\n * Your Twitter object will be instantiated and called as such:\\n * var obj = new Twitter()\\n * obj.postTweet(userId,tweetId)\\n * var param_2 = obj.getNewsFeed(userId)\\n * obj.follow(followerId,followeeId)\\n * obj.unfollow(followerId,followeeId)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Twitter = function() {\\n    this.tweetsByUser = new Map();\\n    this.followList = new Map();\\n    this.time = 0\\n};\\n\\n/** \\n * @param {number} userId \\n * @param {number} tweetId\\n * @return {void}\\n */\\nTwitter.prototype.postTweet = function(userId, tweetId) {\\n    let tweet = this.tweetsByUser.get(userId) || []\\n    tweet.push([tweetId,++this.time])\\n    this.tweetsByUser.set(userId,tweet)\\n\\n\\n};\\n\\n/** \\n * @param {number} userId\\n * @return {number[]}\\n */\\nTwitter.prototype.getNewsFeed = function(userId) {\\n   \\n    let feed = [ ],final = [],count = 0\\n\\n    let heap = new MaxPriorityQueue()\\n\\n\\n\\n    for(let [key,value] of this.tweetsByUser)\\n    {\\n        for(v of value)\\n        {\\n             heap.enqueue([key,v],v[1])\\n        }\\n    }\\n    \\n    while(heap.size() > 0)\\n    {\\n        let tweet = heap.dequeue()\\n        let list = String(this.followList.get(userId)).split(\\',\\').map(Number)\\n        if((list.includes(tweet.element[0]) || tweet.element[0] == userId) && count < 10)\\n           {\\n          \\n                feed.push(tweet.element[1][0])\\n                count++\\n            }\\n    }\\n    \\n    return feed\\n    \\n};\\n\\n/** \\n * @param {number} followerId \\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.follow = function(followerId, followeeId) {\\n    let following = this.followList.get(followerId) || []\\n    if(!following.includes(followeeId)) following.push(followeeId)\\n    this.followList.set(followerId,following)\\n};\\n\\n/** \\n * @param {number} followerId \\n * @param {number} followeeId\\n * @return {void}\\n */\\nTwitter.prototype.unfollow = function(followerId, followeeId) {\\n    const userFollowById = this.followList.get(followerId);\\n  if (!userFollowById) return;\\n  this.followList.delete(followerId);\\n    \\n};\\n\\n/** \\n * Your Twitter object will be instantiated and called as such:\\n * var obj = new Twitter()\\n * obj.postTweet(userId,tweetId)\\n * var param_2 = obj.getNewsFeed(userId)\\n * obj.follow(followerId,followeeId)\\n * obj.unfollow(followerId,followeeId)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2707702,
                "title": "c-priorityqueues-and-two-dictionary",
                "content": "Intuition: each userId is mapped to a priority queue that contains their tweets, sorted in order by timestamp. Additionally, each userId is mapped to a set of users they follow. When GetNewsFeed is called, we get that userId\\'s priority queue and also the priority queue of any user they follow, and combine all the results into one single big priority queue. Then we just return the top 10 results. \\n\\n```\\npublic class Twitter {\\n    \\n    public Dictionary<int, HashSet<int>> userFollowsDict; \\n    public Dictionary<int, PriorityQueue<int,int>> userTweetsDict; \\n    public int timestamp; \\n    \\n    public class CustomComparer : IComparer<int> {\\n        public int Compare(int firstVal, int secondVal) {\\n            return secondVal.CompareTo(firstVal); // max heap \\n        }\\n    }\\n\\n    public Twitter() {\\n        userFollowsDict = new Dictionary<int, HashSet<int>>(); \\n        userTweetsDict = new Dictionary<int, PriorityQueue<int,int>>(); \\n        timestamp = 0; \\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        if (userTweetsDict.ContainsKey(userId)) {\\n            userTweetsDict[userId].Enqueue(tweetId, timestamp); \\n        } else {\\n            userTweetsDict.Add(userId, new PriorityQueue<int, int>(new CustomComparer()));\\n            userTweetsDict[userId].Enqueue(tweetId, timestamp); \\n        }\\n        timestamp++; \\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n        \\n        var allResults = new PriorityQueue<int,int>(new CustomComparer()); \\n        var resultList = new List<int>(); \\n        \\n        // Does this user have any tweets to get?\\n        if (userTweetsDict.ContainsKey(userId)) { \\n            var allTheUsersTweets = userTweetsDict[userId].UnorderedItems; \\n            allResults.EnqueueRange(allTheUsersTweets);\\n        }\\n        \\n        // Does any user this user follows have tweets?\\n        if (userFollowsDict.ContainsKey(userId)) {\\n            foreach(var followee in userFollowsDict[userId]) {\\n                // get all their tweets \\n                if (userTweetsDict.ContainsKey(followee)) {\\n                    var allFolloweeTweets = userTweetsDict[followee].UnorderedItems; \\n                    allResults.EnqueueRange(allFolloweeTweets);\\n                }\\n            }\\n        }\\n        \\n        // all results are combined into a single priority queue\\n        var topTenResults = 10; \\n        while (allResults.Count > 0 && topTenResults > 0) {;\\n            resultList.Add(allResults.Dequeue()); \\n            topTenResults--; \\n        }\\n        \\n        return resultList; \\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if (userFollowsDict.ContainsKey(followerId)) {\\n            if (!userFollowsDict[followerId].Contains(followeeId)) {\\n                userFollowsDict[followerId].Add(followeeId); \\n            }\\n        } else {\\n            userFollowsDict.Add(followerId, new HashSet<int> {followeeId} ); \\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if (userFollowsDict.ContainsKey(followerId)) {\\n            if (userFollowsDict[followerId].Contains(followeeId)) {\\n                userFollowsDict[followerId].Remove(followeeId); \\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Intuition: each userId is mapped to a priority queue that contains their tweets, sorted in order by timestamp. Additionally, each userId is mapped to a set of users they follow. When GetNewsFeed is called, we get that userId\\'s priority queue and also the priority queue of any user they follow, and combine all the results into one single big priority queue. Then we just return the top 10 results. \\n\\n```\\npublic class Twitter {\\n    \\n    public Dictionary<int, HashSet<int>> userFollowsDict; \\n    public Dictionary<int, PriorityQueue<int,int>> userTweetsDict; \\n    public int timestamp; \\n    \\n    public class CustomComparer : IComparer<int> {\\n        public int Compare(int firstVal, int secondVal) {\\n            return secondVal.CompareTo(firstVal); // max heap \\n        }\\n    }\\n\\n    public Twitter() {\\n        userFollowsDict = new Dictionary<int, HashSet<int>>(); \\n        userTweetsDict = new Dictionary<int, PriorityQueue<int,int>>(); \\n        timestamp = 0; \\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        if (userTweetsDict.ContainsKey(userId)) {\\n            userTweetsDict[userId].Enqueue(tweetId, timestamp); \\n        } else {\\n            userTweetsDict.Add(userId, new PriorityQueue<int, int>(new CustomComparer()));\\n            userTweetsDict[userId].Enqueue(tweetId, timestamp); \\n        }\\n        timestamp++; \\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n        \\n        var allResults = new PriorityQueue<int,int>(new CustomComparer()); \\n        var resultList = new List<int>(); \\n        \\n        // Does this user have any tweets to get?\\n        if (userTweetsDict.ContainsKey(userId)) { \\n            var allTheUsersTweets = userTweetsDict[userId].UnorderedItems; \\n            allResults.EnqueueRange(allTheUsersTweets);\\n        }\\n        \\n        // Does any user this user follows have tweets?\\n        if (userFollowsDict.ContainsKey(userId)) {\\n            foreach(var followee in userFollowsDict[userId]) {\\n                // get all their tweets \\n                if (userTweetsDict.ContainsKey(followee)) {\\n                    var allFolloweeTweets = userTweetsDict[followee].UnorderedItems; \\n                    allResults.EnqueueRange(allFolloweeTweets);\\n                }\\n            }\\n        }\\n        \\n        // all results are combined into a single priority queue\\n        var topTenResults = 10; \\n        while (allResults.Count > 0 && topTenResults > 0) {;\\n            resultList.Add(allResults.Dequeue()); \\n            topTenResults--; \\n        }\\n        \\n        return resultList; \\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if (userFollowsDict.ContainsKey(followerId)) {\\n            if (!userFollowsDict[followerId].Contains(followeeId)) {\\n                userFollowsDict[followerId].Add(followeeId); \\n            }\\n        } else {\\n            userFollowsDict.Add(followerId, new HashSet<int> {followeeId} ); \\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if (userFollowsDict.ContainsKey(followerId)) {\\n            if (userFollowsDict[followerId].Contains(followeeId)) {\\n                userFollowsDict[followerId].Remove(followeeId); \\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2647812,
                "title": "python-heap-solution",
                "content": "```\\nfrom heapq import heapify,heappop,heappush\\n\\nclass Twitter:\\n    def __init__(self):\\n        self.data = {} # userid -> [tweet1,tweet2,...]\\n        self.followUser = {} # userid -> [follower1, follower2,...]\\n        self.time = 0\\n    def createUser(self,idd):\\n        if idd not in self.data:\\n            self.data[idd] = []\\n        if idd not in self.followUser:\\n            self.followUser[idd] = set()\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.createUser(userId)\\n        self.data[userId].append([self.time,tweetId])\\n        self.time += 1\\n    def getNewsFeed(self, userId: int) -> List[int]: \\n        self.createUser(userId)\\n        res = []\\n        res += self.data[userId]\\n        for u in self.followUser[userId]:\\n            res += self.data[u]\\n        heapify(res)\\n        # get the 10 most recent pair\\n        return [v for t,v in heapq.nlargest(10,res)]\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.createUser(followerId)\\n        self.createUser(followeeId)\\n        # use set for storing follower to prevent multiple subcribes\\n        self.followUser[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.createUser(followerId)\\n        self.createUser(followeeId)\\n        if followeeId in self.followUser[followerId]:\\n            self.followUser[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import heapify,heappop,heappush\\n\\nclass Twitter:\\n    def __init__(self):\\n        self.data = {} # userid -> [tweet1,tweet2,...]\\n        self.followUser = {} # userid -> [follower1, follower2,...]\\n        self.time = 0\\n    def createUser(self,idd):\\n        if idd not in self.data:\\n            self.data[idd] = []\\n        if idd not in self.followUser:\\n            self.followUser[idd] = set()\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.createUser(userId)\\n        self.data[userId].append([self.time,tweetId])\\n        self.time += 1\\n    def getNewsFeed(self, userId: int) -> List[int]: \\n        self.createUser(userId)\\n        res = []\\n        res += self.data[userId]\\n        for u in self.followUser[userId]:\\n            res += self.data[u]\\n        heapify(res)\\n        # get the 10 most recent pair\\n        return [v for t,v in heapq.nlargest(10,res)]\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.createUser(followerId)\\n        self.createUser(followeeId)\\n        # use set for storing follower to prevent multiple subcribes\\n        self.followUser[followerId].add(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.createUser(followerId)\\n        self.createUser(followeeId)\\n        if followeeId in self.followUser[followerId]:\\n            self.followUser[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647652,
                "title": "c-0ms-100-solution-using-prioirty-queue-and-custom-linked-list",
                "content": "The idea is:\\n- create a custom linked list struct\\n- each user has a linked list of tweets, with the list head\\xA0being the most recent\\n- use a priority queue that stores the heads of linked lists\\n- them it\\'s similiar to merge k sorted list \\n\\nBelow is the C++ implementation (0ms, faster than 100%)\\n\\n```c++\\nstruct LinkedList{\\n    int time;\\n    int id;\\n    LinkedList* next;\\n    LinkedList(int tid, int t){ time = t; id = tid; next = NULL; };\\n};\\n\\nstruct CMP{\\n    bool operator()(const LinkedList* h1, const LinkedList* h2) const {\\n        return h1->time < h2->time; \\n    }\\n};\\n\\nclass Twitter {\\npublic:\\n    int global_time = 1;\\n    unordered_map<int, LinkedList*> tweet_heads;\\n    unordered_map<int, unordered_set<int>>  following;\\n\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        LinkedList* new_post = new LinkedList(tweetId, global_time++);\\n        new_post->next = tweet_heads[userId];\\n        tweet_heads[userId] = new_post;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<LinkedList*, vector<LinkedList*>, CMP>  pq;\\n        if(tweet_heads.find(userId) != tweet_heads.end() and tweet_heads[userId] != NULL){\\n            pq.push(tweet_heads[userId]);\\n        }\\n        for(int user : following[userId]){\\n            if(tweet_heads.find(user) != tweet_heads.end() and tweet_heads[user] != NULL){\\n                pq.push(tweet_heads[user]);\\n            }\\n        }    \\n\\n        int cnt = 0;\\n        while(!pq.empty() and cnt < 10){\\n            LinkedList* cur_tweet = pq.top(); pq.pop();\\n            res.push_back(cur_tweet->id);\\n            cnt ++;\\n            if(cur_tweet->next != NULL){\\n                pq.push(cur_tweet->next);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);    \\n    }\\n};\\n```\\n\\nHope it can help someone!",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nstruct LinkedList{\\n    int time;\\n    int id;\\n    LinkedList* next;\\n    LinkedList(int tid, int t){ time = t; id = tid; next = NULL; };\\n};\\n\\nstruct CMP{\\n    bool operator()(const LinkedList* h1, const LinkedList* h2) const {\\n        return h1->time < h2->time; \\n    }\\n};\\n\\nclass Twitter {\\npublic:\\n    int global_time = 1;\\n    unordered_map<int, LinkedList*> tweet_heads;\\n    unordered_map<int, unordered_set<int>>  following;\\n\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        LinkedList* new_post = new LinkedList(tweetId, global_time++);\\n        new_post->next = tweet_heads[userId];\\n        tweet_heads[userId] = new_post;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<LinkedList*, vector<LinkedList*>, CMP>  pq;\\n        if(tweet_heads.find(userId) != tweet_heads.end() and tweet_heads[userId] != NULL){\\n            pq.push(tweet_heads[userId]);\\n        }\\n        for(int user : following[userId]){\\n            if(tweet_heads.find(user) != tweet_heads.end() and tweet_heads[user] != NULL){\\n                pq.push(tweet_heads[user]);\\n            }\\n        }    \\n\\n        int cnt = 0;\\n        while(!pq.empty() and cnt < 10){\\n            LinkedList* cur_tweet = pq.top(); pq.pop();\\n            res.push_back(cur_tweet->id);\\n            cnt ++;\\n            if(cur_tweet->next != NULL){\\n                pq.push(cur_tweet->next);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        following[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        following[followerId].erase(followeeId);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583978,
                "title": "c-0ms-udpate-feeds-when-follow-unfollow-posttweet",
                "content": "```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n\\t\\tuserFeeds.resize(501);\\n\\t\\tuserTweets.resize(501);\\n\\t\\tgraph.resize(501);\\n    }\\n\\n    void postTweet(int userId, int tweetId) {\\n\\t\\tint ti = tweets.size();\\n\\n        tweets.push_back(tweetId);\\n\\t\\tuserTweets[userId].push_back(ti);\\n\\n\\t\\tuserFeeds[userId].insert(ti);\\n\\t\\tfor (auto &followerId : graph[userId]) {\\n\\t\\t\\tuserFeeds[followerId].insert(ti);\\n\\t\\t}\\n    }\\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> news;\\n\\n\\t\\tauto it = userFeeds[userId].rbegin();\\n\\t\\twhile (it != userFeeds[userId].rend()) {\\n\\t\\t\\tnews.push_back(tweets[*it]);\\n\\t\\t\\tif (news.size() == 10) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t++it;\\n\\t\\t}\\n\\n\\t\\treturn news;\\n    }\\n\\n    void follow(int followerId, int followeeId) {\\n        graph[followeeId].insert(followerId);\\n\\t\\tuserFeeds[followerId].insert(userTweets[followeeId].begin(), userTweets[followeeId].end());\\n    }\\n\\n    void unfollow(int followerId, int followeeId) {\\n        graph[followeeId].erase(followerId);\\n\\n\\t\\tfor (auto &ti : userTweets[followeeId]) {\\n\\t\\t\\tuserFeeds[followerId].erase(ti);\\n\\t\\t}\\n    }\\n\\nprivate:\\n\\tvector<int> tweets; // idx = time -> tweetId\\n\\tvector<vector<int>> userTweets; // idx = userId -> his own tweets = index of tweets\\n\\tvector<set<int>> userFeeds; // idx = userId -> his news feads = index of tweets\\n\\tvector<unordered_set<int>> graph; // userId -> followers\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    Twitter() {\\n\\t\\tuserFeeds.resize(501);\\n\\t\\tuserTweets.resize(501);\\n\\t\\tgraph.resize(501);\\n    }\\n\\n    void postTweet(int userId, int tweetId) {\\n\\t\\tint ti = tweets.size();\\n\\n        tweets.push_back(tweetId);\\n\\t\\tuserTweets[userId].push_back(ti);\\n\\n\\t\\tuserFeeds[userId].insert(ti);\\n\\t\\tfor (auto &followerId : graph[userId]) {\\n\\t\\t\\tuserFeeds[followerId].insert(ti);\\n\\t\\t}\\n    }\\n\\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> news;\\n\\n\\t\\tauto it = userFeeds[userId].rbegin();\\n\\t\\twhile (it != userFeeds[userId].rend()) {\\n\\t\\t\\tnews.push_back(tweets[*it]);\\n\\t\\t\\tif (news.size() == 10) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t++it;\\n\\t\\t}\\n\\n\\t\\treturn news;\\n    }\\n\\n    void follow(int followerId, int followeeId) {\\n        graph[followeeId].insert(followerId);\\n\\t\\tuserFeeds[followerId].insert(userTweets[followeeId].begin(), userTweets[followeeId].end());\\n    }\\n\\n    void unfollow(int followerId, int followeeId) {\\n        graph[followeeId].erase(followerId);\\n\\n\\t\\tfor (auto &ti : userTweets[followeeId]) {\\n\\t\\t\\tuserFeeds[followerId].erase(ti);\\n\\t\\t}\\n    }\\n\\nprivate:\\n\\tvector<int> tweets; // idx = time -> tweetId\\n\\tvector<vector<int>> userTweets; // idx = userId -> his own tweets = index of tweets\\n\\tvector<set<int>> userFeeds; // idx = userId -> his news feads = index of tweets\\n\\tvector<unordered_set<int>> graph; // userId -> followers\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553669,
                "title": "simple-python-solution",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        #map each user to own tweets\\n        self.usersTweets = {}\\n        #time of the tweet\\n        self.tweetTime = 0\\n        #map each user to own following users\\n        self.userFollowing = {}\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId not in self.usersTweets :\\n            self.usersTweets[userId] = []\\n        #add the tweet to the list of tweets of each user\\n        self.usersTweets[userId].append([-self.tweetTime,tweetId])\\n        self.tweetTime+=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        userNewsFeed = []\\n        #get the tweets of the user\\n        if userId in self.usersTweets :\\n            for tweet in self.usersTweets[userId] :\\n                userNewsFeed.append(tweet)\\n        #get the tweet of users who the user followed.\\n        if userId in self.userFollowing :\\n            for f in self.userFollowing[userId] :\\n                if f in self.usersTweets :\\n                    userNewsFeed+=self.usersTweets[f]\\n        #sort the tweets by time (10 most recent tweet)           \\n        userNewsFeed = heapq.nsmallest(len(userNewsFeed),userNewsFeed)[0:10]\\n        return [tweet[1] for tweet in userNewsFeed]\\n    \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followerId not in self.userFollowing :\\n            self.userFollowing[followerId] = set()\\n        self.userFollowing[followerId].add(followeeId)\\n    \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followerId in self.userFollowing :\\n            self.userFollowing[followerId].remove(followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        #map each user to own tweets\\n        self.usersTweets = {}\\n        #time of the tweet\\n        self.tweetTime = 0\\n        #map each user to own following users\\n        self.userFollowing = {}\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId not in self.usersTweets :\\n            self.usersTweets[userId] = []\\n        #add the tweet to the list of tweets of each user\\n        self.usersTweets[userId].append([-self.tweetTime,tweetId])\\n        self.tweetTime+=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        userNewsFeed = []\\n        #get the tweets of the user\\n        if userId in self.usersTweets :\\n            for tweet in self.usersTweets[userId] :\\n                userNewsFeed.append(tweet)\\n        #get the tweet of users who the user followed.\\n        if userId in self.userFollowing :\\n            for f in self.userFollowing[userId] :\\n                if f in self.usersTweets :\\n                    userNewsFeed+=self.usersTweets[f]\\n        #sort the tweets by time (10 most recent tweet)           \\n        userNewsFeed = heapq.nsmallest(len(userNewsFeed),userNewsFeed)[0:10]\\n        return [tweet[1] for tweet in userNewsFeed]\\n    \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followerId not in self.userFollowing :\\n            self.userFollowing[followerId] = set()\\n        self.userFollowing[followerId].add(followeeId)\\n    \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followerId in self.userFollowing :\\n            self.userFollowing[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549016,
                "title": "commented-code-for-better-understanding",
                "content": "```\\nstruct User{\\n    vector<pair<int,int>> tweetid; // time, tweetId\\n    set<int> follow;               //userId is stored\\n};\\nclass Twitter {\\n    map<int,User> user;            // userId, User obj\\n    int time;                      // time\\npublic:\\n    Twitter() {\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        time++;\\n        if(user.find(userId) == user.end())    //creating user if not already\\n        {\\n            User  obj;\\n            user[userId] = obj;\\n        }\\n        user[userId].tweetid.push_back({time,tweetId});   //posting tweet\\n        // cout<<user.size()<<\" \";\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>> pq;\\n        // for()\\n        int n = user[userId].tweetid.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)                  //getting 10 recent post\\n            pq.push(user[userId].tweetid[i]);\\n        for(auto a:user[userId].follow)                    // traversing over its following\\n        {\\n            n = user[a].tweetid.size();\\n            for(int i=n-1;i>=max(0,n-10);i--)              // taking recent 10 ecah of its following\\n                pq.push(user[a].tweetid[i]);\\n        }\\n        n = pq.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)                  // from all posts, taking recent 10\\n        {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(user.find(followerId) == user.end())\\n        {\\n            User  obj;\\n            user[followerId] = obj;\\n        }\\n        if(user.find(followeeId) == user.end())\\n        {\\n            User  obj;\\n            user[followeeId] = obj;\\n        }\\n        user[followerId].follow.insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        user[followerId].follow.erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct User{\\n    vector<pair<int,int>> tweetid; // time, tweetId\\n    set<int> follow;               //userId is stored\\n};\\nclass Twitter {\\n    map<int,User> user;            // userId, User obj\\n    int time;                      // time\\npublic:\\n    Twitter() {\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        time++;\\n        if(user.find(userId) == user.end())    //creating user if not already\\n        {\\n            User  obj;\\n            user[userId] = obj;\\n        }\\n        user[userId].tweetid.push_back({time,tweetId});   //posting tweet\\n        // cout<<user.size()<<\" \";\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        priority_queue<pair<int,int>> pq;\\n        // for()\\n        int n = user[userId].tweetid.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)                  //getting 10 recent post\\n            pq.push(user[userId].tweetid[i]);\\n        for(auto a:user[userId].follow)                    // traversing over its following\\n        {\\n            n = user[a].tweetid.size();\\n            for(int i=n-1;i>=max(0,n-10);i--)              // taking recent 10 ecah of its following\\n                pq.push(user[a].tweetid[i]);\\n        }\\n        n = pq.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)                  // from all posts, taking recent 10\\n        {\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        if(user.find(followerId) == user.end())\\n        {\\n            User  obj;\\n            user[followerId] = obj;\\n        }\\n        if(user.find(followeeId) == user.end())\\n        {\\n            User  obj;\\n            user[followeeId] = obj;\\n        }\\n        user[followerId].follow.insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        user[followerId].follow.erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2537519,
                "title": "easy-solution-primitive-data-types-and-parallel-data-structure",
                "content": "```\\nclass Twitter {\\n    tweetPosts;\\n    tweetUsers;\\n    followings;\\n    constructor() {\\n        this.tweetPosts = [];\\n        this.tweetUsers = [];\\n        this.followings = {};\\n    }\\n\\n    postTweet(userId: number, tweetId: number): void {\\n        this.tweetPosts = [...this.tweetPosts, tweetId];\\n        this.tweetUsers = [...this.tweetUsers, userId];\\n    }\\n\\n    getNewsFeed(userId: number): number[] {\\n        const limit = this.tweetPosts.length > 10? 10 : this.tweetPosts.length;\\n        let feed = [];\\n        let count = 0;\\n        for (let i = this.tweetPosts.length - 1; i >= 0; i--) {\\n            if (count === limit) {\\n                break;\\n            }\\n            if (this.tweetUsers[i] === userId) {\\n                feed.push(this.tweetPosts[i]);\\n                count++;\\n            } else if (this.followings[userId] && this.followings[userId].includes(this.tweetUsers[i])) {\\n                feed.push(this.tweetPosts[i]);\\n                count++;\\n            }\\n        }\\n        return feed;\\n    }\\n\\n    follow(followerId: number, followeeId: number): void {\\n        if (!this.followings[followerId]) {\\n            this.followings[followerId] = [];\\n        }\\n        this.followings[followerId] = [...this.followings[followerId], followeeId];\\n    }\\n\\n    unfollow(followerId: number, followeeId: number): void {\\n        this.followings[followerId]?.find((follow, index)=>{\\n            if(follow === followeeId) {\\n                delete this.followings[followerId][index];\\n            }\\n            return false;\\n        });\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Twitter {\\n    tweetPosts;\\n    tweetUsers;\\n    followings;\\n    constructor() {\\n        this.tweetPosts = [];\\n        this.tweetUsers = [];\\n        this.followings = {};\\n    }\\n\\n    postTweet(userId: number, tweetId: number): void {\\n        this.tweetPosts = [...this.tweetPosts, tweetId];\\n        this.tweetUsers = [...this.tweetUsers, userId];\\n    }\\n\\n    getNewsFeed(userId: number): number[] {\\n        const limit = this.tweetPosts.length > 10? 10 : this.tweetPosts.length;\\n        let feed = [];\\n        let count = 0;\\n        for (let i = this.tweetPosts.length - 1; i >= 0; i--) {\\n            if (count === limit) {\\n                break;\\n            }\\n            if (this.tweetUsers[i] === userId) {\\n                feed.push(this.tweetPosts[i]);\\n                count++;\\n            } else if (this.followings[userId] && this.followings[userId].includes(this.tweetUsers[i])) {\\n                feed.push(this.tweetPosts[i]);\\n                count++;\\n            }\\n        }\\n        return feed;\\n    }\\n\\n    follow(followerId: number, followeeId: number): void {\\n        if (!this.followings[followerId]) {\\n            this.followings[followerId] = [];\\n        }\\n        this.followings[followerId] = [...this.followings[followerId], followeeId];\\n    }\\n\\n    unfollow(followerId: number, followeeId: number): void {\\n        this.followings[followerId]?.find((follow, index)=>{\\n            if(follow === followeeId) {\\n                delete this.followings[followerId][index];\\n            }\\n            return false;\\n        });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522481,
                "title": "without-creating-class-only-two-map-100-fast",
                "content": "\\n```\\nclass Twitter {\\nprivate:    \\n    unordered_map<int,unordered_set<int>> frnd; // user -> his friends. NOTE : set becoz all friends should be unique\\n    unordered_map<int,deque<pair<int,int>>> user_posts; // user -> 10 recent posts in deque NOTE : deque because we need to remove from front to get 10 recent posts\\n    int time = 0;\\n    \\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId){\\n        // insert posts to respective userId\\n        user_posts[userId].push_back({time++,tweetId});\\n        // we\\'ll store at max 10 posts for each person\\n        if(user_posts[userId].size()>10){\\n            user_posts[userId].pop_front();\\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        // priority_queue to easily get recent posts\\n        priority_queue<pair<int,int>> pq;\\n        \\n        // own posts\\n        for(auto &posts : user_posts[userId]){\\n            pq.push(posts);\\n        }      \\n        \\n        // posts of friends\\n        for(auto f : frnd[userId]){\\n            for(auto v : user_posts[f]){\\n                pq.push(v);\\n            }  \\n        }\\n        \\n        // take only 10 recent posts\\n        while(!pq.empty()){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            if(res.size()==10) return res;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        // add to friendList\\n        frnd[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        auto it = frnd[followerId].find(followeeId);\\n        // erase only if followeeId exists\\n        if(it!=frnd[followerId].end()){\\n            frnd[followerId].erase(it);    \\n        }\\n    }\\n};\\n\\n```\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/346c1acd-cd47-4a37-b5d3-095d9b9c076d_1662188656.6741028.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\nprivate:    \\n    unordered_map<int,unordered_set<int>> frnd; // user -> his friends. NOTE : set becoz all friends should be unique\\n    unordered_map<int,deque<pair<int,int>>> user_posts; // user -> 10 recent posts in deque NOTE : deque because we need to remove from front to get 10 recent posts\\n    int time = 0;\\n    \\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId){\\n        // insert posts to respective userId\\n        user_posts[userId].push_back({time++,tweetId});\\n        // we\\'ll store at max 10 posts for each person\\n        if(user_posts[userId].size()>10){\\n            user_posts[userId].pop_front();\\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> res;\\n        // priority_queue to easily get recent posts\\n        priority_queue<pair<int,int>> pq;\\n        \\n        // own posts\\n        for(auto &posts : user_posts[userId]){\\n            pq.push(posts);\\n        }      \\n        \\n        // posts of friends\\n        for(auto f : frnd[userId]){\\n            for(auto v : user_posts[f]){\\n                pq.push(v);\\n            }  \\n        }\\n        \\n        // take only 10 recent posts\\n        while(!pq.empty()){\\n            res.push_back(pq.top().second);\\n            pq.pop();\\n            if(res.size()==10) return res;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        // add to friendList\\n        frnd[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        auto it = frnd[followerId].find(followeeId);\\n        // erase only if followeeId exists\\n        if(it!=frnd[followerId].end()){\\n            frnd[followerId].erase(it);    \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514176,
                "title": "go-simple-solution",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\ntype MyHeap [][4]int\\n\\nfunc (h MyHeap) Len() int           { return len(h) }\\nfunc (h MyHeap) Less(i, j int) bool { return h[i][0] > h[j][0] }\\nfunc (h MyHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MyHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.([4]int))\\n}\\n\\nfunc (h *MyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc (h MyHeap) Top() interface{} {\\n\\treturn h[0]\\n}\\n\\ntype Twitter struct {\\n\\tcnt int\\n\\t// userId -> to list tweets\\n\\ttweetMap map[int][][2]int\\n\\t// userId -> to list follewees\\n\\tfollowedMap map[int]map[int]bool\\n}\\n\\nfunc Constructor() Twitter {\\n\\treturn Twitter{\\n\\t\\tcnt:         0,\\n\\t\\ttweetMap:    map[int][][2]int{},\\n\\t\\tfollowedMap: map[int]map[int]bool{},\\n\\t}\\n}\\n\\nfunc (this *Twitter) PostTweet(userId int, tweetId int) {\\n\\tthis.tweetMap[userId] = append(this.tweetMap[userId], [2]int{this.cnt, tweetId})\\n\\tthis.cnt++\\n}\\n\\nfunc (this *Twitter) GetNewsFeed(userId int) []int {\\n\\tres := []int{}\\n\\tmaxHeap := &MyHeap{}\\n\\theap.Init(maxHeap)\\n\\n    // add following them selve\\n\\tif this.followedMap[userId] == nil {\\n\\t\\tthis.followedMap[userId] = map[int]bool{}\\n\\t}\\n    this.followedMap[userId][userId] = true\\n    \\n\\tfollowees := this.followedMap[userId]\\n\\tfor followeeId, _ := range followees {\\n\\t\\tif listTweets, found := this.tweetMap[followeeId]; found {\\n\\t\\t\\t// listTweets := this.tweetMap[followeeId]\\n\\t\\t\\tindex := len(listTweets) - 1\\n\\t\\t\\tcount, tweetID := listTweets[index][0], listTweets[index][1]\\n\\t\\t\\t// push tweetID to max heap\\n\\t\\t\\theap.Push(maxHeap, [4]int{count, tweetID, followeeId, index - 1})\\n\\t\\t}\\n\\t}\\n\\n\\tfor maxHeap.Len() > 0 && len(res) < 10 {\\n\\t\\ttweet := heap.Pop(maxHeap).([4]int)\\n\\t\\t_, tweetID, followeeId, index := tweet[0], tweet[1], tweet[2], tweet[3]\\n\\t\\tres = append(res, tweetID)\\n\\t\\tif index >= 0 {\\n\\t\\t\\tprevTweet := this.tweetMap[followeeId][index]\\n\\t\\t\\tprevCount, prevTweetID := prevTweet[0], prevTweet[1]\\n\\t\\t\\theap.Push(maxHeap, [4]int{prevCount, prevTweetID, followeeId, index - 1})\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc (this *Twitter) Follow(followerId int, followeeId int) {\\n\\tif v, found := this.followedMap[followerId]; found {\\n\\t\\tv[followeeId] = true\\n\\t} else {\\n\\t\\tthis.followedMap[followerId] = map[int]bool{}\\n\\t\\tthis.followedMap[followerId][followeeId] = true\\n\\t}\\n}\\n\\nfunc (this *Twitter) Unfollow(followerId int, followeeId int) {\\n\\tif v, found := this.followedMap[followerId]; found {\\n\\t\\tdelete(v, followeeId)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\ntype MyHeap [][4]int\\n\\nfunc (h MyHeap) Len() int           { return len(h) }\\nfunc (h MyHeap) Less(i, j int) bool { return h[i][0] > h[j][0] }\\nfunc (h MyHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MyHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.([4]int))\\n}\\n\\nfunc (h *MyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc (h MyHeap) Top() interface{} {\\n\\treturn h[0]\\n}\\n\\ntype Twitter struct {\\n\\tcnt int\\n\\t// userId -> to list tweets\\n\\ttweetMap map[int][][2]int\\n\\t// userId -> to list follewees\\n\\tfollowedMap map[int]map[int]bool\\n}\\n\\nfunc Constructor() Twitter {\\n\\treturn Twitter{\\n\\t\\tcnt:         0,\\n\\t\\ttweetMap:    map[int][][2]int{},\\n\\t\\tfollowedMap: map[int]map[int]bool{},\\n\\t}\\n}\\n\\nfunc (this *Twitter) PostTweet(userId int, tweetId int) {\\n\\tthis.tweetMap[userId] = append(this.tweetMap[userId], [2]int{this.cnt, tweetId})\\n\\tthis.cnt++\\n}\\n\\nfunc (this *Twitter) GetNewsFeed(userId int) []int {\\n\\tres := []int{}\\n\\tmaxHeap := &MyHeap{}\\n\\theap.Init(maxHeap)\\n\\n    // add following them selve\\n\\tif this.followedMap[userId] == nil {\\n\\t\\tthis.followedMap[userId] = map[int]bool{}\\n\\t}\\n    this.followedMap[userId][userId] = true\\n    \\n\\tfollowees := this.followedMap[userId]\\n\\tfor followeeId, _ := range followees {\\n\\t\\tif listTweets, found := this.tweetMap[followeeId]; found {\\n\\t\\t\\t// listTweets := this.tweetMap[followeeId]\\n\\t\\t\\tindex := len(listTweets) - 1\\n\\t\\t\\tcount, tweetID := listTweets[index][0], listTweets[index][1]\\n\\t\\t\\t// push tweetID to max heap\\n\\t\\t\\theap.Push(maxHeap, [4]int{count, tweetID, followeeId, index - 1})\\n\\t\\t}\\n\\t}\\n\\n\\tfor maxHeap.Len() > 0 && len(res) < 10 {\\n\\t\\ttweet := heap.Pop(maxHeap).([4]int)\\n\\t\\t_, tweetID, followeeId, index := tweet[0], tweet[1], tweet[2], tweet[3]\\n\\t\\tres = append(res, tweetID)\\n\\t\\tif index >= 0 {\\n\\t\\t\\tprevTweet := this.tweetMap[followeeId][index]\\n\\t\\t\\tprevCount, prevTweetID := prevTweet[0], prevTweet[1]\\n\\t\\t\\theap.Push(maxHeap, [4]int{prevCount, prevTweetID, followeeId, index - 1})\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc (this *Twitter) Follow(followerId int, followeeId int) {\\n\\tif v, found := this.followedMap[followerId]; found {\\n\\t\\tv[followeeId] = true\\n\\t} else {\\n\\t\\tthis.followedMap[followerId] = map[int]bool{}\\n\\t\\tthis.followedMap[followerId][followeeId] = true\\n\\t}\\n}\\n\\nfunc (this *Twitter) Unfollow(followerId int, followeeId int) {\\n\\tif v, found := this.followedMap[followerId]; found {\\n\\t\\tdelete(v, followeeId)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484556,
                "title": "c-map-stack-faster-than-100-comments",
                "content": "```\\nclass Twitter {\\npublic:\\n    // to store who each user is following\\n    unordered_map<int, unordered_set<int>> followers;\\n    // to store every tweet made\\n    stack<pair<int, int>> global;\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        // add tweet to global stack\\n        global.push({userId, tweetId});\\n        // a user (by default) follows themself since their own tweets show in their feed\\n        followers[userId].insert(userId);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        // counter to ensure we only get a max of 10 tweets\\n        int i = 0;\\n        // return vector\\n        vector<int> ret;\\n        // temporary stack used to restore original global stack after popping tweets\\n        stack<pair<int, int>> temp;\\n        while (!global.empty() && i < 10) {\\n            // get next global tweet\\n            pair<int, int> next = global.top();\\n            // check if current user is following the user who made this tweet\\n            if (followers[userId].find(next.first) != followers[userId].end()) {\\n                ret.push_back(next.second);\\n                i++;\\n            }\\n            global.pop();\\n            temp.push(next);\\n        }\\n        // restore original global stack of tweets for future use\\n        while (!temp.empty()) {\\n            pair<int, int> next = temp.top();\\n            global.push(next);\\n            temp.pop();\\n        }\\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        // insert followee into follower\\'s list\\n        followers[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        // remove followee from follower\\'s list\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    // to store who each user is following\\n    unordered_map<int, unordered_set<int>> followers;\\n    // to store every tweet made\\n    stack<pair<int, int>> global;\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        // add tweet to global stack\\n        global.push({userId, tweetId});\\n        // a user (by default) follows themself since their own tweets show in their feed\\n        followers[userId].insert(userId);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        // counter to ensure we only get a max of 10 tweets\\n        int i = 0;\\n        // return vector\\n        vector<int> ret;\\n        // temporary stack used to restore original global stack after popping tweets\\n        stack<pair<int, int>> temp;\\n        while (!global.empty() && i < 10) {\\n            // get next global tweet\\n            pair<int, int> next = global.top();\\n            // check if current user is following the user who made this tweet\\n            if (followers[userId].find(next.first) != followers[userId].end()) {\\n                ret.push_back(next.second);\\n                i++;\\n            }\\n            global.pop();\\n            temp.push(next);\\n        }\\n        // restore original global stack of tweets for future use\\n        while (!temp.empty()) {\\n            pair<int, int> next = temp.top();\\n            global.push(next);\\n            temp.pop();\\n        }\\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        // insert followee into follower\\'s list\\n        followers[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        // remove followee from follower\\'s list\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438169,
                "title": "java-ood-solution-using-maxheap",
                "content": "Simple readable java solution\\n\\n```\\nclass Twitter {\\n\\n    Map<Integer, Set<Integer>> following;\\n    Map<Integer, List<Tweet>> feed;\\n    int time;\\n    \\n    public Twitter() {\\n        this.following = new HashMap<>();\\n        this.feed = new HashMap<>();\\n        this.time = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(isNewUser(userId)){\\n            addNewUser(userId);\\n        }\\n        \\n        feed.get(userId).add(new Tweet(tweetId, time));\\n        ++time;\\n        return;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {    \\n        if(isNewUser(userId)){\\n            addNewUser(userId);\\n        }\\n        \\n        // Get all the following people tweets and put them in PQ for getting latest feed order\\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<Tweet>((a, b) -> b.timeStamp - a.timeStamp);\\n        for(Integer followingId : following.get(userId)){\\n            if(feed.containsKey(followingId)){\\n                for(Tweet tweet : feed.get(followingId)){\\n                    minHeap.offer(tweet);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> userFeed = new ArrayList<Integer>();\\n        while(userFeed.size() < 10 && !minHeap.isEmpty()){\\n            userFeed.add(minHeap.poll().tweetId);\\n        }\\n        \\n        return userFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(isNewUser(followerId)){\\n            addNewUser(followerId);\\n        }\\n        \\n        following.get(followerId).add(followeeId);\\n        return;\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(!isNewUser(followerId)){\\n            following.get(followerId).remove(followeeId);\\n        }\\n        return;\\n    }\\n    \\n    public boolean isNewUser(int userId){\\n        return !following.containsKey(userId);\\n    }\\n    \\n    public void addNewUser(int userId){\\n        // create new following List\\n        following.put(userId, new HashSet<Integer>());\\n        following.get(userId).add(userId);\\n        \\n        // create new feed list\\n        feed.put(userId, new ArrayList<Tweet>());\\n    }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int timeStamp;\\n    \\n    Tweet(int tweetId, int timeStamp){\\n        this.tweetId = tweetId;\\n        this.timeStamp = timeStamp;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n\\n    Map<Integer, Set<Integer>> following;\\n    Map<Integer, List<Tweet>> feed;\\n    int time;\\n    \\n    public Twitter() {\\n        this.following = new HashMap<>();\\n        this.feed = new HashMap<>();\\n        this.time = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(isNewUser(userId)){\\n            addNewUser(userId);\\n        }\\n        \\n        feed.get(userId).add(new Tweet(tweetId, time));\\n        ++time;\\n        return;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {    \\n        if(isNewUser(userId)){\\n            addNewUser(userId);\\n        }\\n        \\n        // Get all the following people tweets and put them in PQ for getting latest feed order\\n        PriorityQueue<Tweet> minHeap = new PriorityQueue<Tweet>((a, b) -> b.timeStamp - a.timeStamp);\\n        for(Integer followingId : following.get(userId)){\\n            if(feed.containsKey(followingId)){\\n                for(Tweet tweet : feed.get(followingId)){\\n                    minHeap.offer(tweet);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> userFeed = new ArrayList<Integer>();\\n        while(userFeed.size() < 10 && !minHeap.isEmpty()){\\n            userFeed.add(minHeap.poll().tweetId);\\n        }\\n        \\n        return userFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(isNewUser(followerId)){\\n            addNewUser(followerId);\\n        }\\n        \\n        following.get(followerId).add(followeeId);\\n        return;\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(!isNewUser(followerId)){\\n            following.get(followerId).remove(followeeId);\\n        }\\n        return;\\n    }\\n    \\n    public boolean isNewUser(int userId){\\n        return !following.containsKey(userId);\\n    }\\n    \\n    public void addNewUser(int userId){\\n        // create new following List\\n        following.put(userId, new HashSet<Integer>());\\n        following.get(userId).add(userId);\\n        \\n        // create new feed list\\n        feed.put(userId, new ArrayList<Tweet>());\\n    }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int timeStamp;\\n    \\n    Tweet(int tweetId, int timeStamp){\\n        this.tweetId = tweetId;\\n        this.timeStamp = timeStamp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428729,
                "title": "simple-python-solution-using-hashmap-and-hashset-with-step-by-step-explanation",
                "content": "\\n```\\nclass Twitter:\\n    def __init__(self):\\n        self.count = 0\\n        self.follows = collections.defaultdict(list)\\n        self.tweets = collections.defaultdict(list)\\n        self.time = collections.defaultdict(int)\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.count += 1\\n        self.tweets[userId].append(tweetId)\\n        self.time[tweetId] = self.count\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        timeList = []\\n        totalTweets = []\\n        totalTweets += self.tweets[userId]\\n        for followee in self.follows[userId]:\\n            totalTweets.extend(self.tweets[followee])\\n\\n        unique = set(totalTweets)\\n        for tweet in unique:\\n            timeList.append((tweet, self.time[tweet]))\\n        timeList.sort(key=lambda x:x[1], reverse=True)\\n        res = []\\n        for item, time in timeList:\\n            res.append(item)\\n        if len(res) > 10:\\n            return res[:10]\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follows[followerId].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        l = self.follows[followerId]\\n        if followeeId in l:\\n            l.remove(followeeId)\\n            self.follows[followerId] = l\\n```\\n\\n1. initiate class variables\\n\\tself.count -> to record the timestamps during running \\n\\tself.follows -> key:userId, value: a list of Ids that this user is following\\n\\tself.tweets -> key:userId, value: a list of tweet Ids that this user posted\\n\\tself.time -> key:tweetId, value: the timestamp that this tweet posted\\n\\n2. postTweets\\n\\teverytime post a tweet, we:\\n\\t1) increment the timestamp count by 1\\n\\t2) add this tweet to the according user\\'s tweets list\\n\\t3) map the timestamp with according tweet\\n\\n3. getNewsFeed\\n\\twe get news feed from **user-self + user\\'s followees**\\n\\t1) use the tweets hashmap to find all tweets we need\\n\\t2) use hashset to remove duplicates\\n\\t3) use the time hashmap to find post time for each tweet, store as a tuple\\n\\t4) sort the timeList of tuples by post time\\n\\t5) return the tweet only\\n\\t\\n4. Follow\\n\\tsimply add the followeeId to according user\\'s follow list\\n\\n5. Unfollow\\n\\tif followeeId not in the user\\'s follow list -> do nothing\\n\\telse: remove it from the user\\'s follow list and update the hashmap",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Twitter:\\n    def __init__(self):\\n        self.count = 0\\n        self.follows = collections.defaultdict(list)\\n        self.tweets = collections.defaultdict(list)\\n        self.time = collections.defaultdict(int)\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.count += 1\\n        self.tweets[userId].append(tweetId)\\n        self.time[tweetId] = self.count\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        timeList = []\\n        totalTweets = []\\n        totalTweets += self.tweets[userId]\\n        for followee in self.follows[userId]:\\n            totalTweets.extend(self.tweets[followee])\\n\\n        unique = set(totalTweets)\\n        for tweet in unique:\\n            timeList.append((tweet, self.time[tweet]))\\n        timeList.sort(key=lambda x:x[1], reverse=True)\\n        res = []\\n        for item, time in timeList:\\n            res.append(item)\\n        if len(res) > 10:\\n            return res[:10]\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follows[followerId].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        l = self.follows[followerId]\\n        if followeeId in l:\\n            l.remove(followeeId)\\n            self.follows[followerId] = l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419413,
                "title": "simple-c-solution",
                "content": "```\\nclass Twitter {\\npublic:\\n    map<int,set<int>> followee; // userId -> {followees}\\n    vector<pair<int,int>> tweets; // <userId, tweetId>\\n    Twitter() { }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> newsFeeds;\\n        bool isFollowedNewsFeeds = false;\\n        for(int i=tweets.size()-1; i>=0;i--) { // traversing most recent to oldest tweet\\n            isFollowedNewsFeeds = userId == tweets[i].first || followee[userId].find(tweets[i].first) != followee[userId].end();\\n            if(isFollowedNewsFeeds) newsFeeds.push_back(tweets[i].second);\\n            if(newsFeeds.size()==10) break;\\n        }\\n        return vector<int>(newsFeeds.begin(), newsFeeds.begin() + min(10, (int) newsFeeds.size()));\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followee[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followee[followerId].erase(followeeId);\\n    }\\n\\n    void printNewsFeed(int userId) {\\n        vector<int> newsFeeds = getNewsFeed(userId);\\n        for(int newsFeed : newsFeeds) cout<<newsFeed<<\" \";\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\npublic:\\n    map<int,set<int>> followee; // userId -> {followees}\\n    vector<pair<int,int>> tweets; // <userId, tweetId>\\n    Twitter() { }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> newsFeeds;\\n        bool isFollowedNewsFeeds = false;\\n        for(int i=tweets.size()-1; i>=0;i--) { // traversing most recent to oldest tweet\\n            isFollowedNewsFeeds = userId == tweets[i].first || followee[userId].find(tweets[i].first) != followee[userId].end();\\n            if(isFollowedNewsFeeds) newsFeeds.push_back(tweets[i].second);\\n            if(newsFeeds.size()==10) break;\\n        }\\n        return vector<int>(newsFeeds.begin(), newsFeeds.begin() + min(10, (int) newsFeeds.size()));\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followee[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followee[followerId].erase(followeeId);\\n    }\\n\\n    void printNewsFeed(int userId) {\\n        vector<int> newsFeeds = getNewsFeed(userId);\\n        for(int newsFeed : newsFeeds) cout<<newsFeed<<\" \";\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2397044,
                "title": "custom-class-for-tweets-and-user-map-java",
                "content": "```\\nclass Twitter {\\n    HashMap<Integer,UserSchema> map;\\n    int time=0;\\n    public Twitter() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(map.containsKey(userId)){\\n           UserSchema user=map.get(userId);\\n           user.tweets.add(new Tweet(tweetId,++time));\\n        }else{\\n            UserSchema user=new UserSchema();\\n            user.uid=userId;\\n            user.tweets.add(new Tweet(tweetId,++time));\\n            map.put(userId,user);\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        UserSchema t=map.get(userId);\\n        if(t==null) return new ArrayList<>();\\n        List<Tweet> userposts=t.tweets;\\n         List<Tweet> posts=new ArrayList<>(userposts);\\n        Set<Integer> all=map.get(userId).following;\\n        for(Integer item:all){\\n            posts.addAll(map.get(item).tweets);\\n        }\\n        Collections.sort(posts,(a,b)->b.time-a.time);\\n        List<Integer> list=new ArrayList<>();\\n        int i=0;\\n        for(Tweet item:posts){\\n            if(i==10) break;\\n            list.add(item.tweetid);\\n            i++;\\n        }\\n        return list;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!map.containsKey(followeeId)){\\n           UserSchema user= new UserSchema();\\n            user.uid=followeeId;\\n            map.put(followeeId,user);\\n        }\\n        UserSchema user=map.get(followerId);\\n        if(user==null){\\n            user=new UserSchema();\\n            user.uid=followerId;\\n            map.put(followerId,user);\\n        }\\n        user.following.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        UserSchema user=map.get(followerId);\\n        user.following.remove(followeeId);\\n    }\\n}\\n\\nclass UserSchema{\\n    int uid;\\n    int time;\\n    ArrayList<Tweet> tweets=new ArrayList<>();\\n    Set<Integer> following=new HashSet<>();\\n}\\n\\nclass Tweet{\\n    int tweetid;\\n    int time;\\n    Tweet(int id,int t){\\n        this.tweetid=id;\\n        this.time=t;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Twitter {\\n    HashMap<Integer,UserSchema> map;\\n    int time=0;\\n    public Twitter() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(map.containsKey(userId)){\\n           UserSchema user=map.get(userId);\\n           user.tweets.add(new Tweet(tweetId,++time));\\n        }else{\\n            UserSchema user=new UserSchema();\\n            user.uid=userId;\\n            user.tweets.add(new Tweet(tweetId,++time));\\n            map.put(userId,user);\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        UserSchema t=map.get(userId);\\n        if(t==null) return new ArrayList<>();\\n        List<Tweet> userposts=t.tweets;\\n         List<Tweet> posts=new ArrayList<>(userposts);\\n        Set<Integer> all=map.get(userId).following;\\n        for(Integer item:all){\\n            posts.addAll(map.get(item).tweets);\\n        }\\n        Collections.sort(posts,(a,b)->b.time-a.time);\\n        List<Integer> list=new ArrayList<>();\\n        int i=0;\\n        for(Tweet item:posts){\\n            if(i==10) break;\\n            list.add(item.tweetid);\\n            i++;\\n        }\\n        return list;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!map.containsKey(followeeId)){\\n           UserSchema user= new UserSchema();\\n            user.uid=followeeId;\\n            map.put(followeeId,user);\\n        }\\n        UserSchema user=map.get(followerId);\\n        if(user==null){\\n            user=new UserSchema();\\n            user.uid=followerId;\\n            map.put(followerId,user);\\n        }\\n        user.following.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        UserSchema user=map.get(followerId);\\n        user.following.remove(followeeId);\\n    }\\n}\\n\\nclass UserSchema{\\n    int uid;\\n    int time;\\n    ArrayList<Tweet> tweets=new ArrayList<>();\\n    Set<Integer> following=new HashSet<>();\\n}\\n\\nclass Tweet{\\n    int tweetid;\\n    int time;\\n    Tweet(int id,int t){\\n        this.tweetid=id;\\n        this.time=t;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2378509,
                "title": "c-100-faster-easy-to-implement-map-set",
                "content": "class Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    map<int,set<int>>follower;\\n    map<int,set<pair<int,int>>>tweets;\\n    int timer=0;\\n    void postTweet(int userId, int tweetId) {\\n        timer++;\\n        tweets[userId].insert({timer,tweetId});\\n        if(tweets[userId].size()>10)\\n            tweets[userId].erase(tweets[userId].begin());\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<pair<int,int>> v;\\n        for(auto it:follower[userId])\\n            for(auto i:tweets[it])\\n                v.push_back(i);\\n        for(auto i:tweets[userId])\\n                v.push_back(i);\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        int n=v.size()-1;\\n        while(n>=0 and ans.size()<10)\\n        {\\n            ans.push_back(v[n].second);\\n            n--;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower[followerId].erase(followeeId);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Twitter {\\npublic:\\n    Twitter() {\\n        \\n    }\\n    map<int,set<int>>follower;\\n    map<int,set<pair<int,int>>>tweets;\\n    int timer=0;\\n    void postTweet(int userId, int tweetId) {\\n        timer++;\\n        tweets[userId].insert({timer,tweetId});\\n        if(tweets[userId].size()>10)\\n            tweets[userId].erase(tweets[userId].begin());\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<pair<int,int>> v;\\n        for(auto it:follower[userId])\\n            for(auto i:tweets[it])\\n                v.push_back(i);\\n        for(auto i:tweets[userId])\\n                v.push_back(i);\\n        sort(v.begin(),v.end());\\n        vector<int>ans;\\n        int n=v.size()-1;\\n        while(n>=0 and ans.size()<10)\\n        {\\n            ans.push_back(v[n].second);\\n            n--;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        follower[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        follower[followerId].erase(followeeId);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2361886,
                "title": "python-heap-solutions",
                "content": "This is for personal use:\\nThanks for: https://leetcode.com/StefanPochmann/\\n\\n```\\n#do not need to import itertools, collections here\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```\\n\\nthanks to: https://www.youtube.com/watch?v=pNichitDD2E&t=1358s\\n```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time = 0\\n        self.followees = collections.defaultdict(set)\\n        self.tweets = collections.defaultdict(list)#[time,tweets id]\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets[userId].append([self.time,tweetId])\\n        self.time -= 1\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.followees[userId].add(userId)\\n        minHeap = []\\n        rst = []\\n        # append the most recent tweet of every followee\\n        for f in self.followees[userId]:\\n            if f in self.tweets:\\n                index = len(self.tweets[f]) - 1\\n                time, twid = self.tweets[f][index]\\n                minHeap.append([time,twid,f,index-1])\\n        heapq.heapify(minHeap)\\n        while minHeap and len(rst) < 10:#use and but not or\\n            time,twid,f,index = heapq.heappop(minHeap)\\n            rst.append(twid)\\n            if index >= 0:\\n                time, twid = self.tweets[f][index]\\n                heapq.heappush(minHeap,[time,twid,f,index-1])\\n        return rst       \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followees[followerId].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followees[followerId]:\\n            self.followees[followerId].remove(followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\n#do not need to import itertools, collections here\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```\n```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.time = 0\\n        self.followees = collections.defaultdict(set)\\n        self.tweets = collections.defaultdict(list)#[time,tweets id]\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets[userId].append([self.time,tweetId])\\n        self.time -= 1\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.followees[userId].add(userId)\\n        minHeap = []\\n        rst = []\\n        # append the most recent tweet of every followee\\n        for f in self.followees[userId]:\\n            if f in self.tweets:\\n                index = len(self.tweets[f]) - 1\\n                time, twid = self.tweets[f][index]\\n                minHeap.append([time,twid,f,index-1])\\n        heapq.heapify(minHeap)\\n        while minHeap and len(rst) < 10:#use and but not or\\n            time,twid,f,index = heapq.heappop(minHeap)\\n            rst.append(twid)\\n            if index >= 0:\\n                time, twid = self.tweets[f][index]\\n                heapq.heappush(minHeap,[time,twid,f,index-1])\\n        return rst       \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followees[followerId].add(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followees[followerId]:\\n            self.followees[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335994,
                "title": "python",
                "content": "\\t\\n\\tclass Twitter:\\n\\n    def __init__(self):\\n        self.tweets = []\\n        self.followers = defaultdict(list)\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets.append([userId,tweetId])\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        ans= []\\n        \\n        i =  len(self.tweets)-1\\n        while i >= 0 and len(ans) < 10:\\n            p = self.tweets[i]\\n            if p[0] in self.followers[userId] or p[0] == userId:\\n                ans.append(p[1])\\n            \\n            i -= 1\\n        \\n        return ans\\n        \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followers[followerId].append(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followers[followerId]:\\n            self.followers[followerId].remove(followeeId)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\n\\tclass Twitter:\\n\\n    def __init__(self):\\n        self.tweets = []\\n        self.followers = defaultdict(list)\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.tweets.append([userId,tweetId])\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        ans= []\\n        \\n        i =  len(self.tweets)-1\\n        while i >= 0 and len(ans) < 10:\\n            p = self.tweets[i]\\n            if p[0] in self.followers[userId] or p[0] == userId:\\n                ans.append(p[1])\\n            \\n            i -= 1\\n        \\n        return ans\\n        \\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followers[followerId].append(followeeId)\\n        \\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followers[followerId]:\\n            self.followers[followerId].remove(followeeId)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)",
                "codeTag": "Java"
            },
            {
                "id": 2332667,
                "title": "2-hashmap-priority-queue",
                "content": "```\\n#define pii pair<int,int>\\nclass Twitter {\\n    int time;\\n    unordered_map<int,unordered_set<int>> followers;\\n    unordered_map<int,set<pii>> tweets; //userid -> (time, tweetid)\\'s\\npublic:\\n    Twitter() {\\n        time = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        set<pii> &t = tweets[userId];\\n        t.insert({++time,tweetId});\\n        if(t.size() > 10) t.erase(t.begin()); //only store top 10 tweets\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> posts;\\n        priority_queue<pii,vector<pii>,greater<pii>> p; //min heap to get top 10 latest tweets\\n\\t\\t//store self tweets\\n        for(auto &y: tweets[userId]){\\n            p.push(y);\\n        }\\n\\t\\t//store followers tweets\\n        for(auto &x: followers[userId]){\\n            for(auto &y: tweets[x]){\\n                p.push(y);\\n                if(p.size() > 10) p.pop(); //only maintain top 10 tweets\\n            }\\n        }\\n        while(p.size()){\\n            posts.push_back(p.top().second);\\n            p.pop();\\n        }\\n        reverse(posts.begin(),posts.end()); //tweets should be return from latest -> old\\n        return posts;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followers[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,int>\\nclass Twitter {\\n    int time;\\n    unordered_map<int,unordered_set<int>> followers;\\n    unordered_map<int,set<pii>> tweets; //userid -> (time, tweetid)\\'s\\npublic:\\n    Twitter() {\\n        time = 0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        set<pii> &t = tweets[userId];\\n        t.insert({++time,tweetId});\\n        if(t.size() > 10) t.erase(t.begin()); //only store top 10 tweets\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> posts;\\n        priority_queue<pii,vector<pii>,greater<pii>> p; //min heap to get top 10 latest tweets\\n\\t\\t//store self tweets\\n        for(auto &y: tweets[userId]){\\n            p.push(y);\\n        }\\n\\t\\t//store followers tweets\\n        for(auto &x: followers[userId]){\\n            for(auto &y: tweets[x]){\\n                p.push(y);\\n                if(p.size() > 10) p.pop(); //only maintain top 10 tweets\\n            }\\n        }\\n        while(p.size()){\\n            posts.push_back(p.top().second);\\n            p.pop();\\n        }\\n        reverse(posts.begin(),posts.end()); //tweets should be return from latest -> old\\n        return posts;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        followers[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        followers[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274001,
                "title": "python3-heap-queue-and-apply-merge-k-sorted-list",
                "content": "```\\nimport collections\\nimport heapq\\nfrom collections import deque\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = collections.defaultdict(set)\\n        self.tweets = {}\\n        self.timer = 1\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId not in self.tweets:\\n            self.tweets[userId] = deque()\\n            self.tweets[userId].append((-self.timer, tweetId))\\n        else:\\n            self.tweets[userId].appendleft((-self.timer, tweetId))\\n        self.timer += 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        heap = []\\n        print(self.tweets)\\n        if userId in self.tweets and self.tweets[userId]:\\n            heapq.heappush(heap, (self.tweets[userId][0], 0, userId))\\n        for fl in self.users[userId]:\\n            if fl in self.tweets and self.tweets[fl]:\\n                heapq.heappush(heap, (self.tweets[fl][0], 0, fl))\\n        count = 10\\n        res = []\\n        while heap and count:\\n            (timer, twId), index, uid = heapq.heappop(heap)\\n            res.append(twId)\\n            if index < len(self.tweets[uid]) - 1:\\n                heapq.heappush(heap, (self.tweets[uid][index+1], index+1, uid))\\n            count -= 1\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]:\\n            self.users[followerId].remove(followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport heapq\\nfrom collections import deque\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.users = collections.defaultdict(set)\\n        self.tweets = {}\\n        self.timer = 1\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId not in self.tweets:\\n            self.tweets[userId] = deque()\\n            self.tweets[userId].append((-self.timer, tweetId))\\n        else:\\n            self.tweets[userId].appendleft((-self.timer, tweetId))\\n        self.timer += 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        heap = []\\n        print(self.tweets)\\n        if userId in self.tweets and self.tweets[userId]:\\n            heapq.heappush(heap, (self.tweets[userId][0], 0, userId))\\n        for fl in self.users[userId]:\\n            if fl in self.tweets and self.tweets[fl]:\\n                heapq.heappush(heap, (self.tweets[fl][0], 0, fl))\\n        count = 10\\n        res = []\\n        while heap and count:\\n            (timer, twId), index, uid = heapq.heappop(heap)\\n            res.append(twId)\\n            if index < len(self.tweets[uid]) - 1:\\n                heapq.heappush(heap, (self.tweets[uid][index+1], index+1, uid))\\n            count -= 1\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.users[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.users[followerId]:\\n            self.users[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264325,
                "title": "python-oo-design",
                "content": "```\\nfrom typing import List, Dict, Optional\\nimport heapq\\n\\n\\nclass Tweet:\\n\\n    _timestamp = 0\\n\\n    __slots__ = [\"id\", \"timestamp\", \"next\"]\\n\\n    def __init__(self, tweet_id: int) -> None:\\n\\n        self.id = tweet_id\\n        self.timestamp = self._get_timestamp() \\n        self.next: Optional[Tweet] = None\\n    \\n    @classmethod\\n    def _get_timestamp(cls) -> int:\\n\\n        # we decrement timestamp to retrieve the most\\n        # recent tweet first from min heap\\n        cls._timestamp -= 1\\n        return cls._timestamp\\n\\n    def __lt__(self, other: \"Tweet\") -> bool:\\n\\n        return self.timestamp < other.timestamp\\n\\n\\nclass User:\\n\\n    __slots__ = [\"id\", \"tweets\", \"following\"]\\n\\n    def __init__(self, user_id: int) -> None:\\n\\n        self.id = user_id\\n        self.tweets: Optional[Tweet] = None\\n        self.following = set()\\n\\n    def follow(self, user_id: int) -> None:\\n\\n        self.following.add(user_id)\\n\\n    def unfollow(self, user_id: int) -> None:\\n\\n        self.following.discard(user_id)\\n\\n    def post_tweet(self, tweet_id: int) -> None:\\n\\n        tweet = Tweet(tweet_id)\\n        tweet.next = self.tweets\\n        self.tweets = tweet\\n\\n\\nclass Twitter:\\n\\n    def __init__(self, news_feed_len: int = 10) -> None:\\n        \\n        self._users: Dict[int, User] = {}     \\n        self._news_feed_len = news_feed_len\\n\\n    def _get_or_create_user(self, user_id) -> User:\\n        \\n        if user_id not in self._users:\\n            user = User(user_id)\\n            self._users[user_id] = user\\n\\n        return self._users[user_id] \\n        \\n    def postTweet(self, user_id: int, tweet_id: int) -> None:\\n\\n        user = self._get_or_create_user(user_id)\\n        user.post_tweet(tweet_id)\\n                \\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n\\n        user = self._get_or_create_user(user_id)\\n        news_feed = []\\n        recent_tweets: List[Tweet] = []\\n\\n        for followee_id in (user.following | {user.id}):\\n\\n            user = self._get_or_create_user(followee_id)\\n\\n            if user.tweets:\\n                heapq.heappush(recent_tweets, user.tweets)\\n\\n        while recent_tweets and len(news_feed) < self._news_feed_len:\\n\\n            tweet = heapq.heappop(recent_tweets)\\n\\n            if tweet.next:\\n                heapq.heappush(recent_tweets, tweet.next)\\n\\n            news_feed.append(tweet.id)\\n\\n        return news_feed\\n    \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        \\n        user = self._get_or_create_user(follower_id)\\n        user.follow(followee_id)\\n\\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n\\n        user = self._get_or_create_user(follower_id)\\n        user.unfollow(followee_id) \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List, Dict, Optional\\nimport heapq\\n\\n\\nclass Tweet:\\n\\n    _timestamp = 0\\n\\n    __slots__ = [\"id\", \"timestamp\", \"next\"]\\n\\n    def __init__(self, tweet_id: int) -> None:\\n\\n        self.id = tweet_id\\n        self.timestamp = self._get_timestamp() \\n        self.next: Optional[Tweet] = None\\n    \\n    @classmethod\\n    def _get_timestamp(cls) -> int:\\n\\n        # we decrement timestamp to retrieve the most\\n        # recent tweet first from min heap\\n        cls._timestamp -= 1\\n        return cls._timestamp\\n\\n    def __lt__(self, other: \"Tweet\") -> bool:\\n\\n        return self.timestamp < other.timestamp\\n\\n\\nclass User:\\n\\n    __slots__ = [\"id\", \"tweets\", \"following\"]\\n\\n    def __init__(self, user_id: int) -> None:\\n\\n        self.id = user_id\\n        self.tweets: Optional[Tweet] = None\\n        self.following = set()\\n\\n    def follow(self, user_id: int) -> None:\\n\\n        self.following.add(user_id)\\n\\n    def unfollow(self, user_id: int) -> None:\\n\\n        self.following.discard(user_id)\\n\\n    def post_tweet(self, tweet_id: int) -> None:\\n\\n        tweet = Tweet(tweet_id)\\n        tweet.next = self.tweets\\n        self.tweets = tweet\\n\\n\\nclass Twitter:\\n\\n    def __init__(self, news_feed_len: int = 10) -> None:\\n        \\n        self._users: Dict[int, User] = {}     \\n        self._news_feed_len = news_feed_len\\n\\n    def _get_or_create_user(self, user_id) -> User:\\n        \\n        if user_id not in self._users:\\n            user = User(user_id)\\n            self._users[user_id] = user\\n\\n        return self._users[user_id] \\n        \\n    def postTweet(self, user_id: int, tweet_id: int) -> None:\\n\\n        user = self._get_or_create_user(user_id)\\n        user.post_tweet(tweet_id)\\n                \\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n\\n        user = self._get_or_create_user(user_id)\\n        news_feed = []\\n        recent_tweets: List[Tweet] = []\\n\\n        for followee_id in (user.following | {user.id}):\\n\\n            user = self._get_or_create_user(followee_id)\\n\\n            if user.tweets:\\n                heapq.heappush(recent_tweets, user.tweets)\\n\\n        while recent_tweets and len(news_feed) < self._news_feed_len:\\n\\n            tweet = heapq.heappop(recent_tweets)\\n\\n            if tweet.next:\\n                heapq.heappush(recent_tweets, tweet.next)\\n\\n            news_feed.append(tweet.id)\\n\\n        return news_feed\\n    \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        \\n        user = self._get_or_create_user(follower_id)\\n        user.follow(followee_id)\\n\\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n\\n        user = self._get_or_create_user(follower_id)\\n        user.unfollow(followee_id) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258529,
                "title": "typescript-simple-and-efficient-with-o-log-k-for-feed",
                "content": "```typescript\\ntype Tweet = {\\n  id: number\\n  postedAt: number\\n  prev?: Tweet\\n}\\n\\nclass Twitter {\\n  private tweets: Map<number, Tweet>\\n  private follows: Map<number, Set<number>>\\n  private time = 0\\n\\n  constructor() {\\n    this.tweets = new Map()\\n    this.follows = new Map()\\n  }\\n\\n  postTweet(userId: number, tweetId: number): void {\\n    const tweet: Tweet = {\\n      id: tweetId,\\n      postedAt: this.time++,\\n      prev: this.tweets.get(userId)\\n    };\\n\\n    this.tweets.set(userId, tweet)\\n  }\\n\\n  getNewsFeed(userId: number): number[] {\\n    const feed = Array\\n      .from(this.follows.get(userId) ?? new Set<number>())\\n      .map(user => this.tweets.get(user))\\n      .filter((t): t is Tweet => !!t)\\n    \\n\\tif (this.tweets.has(userId))\\n      feed.push(this.tweets.get(userId))\\n\\t\\n    const pq = new MaxPriorityQueue<Tweet>(t => t.postedAt)\\n\\n    const out: number[] = []\\n    while (pq.size() > 0 && out.length < 10) {\\n      const elm = pq.pop()\\n      out.push(elm.id)\\n      if (elm.prev) pq.enqueue(elm.prev)\\n    }\\n\\n    return out\\n  }\\n\\n  follow(followerId: number, followeeId: number): void {\\n    if (this.follows.has(followerId)) {\\n      this.follows.get(followerId)!.add(followeeId)\\n    } else {\\n      this.follows.set(followerId, new Set([followeeId]))\\n    }\\n  }\\n\\n  unfollow(followerId: number, followeeId: number): void {\\n    this.follows.get(followerId)!.delete(followeeId)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```typescript\\ntype Tweet = {\\n  id: number\\n  postedAt: number\\n  prev?: Tweet\\n}\\n\\nclass Twitter {\\n  private tweets: Map<number, Tweet>\\n  private follows: Map<number, Set<number>>\\n  private time = 0\\n\\n  constructor() {\\n    this.tweets = new Map()\\n    this.follows = new Map()\\n  }\\n\\n  postTweet(userId: number, tweetId: number): void {\\n    const tweet: Tweet = {\\n      id: tweetId,\\n      postedAt: this.time++,\\n      prev: this.tweets.get(userId)\\n    };\\n\\n    this.tweets.set(userId, tweet)\\n  }\\n\\n  getNewsFeed(userId: number): number[] {\\n    const feed = Array\\n      .from(this.follows.get(userId) ?? new Set<number>())\\n      .map(user => this.tweets.get(user))\\n      .filter((t): t is Tweet => !!t)\\n    \\n\\tif (this.tweets.has(userId))\\n      feed.push(this.tweets.get(userId))\\n\\t\\n    const pq = new MaxPriorityQueue<Tweet>(t => t.postedAt)\\n\\n    const out: number[] = []\\n    while (pq.size() > 0 && out.length < 10) {\\n      const elm = pq.pop()\\n      out.push(elm.id)\\n      if (elm.prev) pq.enqueue(elm.prev)\\n    }\\n\\n    return out\\n  }\\n\\n  follow(followerId: number, followeeId: number): void {\\n    if (this.follows.has(followerId)) {\\n      this.follows.get(followerId)!.add(followeeId)\\n    } else {\\n      this.follows.set(followerId, new Set([followeeId]))\\n    }\\n  }\\n\\n  unfollow(followerId: number, followeeId: number): void {\\n    this.follows.get(followerId)!.delete(followeeId)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254049,
                "title": "java-solution-easy-and-commented",
                "content": "class Twitter {\\n    LinkedList<int[]> tweets; // The collection includes all tweets.\\n    HashMap<Integer, HashSet<Integer>> userList; //The collection includes all users and their following list.\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        //Initialize two global structures\\n        tweets = new LinkedList();\\n        userList = new HashMap();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        //add a tweet to the global linkedList\\n        tweets.addFirst(new int[] {userId, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        if(!userList.containsKey(userId)) { userListInit(userId); }\\n        \\n        //get user\\'s following list and creat a list to store the result.\\n        HashSet<Integer> followlist = userList.get(userId);\\n        List<Integer> feed = new ArrayList();\\n        int count = 10;// we only retrieve 10 tweets.\\n        \\n        //Traversal all the tweets in the linkedlist, check if their username in he following list.\\n        //if so, add to result. until get 10 results.\\n        for(int[] t : tweets) {\\n            if (count <= 0) {break;}\\n            if(followlist.contains(t[0])) {\\n                feed.add(t[1]);\\n                count--;\\n            }\\n        }\\n        \\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (!userList.containsKey(followerId)) { userListInit(followerId); }\\n        //get user\\'s following list and add a new id in it.\\n        HashSet<Integer> followlist = userList.get(followerId);\\n        followlist.add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (!userList.containsKey(followerId)) { userListInit(followerId); }\\n        //get user\\'s following list and remove an id from it.\\n        HashSet<Integer> followlist = userList.get(followerId);\\n        followlist.remove(followeeId);\\n    }\\n    //initialize a user\\'s following list(add to global hashmap and following himself)\\n    private void userListInit(int userId) {\\n        HashSet<Integer> following = new HashSet();\\n        following.add(userId);\\n        userList.put(userId, following);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Twitter {\\n    LinkedList<int[]> tweets; // The collection includes all tweets.\\n    HashMap<Integer, HashSet<Integer>> userList; //The collection includes all users and their following list.\\n\\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        //Initialize two global structures\\n        tweets = new LinkedList();\\n        userList = new HashMap();\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        //add a tweet to the global linkedList\\n        tweets.addFirst(new int[] {userId, tweetId});\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        if(!userList.containsKey(userId)) { userListInit(userId); }\\n        \\n        //get user\\'s following list and creat a list to store the result.\\n        HashSet<Integer> followlist = userList.get(userId);\\n        List<Integer> feed = new ArrayList();\\n        int count = 10;// we only retrieve 10 tweets.\\n        \\n        //Traversal all the tweets in the linkedlist, check if their username in he following list.\\n        //if so, add to result. until get 10 results.\\n        for(int[] t : tweets) {\\n            if (count <= 0) {break;}\\n            if(followlist.contains(t[0])) {\\n                feed.add(t[1]);\\n                count--;\\n            }\\n        }\\n        \\n        return feed;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        if (!userList.containsKey(followerId)) { userListInit(followerId); }\\n        //get user\\'s following list and add a new id in it.\\n        HashSet<Integer> followlist = userList.get(followerId);\\n        followlist.add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        if (!userList.containsKey(followerId)) { userListInit(followerId); }\\n        //get user\\'s following list and remove an id from it.\\n        HashSet<Integer> followlist = userList.get(followerId);\\n        followlist.remove(followeeId);\\n    }\\n    //initialize a user\\'s following list(add to global hashmap and following himself)\\n    private void userListInit(int userId) {\\n        HashSet<Integer> following = new HashSet();\\n        following.add(userId);\\n        userList.put(userId, following);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2237546,
                "title": "python-heap-solution",
                "content": "```python\\nfrom collections import defaultdict\\nfrom heapq import heapify, heappush, heappop\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow_map = defaultdict(set) # {userId: HashSet(userId)}\\n        self.user_tweets = defaultdict(list) # {userId: List<(timestamp, tweetId)> }\\n        self.tweet_timestamp = 0 # timestamp of tweets\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        # need to convert timestamp into negative, since heapq\\'s implementation is MinHeap\\n        self.user_tweets[userId].append((-self.tweet_timestamp, tweetId))\\n        self.tweet_timestamp += 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        feeds = []\\n        # get all tweets posted by who he/she follows or himself/herself\\n        for k, v in self.user_tweets.items():\\n            if k == userId or k in self.follow_map[userId]:\\n                feeds += v\\n        # build heaps for these tweets        \\n        heapify(feeds)\\n        ans = []\\n        # pop out the 10 most recent tweets (with bigger timestamp)\\n        while len(feeds) > 0 and len(ans) < 10:\\n            timestamp, tweetId = heappop(feeds)\\n            ans.append(tweetId)\\n        \\n        return ans\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_map[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow_map[followerId]:\\n            self.follow_map[followerId].remove(followeeId)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom collections import defaultdict\\nfrom heapq import heapify, heappush, heappop\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow_map = defaultdict(set) # {userId: HashSet(userId)}\\n        self.user_tweets = defaultdict(list) # {userId: List<(timestamp, tweetId)> }\\n        self.tweet_timestamp = 0 # timestamp of tweets\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        # need to convert timestamp into negative, since heapq\\'s implementation is MinHeap\\n        self.user_tweets[userId].append((-self.tweet_timestamp, tweetId))\\n        self.tweet_timestamp += 1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        feeds = []\\n        # get all tweets posted by who he/she follows or himself/herself\\n        for k, v in self.user_tweets.items():\\n            if k == userId or k in self.follow_map[userId]:\\n                feeds += v\\n        # build heaps for these tweets        \\n        heapify(feeds)\\n        ans = []\\n        # pop out the 10 most recent tweets (with bigger timestamp)\\n        while len(feeds) > 0 and len(ans) < 10:\\n            timestamp, tweetId = heappop(feeds)\\n            ans.append(tweetId)\\n        \\n        return ans\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_map[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow_map[followerId]:\\n            self.follow_map[followerId].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222748,
                "title": "c-design-logic-using-map-and-vector-easy-and-simple-code",
                "content": "**Please Upvote if you find my code helpful!!!**\\n```\\nclass Twitter {\\npublic:\\n    vector<pair<int, int>> posts; // tweets in order:  vector of {userId, tweetId}\\n    unordered_map<int, unordered_map<int, int>> rel; // followers - followee relation {userId: {followeeId: 0/1}}\\n    Twitter() {\\n        // Nothing to do here\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        // push the latest tweet into posts\\n        posts.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> tweets;\\n        for(int i=posts.size()-1; i>=0; i--){\\n            if(tweets.size()==10){ // limited (max 10 tweets) according to question\\n                break; \\n            }\\n            if(posts[i].first==userId || rel[userId][posts[i].first]!=0){ // user tweet or user\\'s followings\\' tweet\\n                tweets.push_back(posts[i].second);\\n            }\\n        }\\n        return tweets;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        rel[followerId][followeeId] = 1; // follow logic\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        rel[followerId].erase(followeeId); // unfollow logic\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Design"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    vector<pair<int, int>> posts; // tweets in order:  vector of {userId, tweetId}\\n    unordered_map<int, unordered_map<int, int>> rel; // followers - followee relation {userId: {followeeId: 0/1}}\\n    Twitter() {\\n        // Nothing to do here\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        // push the latest tweet into posts\\n        posts.push_back({userId, tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> tweets;\\n        for(int i=posts.size()-1; i>=0; i--){\\n            if(tweets.size()==10){ // limited (max 10 tweets) according to question\\n                break; \\n            }\\n            if(posts[i].first==userId || rel[userId][posts[i].first]!=0){ // user tweet or user\\'s followings\\' tweet\\n                tweets.push_back(posts[i].second);\\n            }\\n        }\\n        return tweets;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        rel[followerId][followeeId] = 1; // follow logic\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        rel[followerId].erase(followeeId); // unfollow logic\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176863,
                "title": "c-100-faster-easy-to-understand-8-lines-code",
                "content": "```\\n/*\\nSome Observations:\\n\\tWho posted what? vector<pair<int, int>>. This will preserve the order in which we insert the posts.\\n\\t(1 -> 5) (2 -> 6) (1 -> 7)\\n\\n\\tWho follow who? unordered_map<int, unordered_set<int>>. Unordered_set and unordered_map makes the insert and erase operation much simpler and cleaner.\\n\\t1 -> 2, 3\\n*/\\nclass Twitter {\\n    vector<pair<int, int>> whoPosted;\\n    unordered_map<int, unordered_set<int>> whoFollowWho;\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        whoPosted.push_back({ userId, tweetId });\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        unordered_set<int> s = whoFollowWho[userId];\\n        s.insert(userId);\\n        vector<int> ans;\\n        for (int i = whoPosted.size() - 1; i > -1 && ans.size() < 10; --i) if (s.find(whoPosted[i].first) != s.end()) ans.push_back(whoPosted[i].second);\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        whoFollowWho[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        whoFollowWho[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\nSome Observations:\\n\\tWho posted what? vector<pair<int, int>>. This will preserve the order in which we insert the posts.\\n\\t(1 -> 5) (2 -> 6) (1 -> 7)\\n\\n\\tWho follow who? unordered_map<int, unordered_set<int>>. Unordered_set and unordered_map makes the insert and erase operation much simpler and cleaner.\\n\\t1 -> 2, 3\\n*/\\nclass Twitter {\\n    vector<pair<int, int>> whoPosted;\\n    unordered_map<int, unordered_set<int>> whoFollowWho;\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        whoPosted.push_back({ userId, tweetId });\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        unordered_set<int> s = whoFollowWho[userId];\\n        s.insert(userId);\\n        vector<int> ans;\\n        for (int i = whoPosted.size() - 1; i > -1 && ans.size() < 10; --i) if (s.find(whoPosted[i].first) != s.end()) ans.push_back(whoPosted[i].second);\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        whoFollowWho[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        whoFollowWho[followerId].erase(followeeId);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175791,
                "title": "java-oo-code-clean-and-minimal",
                "content": "```\\nclass Twitter {\\n\\n    Map<Integer, User> users;\\n    int timestamp;\\n    \\n    public Twitter() {\\n        users = new HashMap<>();\\n        timestamp = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        User u = getUser(userId);\\n        Tweet t = new Tweet(tweetId, userId, ++timestamp);\\n        \\n        Queue<Tweet> userTweets = u.tweets;\\n        userTweets.offer(t);\\n        if (userTweets.size() >= 11) {\\n            userTweets.poll();\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        User u = getUser(userId);\\n        Queue<Tweet> userTweets = new PriorityQueue<>((a,b) -> (a.timestamp - b.timestamp));\\n        userTweets.addAll(u.tweets);\\n        \\n        Set<Integer> usersFollowed = u.following;\\n        \\n        for (Integer userFollowed: usersFollowed) {\\n            Queue<Tweet> followedUserTweets = getUser(userFollowed).tweets;\\n            \\n            Iterator<Tweet> iter = followedUserTweets.iterator();\\n            while (iter.hasNext()) {\\n                userTweets.offer(iter.next());\\n                if (userTweets.size() >= 11) {\\n                    userTweets.poll();\\n                }\\n            }   \\n            \\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        while (userTweets.size() >= 1) {\\n            res.add(0,userTweets.poll().tweetId);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        User u = getUser(followerId);\\n        Set<Integer> followingList = u.following;\\n        followingList.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        User u = getUser(followerId);\\n        Set<Integer> followingList = u.following;\\n        \\n        followingList.remove(followeeId);\\n    }\\n    \\n    User getUser(int userId) {\\n        if (!users.containsKey(userId)) {\\n            users.put(userId, new User(userId));\\n        }\\n        return users.get(userId);\\n    }\\n    \\n}\\n\\nclass User {\\n    int userId;\\n    Set<Integer> following;\\n    Queue<Tweet> tweets;\\n    \\n    public User(int userId) {\\n        this.userId = userId;\\n        this.following = new HashSet<>();\\n        this.tweets = new PriorityQueue<>((a,b) -> (a.timestamp - b.timestamp));\\n    }\\n    \\n    public int hashCode() {\\n        return Objects.hash(userId);\\n    }\\n    \\n    // public int compareTo(Object u1) {\\n    //     User other = (User) u1;\\n    //     return Integer.compare(this.userId, other.userId);\\n    // }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int userId;\\n    int timestamp;\\n    \\n    public Tweet(int tweetId, int userId, int timestamp) {\\n        this.tweetId = tweetId;\\n        this.userId = userId;\\n        this.timestamp = timestamp;\\n    }\\n    \\n    public int hashCode() {\\n        return Objects.hash(tweetId);\\n    }\\n    \\n    // public int compareTo(Object t1) {\\n    //     Tweet other = (Tweet) t1;\\n    //     return Integer.compare(this.timestamp, other.timestamp);\\n    // }\\n}\\n\\n\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\n\\n    Map<Integer, User> users;\\n    int timestamp;\\n    \\n    public Twitter() {\\n        users = new HashMap<>();\\n        timestamp = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        User u = getUser(userId);\\n        Tweet t = new Tweet(tweetId, userId, ++timestamp);\\n        \\n        Queue<Tweet> userTweets = u.tweets;\\n        userTweets.offer(t);\\n        if (userTweets.size() >= 11) {\\n            userTweets.poll();\\n        }\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        User u = getUser(userId);\\n        Queue<Tweet> userTweets = new PriorityQueue<>((a,b) -> (a.timestamp - b.timestamp));\\n        userTweets.addAll(u.tweets);\\n        \\n        Set<Integer> usersFollowed = u.following;\\n        \\n        for (Integer userFollowed: usersFollowed) {\\n            Queue<Tweet> followedUserTweets = getUser(userFollowed).tweets;\\n            \\n            Iterator<Tweet> iter = followedUserTweets.iterator();\\n            while (iter.hasNext()) {\\n                userTweets.offer(iter.next());\\n                if (userTweets.size() >= 11) {\\n                    userTweets.poll();\\n                }\\n            }   \\n            \\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        while (userTweets.size() >= 1) {\\n            res.add(0,userTweets.poll().tweetId);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        User u = getUser(followerId);\\n        Set<Integer> followingList = u.following;\\n        followingList.add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        User u = getUser(followerId);\\n        Set<Integer> followingList = u.following;\\n        \\n        followingList.remove(followeeId);\\n    }\\n    \\n    User getUser(int userId) {\\n        if (!users.containsKey(userId)) {\\n            users.put(userId, new User(userId));\\n        }\\n        return users.get(userId);\\n    }\\n    \\n}\\n\\nclass User {\\n    int userId;\\n    Set<Integer> following;\\n    Queue<Tweet> tweets;\\n    \\n    public User(int userId) {\\n        this.userId = userId;\\n        this.following = new HashSet<>();\\n        this.tweets = new PriorityQueue<>((a,b) -> (a.timestamp - b.timestamp));\\n    }\\n    \\n    public int hashCode() {\\n        return Objects.hash(userId);\\n    }\\n    \\n    // public int compareTo(Object u1) {\\n    //     User other = (User) u1;\\n    //     return Integer.compare(this.userId, other.userId);\\n    // }\\n}\\n\\nclass Tweet {\\n    int tweetId;\\n    int userId;\\n    int timestamp;\\n    \\n    public Tweet(int tweetId, int userId, int timestamp) {\\n        this.tweetId = tweetId;\\n        this.userId = userId;\\n        this.timestamp = timestamp;\\n    }\\n    \\n    public int hashCode() {\\n        return Objects.hash(tweetId);\\n    }\\n    \\n    // public int compareTo(Object t1) {\\n    //     Tweet other = (Tweet) t1;\\n    //     return Integer.compare(this.timestamp, other.timestamp);\\n    // }\\n}\\n\\n\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170265,
                "title": "c-simple-implementation",
                "content": "```\\nclass Twitter {\\n\\npublic:\\n    unordered_map<int,unordered_set<int>>friends;\\n    int cnt;\\n    priority_queue<vector<int>>newsfeed;\\n    Twitter() {\\n        cnt=0;\\n        newsfeed=priority_queue<vector<int>>();\\n        friends.clear();\\n    }\\n    void postTweet(int userId, int tweetId) {\\n        newsfeed.push({cnt++,tweetId,userId});\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<vector<int>>pq=this->newsfeed;\\n        vector<int>ans;\\n        int i=0;\\n        while(i<10 and !pq.empty()){\\n            auto tp=pq.top();pq.pop();\\n            if(tp[2]==userId || friends[userId].count(tp[2])){\\n                ans.push_back(tp[1]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Twitter {\\n\\npublic:\\n    unordered_map<int,unordered_set<int>>friends;\\n    int cnt;\\n    priority_queue<vector<int>>newsfeed;\\n    Twitter() {\\n        cnt=0;\\n        newsfeed=priority_queue<vector<int>>();\\n        friends.clear();\\n    }\\n    void postTweet(int userId, int tweetId) {\\n        newsfeed.push({cnt++,tweetId,userId});\\n    }\\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<vector<int>>pq=this->newsfeed;\\n        vector<int>ans;\\n        int i=0;\\n        while(i<10 and !pq.empty()){\\n            auto tp=pq.top();pq.pop();\\n            if(tp[2]==userId || friends[userId].count(tp[2])){\\n                ans.push_back(tp[1]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n    void follow(int followerId, int followeeId) {\\n        friends[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167026,
                "title": "simple-python-two-approaches-sort-naively-or-heapify",
                "content": "```py\\n# assign a timestamp to tweets and sort the tweets naively when you get feed \\nclass Twitter:\\n\\n    def __init__(self):\\n        self.user_to_tweets_map = collections.defaultdict(list) # userId -> list of [tweetIds]\\n        self.follower_to_followee_map = collections.defaultdict(set)  # userId -> set of followeeId\\n        self.timestamp = 0\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_to_tweets_map[userId].append((self.timestamp, tweetId))\\n        self.timestamp += 1\\n\\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n        tweet_candidates = self.user_to_tweets_map[user_id][::]\\n        for followee_id in self.follower_to_followee_map[user_id]:\\n            tweet_candidates.extend(self.user_to_tweets_map[followee_id]) \\n        \\n        tweet_candidates.sort(reverse=True) # most recent to least recent\\n        return [tweetId for timestamp, tweetId in tweet_candidates[:10]]\\n        \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].add(followee_id)\\n        \\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].discard(followee_id)\\n```\\n\\n```py\\n# Use a heap to get most recent tweets. Python doesn\\'t have max_heap so negate the timestamps and use min_heap\\nmin_heap[0] gives the lowest timestamp. Timestamps go to negative, so most timestamp is the most negative one, i.e lowest value. min_heap[0] gives most recent timestamp.\\nclass Twitter2:\\n\\n    def __init__(self):\\n        self.user_to_tweets_map = collections.defaultdict(list) # userId -> list of (timestamp, tweetIds)\\n        self.follower_to_followee_map = collections.defaultdict(set)  # userId -> set of followeeId\\n        self.timestamp = 0\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_to_tweets_map[userId].append((self.timestamp, tweetId))\\n        self.timestamp -= 1\\n\\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n        news = []\\n        min_heap = [] # index 0 will give lowest timestamp, i.e. most recent tweet, because timestamp goies to negative\\n        for f_id in self.follower_to_followee_map[user_id] | {user_id}:\\n            if f_id in self.user_to_tweets_map: # has tweeted\\n                min_heap.extend(self.user_to_tweets_map[f_id])\\n                \\n        heapq.heapify(min_heap)\\n        while min_heap and len(news) < 10:\\n            timestamp, tweet_id = heapq.heappop(min_heap)\\n            news.append(tweet_id)\\n        return news\\n    \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].add(followee_id)\\n        \\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].discard(followee_id)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\n# assign a timestamp to tweets and sort the tweets naively when you get feed \\nclass Twitter:\\n\\n    def __init__(self):\\n        self.user_to_tweets_map = collections.defaultdict(list) # userId -> list of [tweetIds]\\n        self.follower_to_followee_map = collections.defaultdict(set)  # userId -> set of followeeId\\n        self.timestamp = 0\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_to_tweets_map[userId].append((self.timestamp, tweetId))\\n        self.timestamp += 1\\n\\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n        tweet_candidates = self.user_to_tweets_map[user_id][::]\\n        for followee_id in self.follower_to_followee_map[user_id]:\\n            tweet_candidates.extend(self.user_to_tweets_map[followee_id]) \\n        \\n        tweet_candidates.sort(reverse=True) # most recent to least recent\\n        return [tweetId for timestamp, tweetId in tweet_candidates[:10]]\\n        \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].add(followee_id)\\n        \\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].discard(followee_id)\\n```\n```py\\n# Use a heap to get most recent tweets. Python doesn\\'t have max_heap so negate the timestamps and use min_heap\\nmin_heap[0] gives the lowest timestamp. Timestamps go to negative, so most timestamp is the most negative one, i.e lowest value. min_heap[0] gives most recent timestamp.\\nclass Twitter2:\\n\\n    def __init__(self):\\n        self.user_to_tweets_map = collections.defaultdict(list) # userId -> list of (timestamp, tweetIds)\\n        self.follower_to_followee_map = collections.defaultdict(set)  # userId -> set of followeeId\\n        self.timestamp = 0\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_to_tweets_map[userId].append((self.timestamp, tweetId))\\n        self.timestamp -= 1\\n\\n    def getNewsFeed(self, user_id: int) -> List[int]:\\n        news = []\\n        min_heap = [] # index 0 will give lowest timestamp, i.e. most recent tweet, because timestamp goies to negative\\n        for f_id in self.follower_to_followee_map[user_id] | {user_id}:\\n            if f_id in self.user_to_tweets_map: # has tweeted\\n                min_heap.extend(self.user_to_tweets_map[f_id])\\n                \\n        heapq.heapify(min_heap)\\n        while min_heap and len(news) < 10:\\n            timestamp, tweet_id = heapq.heappop(min_heap)\\n            news.append(tweet_id)\\n        return news\\n    \\n    def follow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].add(followee_id)\\n        \\n    def unfollow(self, follower_id: int, followee_id: int) -> None:\\n        self.follower_to_followee_map[follower_id].discard(followee_id)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166485,
                "title": "c-unordered-map-vectors-faster-then-100-easy-solution",
                "content": "class Twitter {\\npublic:\\n\\n    vector<pair<int, int>> posts;\\n    unordered_map<int, unordered_map<int, int >> mp;\\n    Twitter()   {}\\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back({userId, tweetId});    \\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int cnt = 0;\\n        int n = posts.size();\\n        for(int i = n-1; i>=0; i--){\\n            if(cnt==10) break;\\n            int usr = posts[i].first;\\n            int twt = posts[i].second;\\n            if(userId == usr or mp[userId][usr]==1){\\n                feed.push_back(twt);\\n                cnt++;\\n            }\\n        }\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId][followeeId] = 1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId][followeeId] = 0;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Twitter {\\npublic:\\n\\n    vector<pair<int, int>> posts;\\n    unordered_map<int, unordered_map<int, int >> mp;\\n    Twitter()   {}\\n    void postTweet(int userId, int tweetId) {\\n        posts.push_back({userId, tweetId});    \\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feed;\\n        int cnt = 0;\\n        int n = posts.size();\\n        for(int i = n-1; i>=0; i--){\\n            if(cnt==10) break;\\n            int usr = posts[i].first;\\n            int twt = posts[i].second;\\n            if(userId == usr or mp[userId][usr]==1){\\n                feed.push_back(twt);\\n                cnt++;\\n            }\\n        }\\n        return feed;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId][followeeId] = 1;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        mp[followerId][followeeId] = 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2156538,
                "title": "python-design-twitter",
                "content": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.counter = 0\\n        self.tweets = collections.defaultdict(list)\\n        self.tweets_counter = collections.defaultdict(int)\\n        self.followers_list = collections.defaultdict(list)\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.counter += 1\\n        self.tweets_counter[tweetId] = self.counter\\n        self.tweets[userId].append(tweetId)\\n        \\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        userlist = [userId] + self.followers_list[userId]\\n        tweetslist= []\\n        tweetssorted = []\\n        \\n        for user in userlist:\\n            tweetslist.extend(self.tweets[user])\\n        \\n        unique_tweets = set()\\n        for tweet in tweetslist:\\n            if tweet not in unique_tweets:\\n                tweetssorted.append((tweet, self.tweets_counter[tweet]))\\n                unique_tweets.add(tweet)\\n        \\n        tweetssorted = sorted(tweetssorted, key=lambda x: x[1], reverse=True)\\n        return [x[0] for x in tweetssorted][:10] \\n            \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followers_list[followerId].append(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followers_list[followerId]:\\n            self.followers_list[followerId].remove(followeeId)\\n        \\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.counter = 0\\n        self.tweets = collections.defaultdict(list)\\n        self.tweets_counter = collections.defaultdict(int)\\n        self.followers_list = collections.defaultdict(list)\\n        \\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.counter += 1\\n        self.tweets_counter[tweetId] = self.counter\\n        self.tweets[userId].append(tweetId)\\n        \\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        userlist = [userId] + self.followers_list[userId]\\n        tweetslist= []\\n        tweetssorted = []\\n        \\n        for user in userlist:\\n            tweetslist.extend(self.tweets[user])\\n        \\n        unique_tweets = set()\\n        for tweet in tweetslist:\\n            if tweet not in unique_tweets:\\n                tweetssorted.append((tweet, self.tweets_counter[tweet]))\\n                unique_tweets.add(tweet)\\n        \\n        tweetssorted = sorted(tweetssorted, key=lambda x: x[1], reverse=True)\\n        return [x[0] for x in tweetssorted][:10] \\n            \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.followers_list[followerId].append(followeeId)\\n        \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.followers_list[followerId]:\\n            self.followers_list[followerId].remove(followeeId)\\n        \\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152740,
                "title": "0-ms-and-faster-than-100-c-solution",
                "content": "```\\nclass Twitter {\\npublic:\\n    priority_queue<pair<int,pair<int,int>>> pq;   // it stores  <id , <userId,tweetId>>\\n    unordered_map<int,vector<int>> mp;  // hashmap for storing userId and corresponding vector of followeeIds\\n    int id;\\n    Twitter() {\\n        id = 1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({id,{userId,tweetId}});\\n        id++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feeds;\\n        int k = 10;\\n        vector<pair<int,pair<int,int>>> extracted;  // it stored removed tweets while poping from pq\\n        \\n        while(!pq.empty() and k){\\n            extracted.push_back(pq.top());\\n\\t\\t\\t\\n\\t\\t\\t// checking whether pq.top() is tweeted by user\\'s followees\\n            if(find(mp[userId].begin(),mp[userId].end(),pq.top().second.first)!=mp[userId].end()){\\n                feeds.push_back(pq.top().second.second);\\n                k--;\\n            }\\n\\t\\t\\t// else checking whether pq.top() is tweeted by user itself\\n\\t\\t\\telse if(pq.top().second.first==userId){\\n                feeds.push_back(pq.top().second.second);\\n                k--;\\n            }\\n            pq.pop();\\n        }\\n        \\n\\t\\t// again inserting tweets that are popped and stored in extracted vector\\n        for(auto p:extracted){\\n            pq.push(p);\\n        }\\n        \\n        return feeds;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        auto it = find(mp[followerId].begin(),mp[followerId].end(),followeeId);\\n        if(it!=mp[followerId].end()){\\n            mp[followerId].erase(it);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\npublic:\\n    priority_queue<pair<int,pair<int,int>>> pq;   // it stores  <id , <userId,tweetId>>\\n    unordered_map<int,vector<int>> mp;  // hashmap for storing userId and corresponding vector of followeeIds\\n    int id;\\n    Twitter() {\\n        id = 1;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        pq.push({id,{userId,tweetId}});\\n        id++;\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> feeds;\\n        int k = 10;\\n        vector<pair<int,pair<int,int>>> extracted;  // it stored removed tweets while poping from pq\\n        \\n        while(!pq.empty() and k){\\n            extracted.push_back(pq.top());\\n\\t\\t\\t\\n\\t\\t\\t// checking whether pq.top() is tweeted by user\\'s followees\\n            if(find(mp[userId].begin(),mp[userId].end(),pq.top().second.first)!=mp[userId].end()){\\n                feeds.push_back(pq.top().second.second);\\n                k--;\\n            }\\n\\t\\t\\t// else checking whether pq.top() is tweeted by user itself\\n\\t\\t\\telse if(pq.top().second.first==userId){\\n                feeds.push_back(pq.top().second.second);\\n                k--;\\n            }\\n            pq.pop();\\n        }\\n        \\n\\t\\t// again inserting tweets that are popped and stored in extracted vector\\n        for(auto p:extracted){\\n            pq.push(p);\\n        }\\n        \\n        return feeds;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        mp[followerId].push_back(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        auto it = find(mp[followerId].begin(),mp[followerId].end(),followeeId);\\n        if(it!=mp[followerId].end()){\\n            mp[followerId].erase(it);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140633,
                "title": "go-clear-solution",
                "content": "```\\ntype TweetHeap []*Tweet\\n\\nfunc (h TweetHeap) Len() int           { return len(h) }\\nfunc (h TweetHeap) Less(i, j int) bool { return h[i].at > h[j].at }\\nfunc (h TweetHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *TweetHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(*Tweet))\\n}\\n\\nfunc (h *TweetHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype Tweet struct {\\n    id      int\\n    at      int\\n    next    *Tweet\\n}\\n\\ntype Twitter struct {\\n    follows     map[int]map[int]bool\\n    tweets      map[int]*Tweet\\n    time        int\\n}\\n\\nfunc Constructor() Twitter {\\n    return Twitter{map[int]map[int]bool{}, map[int]*Tweet{}, 0}\\n}\\n\\nfunc (t *Twitter) PostTweet(userId int, tweetId int) {\\n    t.tweets[userId] = &Tweet{tweetId, t.time, t.tweets[userId]}\\n    t.time++\\n}\\n\\nfunc (t *Twitter) GetNewsFeed(userId int) []int {\\n    tweets := TweetHeap{}\\n    \\n    if t.tweets[userId] != nil { heap.Push(&tweets, t.tweets[userId]) }\\n    for following := range t.follows[userId] {\\n        if t.tweets[following] != nil { heap.Push(&tweets, t.tweets[following]) }\\n    }\\n    \\n    feed := []int{}\\n    for len(feed) < 10 && len(tweets) > 0 {\\n        mostRecent := heap.Pop(&tweets).(*Tweet)\\n        if mostRecent.next != nil { heap.Push(&tweets, mostRecent.next) }\\n        feed = append(feed, mostRecent.id)\\n    }\\n    return feed\\n}\\n\\nfunc (t *Twitter) Follow(followerId int, followeeId int)  {\\n    if t.follows[followerId] == nil { t.follows[followerId] = make(map[int]bool) }\\n    t.follows[followerId][followeeId] = true\\n}\\n\\nfunc (t *Twitter) Unfollow(followerId int, followeeId int)  {\\n    if t.follows[followerId] == nil { t.follows[followerId] = make(map[int]bool) }\\n    delete(t.follows[followerId], followeeId)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype TweetHeap []*Tweet\\n\\nfunc (h TweetHeap) Len() int           { return len(h) }\\nfunc (h TweetHeap) Less(i, j int) bool { return h[i].at > h[j].at }\\nfunc (h TweetHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *TweetHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(*Tweet))\\n}\\n\\nfunc (h *TweetHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype Tweet struct {\\n    id      int\\n    at      int\\n    next    *Tweet\\n}\\n\\ntype Twitter struct {\\n    follows     map[int]map[int]bool\\n    tweets      map[int]*Tweet\\n    time        int\\n}\\n\\nfunc Constructor() Twitter {\\n    return Twitter{map[int]map[int]bool{}, map[int]*Tweet{}, 0}\\n}\\n\\nfunc (t *Twitter) PostTweet(userId int, tweetId int) {\\n    t.tweets[userId] = &Tweet{tweetId, t.time, t.tweets[userId]}\\n    t.time++\\n}\\n\\nfunc (t *Twitter) GetNewsFeed(userId int) []int {\\n    tweets := TweetHeap{}\\n    \\n    if t.tweets[userId] != nil { heap.Push(&tweets, t.tweets[userId]) }\\n    for following := range t.follows[userId] {\\n        if t.tweets[following] != nil { heap.Push(&tweets, t.tweets[following]) }\\n    }\\n    \\n    feed := []int{}\\n    for len(feed) < 10 && len(tweets) > 0 {\\n        mostRecent := heap.Pop(&tweets).(*Tweet)\\n        if mostRecent.next != nil { heap.Push(&tweets, mostRecent.next) }\\n        feed = append(feed, mostRecent.id)\\n    }\\n    return feed\\n}\\n\\nfunc (t *Twitter) Follow(followerId int, followeeId int)  {\\n    if t.follows[followerId] == nil { t.follows[followerId] = make(map[int]bool) }\\n    t.follows[followerId][followeeId] = true\\n}\\n\\nfunc (t *Twitter) Unfollow(followerId int, followeeId int)  {\\n    if t.follows[followerId] == nil { t.follows[followerId] = make(map[int]bool) }\\n    delete(t.follows[followerId], followeeId)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079610,
                "title": "rust",
                "content": "```rust\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Twitter {\\n    tweets: Vec<(i32, i32)>,\\n    users: HashMap<i32, HashSet<i32>>,\\n}\\n\\nimpl Twitter {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\\n        self.tweets.push((user_id, tweet_id));\\n    }\\n\\n    fn get_news_feed(&self, user_id: i32) -> Vec<i32> {\\n        let mut res = vec![];\\n        for &(u, t) in self.tweets.iter().rev() {\\n            if res.len() == 10 {\\n                break;\\n            }\\n            if u == user_id {\\n                res.push(t);\\n            } else if let Some(follows) = self.users.get(&user_id) {\\n                if follows.contains(&u) {\\n                    res.push(t);\\n                }\\n            }\\n        }\\n        res\\n    }\\n\\n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.users\\n            .entry(follower_id)\\n            .or_insert_with(HashSet::new)\\n            .insert(followee_id);\\n    }\\n\\n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.users\\n            .entry(follower_id)\\n            .or_insert_with(HashSet::new)\\n            .remove(&followee_id);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\n#[derive(Default)]\\nstruct Twitter {\\n    tweets: Vec<(i32, i32)>,\\n    users: HashMap<i32, HashSet<i32>>,\\n}\\n\\nimpl Twitter {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\\n        self.tweets.push((user_id, tweet_id));\\n    }\\n\\n    fn get_news_feed(&self, user_id: i32) -> Vec<i32> {\\n        let mut res = vec![];\\n        for &(u, t) in self.tweets.iter().rev() {\\n            if res.len() == 10 {\\n                break;\\n            }\\n            if u == user_id {\\n                res.push(t);\\n            } else if let Some(follows) = self.users.get(&user_id) {\\n                if follows.contains(&u) {\\n                    res.push(t);\\n                }\\n            }\\n        }\\n        res\\n    }\\n\\n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.users\\n            .entry(follower_id)\\n            .or_insert_with(HashSet::new)\\n            .insert(followee_id);\\n    }\\n\\n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\\n        self.users\\n            .entry(follower_id)\\n            .or_insert_with(HashSet::new)\\n            .remove(&followee_id);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067140,
                "title": "easy-and-intuitive-java-heap-solution-with-comments",
                "content": "```\\nclass Twitter {\\n\\n  Map < Integer, Set < Integer >> followMap;\\n\\t\\n  // key: useId | value:  tweet id and timestamp\\n  Map < Integer, Queue < int[] >> tweetMap;\\n\\n  int size;\\n\\n  int timestamp;\\n\\n  public Twitter() {\\n    this.followMap = new HashMap < Integer, Set < Integer >> ();\\n    this.tweetMap = new HashMap < Integer, Queue < int[] >> ();\\n    this.size = 10;\\n    this.timestamp = 0;\\n  }\\n\\n  public void postTweet(int userId, int tweetId) {\\n    Queue < int[] > queue = tweetMap.getOrDefault(userId, new LinkedList < int[] > ());\\n    queue.offer(new int[] {\\n      tweetId,\\n      timestamp++\\n    });\\n    // only recent 10 tweets are needed\\n    if (queue.size() > size) {\\n      queue.poll();\\n    }\\n    tweetMap.put(userId, queue);\\n  }\\n\\n  public List < Integer > getNewsFeed(int userId) {\\n    // retrive users that we are following\\n    Set < Integer > following = followMap.getOrDefault(userId, new HashSet < Integer > ());\\n    following.add(userId);\\n    \\n    // create a min heap. Top 10 tweets with larger timestamp will be in the heap\\n    Queue < int[] > minHeap = new PriorityQueue < int[] > (size, (a, b) -> a[1] - b[1]);\\n    for (Integer followingUserId: following) {\\n      Queue < int[] > tweets = tweetMap.getOrDefault(followingUserId, new LinkedList < int[] > ());\\n      minHeap.addAll(tweets);\\n      while (minHeap.size() > size) {\\n        minHeap.poll();\\n      }\\n    }\\n      \\n    // let most recent tweet show first\\n    List < Integer > res = new ArrayList < > ();\\n    while (minHeap.size() > 0) res.add(minHeap.poll()[0]);\\n    Collections.reverse(res);\\n    return res;\\n\\n  }\\n\\n  public void follow(int followerId, int followeeId) {\\n    Set < Integer > following = followMap.getOrDefault(followerId, new HashSet < Integer > ());\\n    following.add(followeeId);\\n    followMap.put(followerId, following);\\n  }\\n\\n  public void unfollow(int followerId, int followeeId) {\\n    Set < Integer > following = followMap.getOrDefault(followerId, new HashSet < Integer > ());\\n    following.remove(followeeId);\\n    followMap.put(followerId, following);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Twitter {\\n\\n  Map < Integer, Set < Integer >> followMap;\\n\\t\\n  // key: useId | value:  tweet id and timestamp\\n  Map < Integer, Queue < int[] >> tweetMap;\\n\\n  int size;\\n\\n  int timestamp;\\n\\n  public Twitter() {\\n    this.followMap = new HashMap < Integer, Set < Integer >> ();\\n    this.tweetMap = new HashMap < Integer, Queue < int[] >> ();\\n    this.size = 10;\\n    this.timestamp = 0;\\n  }\\n\\n  public void postTweet(int userId, int tweetId) {\\n    Queue < int[] > queue = tweetMap.getOrDefault(userId, new LinkedList < int[] > ());\\n    queue.offer(new int[] {\\n      tweetId,\\n      timestamp++\\n    });\\n    // only recent 10 tweets are needed\\n    if (queue.size() > size) {\\n      queue.poll();\\n    }\\n    tweetMap.put(userId, queue);\\n  }\\n\\n  public List < Integer > getNewsFeed(int userId) {\\n    // retrive users that we are following\\n    Set < Integer > following = followMap.getOrDefault(userId, new HashSet < Integer > ());\\n    following.add(userId);\\n    \\n    // create a min heap. Top 10 tweets with larger timestamp will be in the heap\\n    Queue < int[] > minHeap = new PriorityQueue < int[] > (size, (a, b) -> a[1] - b[1]);\\n    for (Integer followingUserId: following) {\\n      Queue < int[] > tweets = tweetMap.getOrDefault(followingUserId, new LinkedList < int[] > ());\\n      minHeap.addAll(tweets);\\n      while (minHeap.size() > size) {\\n        minHeap.poll();\\n      }\\n    }\\n      \\n    // let most recent tweet show first\\n    List < Integer > res = new ArrayList < > ();\\n    while (minHeap.size() > 0) res.add(minHeap.poll()[0]);\\n    Collections.reverse(res);\\n    return res;\\n\\n  }\\n\\n  public void follow(int followerId, int followeeId) {\\n    Set < Integer > following = followMap.getOrDefault(followerId, new HashSet < Integer > ());\\n    following.add(followeeId);\\n    followMap.put(followerId, following);\\n  }\\n\\n  public void unfollow(int followerId, int followeeId) {\\n    Set < Integer > following = followMap.getOrDefault(followerId, new HashSet < Integer > ());\\n    following.remove(followeeId);\\n    followMap.put(followerId, following);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001261,
                "title": "python-multiple-hashmap-solution",
                "content": "```\\nimport collections\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.user_tweets = collections.defaultdict(list)\\n        self.user_following = collections.defaultdict(list)\\n        self.all_tweets = []\\n        \\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_tweets[userId].append(tweetId)\\n        self.all_tweets.append([tweetId, userId])\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        connected_user_id = [userId] + self.user_following[userId]\\n        for x in self.all_tweets[::-1]:\\n            if x[1] in connected_user_id:\\n                res.append(x[0])\\n            if len(res) == 10:\\n                return res\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.user_following[followerId].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.user_following[followerId]:\\n            self.user_following[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.user_tweets = collections.defaultdict(list)\\n        self.user_following = collections.defaultdict(list)\\n        self.all_tweets = []\\n        \\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.user_tweets[userId].append(tweetId)\\n        self.all_tweets.append([tweetId, userId])\\n        \\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res = []\\n        connected_user_id = [userId] + self.user_following[userId]\\n        for x in self.all_tweets[::-1]:\\n            if x[1] in connected_user_id:\\n                res.append(x[0])\\n            if len(res) == 10:\\n                return res\\n        return res\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.user_following[followerId].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.user_following[followerId]:\\n            self.user_following[followerId].remove(followeeId)\\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981497,
                "title": "python-3-solution-with-approach-design-twitter",
                "content": "**Approach :**\\n1. Initialized a huge dictionary with key and values as follows:\\n\\t```\\n\\tusers = { userId1 : { \"Tweets\" : [ TweetId1 , TweetId2, ... ] ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"Following\" : [ userId1 , userId2 , userId3 , .... ]\\n\\t\\t\\t\\t\\t    } ,\\n\\t          userId2 : { \"Tweets\" : [ TweetId1 , TweetId2, TweetId3 ... ] ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"Following\" : [ userId1 , userId2 , .... ]\\n\\t\\t\\t\\t\\t    }\\t \\n\\t\\t    }\\n\\t```\\n2. To keep track of the time of all the tweets, we use a variable \"Time\" which gets updated everytime a new tweet is uploaded.\\n3. Repeatedly following a user, Unfollowing a user who you haven\\'t followed & limiting the number of Tweets (to 10) to display cases are handled.\\n\\n**Code :**\\n```\\nfrom collections import defaultdict\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.Time = 0  \\n        self.users = defaultdict(dict)\\n    \\n    def getTime(self) -> int:\\n        self.Time += 1\\n        return 1000000000 - self.Time + 1\\n    \\n    def newUser(self,userId) -> None:\\n        if self.users.get(userId):\\n            return\\n        self.users[userId][\"Tweets\"] = []\\n        self.users[userId][\"Following\"] = [userId]\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.newUser(userId)\\n        self.users[userId][\"Tweets\"].append([self.getTime(),tweetId])\\n                \\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.newUser(userId)\\n        tweets = []\\n        for user in self.users[userId][\"Following\"]:\\n            tweets.extend(self.users[user][\"Tweets\"])\\n        tweets.sort()\\n        n = len(tweets)\\n        if n>=10:n = 10\\n        return [tweets[i][1] for i in range(n)]\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.newUser(followerId)\\n        self.newUser(followeeId)\\n        if followeeId not in self.users[followerId][\"Following\"]:\\n            self.users[followerId][\"Following\"].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.newUser(followerId)\\n        self.newUser(followeeId)\\n        if followeeId in self.users[followerId][\"Following\"]:\\n            self.users[followerId][\"Following\"].remove(followeeId)\\n```",
                "solutionTags": [
                    "Design"
                ],
                "code": "```\\n\\tusers = { userId1 : { \"Tweets\" : [ TweetId1 , TweetId2, ... ] ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"Following\" : [ userId1 , userId2 , userId3 , .... ]\\n\\t\\t\\t\\t\\t    } ,\\n\\t          userId2 : { \"Tweets\" : [ TweetId1 , TweetId2, TweetId3 ... ] ,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\"Following\" : [ userId1 , userId2 , .... ]\\n\\t\\t\\t\\t\\t    }\\t \\n\\t\\t    }\\n\\t```\n```\\nfrom collections import defaultdict\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.Time = 0  \\n        self.users = defaultdict(dict)\\n    \\n    def getTime(self) -> int:\\n        self.Time += 1\\n        return 1000000000 - self.Time + 1\\n    \\n    def newUser(self,userId) -> None:\\n        if self.users.get(userId):\\n            return\\n        self.users[userId][\"Tweets\"] = []\\n        self.users[userId][\"Following\"] = [userId]\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.newUser(userId)\\n        self.users[userId][\"Tweets\"].append([self.getTime(),tweetId])\\n                \\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        self.newUser(userId)\\n        tweets = []\\n        for user in self.users[userId][\"Following\"]:\\n            tweets.extend(self.users[user][\"Tweets\"])\\n        tweets.sort()\\n        n = len(tweets)\\n        if n>=10:n = 10\\n        return [tweets[i][1] for i in range(n)]\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.newUser(followerId)\\n        self.newUser(followeeId)\\n        if followeeId not in self.users[followerId][\"Following\"]:\\n            self.users[followerId][\"Following\"].append(followeeId)\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.newUser(followerId)\\n        self.newUser(followeeId)\\n        if followeeId in self.users[followerId][\"Following\"]:\\n            self.users[followerId][\"Following\"].remove(followeeId)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971858,
                "title": "python-simple-solution-with-dict-and-set-with-explanation",
                "content": "```\\nfrom collections import defaultdict\\n\\n\\nclass Twitter:\\n\\t\\n\\t# store followers like this: {userId: set(followeeId, ...), ...}\\n\\t# twits are stored globally as a list of tuples: (userId, twitId) (stack)\\n    def __init__(self):\\n        self.follow_list = defaultdict(set)\\n        self.twit_storage = []\\n\\t\\n\\t# to post twit we just need to append an element to the global stack\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.twit_storage.append((userId, tweetId))\\n\\n   # firstly construct a set of user\\'s followees ids + user id \\n   # iterate over global twit_storage from the end until we find 10 elements or the storage is over\\n   def getNewsFeed(self, userId: int) -> List[int]:\\n        user_follows = self.follow_list[userId]\\n        user_follows.add(userId)\\n        news = []\\n        i = len(self.twit_storage) - 1\\n        while len(news) < 10 and i >= 0:\\n            if self.twit_storage[i][0] in user_follows:\\n                news.append(self.twit_storage[i][1])\\n            i -= 1\\n\\n        return news\\n\\t\\n\\t# add followeeId to user\\'s set in follow list \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_list[followerId].add(followeeId)\\n\\t\\n\\t# remove followeeId from user\\'s set in follow list \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_list[followerId].discard(followeeId)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Twitter:\\n\\t\\n\\t# store followers like this: {userId: set(followeeId, ...), ...}\\n\\t# twits are stored globally as a list of tuples: (userId, twitId) (stack)\\n    def __init__(self):\\n        self.follow_list = defaultdict(set)\\n        self.twit_storage = []\\n\\t\\n\\t# to post twit we just need to append an element to the global stack\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        self.twit_storage.append((userId, tweetId))\\n\\n   # firstly construct a set of user\\'s followees ids + user id \\n   # iterate over global twit_storage from the end until we find 10 elements or the storage is over\\n   def getNewsFeed(self, userId: int) -> List[int]:\\n        user_follows = self.follow_list[userId]\\n        user_follows.add(userId)\\n        news = []\\n        i = len(self.twit_storage) - 1\\n        while len(news) < 10 and i >= 0:\\n            if self.twit_storage[i][0] in user_follows:\\n                news.append(self.twit_storage[i][1])\\n            i -= 1\\n\\n        return news\\n\\t\\n\\t# add followeeId to user\\'s set in follow list \\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_list[followerId].add(followeeId)\\n\\t\\n\\t# remove followeeId from user\\'s set in follow list \\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        self.follow_list[followerId].discard(followeeId)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958371,
                "title": "c-100-faster-0ms-unordered-map",
                "content": "~~~\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_map<int,int>>m1;\\n    int x;\\n    set<pair<int, pair<int,int>>>s1;\\n    Twitter() {\\n        x = 1;\\n    }\\n    void postTweet(int u, int t) {\\n        s1.insert({x++ , {u, t} });\\n    }\\n    \\n    vector<int> getNewsFeed(int u) {\\n        int k = 10;\\n        vector<int>v;\\n        for(auto it = s1.rbegin(); it!= s1.rend() ; it++)\\n        {\\n            if((it->second.first == u) || (m1[u][it->second.first] == 1))\\n            {\\n                k--;\\n                v.push_back(it->second.second);\\n            }\\n            if(k== 0)\\n                break;\\n        }\\n        return v;\\n    }\\n    \\n    void follow(int f, int F) {   \\n        m1[f][F] = 1; \\n    }\\n    \\n    void unfollow(int f, int F) {\\n        m1[f][F] = 0;\\n    }\\n};\\n\\n~~~",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "~~~\\nclass Twitter {\\npublic:\\n    unordered_map<int,unordered_map<int,int>>m1;\\n    int x;\\n    set<pair<int, pair<int,int>>>s1;\\n    Twitter() {\\n        x = 1;\\n    }\\n    void postTweet(int u, int t) {\\n        s1.insert({x++ , {u, t} });\\n    }\\n    \\n    vector<int> getNewsFeed(int u) {\\n        int k = 10;\\n        vector<int>v;\\n        for(auto it = s1.rbegin(); it!= s1.rend() ; it++)\\n        {\\n            if((it->second.first == u) || (m1[u][it->second.first] == 1))\\n            {\\n                k--;\\n                v.push_back(it->second.second);\\n            }\\n            if(k== 0)\\n                break;\\n        }\\n        return v;\\n    }\\n    \\n    void follow(int f, int F) {   \\n        m1[f][F] = 1; \\n    }\\n    \\n    void unfollow(int f, int F) {\\n        m1[f][F] = 0;\\n    }\\n};\\n\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1932452,
                "title": "design-twitter-java-ooad",
                "content": "```\\nclass Twitter {\\n\\n    private Map<Integer,Set<Integer>> followersToFolloweeMap;\\n    private Map<Integer,List<Tweet>> userToPostsMap;\\n    private final Integer postLimit = 10;\\n    private int timePool = 0;\\n    \\n    private class Tweet {\\n        int userId;\\n        int tweetId;\\n        int time;\\n        public Tweet(int userId, int tweetId){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n            time = timePool++;\\n        }\\n    }\\n    \\n    public Twitter() {\\n        followersToFolloweeMap = new  HashMap<Integer,Set<Integer>>();\\n        userToPostsMap =new HashMap<Integer,List<Tweet>>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n          Tweet curTweet = new Tweet(userId, tweetId);\\n          userToPostsMap.putIfAbsent(userId, new ArrayList<Tweet>());\\n          userToPostsMap.get(userId).add(curTweet);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n          PriorityQueue<Tweet> q = new PriorityQueue<>((a,b) -> {return b.time -a.time;});\\n          List<Integer> recentTweets = new ArrayList<Integer>();\\n          int idx=0;\\n          // put my tweets\\n         if(userToPostsMap.containsKey(userId)){\\n            for(Tweet post:userToPostsMap.get(userId)) {\\n                q.offer(post);\\n            }\\n         }\\n        // put my followers tweets.\\n        if(followersToFolloweeMap.containsKey(userId)) {\\n            \\n            for(Integer followers : followersToFolloweeMap.get(userId)) {\\n                if(userToPostsMap.containsKey(followers)) { // this follower has posts\\n                    for(Tweet post:userToPostsMap.get(followers)) {\\n                        q.offer(post);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        while(idx<postLimit && !q.isEmpty()) {\\n            recentTweets.add(q.poll().tweetId);\\n            idx++;\\n        }\\n        \\n        return recentTweets;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        followersToFolloweeMap.putIfAbsent(followerId, new LinkedHashSet<>());\\n        followersToFolloweeMap.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n         if(followersToFolloweeMap.containsKey(followerId)){\\n            Set<Integer> followList = followersToFolloweeMap.get(followerId);\\n            followList.remove(followeeId);\\n         }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\n\\n    private Map<Integer,Set<Integer>> followersToFolloweeMap;\\n    private Map<Integer,List<Tweet>> userToPostsMap;\\n    private final Integer postLimit = 10;\\n    private int timePool = 0;\\n    \\n    private class Tweet {\\n        int userId;\\n        int tweetId;\\n        int time;\\n        public Tweet(int userId, int tweetId){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n            time = timePool++;\\n        }\\n    }\\n    \\n    public Twitter() {\\n        followersToFolloweeMap = new  HashMap<Integer,Set<Integer>>();\\n        userToPostsMap =new HashMap<Integer,List<Tweet>>();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n          Tweet curTweet = new Tweet(userId, tweetId);\\n          userToPostsMap.putIfAbsent(userId, new ArrayList<Tweet>());\\n          userToPostsMap.get(userId).add(curTweet);\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n          PriorityQueue<Tweet> q = new PriorityQueue<>((a,b) -> {return b.time -a.time;});\\n          List<Integer> recentTweets = new ArrayList<Integer>();\\n          int idx=0;\\n          // put my tweets\\n         if(userToPostsMap.containsKey(userId)){\\n            for(Tweet post:userToPostsMap.get(userId)) {\\n                q.offer(post);\\n            }\\n         }\\n        // put my followers tweets.\\n        if(followersToFolloweeMap.containsKey(userId)) {\\n            \\n            for(Integer followers : followersToFolloweeMap.get(userId)) {\\n                if(userToPostsMap.containsKey(followers)) { // this follower has posts\\n                    for(Tweet post:userToPostsMap.get(followers)) {\\n                        q.offer(post);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        while(idx<postLimit && !q.isEmpty()) {\\n            recentTweets.add(q.poll().tweetId);\\n            idx++;\\n        }\\n        \\n        return recentTweets;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        followersToFolloweeMap.putIfAbsent(followerId, new LinkedHashSet<>());\\n        followersToFolloweeMap.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        \\n         if(followersToFolloweeMap.containsKey(followerId)){\\n            Set<Integer> followList = followersToFolloweeMap.get(followerId);\\n            followList.remove(followeeId);\\n         }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929331,
                "title": "java-clean-ooa-d",
                "content": "```java\\n class Twitter {\\n        Map<Integer, Set<Integer>> followMap;\\n        Map<Integer, List<Integer>> tweetMap;\\n        Map<Integer, Integer> tweetTimeMap;\\n        AtomicInteger timestamp; // You can switch to int for the purpose of the question, i am using it for fun to mimic real world concurrency scenario\\n\\n        public Twitter() {\\n            this.followMap = new ConcurrentHashMap<>();\\n            this.tweetMap = new ConcurrentHashMap<>();\\n            this.tweetTimeMap = new ConcurrentHashMap<>();\\n            this.timestamp = new AtomicInteger(0);\\n        }\\n\\n        public void postTweet(int userId, int tweetId) {\\n            List<Integer> tweets = this.tweetMap.getOrDefault(userId, new ArrayList<>());\\n            tweets.add(tweetId);\\n            this.tweetMap.put(userId, tweets);\\n            this.tweetTimeMap.put(tweetId, this.timestamp.incrementAndGet());\\n        }\\n\\n        public List<Integer> getNewsFeed(int userId) {\\n            Set<Integer> followers = this.followMap.getOrDefault(userId, new HashSet<>());\\n            followers.add(userId);\\n            return followers.stream()\\n                    .flatMap(f -> this.tweetMap.getOrDefault(f, new ArrayList<>()).stream())\\n                    .sorted(Comparator.comparingInt(this.tweetTimeMap::get).reversed())\\n                    .limit(10)\\n                    .collect(Collectors.toList());\\n        }\\n\\n        public void follow(int followerId, int followeeId) {\\n            Set<Integer> followees = this.followMap.getOrDefault(followerId, new HashSet<>());\\n            followees.add(followeeId);\\n            this.followMap.put(followerId, followees);\\n        }\\n\\n        public void unfollow(int followerId, int followeeId) {\\n            if (this.followMap.containsKey(followerId)) {\\n                this.followMap.get(followerId).remove(followeeId);\\n            }\\n        }\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```java\\n class Twitter {\\n        Map<Integer, Set<Integer>> followMap;\\n        Map<Integer, List<Integer>> tweetMap;\\n        Map<Integer, Integer> tweetTimeMap;\\n        AtomicInteger timestamp; // You can switch to int for the purpose of the question, i am using it for fun to mimic real world concurrency scenario\\n\\n        public Twitter() {\\n            this.followMap = new ConcurrentHashMap<>();\\n            this.tweetMap = new ConcurrentHashMap<>();\\n            this.tweetTimeMap = new ConcurrentHashMap<>();\\n            this.timestamp = new AtomicInteger(0);\\n        }\\n\\n        public void postTweet(int userId, int tweetId) {\\n            List<Integer> tweets = this.tweetMap.getOrDefault(userId, new ArrayList<>());\\n            tweets.add(tweetId);\\n            this.tweetMap.put(userId, tweets);\\n            this.tweetTimeMap.put(tweetId, this.timestamp.incrementAndGet());\\n        }\\n\\n        public List<Integer> getNewsFeed(int userId) {\\n            Set<Integer> followers = this.followMap.getOrDefault(userId, new HashSet<>());\\n            followers.add(userId);\\n            return followers.stream()\\n                    .flatMap(f -> this.tweetMap.getOrDefault(f, new ArrayList<>()).stream())\\n                    .sorted(Comparator.comparingInt(this.tweetTimeMap::get).reversed())\\n                    .limit(10)\\n                    .collect(Collectors.toList());\\n        }\\n\\n        public void follow(int followerId, int followeeId) {\\n            Set<Integer> followees = this.followMap.getOrDefault(followerId, new HashSet<>());\\n            followees.add(followeeId);\\n            this.followMap.put(followerId, followees);\\n        }\\n\\n        public void unfollow(int followerId, int followeeId) {\\n            if (this.followMap.containsKey(followerId)) {\\n                this.followMap.get(followerId).remove(followeeId);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848267,
                "title": "swift-map-set-easy-clean",
                "content": "```\\nimport Foundation\\n\\nclass Twitter {\\n\\n    var userIDAndTweetMap = [Int:[(Int, Int)]]()\\n    var followerAndfolloweeMap = [Int:Set<Int>]() // [follower: Set<followee>]\\n    let maxPost = 10\\n    var currentTimeRef = 10000\\n    \\n    init() {\\n        \\n    }\\n    \\n    func postTweet(_ userId: Int, _ tweetId: Int) {\\n        currentTimeRef += 1\\n        \\n        // add tweet to user\\'s feed\\n        userIDAndTweetMap[userId, default: [(Int, Int)]()].append((tweetId, currentTimeRef))\\n        if userIDAndTweetMap[userId]!.count > maxPost {\\n            userIDAndTweetMap[userId]!.removeFirst()\\n        }\\n    }\\n    \\n    func getNewsFeed(_ userId: Int) -> [Int] {\\n        var allFeeds = [(Int, Int)]()\\n        \\n        if let feeds = userIDAndTweetMap[userId] {\\n            allFeeds.append(contentsOf: feeds)\\n        }\\n        \\n        if let followeeIds = followerAndfolloweeMap[userId] {\\n            for followeeId in Array(followeeIds) {\\n                if let feeds = userIDAndTweetMap[followeeId] {\\n                    allFeeds.append(contentsOf: feeds)\\n                }\\n            }\\n        }\\n        allFeeds.sort { $0.1 > $1.1 }\\n        let feeds = allFeeds.map { $0.0 }\\n        \\n        return feeds.count <= maxPost ? feeds : Array(feeds[0..<10])\\n    }\\n    \\n    func follow(_ followerId: Int, _ followeeId: Int) {\\n        followerAndfolloweeMap[followerId, default: Set<Int>()].insert(followeeId)\\n    }\\n    \\n    func unfollow(_ followerId: Int, _ followeeId: Int) {\\n        followerAndfolloweeMap[followerId]?.remove(followeeId)\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * let obj = Twitter()\\n * obj.postTweet(userId, tweetId)\\n * let ret_2: [Int] = obj.getNewsFeed(userId)\\n * obj.follow(followerId, followeeId)\\n * obj.unfollow(followerId, followeeId)\\n */\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport Foundation\\n\\nclass Twitter {\\n\\n    var userIDAndTweetMap = [Int:[(Int, Int)]]()\\n    var followerAndfolloweeMap = [Int:Set<Int>]() // [follower: Set<followee>]\\n    let maxPost = 10\\n    var currentTimeRef = 10000\\n    \\n    init() {\\n        \\n    }\\n    \\n    func postTweet(_ userId: Int, _ tweetId: Int) {\\n        currentTimeRef += 1\\n        \\n        // add tweet to user\\'s feed\\n        userIDAndTweetMap[userId, default: [(Int, Int)]()].append((tweetId, currentTimeRef))\\n        if userIDAndTweetMap[userId]!.count > maxPost {\\n            userIDAndTweetMap[userId]!.removeFirst()\\n        }\\n    }\\n    \\n    func getNewsFeed(_ userId: Int) -> [Int] {\\n        var allFeeds = [(Int, Int)]()\\n        \\n        if let feeds = userIDAndTweetMap[userId] {\\n            allFeeds.append(contentsOf: feeds)\\n        }\\n        \\n        if let followeeIds = followerAndfolloweeMap[userId] {\\n            for followeeId in Array(followeeIds) {\\n                if let feeds = userIDAndTweetMap[followeeId] {\\n                    allFeeds.append(contentsOf: feeds)\\n                }\\n            }\\n        }\\n        allFeeds.sort { $0.1 > $1.1 }\\n        let feeds = allFeeds.map { $0.0 }\\n        \\n        return feeds.count <= maxPost ? feeds : Array(feeds[0..<10])\\n    }\\n    \\n    func follow(_ followerId: Int, _ followeeId: Int) {\\n        followerAndfolloweeMap[followerId, default: Set<Int>()].insert(followeeId)\\n    }\\n    \\n    func unfollow(_ followerId: Int, _ followeeId: Int) {\\n        followerAndfolloweeMap[followerId]?.remove(followeeId)\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * let obj = Twitter()\\n * obj.postTweet(userId, tweetId)\\n * let ret_2: [Int] = obj.getNewsFeed(userId)\\n * obj.follow(followerId, followeeId)\\n * obj.unfollow(followerId, followeeId)\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833921,
                "title": "java-solution",
                "content": "```\\nclass User {\\n  Set < Integer > following = new HashSet();\\n  Map < Integer, Integer > post = new HashMap();\\n}\\n\\nclass Twitter {\\n  int postId = 1;\\n  Map < Integer, User > map = null;\\n  public Twitter() {\\n    map = new HashMap();\\n  }\\n\\n  public void postTweet(int userId, int tweetId) {\\n    User user = map.get(userId);\\n    if (user != null) {\\n      user.post.put(postId, tweetId);\\n    } else {\\n      User newUser = new User();\\n      newUser.post.put(postId, tweetId);\\n      map.put(userId, newUser);\\n    }\\n    postId++;\\n  }\\n\\n  public List < Integer > getNewsFeed(int userId) {\\n    ArrayList<Map.Entry<Integer,Integer>> result = new ArrayList();\\n    User user = map.get(userId);\\n    if (user != null) {\\n      result.addAll(user.post.entrySet());\\n      for (int i: user.following) {\\n        User user2 = map.get(i);\\n        if (user2 != null) {\\n          result.addAll(user2.post.entrySet());\\n        }\\n      }\\n      Collections.sort(result, (Map.Entry<Integer,Integer> a, Map.Entry<Integer,Integer> b ) ->  b.getKey()-a.getKey());\\n    }\\n    List<Integer> list = new ArrayList();\\n    for(Map.Entry<Integer,Integer> entry : result){\\n        list.add(entry.getValue());\\n        if(list.size()==10)\\n            return list;\\n        \\n    }\\n    return list;\\n  }\\n\\n  public void follow(int followerId, int followeeId) {\\n    User user = map.get(followerId);\\n    if (user != null) {\\n      user.following.add(followeeId);\\n    } else {\\n      User newUser = new User();\\n      newUser.following.add(followeeId);\\n      map.put(followerId, newUser);\\n    }\\n  }\\n\\n  public void unfollow(int followerId, int followeeId) {\\n    User user = map.get(followerId);\\n    if (user != null) {\\n      user.following.remove(followeeId);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass User {\\n  Set < Integer > following = new HashSet();\\n  Map < Integer, Integer > post = new HashMap();\\n}\\n\\nclass Twitter {\\n  int postId = 1;\\n  Map < Integer, User > map = null;\\n  public Twitter() {\\n    map = new HashMap();\\n  }\\n\\n  public void postTweet(int userId, int tweetId) {\\n    User user = map.get(userId);\\n    if (user != null) {\\n      user.post.put(postId, tweetId);\\n    } else {\\n      User newUser = new User();\\n      newUser.post.put(postId, tweetId);\\n      map.put(userId, newUser);\\n    }\\n    postId++;\\n  }\\n\\n  public List < Integer > getNewsFeed(int userId) {\\n    ArrayList<Map.Entry<Integer,Integer>> result = new ArrayList();\\n    User user = map.get(userId);\\n    if (user != null) {\\n      result.addAll(user.post.entrySet());\\n      for (int i: user.following) {\\n        User user2 = map.get(i);\\n        if (user2 != null) {\\n          result.addAll(user2.post.entrySet());\\n        }\\n      }\\n      Collections.sort(result, (Map.Entry<Integer,Integer> a, Map.Entry<Integer,Integer> b ) ->  b.getKey()-a.getKey());\\n    }\\n    List<Integer> list = new ArrayList();\\n    for(Map.Entry<Integer,Integer> entry : result){\\n        list.add(entry.getValue());\\n        if(list.size()==10)\\n            return list;\\n        \\n    }\\n    return list;\\n  }\\n\\n  public void follow(int followerId, int followeeId) {\\n    User user = map.get(followerId);\\n    if (user != null) {\\n      user.following.add(followeeId);\\n    } else {\\n      User newUser = new User();\\n      newUser.following.add(followeeId);\\n      map.put(followerId, newUser);\\n    }\\n  }\\n\\n  public void unfollow(int followerId, int followeeId) {\\n    User user = map.get(followerId);\\n    if (user != null) {\\n      user.following.remove(followeeId);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782159,
                "title": "java-o-n-log-k-design-priority-queue-hashing",
                "content": "```\\nclass Twitter {\\n    HashMap<Integer, HashSet<Tweet>> posts; \\n    HashMap<Integer, HashSet<Integer>> follows;\\n    int time;\\n    \\n    public Twitter() {\\n        posts = new HashMap<>();\\n        follows = new HashMap<>();\\n        time = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(!posts.containsKey(userId)) posts.put(userId, new HashSet<>());\\n        posts.get(userId).add(new Tweet(tweetId, time++));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> newsFeed = new LinkedList<>();\\n        PriorityQueue<Tweet> pq = new PriorityQueue<>();\\n        \\n        if(posts.containsKey(userId)) {\\n            for(Tweet tweet : posts.get(userId)) {\\n                if(pq.size() < 10) {\\n                    pq.add(tweet);\\n                } else if(tweet.compareTo(pq.peek()) > 0) {\\n                    pq.poll();\\n                    pq.add(tweet);\\n                }\\n            }\\n        }\\n        \\n        if(follows.containsKey(userId)) {\\n            for(int foloweeId : follows.get(userId)) {\\n                if(posts.containsKey(foloweeId)) {\\n                    for(Tweet tweet : posts.get(foloweeId)) {\\n                            if(pq.size() < 10) {\\n                            pq.add(tweet);\\n                        } else if(tweet.compareTo(pq.peek()) > 0) {\\n                            pq.poll();\\n                            pq.add(tweet);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            newsFeed.add(0, pq.poll().tweetId);\\n        }\\n        \\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!follows.containsKey(followerId)) follows.put(followerId, new HashSet<>());\\n        follows.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(follows.containsKey(followerId)) follows.get(followerId).remove(followeeId);\\n    }\\n    \\n    private class Tweet implements Comparable<Tweet> {\\n        int tweetId, time;\\n        public Tweet(int tweetId, int time) {\\n            this.tweetId = tweetId;\\n            this.time = time;\\n        }\\n        @Override\\n        public int compareTo(Tweet tweet) {\\n            return this.time - tweet.time;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Twitter {\\n    HashMap<Integer, HashSet<Tweet>> posts; \\n    HashMap<Integer, HashSet<Integer>> follows;\\n    int time;\\n    \\n    public Twitter() {\\n        posts = new HashMap<>();\\n        follows = new HashMap<>();\\n        time = 0;\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n        if(!posts.containsKey(userId)) posts.put(userId, new HashSet<>());\\n        posts.get(userId).add(new Tweet(tweetId, time++));\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        List<Integer> newsFeed = new LinkedList<>();\\n        PriorityQueue<Tweet> pq = new PriorityQueue<>();\\n        \\n        if(posts.containsKey(userId)) {\\n            for(Tweet tweet : posts.get(userId)) {\\n                if(pq.size() < 10) {\\n                    pq.add(tweet);\\n                } else if(tweet.compareTo(pq.peek()) > 0) {\\n                    pq.poll();\\n                    pq.add(tweet);\\n                }\\n            }\\n        }\\n        \\n        if(follows.containsKey(userId)) {\\n            for(int foloweeId : follows.get(userId)) {\\n                if(posts.containsKey(foloweeId)) {\\n                    for(Tweet tweet : posts.get(foloweeId)) {\\n                            if(pq.size() < 10) {\\n                            pq.add(tweet);\\n                        } else if(tweet.compareTo(pq.peek()) > 0) {\\n                            pq.poll();\\n                            pq.add(tweet);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            newsFeed.add(0, pq.poll().tweetId);\\n        }\\n        \\n        return newsFeed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n        if(!follows.containsKey(followerId)) follows.put(followerId, new HashSet<>());\\n        follows.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n        if(follows.containsKey(followerId)) follows.get(followerId).remove(followeeId);\\n    }\\n    \\n    private class Tweet implements Comparable<Tweet> {\\n        int tweetId, time;\\n        public Tweet(int tweetId, int time) {\\n            this.tweetId = tweetId;\\n            this.time = time;\\n        }\\n        @Override\\n        public int compareTo(Tweet tweet) {\\n            return this.time - tweet.time;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760641,
                "title": "c-using-dictionary-and-linkedlist-faster-than-100",
                "content": "``` \\npublic class Twitter {\\n\\n    Dictionary<int, List<int>> followersList;\\n    LinkedList<Tweet> tweets;\\n\\t\\n    public Twitter() {\\n        followersList = new Dictionary<int, List<int>>();\\n        tweets = new LinkedList<Tweet>();\\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        tweets.AddFirst(new Tweet{userId = userId, tweetId = tweetId});\\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n        List<int> peopleUserFollows = new List<int>() {userId};\\n        if(followersList.ContainsKey(userId))\\n        {\\n            peopleUserFollows.AddRange(followersList[userId]);\\n        }\\n        int count = 0;\\n        var tempTweets = tweets.First;\\n        IList<int> result = new List<int>();\\n        while(count < 10 && tempTweets != null)\\n        {       \\n            if(peopleUserFollows.Contains(tempTweets.Value.userId))\\n            {\\n                result.Add(tempTweets.Value.tweetId);\\n                count++;\\n            }\\n            tempTweets = tempTweets.Next;\\n        }\\n        return result;\\n        \\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if(followersList.ContainsKey(followerId))\\n        {\\n            followersList[followerId].Add(followeeId);\\n        }\\n        else\\n        {\\n            followersList.Add(followerId, new List<int>(){followeeId});\\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if(followersList.ContainsKey(followerId))\\n        {\\n            if(followersList[followerId].Contains(followeeId))\\n            {\\n                followersList[followerId].Remove(followeeId);\\n            }\\n        }\\n    }\\n}\\n\\npublic class Tweet\\n{\\n    public int userId;\\n    public int tweetId;\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */",
                "solutionTags": [],
                "code": "``` \\npublic class Twitter {\\n\\n    Dictionary<int, List<int>> followersList;\\n    LinkedList<Tweet> tweets;\\n\\t\\n    public Twitter() {\\n        followersList = new Dictionary<int, List<int>>();\\n        tweets = new LinkedList<Tweet>();\\n    }\\n    \\n    public void PostTweet(int userId, int tweetId) {\\n        tweets.AddFirst(new Tweet{userId = userId, tweetId = tweetId});\\n    }\\n    \\n    public IList<int> GetNewsFeed(int userId) {\\n        List<int> peopleUserFollows = new List<int>() {userId};\\n        if(followersList.ContainsKey(userId))\\n        {\\n            peopleUserFollows.AddRange(followersList[userId]);\\n        }\\n        int count = 0;\\n        var tempTweets = tweets.First;\\n        IList<int> result = new List<int>();\\n        while(count < 10 && tempTweets != null)\\n        {       \\n            if(peopleUserFollows.Contains(tempTweets.Value.userId))\\n            {\\n                result.Add(tempTweets.Value.tweetId);\\n                count++;\\n            }\\n            tempTweets = tempTweets.Next;\\n        }\\n        return result;\\n        \\n    }\\n    \\n    public void Follow(int followerId, int followeeId) {\\n        if(followersList.ContainsKey(followerId))\\n        {\\n            followersList[followerId].Add(followeeId);\\n        }\\n        else\\n        {\\n            followersList.Add(followerId, new List<int>(){followeeId});\\n        }\\n    }\\n    \\n    public void Unfollow(int followerId, int followeeId) {\\n        if(followersList.ContainsKey(followerId))\\n        {\\n            if(followersList[followerId].Contains(followeeId))\\n            {\\n                followersList[followerId].Remove(followeeId);\\n            }\\n        }\\n    }\\n}\\n\\npublic class Tweet\\n{\\n    public int userId;\\n    public int tweetId;\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.PostTweet(userId,tweetId);\\n * IList<int> param_2 = obj.GetNewsFeed(userId);\\n * obj.Follow(followerId,followeeId);\\n * obj.Unfollow(followerId,followeeId);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1752208,
                "title": "java-faster-then-99-17-no-treeset-no-priority-queue",
                "content": "```\\nclass Twitter {\\n   class Tweet{\\n        int time;\\n        int post_id;\\n        Tweet(int time , int post_id){\\n            this.time = time;\\n            this.post_id = post_id;\\n        }\\n    }\\n    \\n    static int timer = 1;\\n    final Map <Integer , List <Integer> > follower;\\n    final Map <Integer , ArrayList <Tweet> > tweets;\\n    public Twitter() {\\n        follower = new HashMap <Integer, List <Integer>> ();\\n        tweets = new HashMap <Integer , ArrayList <Tweet>> ();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n         if(tweets.get(userId) == null){\\n             tweets.put(userId , new ArrayList <Tweet> ());\\n         }\\n         tweets.get(userId).add(0,new Tweet(timer , tweetId));\\n         timer++;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        if(follower.get(userId) == null){\\n            follower.put(userId , new LinkedList <Integer> ());\\n            follower.get(userId).add(userId);\\n        }\\n        List <Integer> feed = new ArrayList <Integer> ();\\n        Map <Integer , Integer> cache = new HashMap <> ();\\n        int size = 0;\\n        int currTime , minUser;\\n        while(size < 10){\\n            minUser = -1;\\n            currTime = Integer.MIN_VALUE;\\n            for(int user : follower.get(userId)){\\n                 if(cache.get(user) == null)\\n                     cache.put(user , 0);\\n                 if(tweets.get(user)!=null && tweets.get(user).size() > cache.get(user)){\\n                     Tweet tweet = tweets.get(user).get(cache.get(user));\\n                     if(tweet.time > currTime){\\n                         minUser = user;\\n                         currTime = tweet.time;\\n                     }\\n                 }\\n            }\\n            if(minUser == -1) break;\\n            Tweet tweet = tweets.get(minUser).get(cache.get(minUser));\\n            feed.add(tweet.post_id);\\n            cache.put(minUser , cache.get(minUser) + 1);\\n            size++;\\n            \\n        }\\n        cache = null;\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n          if(follower.get(followerId) == null){\\n              follower.put(followerId , new LinkedList <Integer> ());\\n              follower.get(followerId).add(followerId);\\n          }\\n        \\n          follower.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n         if(follower.get(followerId) == null) return;\\n          follower.get(followerId).remove(new Integer(followeeId));\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Twitter {\\n   class Tweet{\\n        int time;\\n        int post_id;\\n        Tweet(int time , int post_id){\\n            this.time = time;\\n            this.post_id = post_id;\\n        }\\n    }\\n    \\n    static int timer = 1;\\n    final Map <Integer , List <Integer> > follower;\\n    final Map <Integer , ArrayList <Tweet> > tweets;\\n    public Twitter() {\\n        follower = new HashMap <Integer, List <Integer>> ();\\n        tweets = new HashMap <Integer , ArrayList <Tweet>> ();\\n    }\\n    \\n    public void postTweet(int userId, int tweetId) {\\n         if(tweets.get(userId) == null){\\n             tweets.put(userId , new ArrayList <Tweet> ());\\n         }\\n         tweets.get(userId).add(0,new Tweet(timer , tweetId));\\n         timer++;\\n    }\\n    \\n    public List<Integer> getNewsFeed(int userId) {\\n        if(follower.get(userId) == null){\\n            follower.put(userId , new LinkedList <Integer> ());\\n            follower.get(userId).add(userId);\\n        }\\n        List <Integer> feed = new ArrayList <Integer> ();\\n        Map <Integer , Integer> cache = new HashMap <> ();\\n        int size = 0;\\n        int currTime , minUser;\\n        while(size < 10){\\n            minUser = -1;\\n            currTime = Integer.MIN_VALUE;\\n            for(int user : follower.get(userId)){\\n                 if(cache.get(user) == null)\\n                     cache.put(user , 0);\\n                 if(tweets.get(user)!=null && tweets.get(user).size() > cache.get(user)){\\n                     Tweet tweet = tweets.get(user).get(cache.get(user));\\n                     if(tweet.time > currTime){\\n                         minUser = user;\\n                         currTime = tweet.time;\\n                     }\\n                 }\\n            }\\n            if(minUser == -1) break;\\n            Tweet tweet = tweets.get(minUser).get(cache.get(minUser));\\n            feed.add(tweet.post_id);\\n            cache.put(minUser , cache.get(minUser) + 1);\\n            size++;\\n            \\n        }\\n        cache = null;\\n        return feed;\\n    }\\n    \\n    public void follow(int followerId, int followeeId) {\\n          if(follower.get(followerId) == null){\\n              follower.put(followerId , new LinkedList <Integer> ());\\n              follower.get(followerId).add(followerId);\\n          }\\n        \\n          follower.get(followerId).add(followeeId);\\n    }\\n    \\n    public void unfollow(int followerId, int followeeId) {\\n         if(follower.get(followerId) == null) return;\\n          follower.get(followerId).remove(new Integer(followeeId));\\n    }\\n}\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter obj = new Twitter();\\n * obj.postTweet(userId,tweetId);\\n * List<Integer> param_2 = obj.getNewsFeed(userId);\\n * obj.follow(followerId,followeeId);\\n * obj.unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744135,
                "title": "100-faster-c-sort-k-sorted-list-max-heap",
                "content": "```\\nstruct cmp{\\n  bool operator () (vector<int>&a,vector<int>&b)\\n  {\\n      return a[0]<b[0];\\n  }\\n};\\nclass Twitter {\\npublic:\\n    vector<unordered_set<int>>connections;\\n    vector< vector<pair<int,int>> >timeline;// <time,tweetId>\\n    int time;\\n    Twitter() {\\n        connections=vector<unordered_set<int>>(501,unordered_set<int>());\\n        timeline=vector<vector<pair<int,int>> >(501,vector<pair<int,int> >());\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline[userId].push_back({++time,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        //make a max_pq according to the tweettime, insert maxtimetweet of all followees of the user ans user into it\\n        //retrive top 10 tweets;\\n        vector<int>res;\\n        priority_queue<vector<int>,vector<vector<int>>,cmp>pq;\\n        if(timeline[userId].size()>0)\\n                pq.push({timeline[userId].back().first,timeline[userId].back().second,userId,(int)timeline[userId].size()-1});\\n        for(auto&con:connections[userId])\\n        {\\n            if(timeline[con].size()>0)\\n                pq.push({timeline[con].back().first,timeline[con].back().second,con,(int)timeline[con].size()-1});\\n        }\\n        int k=10;\\n        while(!pq.empty() && k--)\\n        {\\n            auto p=pq.top();\\n            pq.pop();\\n            int time=p[0],tweetid=p[1],conid=p[2],tweetnum=p[3];\\n            res.push_back(tweetid);\\n            // cout<<conid<<\" \"<<tweetnum<<\" | \";\\n            tweetnum--;\\n            \\n            if(tweetnum>=0)\\n            {\\n                int next_tweettime= timeline[conid][tweetnum].first;\\n                int next_tweetid= timeline[conid][tweetnum].second;\\n                pq.push({next_tweettime,next_tweetid,conid,tweetnum});\\n            }\\n        }\\n        // cout<<endl;\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        connections[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        connections[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp{\\n  bool operator () (vector<int>&a,vector<int>&b)\\n  {\\n      return a[0]<b[0];\\n  }\\n};\\nclass Twitter {\\npublic:\\n    vector<unordered_set<int>>connections;\\n    vector< vector<pair<int,int>> >timeline;// <time,tweetId>\\n    int time;\\n    Twitter() {\\n        connections=vector<unordered_set<int>>(501,unordered_set<int>());\\n        timeline=vector<vector<pair<int,int>> >(501,vector<pair<int,int> >());\\n        time=0;\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        timeline[userId].push_back({++time,tweetId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        //make a max_pq according to the tweettime, insert maxtimetweet of all followees of the user ans user into it\\n        //retrive top 10 tweets;\\n        vector<int>res;\\n        priority_queue<vector<int>,vector<vector<int>>,cmp>pq;\\n        if(timeline[userId].size()>0)\\n                pq.push({timeline[userId].back().first,timeline[userId].back().second,userId,(int)timeline[userId].size()-1});\\n        for(auto&con:connections[userId])\\n        {\\n            if(timeline[con].size()>0)\\n                pq.push({timeline[con].back().first,timeline[con].back().second,con,(int)timeline[con].size()-1});\\n        }\\n        int k=10;\\n        while(!pq.empty() && k--)\\n        {\\n            auto p=pq.top();\\n            pq.pop();\\n            int time=p[0],tweetid=p[1],conid=p[2],tweetnum=p[3];\\n            res.push_back(tweetid);\\n            // cout<<conid<<\" \"<<tweetnum<<\" | \";\\n            tweetnum--;\\n            \\n            if(tweetnum>=0)\\n            {\\n                int next_tweettime= timeline[conid][tweetnum].first;\\n                int next_tweetid= timeline[conid][tweetnum].second;\\n                pq.push({next_tweettime,next_tweetid,conid,tweetnum});\\n            }\\n        }\\n        // cout<<endl;\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        connections[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        connections[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1737979,
                "title": "java-simple-solution-8-ms-faster-than-98-86",
                "content": "**Runtime: 8 ms, faster than 98.86% of Java online submissions.**\\n```\\nclass Twitter {\\n    class Node{\\n        int userId;\\n        int tweetId;\\n        Node next;\\n        \\n        Node(){}\\n        \\n        Node(int userId, int tweetId){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n        }\\n        \\n        Node(int userId, int tweetId, Node next){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n            this.next = next;\\n        }\\n    }\\n    \\n    HashMap<Integer, HashSet<Integer>> connections;\\n    \\n    Node head;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        connections = new HashMap<>();\\n        head = new Node(0,0);\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        insert(new Node(userId, tweetId));\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        connections.putIfAbsent(userId, new HashSet<>());\\n        \\n        List<Integer> l = new ArrayList<>();\\n        \\n        Node curr = head.next;\\n        \\n        while(curr != null && l.size() < 10){\\n            if(connections.get(userId).contains(curr.userId) || userId == curr.userId)\\n                l.add(curr.tweetId);\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        connections.putIfAbsent(followerId, new HashSet<>());\\n        \\n        connections.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        connections.putIfAbsent(followerId, new HashSet<>());\\n        \\n        if(connections.get(followerId).contains(followeeId))\\n            connections.get(followerId).remove(followeeId);\\n    }\\n    \\n    public void insert(Node node){\\n        node.next = head.next;\\n        head.next = node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Twitter {\\n    class Node{\\n        int userId;\\n        int tweetId;\\n        Node next;\\n        \\n        Node(){}\\n        \\n        Node(int userId, int tweetId){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n        }\\n        \\n        Node(int userId, int tweetId, Node next){\\n            this.userId = userId;\\n            this.tweetId = tweetId;\\n            this.next = next;\\n        }\\n    }\\n    \\n    HashMap<Integer, HashSet<Integer>> connections;\\n    \\n    Node head;\\n    \\n    /** Initialize your data structure here. */\\n    public Twitter() {\\n        connections = new HashMap<>();\\n        head = new Node(0,0);\\n    }\\n    \\n    /** Compose a new tweet. */\\n    public void postTweet(int userId, int tweetId) {\\n        insert(new Node(userId, tweetId));\\n    }\\n    \\n    /** Retrieve the 10 most recent tweet ids in the user\\'s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */\\n    public List<Integer> getNewsFeed(int userId) {\\n        connections.putIfAbsent(userId, new HashSet<>());\\n        \\n        List<Integer> l = new ArrayList<>();\\n        \\n        Node curr = head.next;\\n        \\n        while(curr != null && l.size() < 10){\\n            if(connections.get(userId).contains(curr.userId) || userId == curr.userId)\\n                l.add(curr.tweetId);\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\\n    public void follow(int followerId, int followeeId) {\\n        connections.putIfAbsent(followerId, new HashSet<>());\\n        \\n        connections.get(followerId).add(followeeId);\\n    }\\n    \\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\\n    public void unfollow(int followerId, int followeeId) {\\n        connections.putIfAbsent(followerId, new HashSet<>());\\n        \\n        if(connections.get(followerId).contains(followeeId))\\n            connections.get(followerId).remove(followeeId);\\n    }\\n    \\n    public void insert(Node node){\\n        node.next = head.next;\\n        head.next = node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736996,
                "title": "faster-than-100",
                "content": "```class Twitter {\\npublic:\\n    map<int,set<int>> userfollowing;\\n    vector<pair<int,int>> tweets;\\n    Twitter() {\\n    }\\n    int i=1;\\n    void postTweet(int userId, int tweetId) {\\n        pair<int,int> p;\\n        p.first=userId;\\n        p.second=tweetId;\\n        tweets.push_back(p);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        int count=0;\\n        vector<int> ans;\\n        set<int> s=userfollowing[userId];\\n        for(auto it=tweets.rbegin();count<10&&it!=tweets.rend();it++){\\n            if(s.find(it->first)!=s.end()||it->first==userId){\\n                ans.push_back(it->second);\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        userfollowing[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        userfollowing[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */",
                "solutionTags": [],
                "code": "```class Twitter {\\npublic:\\n    map<int,set<int>> userfollowing;\\n    vector<pair<int,int>> tweets;\\n    Twitter() {\\n    }\\n    int i=1;\\n    void postTweet(int userId, int tweetId) {\\n        pair<int,int> p;\\n        p.first=userId;\\n        p.second=tweetId;\\n        tweets.push_back(p);\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        int count=0;\\n        vector<int> ans;\\n        set<int> s=userfollowing[userId];\\n        for(auto it=tweets.rbegin();count<10&&it!=tweets.rend();it++){\\n            if(s.find(it->first)!=s.end()||it->first==userId){\\n                ans.push_back(it->second);\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        userfollowing[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        userfollowing[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1659504,
                "title": "an-intuitive-and-elegant-c-solution",
                "content": "I use a nested map structure to simulate the \"follow\" relationship, \\nthe rest are just follow the description of the problem.\\n\\nThe getNewsFeed() might have some problem when scale-up, since it must go through the tweet list every time it is invoked.\\n \\n```\\nclass Twitter {\\n    vector<pair<int, int>> tweet;\\n    map<int, map<int, bool>> feed;\\npublic:\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet.push_back({tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ret;\\n        \\n        for (int i = tweet.size() - 1; i >= 0 && ret.size() < 10; --i)\\n            if (feed[userId][tweet[i].second] || tweet[i].second == userId)\\n                ret.push_back(tweet[i].first);\\n        \\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        feed[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        feed[followerId][followeeId] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Twitter {\\n    vector<pair<int, int>> tweet;\\n    map<int, map<int, bool>> feed;\\npublic:\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweet.push_back({tweetId, userId});\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ret;\\n        \\n        for (int i = tweet.size() - 1; i >= 0 && ret.size() < 10; --i)\\n            if (feed[userId][tweet[i].second] || tweet[i].second == userId)\\n                ret.push_back(tweet[i].first);\\n        \\n        return ret;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        feed[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        feed[followerId][followeeId] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606794,
                "title": "o-1-most-efficient-solution",
                "content": "class Twitter(object):\\n\\n    def __init__(self):\\n        # userId -> set(people followed id)\\n        self.follows = collections.defaultdict(set)\\n        # array[(userId, tweetId)]\\n        self.posts = []\\n\\n    def postTweet(self, userId, tweetId):\\n        self.posts.append([userId, tweetId])\\n\\n    def getNewsFeed(self, userId):\\n        res = []\\n        count = 0\\n        i = len(self.posts) - 1\\n        while count < 10 and i >= 0:\\n            # lookup in a set is O(1)\\n            if self.posts[i][0] == userId or self.posts[i][0] in self.follows[userId]:\\n                res.append(self.posts[i][1])\\n                count += 1\\n            i -= 1\\n        return res\\n        \\n\\n    def follow(self, followerId, followeeId):\\n        self.follows[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.follows[followerId].discard(followeeId)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Twitter(object):\\n\\n    def __init__(self):\\n        # userId -> set(people followed id)\\n        self.follows = collections.defaultdict(set)\\n        # array[(userId, tweetId)]\\n        self.posts = []\\n\\n    def postTweet(self, userId, tweetId):\\n        self.posts.append([userId, tweetId])\\n\\n    def getNewsFeed(self, userId):\\n        res = []\\n        count = 0\\n        i = len(self.posts) - 1\\n        while count < 10 and i >= 0:\\n            # lookup in a set is O(1)\\n            if self.posts[i][0] == userId or self.posts[i][0] in self.follows[userId]:\\n                res.append(self.posts[i][1])\\n                count += 1\\n            i -= 1\\n        return res\\n        \\n\\n    def follow(self, followerId, followeeId):\\n        self.follows[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.follows[followerId].discard(followeeId)",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1678863,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1989964,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1873303,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1567963,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1571630,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1571938,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1573128,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1930455,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1833354,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1930684,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1678863,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1989964,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1873303,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1567963,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1571630,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1571938,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1573128,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1930455,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1833354,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1930684,
                "content": [
                    {
                        "username": "candi-project",
                        "content": "This should be hard not medium.\\nA lot of edge cases need to be considered."
                    },
                    {
                        "username": "Bl4ckBurn",
                        "content": "More like design X"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn I feel like all interview questions should be like that. I loved this problem because:\\n- It is an object oriented design question which is already much closer to what you might actually do in a job than 99% problems \\n- there are so many ways to approach it ! I\\'ve coded 3 different solutions to it which all have different perks and downsides (some of them put all the complexity in the post operation, some of them in the getnewsfeed, etc...). \\n- It lets you use a variety of different data structures (I\\'ve used linked list, queue, heap, and I\\'m sure you could come up with other ways)\\n- it actually feels like a relevant problem that you\\'re farely likely to encounter some variation of when coding real solutions. Not like a goddamn palindrome thing. Why, oh, why are problem makers fetishizing palindromes so much?"
                    },
                    {
                        "username": "LiQuanlai",
                        "content": "there is a case where a user unfollows himself, and in the end he should still be seeing his posts.\\nthis case wasted me a long time !"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "The user really doesn\\'t follow himself. Well, they can, I suppose, but it says in the description that the users feed will contain their posts. so it really doesn\\'t matter if they follow themselves or not."
                    },
                    {
                        "username": "dragengx",
                        "content": "What's the point of tweetId? Is that showing the time of the tweet posted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The tweetId is here to uniquely identify a tweet, but I see no guarantee that they\\'d be respecting the chronlogical order. You might have tweetId #3564 posted before tweetId #2 so better maintain your own system for keeping track of the time"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@user0181Tj](/user0181Tj) No, it\\'s actually not. You still have to maintain your own timestamp because the tweetIDs aren\\'t given in sorted order."
                    },
                    {
                        "username": "user0181Tj",
                        "content": "That is the way I understood it."
                    },
                    {
                        "username": "hatemelseidy",
                        "content": "As you may know, there are 2 main approaches for this design:\\n1. The first has some distributed complexity in all the operations and an O(1) getNewsFeed.\\n2. The second is the O(1) for all operations and most of the complexity is the getNewsFeed.\\n\\n**Which is better and why?**\\n\\nI beleive that this is not an algorithmic/design problem this is a UX problem. Regardless of the actual complexities. Let\\'s say that we have 2 users the first has 1M followers (people following him/her), let\\'s call this user **celebrity** and the second user is following 1M other users and let\\'s call this user **normal**.\\n\\n* **Design 1 => The O(1) getNewsFeed.**\\nWhile both of the users will have a very fast and nice getNewsFeed experience let\\'s think about posting a tweet.\\n  * The **celerity** will have a bad experience whenever he is posting a tweet and that\\'s because he/she has a lot of followers and his new tweet will need somehow to be published to all the news feeds of the 1M followers.\\n  * The **normal** user will post a tweet in almost no time because he has very few or no followers.\\n\\n* **Design 2 => The Complex getNewsFeed.**\\nThis time both of the users will enjoy a fantastic O(1) post tweet, but then when it comes to getting the news feed.\\n  * The **celebrity** will is following few others and aggregating his/her news feed won\\'t take long.\\n  * Although the **normal** user who is following 1M users will need sometime to aggregate his very complex news feed.\\n\\nNow, if you took a closer look at the previous comparison you will find that the user who has taken explicit actions to follow lots and lots of people is making his/her feed complex, he/she unfollows people it becomse simpler. Although the celebrity who is not following a lot is getting better experience because he/she has not taken explicit actions to make other people follow him.\\n\\nIn other words, the first design is somehow punishing the celebrities for getting more and more followers while the second design is punishing the users who follow a lot of people.\\n\\n***Which punishment would you choose for your users? :) :)***\\n\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "I would argue that option two is far superior. I would suspect that number of followed users stays fairly constant and small among all users. The only way I can even imagine a user following a million users if if following can be performed programmatically via API. No one is pressing a subscribe button a million times."
                    },
                    {
                        "username": "kalamoudi",
                        "content": "O(n) getNewsFeed() then caching it"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "That was a great read , though the only one\\'s which will get punished are us !\\njokes aside ... I think it would be better to chose 2nd option , because the number of people a user follows is pretty limited , when we think about the majority of people... I have never seen someone follow more than a couple of thousand people , that too in rare case ( the accounts that want to grow , they deliberately follow people in hope of getting a follow back ). "
                    },
                    {
                        "username": "Tpdi",
                        "content": "Runtime: 652 ms, faster than 100.00% of Scala online submissions for Design Twitter.\\nMemory Usage: 73.5 MB, less than 100.00% of Scala online submissions for Design Twitter.\\n\\nEach method is a single expression, 31 lines total (not inclusing comments)."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "Damn, mine in Python 37 ms, only beats 95%. Is Scala slower than Python?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "652 ms beats 100%??\\nDamn, and here I was thinking python was slow. Well scala is just one more item in the long list of languages I\\'ll thoroughly enjoy never learning"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Ok, but is the tweetId that the input adds always going to be bigger than that of the previous input? That\\'s important and not mentioned."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "is there a problem with test case 13? user posts [1,5] and then many others but when gettweet of 1 all are printed except tweet id 5 . Why so? this does  not make sense. why twweet id 5 not in expected result ?"
                    },
                    {
                        "username": "surfingcat",
                        "content": "news feed is 10 elements, the 5 falls off the window"
                    },
                    {
                        "username": "jankovicsandras",
                        "content": "I have the same problem."
                    },
                    {
                        "username": "samuelmayna",
                        "content": "The wording should be \"Retrieves the   `10` or `less`  tweets \" . I designed my code having the count of  10 and now I have to redesign and code the question afresh."
                    }
                ]
            },
            {
                "id": 1778164,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 1693407,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 1576373,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 1573746,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2075550,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2072668,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2057199,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2052643,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2051641,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2048131,
                "content": [
                    {
                        "username": "ninidhia",
                        "content": "I think there is a problem with test case no. 11.\\nThis is their input:\\n`[\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]`\\n`[[],[1,5],[1,3],[1,101],[1,13],[1,10],[1,2],[1,94],[1,505],[1,333],[1,22],[1,11],[1]]`\\nHowever, their expected output is this:\\n`[null,null,null,null,null,null,null,null,null,null,null,null,[11,22,333,505,94,2,10,13,101,3]]`\\nWhy isn\\'t `5` amongst the output? It was clearly posted at the very beginning. The first call `postTweet(1,5)` should have added it to the list of tweets. Therefore, it should be returned.\\nAnyone else having this issue? "
                    },
                    {
                        "username": "bounassarserena",
                        "content": "It is because the latest 10 tweets should be returned"
                    },
                    {
                        "username": "topswe",
                        "content": "    # you need a map from userId -> list/deque of pairs tweets they made, with an index/val representing the time\\n    \\n    # map userId -> list/set of people they follow\\n    \\n    # and in getNewsFeed(), we use a k-way merge for 10 iterations... where k is the number of followers of the user_id + 1. (the +1 is for the user\\'s posts)"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/f439287e-a906-47fd-8285-9b1ee79d8e6a_1644678346.5004957.jpeg)\\n"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-355-design-twitter.html"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A mind-numbingly boring problem."
                    },
                    {
                        "username": "bashyal",
                        "content": "This is such an amazing problem ? Are there anything similar to this "
                    },
                    {
                        "username": "Sacha_924",
                        "content": "[\"Twitter\",\"postTweet\",\"postTweet\",\"getNewsFeed\"]\\n[[],[1,5],[1,3],[1]]\\n\\nI find that this testcase should not be valid because in my opinion if a tweet is posted after another tweet, its id should be higher.\\nHere we have a tweet with id 5, and then id 3\\nAnd I based myself on this principle to solve the problem and for me these cases should not happen :c"
                    },
                    {
                        "username": "user6443Ka",
                        "content": "Suppose user 1 doesn\\'t follow anybody. User 2 posts 10 tweets in a row. THEN user 1 starts following user 2.\\nAre the 10 posts supposed to show up on user 1\\'s feed?"
                    },
                    {
                        "username": "matthewjchou",
                        "content": "Thought this was fairly straightforward until submitting made me realize that feeds should include tweets from even before a user followed another user...\\n"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Is Elon going to hire me if I solve this question?)"
                    }
                ]
            },
            {
                "id": 2038595,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 2038570,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 2004895,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1995831,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1988338,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1982781,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1982519,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1979456,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1970103,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1964771,
                "content": [
                    {
                        "username": "yeedaKing",
                        "content": "So many edge cases!  "
                    },
                    {
                        "username": "SHREYSODHI",
                        "content": "Can you change the name of this problem to design X.com now? "
                    },
                    {
                        "username": "Deep_down",
                        "content": "I just stucked after seeing this :\\')\\nhow many of you also....\\n:) :) :)\\n\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "good question\nbut c++ runtime sucks i got better than 37% of submissions for first time\ni submitted the same code again got better than 100% of submissions\nbruh :)"
                    },
                    {
                        "username": "asagarwa",
                        "content": "Question name should be changed to Design X"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\n\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"unfollow\", \"unfollow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [3, 0], [3, 1], [1], [3, 2], [1, 3], [1, 3], [3, 2], [2, 1], [2, 1], [3]]\n```\n```\n[\"Twitter\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\"]\n```\n```\n[[], [1, 2], [1], [1, 2], [2, 3], [2, 1], [1, 0], [1], [2, 1], [3, 1], [3, 1], [3], [1, 3], [1], [3, 2], [1, 2], [3, 2], [3, 1], [3, 3], [2, 1], [2]]\n```\n```\n[\"Twitter\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"follow\", \"postTweet\", \"unfollow\", \"postTweet\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"unfollow\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"follow\", \"postTweet\", \"postTweet\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"unfollow\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"unfollow\", \"unfollow\", \"follow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"follow\", \"postTweet\", \"postTweet\", \"follow\", \"follow\", \"follow\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"postTweet\", \"unfollow\", \"follow\", \"unfollow\", \"postTweet\", \"unfollow\", \"follow\", \"getNewsFeed\", \"postTweet\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"postTweet\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"getNewsFeed\", \"unfollow\", \"postTweet\", \"follow\", \"unfollow\", \"getNewsFeed\", \"unfollow\", \"unfollow\"]\n```\n```\n[[], [2, 0], [5, 1], [5], [4, 2], [2, 5], [4, 1], [2, 4], [1, 4], [3, 2], [2, 4], [3, 3], [3, 4], [5], [4, 2], [5, 5], [1, 3], [1], [2, 3], [3], [4, 2], [3, 5], [3, 1], [2, 4], [3, 2], [4, 3], [5, 2], [4, 2], [2, 6], [3], [2, 4], [3, 4], [3, 5], [2], [4], [1, 5], [2, 7], [4, 8], [2, 4], [4, 1], [3, 1], [5, 2], [3, 2], [5, 2], [3, 9], [2, 1], [3], [1, 2], [2], [1], [3, 10], [5], [4, 5], [5, 3], [4, 2], [5, 2], [2], [1], [2], [1, 5], [5, 2], [2, 11], [4, 12], [5, 1], [4, 2], [5, 2], [4, 3], [1], [2], [3], [5, 13], [3], [5, 14], [2, 4], [2, 1], [2, 1], [2, 15], [2, 5], [1, 2], [4], [5, 16], [2, 3], [2], [2, 3], [2], [3], [4], [3], [2, 17], [1], [2], [3], [3], [1], [2, 1], [3, 18], [4, 3], [1, 4], [1], [1, 5], [2, 1]]\n```\n\nCode to generate test cases:\n\n```\nmax_user_id = 5\nops_count = 100\nops = [\"Twitter\"]\nargs = [[]]\ntweetId = 0\n\nfor i in range(ops_count):\n    op = random.choice([\"getNewsFeed\", \"follow\", \"unfollow\", \"postTweet\"])\n    ops.append(op)\n\nfor i in range(1, ops_count+1):\n    op = ops[i]\n    if op == \"getNewsFeed\":\n        args.append([random.randint(1, max_user_id)])\n    elif op == \"follow\" or op == \"unfollow\":\n        follower_id = random.randint(1, max_user_id)\n        unfollower_id = follower_id\n        while unfollower_id == follower_id:\n            unfollower_id = random.randint(1, max_user_id)\n        args.append([follower_id, unfollower_id])\n    elif op == \"postTweet\":\n        args.append([random.randint(1, max_user_id), tweetId])\n        tweetId += 1\nprint(json.dumps(ops))\nprint(json.dumps(args))\n```"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Beautiful Question !!! Extremely important to learn low level design through it !!! Do give it a try and if you solve, try to come up with two-three designs and the optimal design among them and the reason for that! I loved it leetcode!"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "change its tag to hard now !!!!"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "a particular user with a follower id can have more then one differnet tweet ids...\\n"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "The worst case time complexity of getNewsFeed() is O( 5000 * log(5000) ). 5000 is from 10 (latest tweet) * 500 (max users)"
                    }
                ]
            },
            {
                "id": 1959521,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1956234,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1908722,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1905184,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1802289,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1793144,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1769800,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1764198,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1761841,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            },
            {
                "id": 1732671,
                "content": [
                    {
                        "username": "codez93",
                        "content": "Somehow this question is application of K sorted linked list."
                    },
                    {
                        "username": "aron93",
                        "content": "The tweetId do not seem to be chronologically increasing. (e.g, they are random)\\nTherefore, the actual tweetId cannot be used to retrieve the most recent feed for the postTweet() function"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I build design for considering below scope:\n\nDesigning postTweet should be fast\nBuilding news feed for users on request basis.\n\nI believe design depends on scope of requirement. Kept it simple. Making complex code and become maintenance nightmare.\n[leetcode solution](https://leetcode.com/problems/design-twitter/solutions/3571318/java-design-map-priorityqueue-for-on-request-built-news-feed/)\n"
                    },
                    {
                        "username": "Kishore1610",
                        "content": "can anyone help me solve this error it kept raising this error\\n\\nTypeError: \\'dict\\' object is not callable\\n    result = obj.follow(\\nLine 82 in __helper_select_method__ (Solution.py)\\n    ret.append(__DriverSolution__().__helper_select_method__(method, params[index], obj))\\nLine 129 in _driver (Solution.py)\\n    _driver()\\nLine 138 in <module> (Solution.py)\\n\\nmY code \\nclass tweet:\\n    def __init__(self,user,tweet,time):\\n        self.user=user\\n        self.tweet=tweet\\n        self.time=time\\n    def __lt__(self,other):\\n        return self.time<other.time\\n\\nclass Twitter:\\n\\n    def __init__(self):\\n        self.follow={}\\n        self.tw={}\\n        self.time=100000000\\n\\n    def postTweet(self, userId: int, tweetId: int) -> None:\\n        if userId in self.tw:\\n            self.tw[userId]+=[tweet(userId,tweetId,self.time)]\\n        else:\\n            self.tw[userId]=[tweet(userId,tweetId,self.time)]\\n        self.time-=1\\n\\n    def getNewsFeed(self, userId: int) -> List[int]:\\n        res=[]\\n        heap=[]\\n        if userId in self.tw:\\n            for i in self.tw[userId]:\\n                heapq.heappush(heap,i)\\n        if userId in self.follow:\\n            for i in self.follow[userId]:\\n                if i in self.tw:\\n                    for j in self.tw[i]:\\n                       heapq.heappush(heap,j)\\n\\n        while(heap and len(res)<10):\\n            res.append(heapq.heappop(heap).user)\\n        return res\\n\\n\\n    def follow(self, followerId: int, followeeId: int) -> None:\\n        if followeeId in self.follow:\\n            self.follow[followeeId]+=[followerId]\\n        else:\\n            self.follow[followeeId]=[followerId]\\n\\n    def unfollow(self, followerId: int, followeeId: int) -> None:\\n        for i in range(len(self.follow[followeeId])):\\n            if self.follow[followeeId][i]==followerId:\\n                self.follow[followeeId].pop(i)\\n        \\n        \\n\\n\\n# Your Twitter object will be instantiated and called as such:\\n# obj = Twitter()\\n# obj.postTweet(userId,tweetId)\\n# param_2 = obj.getNewsFeed(userId)\\n# obj.follow(followerId,followeeId)\\n# obj.unfollow(followerId,followeeId):\\n"
                    },
                    {
                        "username": "thisisphan",
                        "content": "This is a good question, but it need more clarification on edge cases.\nFor example, from the test cases, it looks like the tweetID is always incrementing and could be used to check which tweet came first.\nHowever, this is not the case."
                    },
                    {
                        "username": "g1patil",
                        "content": "Lot of requirements are missing. For example , once you start unfollowing , we need to clean their timeline. \nAlso once you start following someone, you will start seeing the onwards tweets. Look like requirement here is , once they start following someone, that person tweets should be right away get populated. This is could become very complex.  Or simply, once you follow someone, your timeline should be refreshed with tweets that you \"missed\" ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Twitter(object):\\n\\n    def __init__(self):\\n        self.timer = itertools.count(step=-1)\\n        self.tweets = collections.defaultdict(collections.deque)\\n        self.followees = collections.defaultdict(set)\\n\\n    def postTweet(self, userId, tweetId):\\n        self.tweets[userId].appendleft((next(self.timer), tweetId))\\n\\n    def getNewsFeed(self, userId):\\n        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))\\n        return [t for _, t in itertools.islice(tweets, 10)]\\n\\n    def follow(self, followerId, followeeId):\\n        self.followees[followerId].add(followeeId)\\n\\n    def unfollow(self, followerId, followeeId):\\n        self.followees[followerId].discard(followeeId)\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "z57909160",
                        "content": "This is exactly same with \"merge k sorted list\", to store user tweets, it is better use either ListNode or LinkedList which has next pointer to make it easier for enqueue the next most recent one."
                    }
                ]
            }
        ]
    },
    {
        "title": "Assign Cookies",
        "question_content": "<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>\n\n<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2,3], s = [1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2], s = [1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= g.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= g[i], s[j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 93987,
                "title": "simple-greedy-java-solution",
                "content": "```\\nArrays.sort(g);\\nArrays.sort(s);\\nint i = 0;\\nfor(int j=0;i<g.length && j<s.length;j++) {\\n\\tif(g[i]<=s[j]) i++;\\n}\\nreturn i;\\n```\\n\\nJust assign the cookies starting from the child with less greediness to maximize the number of happy children .",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nArrays.sort(g);\\nArrays.sort(s);\\nint i = 0;\\nfor(int j=0;i<g.length && j<s.length;j++) {\\n\\tif(g[i]<=s[j]) i++;\\n}\\nreturn i;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94063,
                "title": "simple-python-o-nlogn",
                "content": "```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()\\n        s.sort()\\n        \\n        childi = 0\\n        cookiei = 0\\n        \\n        while cookiei < len(s) and childi < len(g):\\n            if s[cookiei] >= g[childi]:\\n                childi += 1\\n            cookiei += 1\\n        \\n        return childi\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()\\n        s.sort()\\n        \\n        childi = 0\\n        cookiei = 0\\n        \\n        while cookiei < len(s) and childi < len(g):\\n            if s[cookiei] >= g[childi]:\\n                childi += 1\\n            cookiei += 1\\n        \\n        return childi\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93991,
                "title": "easy-understanding-c-solution-o-nlogn",
                "content": "````  \\n  int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0, j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(s[j]>=g[i])\\n                i++; // when the child get the cookie, foward child by 1\\n            j++;\\n        }\\n        return i;\\n    }\\n````",
                "solutionTags": [],
                "code": "````  \\n  int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0, j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(s[j]>=g[i])\\n                i++; // when the child get the cookie, foward child by 1\\n            j++;\\n        }\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210952,
                "title": "python3",
                "content": "```\\n# \\u5148\\u5BF9g, s\\u4E24\\u4E2A\\u6570\\u7EC4\\u8FDB\\u884C\\u6392\\u5E8F\\n# \\u8D2A\\u5FC3\\u7B97\\u6CD5\\n# \\u8D2A\\u5FC3\\u601D\\u60F31 \\u4F18\\u5148\\u6EE1\\u8DB3\\u9700\\u6C42\\u56E0\\u5B50\\u8F83\\u5C0F\\u7684\\u5B69\\u5B50\\u3002\\u56E0\\u4E3A\\u5982\\u679C\\u8F83\\u5C0F\\u9700\\u6C42\\u7684\\u5B69\\u5B50\\u65E0\\u6CD5\\u88AB\\u6EE1\\u8DB3\\uFF0C\\u5219\\u4E4B\\u540E\\u7684\\u8F83\\u5927\\u7684\\u9700\\u6C42\\u66F4\\u4E0D\\u53EF\\u80FD\\u80FD\\u88AB\\u6EE1\\u8DB3\\u4E86\\u3002\\n#\\u8D2A\\u5FC3\\u601D\\u60F32 \\u5C3D\\u91CF\\u7528\\u8F83\\u5C0F\\u7684\\u7CD6\\u679C\\u53BB\\u4F18\\u5148\\u6EE1\\u8DB3\\u5B69\\u5B50\\u3002\\n\\nclass Solution:\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()    # \\u5BF9\\u9700\\u6C42\\u56E0\\u5B50\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u4ECE\\u5C0F\\u5230\\u5927\\n        s.sort()    # \\u5BF9\\u7CD6\\u679C\\u6570\\u7EC4\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u4ECE\\u5C0F\\u5230\\u5927\\n        child  = 0  # \\u8BB0\\u5F55\\u53EF\\u4EE5\\u88AB\\u6EE1\\u8DB3\\u5B69\\u5B50\\u6570\\n        cookie = 0  # \\u8BB0\\u5F55\\u53EF\\u4EE5\\u6EE1\\u8DB3\\u7684\\u7CD6\\u679C\\u6570\\n        while  child <len(g) and cookie < len(s):\\n            if g[child] <= s[cookie]: \\n                child += 1\\n            cookie += 1\\n        return child\\n```",
                "solutionTags": [],
                "code": "```\\n# \\u5148\\u5BF9g, s\\u4E24\\u4E2A\\u6570\\u7EC4\\u8FDB\\u884C\\u6392\\u5E8F\\n# \\u8D2A\\u5FC3\\u7B97\\u6CD5\\n# \\u8D2A\\u5FC3\\u601D\\u60F31 \\u4F18\\u5148\\u6EE1\\u8DB3\\u9700\\u6C42\\u56E0\\u5B50\\u8F83\\u5C0F\\u7684\\u5B69\\u5B50\\u3002\\u56E0\\u4E3A\\u5982\\u679C\\u8F83\\u5C0F\\u9700\\u6C42\\u7684\\u5B69\\u5B50\\u65E0\\u6CD5\\u88AB\\u6EE1\\u8DB3\\uFF0C\\u5219\\u4E4B\\u540E\\u7684\\u8F83\\u5927\\u7684\\u9700\\u6C42\\u66F4\\u4E0D\\u53EF\\u80FD\\u80FD\\u88AB\\u6EE1\\u8DB3\\u4E86\\u3002\\n#\\u8D2A\\u5FC3\\u601D\\u60F32 \\u5C3D\\u91CF\\u7528\\u8F83\\u5C0F\\u7684\\u7CD6\\u679C\\u53BB\\u4F18\\u5148\\u6EE1\\u8DB3\\u5B69\\u5B50\\u3002\\n\\nclass Solution:\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()    # \\u5BF9\\u9700\\u6C42\\u56E0\\u5B50\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u4ECE\\u5C0F\\u5230\\u5927\\n        s.sort()    # \\u5BF9\\u7CD6\\u679C\\u6570\\u7EC4\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u4ECE\\u5C0F\\u5230\\u5927\\n        child  = 0  # \\u8BB0\\u5F55\\u53EF\\u4EE5\\u88AB\\u6EE1\\u8DB3\\u5B69\\u5B50\\u6570\\n        cookie = 0  # \\u8BB0\\u5F55\\u53EF\\u4EE5\\u6EE1\\u8DB3\\u7684\\u7CD6\\u679C\\u6570\\n        while  child <len(g) and cookie < len(s):\\n            if g[child] <= s[cookie]: \\n                child += 1\\n            cookie += 1\\n        return child\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93997,
                "title": "array-sort-two-pointer-greedy-solution-o-nlogn",
                "content": "To assign cookies to children optimaly we should give for each child the closest higher cookie. By using this greedy approach overall sum of wasted cookies will be minimum amoung all. To use this greedy solution in effective way we can sort both arrays and use two pointers. We should move pointer of children only if there is enough cookies to make that child content. In each step we will try to make content child at position pointerG by searching the closes higher cookie value.\\n```\\npublic class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int pointG = 0;\\n        int pointS = 0;\\n        \\n        while (pointG<g.length && pointS<s.length) {\\n            if (g[pointG]<=s[pointS]) {\\n                pointG++;\\n                pointS++;\\n            } else {\\n                pointS++;\\n            }\\n        }\\n        \\n        return pointG;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int pointG = 0;\\n        int pointS = 0;\\n        \\n        while (pointG<g.length && pointS<s.length) {\\n            if (g[pointG]<=s[pointS]) {\\n                pointG++;\\n                pointS++;\\n            } else {\\n                pointS++;\\n            }\\n        }\\n        \\n        return pointG;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841313,
                "title": "simple-js-solution",
                "content": "```\\nvar findContentChildren = function(g, s) {\\n    g.sort((a,b) => a-b);\\n    s.sort((a,b) => a-b);\\n    let j = 0, res = 0;\\n    for (let num of s) {\\n        if (num >= g[j]) res++, j++;\\n    }\\n    return res;\\n    // Time Complexity: O(nlogn)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findContentChildren = function(g, s) {\\n    g.sort((a,b) => a-b);\\n    s.sort((a,b) => a-b);\\n    let j = 0, res = 0;\\n    for (let num of s) {\\n        if (num >= g[j]) res++, j++;\\n    }\\n    return res;\\n    // Time Complexity: O(nlogn)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2627736,
                "title": "python-easy-to-understand-simple",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        i, j, ans = 0, 0, 0\\n        g.sort()\\n        s.sort()\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                ans, i = ans + 1, i + 1\\n            j += 1\\n        return ans\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        i, j, ans = 0, 0, 0\\n        g.sort()\\n        s.sort()\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                ans, i = ans + 1, i + 1\\n            j += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447681,
                "title": "c-java-python-js-fully-explained-greedy-two-pointers-heap-priority-queue-sorting",
                "content": "# Intuition:\\nThe problem requires us to maximize the number of children that can be content with a cookie. We can approach this by first sorting the greed factors of children and the sizes of cookies in non-decreasing order. Then we can assign cookies to children starting with the child with the lowest greed factor, as long as the cookie size is at least as big as the child\\'s greed factor.\\n\\n# Approach\\n## Greedy Algorithm:\\n1. Sort the greed factors of children and the sizes of cookies in non-decreasing order.\\n2. Initialize a variable contentChildren to 0 to keep track of the number of children that can be content with a cookie.\\n3. Use two pointers i and j to point to the current child\\'s greed factor and the current cookie size, respectively.\\n4. Iterate over the two sorted arrays, and for each cookie size, check if it can satisfy the current child\\'s greed factor. If so, assign the cookie to the child, increment contentChildren and move on to the next child and cookie. If not, move on to the next cookie.\\n5. Return contentChildren.\\n## Max Heap Algorithm:\\n\\n1. Sort the greed factors of children and the sizes of cookies in non-increasing order.\\n2. Initialize a variable contentChildren to 0 to keep track of the number of children that can be content with a cookie.\\n3. Use two pointers i and j to point to the current child\\'s greed factor and the current cookie size, respectively.\\n4. Use a max heap (priority_queue) to store the available cookie sizes.\\n5. Iterate over the two sorted arrays, and for each cookie size, check if it can satisfy the current child\\'s greed factor. If so, assign the cookie to the child, increment contentChildren and move on to the next child and cookie. If not, add the cookie to the max heap.\\n6. Use the remaining cookies in the heap to satisfy the remaining children. While the heap is not empty and there are still children to be satisfied, check if the top cookie in the heap can satisfy the current child\\'s greed factor. If so, assign the cookie to the child, increment contentChildren and remove the cookie from the heap. If not, break out of the loop.\\n7. Return contentChildren.\\n\\n# Complexity:\\n## Time Complexity:\\nBoth approaches involve sorting the arrays, which takes O(n log n) time. Then we iterate over the arrays, which takes O(n) time. Using a priority_queue adds an additional O(log n) time per insertion and removal, so the max heap approach has a slightly higher time complexity. Therefore, the time complexity of both approaches is O(n log n).\\n\\n## Space Complexity:\\nBoth approaches use O(1) extra space for the pointers and variables. The max heap approach uses O(n) extra space for the priority_queue. \\n- Therefore the space complexity of the greedy algorithm is O(1) and the space complexity of the max heap algorithm is O(n).\\n\\n# C++\\n## Greedy Algorithm\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end()); // sort the children\\'s greed factors in non-decreasing order\\n        sort(s.begin(), s.end()); // sort the cookie sizes in non-decreasing order\\n        int contentChildren = 0;\\n        int i = 0; // pointer to the current child\\'s greed factor\\n        int j = 0; // pointer to the current cookie size\\n        while (i < g.size() && j < s.size()) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return contentChildren;\\n    }\\n};\\n```\\n## Max Heap\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        // Sort the children\\'s greed factors and the cookies\\' sizes in non-increasing order\\n        sort(g.rbegin(), g.rend());\\n        sort(s.rbegin(), s.rend());\\n        \\n        int contentChildren = 0;\\n        int i = 0; // Index for the children\\'s greed factors\\n        int j = 0; // Index for the cookies\\' sizes\\n        \\n        // Use a max heap to store the available cookie sizes\\n        priority_queue<int> pq;\\n        while (i < g.size() && j < s.size()) {\\n            if (s[j] >= g[i]) {\\n                contentChildren++; // Assign the cookie to the child\\n                i++; // Move on to the next child\\n                j++; // Move on to the next cookie\\n            } else {\\n                pq.push(s[j]); // Add the cookie to the heap\\n                j++; // Move on to the next cookie\\n            }\\n        }\\n        // Use the remaining cookies in the heap to satisfy the remaining children\\n        while (i < g.size() && !pq.empty()) {\\n            if (pq.top() >= g[i]) {\\n                contentChildren++; // Assign the cookie to the child\\n                i++; // Move on to the next child\\n                pq.pop(); // Remove the cookie from the heap\\n            } else {\\n                break; // The remaining cookies in the heap are too small to satisfy the remaining children\\n            }\\n        }\\n        return contentChildren;\\n    }\\n};\\n\\n```\\n# JavaScript\\n## Greedy Algorithm\\n```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nfunction findContentChildren(g, s) {\\n        g.sort((a, b) => a - b); // sort the children\\'s greed factors in non-decreasing order\\n        s.sort((a, b) => a - b); // sort the cookie sizes in non-decreasing order\\n        let contentChildren = 0;\\n        let i = 0; // pointer to the current child\\'s greed factor\\n        let j = 0; // pointer to the current cookie size\\n        while (i < g.length && j < s.length) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n        j++;\\n    }\\n    return contentChildren;\\n};\\n```\\n\\n# Java\\n## Greedy Algorithm\\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g); // sort the children\\'s greed factors in non-decreasing order\\n        Arrays.sort(s); // sort the cookie sizes in non-decreasing order\\n        int contentChildren = 0;\\n        int i = 0; // pointer to the current child\\'s greed factor\\n        int j = 0; // pointer to the current cookie size\\n        while (i < g.length && j < s.length) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n    return contentChildren;\\n    }\\n}        \\n```\\n# Python\\n## Greedy Algorithm\\n```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        g.sort() # sort the children\\'s greed factors in non-decreasing order\\n        s.sort() # sort the cookie sizes in non-decreasing order\\n        contentChildren = 0\\n        i = 0 # pointer to the current child\\'s greed factor\\n        j = 0 # pointer to the current cookie size\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]: # if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren += 1\\n                i += 1\\n            j += 1\\n        return contentChildren\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end()); // sort the children\\'s greed factors in non-decreasing order\\n        sort(s.begin(), s.end()); // sort the cookie sizes in non-decreasing order\\n        int contentChildren = 0;\\n        int i = 0; // pointer to the current child\\'s greed factor\\n        int j = 0; // pointer to the current cookie size\\n        while (i < g.size() && j < s.size()) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return contentChildren;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        // Sort the children\\'s greed factors and the cookies\\' sizes in non-increasing order\\n        sort(g.rbegin(), g.rend());\\n        sort(s.rbegin(), s.rend());\\n        \\n        int contentChildren = 0;\\n        int i = 0; // Index for the children\\'s greed factors\\n        int j = 0; // Index for the cookies\\' sizes\\n        \\n        // Use a max heap to store the available cookie sizes\\n        priority_queue<int> pq;\\n        while (i < g.size() && j < s.size()) {\\n            if (s[j] >= g[i]) {\\n                contentChildren++; // Assign the cookie to the child\\n                i++; // Move on to the next child\\n                j++; // Move on to the next cookie\\n            } else {\\n                pq.push(s[j]); // Add the cookie to the heap\\n                j++; // Move on to the next cookie\\n            }\\n        }\\n        // Use the remaining cookies in the heap to satisfy the remaining children\\n        while (i < g.size() && !pq.empty()) {\\n            if (pq.top() >= g[i]) {\\n                contentChildren++; // Assign the cookie to the child\\n                i++; // Move on to the next child\\n                pq.pop(); // Remove the cookie from the heap\\n            } else {\\n                break; // The remaining cookies in the heap are too small to satisfy the remaining children\\n            }\\n        }\\n        return contentChildren;\\n    }\\n};\\n\\n```\n```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nfunction findContentChildren(g, s) {\\n        g.sort((a, b) => a - b); // sort the children\\'s greed factors in non-decreasing order\\n        s.sort((a, b) => a - b); // sort the cookie sizes in non-decreasing order\\n        let contentChildren = 0;\\n        let i = 0; // pointer to the current child\\'s greed factor\\n        let j = 0; // pointer to the current cookie size\\n        while (i < g.length && j < s.length) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n        j++;\\n    }\\n    return contentChildren;\\n};\\n```\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g); // sort the children\\'s greed factors in non-decreasing order\\n        Arrays.sort(s); // sort the cookie sizes in non-decreasing order\\n        int contentChildren = 0;\\n        int i = 0; // pointer to the current child\\'s greed factor\\n        int j = 0; // pointer to the current cookie size\\n        while (i < g.length && j < s.length) {\\n            if (s[j] >= g[i]) { // if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n    return contentChildren;\\n    }\\n}        \\n```\n```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        g.sort() # sort the children\\'s greed factors in non-decreasing order\\n        s.sort() # sort the cookie sizes in non-decreasing order\\n        contentChildren = 0\\n        i = 0 # pointer to the current child\\'s greed factor\\n        j = 0 # pointer to the current cookie size\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]: # if the current cookie can satisfy the current child\\'s greed factor\\n                contentChildren += 1\\n                i += 1\\n            j += 1\\n        return contentChildren\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277329,
                "title": "455-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the findContentChildren function that takes in two lists of integers, g and s, and returns an integer representing the number of content children.\\n2. Sort the lists g and s in non-decreasing order using the sort() method.\\n3. Initialize two indices i and j to 0.\\n4. While i is less than the length of g and j is less than the length of s, do the following:\\na. Check if the current cookie s[j] is large enough to satisfy the current child\\'s greed g[i].\\nb. If the current cookie is large enough, increment i to indicate that the current child has been assigned a cookie.\\nc. Regardless of whether a cookie was assigned or not, increment j to move to the next cookie.\\n5. Return the value of i as the number of content children.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        i, j = 0, 0\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i += 1\\n            j += 1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        i, j = 0, 0\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i += 1\\n            j += 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407991,
                "title": "8ms-java-simplest-greedy-and-two-pointer-approach-explanatory-code",
                "content": "```\\n\\n//sort both the arrays, now both the greed and size array are arranged in increasing order,now start traversal from back \\n\\n//Our motive is to get top max size cookie which satisfies the greed traversing from largest to smallest..\\n\\n//keep 1st pointer on greed array(say i) on the last index(ie. i=g.size-1) and 2nd on size array (say j) on the last index (j=s.size-1).\\n\\n\\n// Keep moving only 1st pointer on greed array and as we find suitable size(s[j]>=g[i]) increase the count and then move both the pointers on the respective arrays.\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count=0;\\n        for(int i=g.length-1,j=s.length-1; j>=0 && i>=0 ;i--)\\n        {\\n            if(s[j]>=g[i]) \\n            {\\n                count++;\\n                j--;\\n            }\\n        }\\n        return count;\\n   }\\n}\\n\\n//time taken is nlog(n) for sorting and n for getting count,which makes it nlog(n)\\n\\n// if you found it helpful, please consider an upvote.\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n\\n//sort both the arrays, now both the greed and size array are arranged in increasing order,now start traversal from back \\n\\n//Our motive is to get top max size cookie which satisfies the greed traversing from largest to smallest..\\n\\n//keep 1st pointer on greed array(say i) on the last index(ie. i=g.size-1) and 2nd on size array (say j) on the last index (j=s.size-1).\\n\\n\\n// Keep moving only 1st pointer on greed array and as we find suitable size(s[j]>=g[i]) increase the count and then move both the pointers on the respective arrays.\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count=0;\\n        for(int i=g.length-1,j=s.length-1; j>=0 && i>=0 ;i--)\\n        {\\n            if(s[j]>=g[i]) \\n            {\\n                count++;\\n                j--;\\n            }\\n        }\\n        return count;\\n   }\\n}\\n\\n//time taken is nlog(n) for sorting and n for getting count,which makes it nlog(n)\\n\\n// if you found it helpful, please consider an upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847595,
                "title": "c-solution-with-sort-two-pointer-easy-to-understand",
                "content": "If you think my solution is helpful,please give me a reputation : )\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n\\t\\t// g for children , s for cookie\\n        int len_g = g.size();\\n        int len_s = s.size();\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0,j = 0,ans = 0;\\n        while(i < len_g && j < len_s){\\n            if (s[j] >= g[i]){ // we alway want s[i] < g[j] , and if ( s[j] >= g[i] ) we get a answer,so we can get next element (cookie) by doing i++.\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n\\t\\t// g for children , s for cookie\\n        int len_g = g.size();\\n        int len_s = s.size();\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0,j = 0,ans = 0;\\n        while(i < len_g && j < len_s){\\n            if (s[j] >= g[i]){ // we alway want s[i] < g[j] , and if ( s[j] >= g[i] ) we get a answer,so we can get next element (cookie) by doing i++.\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553739,
                "title": "python-99-83-clean-explained-with-a-tip",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        gs,ss = sorted(g),sorted(s)\\n        c = 0\\n        while ss and gs:\\n            if ss[-1] >= gs[-1]:\\n                ss.pop()\\n                c += 1\\n            gs.pop()\\n        return c\\n```\\n\\nThe logic:\\n\\n1. First, we sort lists a prepare a counter `c`:\\n\\n```\\n        gs,ss = sorted(g),sorted(s)\\n        c = 0\\n```\\n\\n2. While we have something left in both lists we:\\n\\n- Pick the largest candy:\\n- Keep skipping kids if their grid factor is larger than the current candy\\n- If we find a kid who would be happy with the current candy - take that candy out of the list and increase the counter\\n```\\n        while ss and gs:\\n            if ss[-1] >= gs[-1]:\\n                ss.pop()\\n                c += 1\\n            gs.pop()\\n```\\n\\n3. Return the counter.\\n\\nOk, here is a tip. While some solutions use pointers, if you use `pop()`, that saves two pointers and allows us to get away with only 3 extra variables insted of 5.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        gs,ss = sorted(g),sorted(s)\\n        c = 0\\n        while ss and gs:\\n            if ss[-1] >= gs[-1]:\\n                ss.pop()\\n                c += 1\\n            gs.pop()\\n        return c\\n```\n```\\n        gs,ss = sorted(g),sorted(s)\\n        c = 0\\n```\n```\\n        while ss and gs:\\n            if ss[-1] >= gs[-1]:\\n                ss.pop()\\n                c += 1\\n            gs.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401085,
                "title": "9-ms-faster-than-88-09-of-java-online-submissions-java-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int i =0,j=0,c=0;\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        \\n        for(;i< g.length;i++)\\n        {\\n                // System.out.println(s[j]+\" \"+g[i]);\\n \\n            while(j<s.length)\\n            {\\n                if(s[j]>=g[i] )\\n                {\\n                    // System.out.println(s[j]+\" \"+g[i]);\\n                    j++;c++;\\n                    break;\\n                }\\n                j++;\\n            }\\n        }\\n       \\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int i =0,j=0,c=0;\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        \\n        for(;i< g.length;i++)\\n        {\\n                // System.out.println(s[j]+\" \"+g[i]);\\n \\n            while(j<s.length)\\n            {\\n                if(s[j]>=g[i] )\\n                {\\n                    // System.out.println(s[j]+\" \"+g[i]);\\n                    j++;c++;\\n                    break;\\n                }\\n                j++;\\n            }\\n        }\\n       \\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94024,
                "title": "java-solution-with-binary-search-tree",
                "content": "```\\npublic class AssignCookies {\\n    public static int findContentChildren(int[] g, int[] s) {\\n    \\tint count = 0;\\n    \\tTreeMap<Integer,Integer> tree = new TreeMap<>();\\n    \\tfor(int temp : s){\\n    \\t\\tInteger num = tree.get(temp);\\n    \\t\\tnum = num==null?0:num;\\n    \\t\\ttree.put(temp,num+1);\\n    \\t}\\n    \\tfor(int temp : g){\\n    \\t\\tInteger targ = tree.ceilingKey(temp);\\n    \\t\\tif(targ!=null){\\n    \\t\\t\\tInteger num = tree.get(targ);\\n    \\t\\t\\tif(num>0){\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tif(num==1){\\n    \\t\\t\\t\\t\\ttree.remove(targ);\\n    \\t\\t\\t\\t}else{\\n                                        tree.put(targ, num - 1);\\n                                }\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class AssignCookies {\\n    public static int findContentChildren(int[] g, int[] s) {\\n    \\tint count = 0;\\n    \\tTreeMap<Integer,Integer> tree = new TreeMap<>();\\n    \\tfor(int temp : s){\\n    \\t\\tInteger num = tree.get(temp);\\n    \\t\\tnum = num==null?0:num;\\n    \\t\\ttree.put(temp,num+1);\\n    \\t}\\n    \\tfor(int temp : g){\\n    \\t\\tInteger targ = tree.ceilingKey(temp);\\n    \\t\\tif(targ!=null){\\n    \\t\\t\\tInteger num = tree.get(targ);\\n    \\t\\t\\tif(num>0){\\n    \\t\\t\\t\\tcount++;\\n    \\t\\t\\t\\tif(num==1){\\n    \\t\\t\\t\\t\\ttree.remove(targ);\\n    \\t\\t\\t\\t}else{\\n                                        tree.put(targ, num - 1);\\n                                }\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672401,
                "title": "java-sort-and-greedy",
                "content": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int res = 0, i = 0, j = 0, m = g.length, n = s.length;\\n        while (i < m && j < n) {\\n            if (g[i] > s[j]) j++;  // find next larger cookie\\n            else {  // assign the min content to the min cookie;\\n                res++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int res = 0, i = 0, j = 0, m = g.length, n = s.length;\\n        while (i < m && j < n) {\\n            if (g[i] > s[j]) j++;  // find next larger cookie\\n            else {  // assign the min content to the min cookie;\\n                res++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93990,
                "title": "a-few-solutions",
                "content": "Let input `g` be the cookie size we `need` and let input `s` be the cookie size we `have`.\\n\\nSort `need` and `have` to greedily consume each `i`<sup>th</sup> cookie if-and-only-if we `have` what we `need`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findContentChildren(need: IntArray, have: IntArray): Int {\\n        need.sort()\\n        have.sort()\\n        var (i, j) = Pair(0, 0)\\n        while (i < need.size && j < have.size) {\\n            if (need[i] <= have[j])\\n                ++i\\n            ++j\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findContentChildren = (need, have) => {\\n    need.sort((a, b) => a - b);\\n    have.sort((a, b) => a - b);\\n    let [i, j] = [0, 0];\\n    while (i < need.length && j < have.length) {\\n        if (need[i] <= have[j])\\n            ++i;\\n        ++j;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findContentChildren(self, need: List[int], have: List[int], i = 0, j = 0) -> int:\\n        need.sort()\\n        have.sort()\\n        while i < len(need) and j < len(have):\\n            if need[i] <= have[j]:\\n                i += 1\\n            j += 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn find_content_children(mut need: VI, mut have: VI) -> i32 {\\n        need.sort();\\n        have.sort();\\n        let (mut i, mut j) = (0, 0);\\n        while i < need.len() && j < have.len() {\\n            if need[i] <= have[j] {\\n                i += 1;\\n            }\\n            j += 1;\\n        }\\n        i as i32\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findContentChildren(VI& need, VI& have) {\\n        auto [i, j] = make_pair(0, 0);\\n        while (i < need.size() && j < have.size()) {\\n            if (need[i] <= have[j])\\n                ++i;\\n            ++j;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findContentChildren(need: IntArray, have: IntArray): Int {\\n        need.sort()\\n        have.sort()\\n        var (i, j) = Pair(0, 0)\\n        while (i < need.size && j < have.size) {\\n            if (need[i] <= have[j])\\n                ++i\\n            ++j\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet findContentChildren = (need, have) => {\\n    need.sort((a, b) => a - b);\\n    have.sort((a, b) => a - b);\\n    let [i, j] = [0, 0];\\n    while (i < need.length && j < have.length) {\\n        if (need[i] <= have[j])\\n            ++i;\\n        ++j;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def findContentChildren(self, need: List[int], have: List[int], i = 0, j = 0) -> int:\\n        need.sort()\\n        have.sort()\\n        while i < len(need) and j < len(have):\\n            if need[i] <= have[j]:\\n                i += 1\\n            j += 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn find_content_children(mut need: VI, mut have: VI) -> i32 {\\n        need.sort();\\n        have.sort();\\n        let (mut i, mut j) = (0, 0);\\n        while i < need.len() && j < have.len() {\\n            if need[i] <= have[j] {\\n                i += 1;\\n            }\\n            j += 1;\\n        }\\n        i as i32\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findContentChildren(VI& need, VI& have) {\\n        auto [i, j] = make_pair(0, 0);\\n        while (i < need.size() && j < have.size()) {\\n            if (need[i] <= have[j])\\n                ++i;\\n            ++j;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94009,
                "title": "simple-python-solution",
                "content": "    class Solution(object):\\n        def findContentChildren(self, g, s):\\n            g.sort()\\n            s.sort()\\n            i, j = 0, 0\\n            while i < len(g) and j < len(s):\\n                if s[j] >= g[i]:\\n                    i += 1\\n                j += 1\\n            return i",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def findContentChildren(self, g, s):\\n            g.sort()\\n            s.sort()\\n            i, j = 0, 0\\n            while i < len(g) and j < len(s):\\n                if s[j] >= g[i]:\\n                    i += 1\\n                j += 1\\n            return i",
                "codeTag": "Java"
            },
            {
                "id": 94002,
                "title": "python-concise-efficient-solution",
                "content": "My solution from the contest:\\n\\n```\\ndef findContentChildren(self, g, s):\\n    g.sort()\\n    s.sort()\\n    res = 0\\n    i = 0\\n    for e in s:\\n        if i == len(g):\\n            break\\n        if e >= g[i]:\\n            res += 1\\n            i += 1\\n    return res\\n```\\n\\nO(nlogn) time and O(1) space",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findContentChildren(self, g, s):\\n    g.sort()\\n    s.sort()\\n    res = 0\\n    i = 0\\n    for e in s:\\n        if i == len(g):\\n            break\\n        if e >= g[i]:\\n            res += 1\\n            i += 1\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3038770,
                "title": "easy-c-solution-greedy-approach-beats-85",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int n=g.size();\\n        int m=s.size();\\n        int i=0,j=0;\\n        int res=0;\\n        while(i<n && j<m ){\\n            if(s[j]>=g[i]){\\n                res++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int n=g.size();\\n        int m=s.size();\\n        int i=0,j=0;\\n        int res=0;\\n        while(i<n && j<m ){\\n            if(s[j]>=g[i]){\\n                res++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898724,
                "title": "simple-explanation",
                "content": "# Intuition\\nThink like dad\\uD83D\\uDC68\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66!\\n- You have a cookies & you first think how to give cookies to childrens :\\n- case1 : Random order\\n- case2 : Give minimum size cookie which child have minimum greed & then jump into another child (when first child satisfy).\\n- At the end you have maximum child feed.\\n# Approach\\n### case2\\n- Sort both g & s.\\n- Loop over cookie(s) & check it is satisy greed of child then increment child.\\n- return child.\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))  (sorting)\\n- Space complexity:\\nO(N) (sorting)\\n\\n# Code\\n```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\n        # Sort g & s\\n        g.sort()\\n        s.sort()\\n        \\n        # Set child to zero\\n        child = 0\\n        \\n        # Loop over s(cookies)\\n        for cookie in s:\\n            \\n            # If child greed satisfy\\n            if cookie >= g[child]:\\n                \\n                # Then increment child\\n                child += 1\\n                \\n            # If no child left\\n            if child == len(g):\\n                \\n                # Then return child\\n                return child\\n        \\n        # Return child\\n        return child\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\n        # Sort g & s\\n        g.sort()\\n        s.sort()\\n        \\n        # Set child to zero\\n        child = 0\\n        \\n        # Loop over s(cookies)\\n        for cookie in s:\\n            \\n            # If child greed satisfy\\n            if cookie >= g[child]:\\n                \\n                # Then increment child\\n                child += 1\\n                \\n            # If no child left\\n            if child == len(g):\\n                \\n                # Then return child\\n                return child\\n        \\n        # Return child\\n        return child\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704295,
                "title": "java-greedy-and-2-pointers-explained",
                "content": "**Idea:** \\n* Greedy and 2 pointers\\n* Sort both the arrays and maintain pointers at each array\\n* Move cookie pointer until greed at current pointer is greater than or equal to cookie-size at current pointer. \\n* Move greed pointer when condition is satisfied and increment count\\n>**T/S:** O(m lg m + n lg n)/O(m + n), where m = size(greed), n = size(cookieSize)\\n```\\npublic int findContentChildren(int[] greed, int[] cookieSize) {\\n\\tArrays.sort(greed);\\n\\tArrays.sort(cookieSize);\\n\\tvar child = 0;\\n\\n\\tfor (var cookie = 0; cookie < cookieSize.length && child < greed.length; cookie++)\\n\\t\\tif (cookieSize[cookie] >= greed[child])\\n\\t\\t\\tchild++;\\n\\n\\treturn child;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\npublic int findContentChildren(int[] greed, int[] cookieSize) {\\n\\tArrays.sort(greed);\\n\\tArrays.sort(cookieSize);\\n\\tvar child = 0;\\n\\n\\tfor (var cookie = 0; cookie < cookieSize.length && child < greed.length; cookie++)\\n\\t\\tif (cookieSize[cookie] >= greed[child])\\n\\t\\t\\tchild++;\\n\\n\\treturn child;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94008,
                "title": "c-short-solution",
                "content": "```   \\n int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=g.size()-1, j=s.size()-1,count = 0;\\n        while(i>=0 && j>=0)\\n        {\\n            if(g[i]>s[j]) i--;\\n            else if(g[i--]<=s[j--]) count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=g.size()-1, j=s.size()-1,count = 0;\\n        while(i>=0 && j>=0)\\n        {\\n            if(g[i]>s[j]) i--;\\n            else if(g[i--]<=s[j--]) count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416148,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346709,
                "title": "java-9ms-easy-85",
                "content": "# Please Upvote\\n\\n```\\nif(s.length == 0 || g.length == 0)\\n            return 0;\\n        int n = g.length > s.length ? g.length-1 : s.length-1;\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count = 0, i = s.length-1,j = g.length-1;\\n        while(n-- >= 0){\\n            if(i >= 0 && j >= 0 && s[i] >= g[j]){\\n                count++;\\n                i--;\\n                j--;\\n            }else if(j >= 0 && i >= 0 && s[i] < g[j])\\n                j--;\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nif(s.length == 0 || g.length == 0)\\n            return 0;\\n        int n = g.length > s.length ? g.length-1 : s.length-1;\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count = 0, i = s.length-1,j = g.length-1;\\n        while(n-- >= 0){\\n            if(i >= 0 && j >= 0 && s[i] >= g[j]){\\n                count++;\\n                i--;\\n                j--;\\n            }else if(j >= 0 && i >= 0 && s[i] < g[j])\\n                j--;\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806616,
                "title": "c-hashing-solution-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findContentChildren(vector<int>& g, vector<int>& s) {\\n\\t\\t//storing cookie size in a map\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\tmp[it]++;\\n\\t\\t\\t}\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(auto &it: g){\\n\\t\\t\\t //finding if there exist any cookie greater than or equal to child greed\\n\\t\\t\\t\\tauto itr=mp.lower_bound(it);\\n\\t\\t\\t\\tif(itr!=mp.end()){\\n\\t\\t\\t\\t\\t(*itr).second--;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tif((*itr).second==0){\\n\\t\\t\\t\\t\\t\\tmp.erase((*itr).first);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findContentChildren(vector<int>& g, vector<int>& s) {\\n\\t\\t//storing cookie size in a map\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto &it: s){\\n\\t\\t\\t\\tmp[it]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1733146,
                "title": "c-simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                cnt++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n#### **Please Upvote if Understood The Solution :)**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                cnt++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591727,
                "title": "python-greedy-solution",
                "content": "A greedy solution where we sort and greedy and size lists. Now loop through both the lists to greedily assign a greedy child a cookie based on the condition: s[j] >= g[i].\\n\\n\\nTime Complexity: O(nlogn) where n is max(g,s) sizes\\n```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        \\n        #Sort Greed Factor and Cookie Size\\n        g.sort()\\n        s.sort()\\n        \\n        #Initialise ans\\n        ans = 0\\n        \\n        i = 0\\n        j = 0\\n        \\n        while(i<len(g) and j<len(s)):\\n            \\n            #Cookie Assigned\\n            if(s[j] >= g[i]):\\n                ans += 1\\n                j += 1\\n                i += 1\\n            #Search if any cookie will be enough for greed    \\n            else:\\n                j += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        \\n        #Sort Greed Factor and Cookie Size\\n        g.sort()\\n        s.sort()\\n        \\n        #Initialise ans\\n        ans = 0\\n        \\n        i = 0\\n        j = 0\\n        \\n        while(i<len(g) and j<len(s)):\\n            \\n            #Cookie Assigned\\n            if(s[j] >= g[i]):\\n                ans += 1\\n                j += 1\\n                i += 1\\n            #Search if any cookie will be enough for greed    \\n            else:\\n                j += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264331,
                "title": "easy-to-understand-for-beginners-as-well",
                "content": "```\\nvar findContentChildren = function(g, s) {\\n    let count=0;\\n    let i=0,j=0;\\n    g.sort((a,b)=>a-b);\\n    s.sort((a,b)=>a-b);\\n    while(i<g.length && j<s.length){\\n        if(g[i]<=s[j]){\\n\\t\\t// if the child\\'s greed is less than or equal to cookie\\'s size then we have given that cookie to that child\\n            count++;\\n            i++;\\n            j++;\\n        }else {\\n\\t\\t// if the child\\'s greed is greater than cookie\\'s size then we have to look for next bigger sized cookie(as we have sorted)\\n            j++;\\n        }   \\n    }\\n    return count;\\n};\\n```\\nOr you can do the other way around, keeping the pointers at last position and decrementing.\\nBoth woks.\\nRuntime: 100 ms, faster than 90.46% of JavaScript online submissions for Assign Cookies.\\nMemory Usage: 41.1 MB, less than 63.36% of JavaScript online submissions for Assign Cookies.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findContentChildren = function(g, s) {\\n    let count=0;\\n    let i=0,j=0;\\n    g.sort((a,b)=>a-b);\\n    s.sort((a,b)=>a-b);\\n    while(i<g.length && j<s.length){\\n        if(g[i]<=s[j]){\\n\\t\\t// if the child\\'s greed is less than or equal to cookie\\'s size then we have given that cookie to that child\\n            count++;\\n            i++;\\n            j++;\\n        }else {\\n\\t\\t// if the child\\'s greed is greater than cookie\\'s size then we have to look for next bigger sized cookie(as we have sorted)\\n            j++;\\n        }   \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355290,
                "title": "faster-than-100",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        if not g or not s:\\n            return 0\\n        g.sort()\\n        s.sort()\\n        res = 0\\n        child_i = 0 \\n        for cake in s:\\n            if child_i >= len(g):\\n                return res\\n            if cake >= g[child_i]:\\n                res += 1\\n                child_i += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        if not g or not s:\\n            return 0\\n        g.sort()\\n        s.sort()\\n        res = 0\\n        child_i = 0 \\n        for cake in s:\\n            if child_i >= len(g):\\n                return res\\n            if cake >= g[child_i]:\\n                res += 1\\n                child_i += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93988,
                "title": "c-two-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        priority_queue<int, vector<int>, greater<int>> gq(g.begin(), g.end());\\n        priority_queue<int, vector<int>, greater<int>> sq(s.begin(), s.end());\\n        int res;\\n        while(!sq.empty() && !gq.empty())\\n        {\\n            if (sq.top()>=gq.top())\\n            {\\n                sq.pop();\\n                gq.pop();\\n                res++;\\n            }\\n            else\\n            {\\n                sq.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        priority_queue<int, vector<int>, greater<int>> gq(g.begin(), g.end());\\n        priority_queue<int, vector<int>, greater<int>> sq(s.begin(), s.end());\\n        int res;\\n        while(!sq.empty() && !gq.empty())\\n        {\\n            if (sq.top()>=gq.top())\\n            {\\n                sq.pop();\\n                gq.pop();\\n                res++;\\n            }\\n            else\\n            {\\n                sq.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763048,
                "title": "super-easy-solution",
                "content": "# Intuition:\\nThe problem requires us to maximize the number of children who can be content with the cookies they receive. To do this, we can sort both the children\\'s greed factors and the cookie sizes in descending order. This sorting allows us to start with the largest cookies and greediest children, ensuring that we satisfy the most demanding children first.\\n\\n# Approach:\\n\\nSort both the children and cookie arrays in descending order using sort() in C++.\\nInitialize two variables: curr to keep track of the current cookie index and count to count the number of content children.\\nIterate through the sorted children array.\\nCheck if curr is within the bounds of the cookie array and if the current cookie\\'s size is greater than or equal to the current child\\'s greed factor.\\nIf the condition is true, increment count and move to the next cookie by incrementing curr.\\nReturn the value of count as the maximum number of content children.\\n# Complexity Analysis:\\n\\nSorting the children array and cookie array takes O(N log N) time, where N is the number of elements in the respective arrays.\\nThe for loop iterates through the children array, which takes O(N) time.\\nThus, the overall time complexity of the solution is dominated by the sorting step, i.e., O(N log N).\\nThe space complexity is O(1) as we are using only a few variables to store the results, and no additional data structures are used\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& children, vector<int>& cookie) {\\n        sort(children.rbegin(),children.rend());\\n        sort(cookie.rbegin(),cookie.rend());\\n        int curr=0;\\n        int count=0;\\n        for(int i=0;i<children.size();i++){\\n            if(curr<cookie.size() && cookie[curr]>=children[i]){\\n                count++;\\n                curr++;\\n         }\\n      }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& children, vector<int>& cookie) {\\n        sort(children.rbegin(),children.rend());\\n        sort(cookie.rbegin(),cookie.rend());\\n        int curr=0;\\n        int count=0;\\n        for(int i=0;i<children.size();i++){\\n            if(curr<cookie.size() && cookie[curr]>=children[i]){\\n                count++;\\n                curr++;\\n         }\\n      }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057240,
                "title": "java-simple-easy-and-faster-solution",
                "content": "\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int m = g.length ; int n = s.length ;\\n        int i= 0; // Pointer for greed\\n        int j = 0 ; // Pointer for size \\n        int count = 0 ;\\n        while(i<m && j<n){\\n            if(s[j]<g[i]){\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int m = g.length ; int n = s.length ;\\n        int i= 0; // Pointer for greed\\n        int j = 0 ; // Pointer for size \\n        int count = 0 ;\\n        while(i<m && j<n){\\n            if(s[j]<g[i]){\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3034503,
                "title": "java-5-lines-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int idx = 0, count = 0, len = Math.min(g.length, s.length);\\n        for (int i = 0; i < len && idx < s.length; i++) count += s[idx++] >= g[i] ? 1 : (--i - i);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int idx = 0, count = 0, len = Math.min(g.length, s.length);\\n        for (int i = 0; i < len && idx < s.length; i++) count += s[idx++] >= g[i] ? 1 : (--i - i);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962960,
                "title": "c-easy-wasy-to-solve-the-question",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& child, vector<int>& s) {\\n        sort(child.rbegin(),child.rend());\\n        sort(s.rbegin(),s.rend());\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(i<child.size()){\\n            if(j<s.size() && s[j]>=child[i]){\\n                cnt++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& child, vector<int>& s) {\\n        sort(child.rbegin(),child.rend());\\n        sort(s.rbegin(),s.rend());\\n        int i=0,j=0;\\n        int cnt=0;\\n        while(i<child.size()){\\n            if(j<s.size() && s[j]>=child[i]){\\n                cnt++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954513,
                "title": "java-sorting-easy",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < g.length && j < s.length) {\\n            if (g[i] <= s[j]) {\\n                count++;\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(g * logg) + O(s * logs) + O(min(g, s))\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < g.length && j < s.length) {\\n            if (g[i] <= s[j]) {\\n                count++;\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(g * logg) + O(s * logs) + O(min(g, s))\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822137,
                "title": "c-easy-solution-tc-o-n-log-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int count=0;\\n       int i=0,j=0;\\n      while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n            j++;\\n            }\\n        }\\n        return count;\\n        }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int count=0;\\n       int i=0,j=0;\\n      while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n            j++;\\n            }\\n        }\\n        return count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479650,
                "title": "cpp-code-99-faster-using-single-for-loop",
                "content": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int i , j;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(i=0,j=0; i < g.size() && j < s.size();j++)\\n        {\\n            if(s[j] >= g[i])\\n            {\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int i , j;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(i=0,j=0; i < g.size() && j < s.size();j++)\\n        {\\n            if(s[j] >= g[i])\\n            {\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1352022,
                "title": "java-greedy-approach-easy-to-understand",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0, j = 0;\\n        int sum = 0;\\n        while (i < g.length && j < s.length) {\\n            if (g[i] <= s[j]) {\\n                sum++;\\n                i++; j++;\\n            }\\n            else j++;\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0, j = 0;\\n        int sum = 0;\\n        while (i < g.length && j < s.length) {\\n            if (g[i] <= s[j]) {\\n                sum++;\\n                i++; j++;\\n            }\\n            else j++;\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281475,
                "title": "python-sort-heap",
                "content": "We take a greedy approach! For each element in `g` (when it\\'s sorted), we find the first minimium in `s` that is greater than or equal to g.\\n\\n\\n```python\\nfrom heapq import *\\n\\n\\nclass Solution:\\n    \\n    def findContentChildren(self, g, s, score = 0):\\n                        \\n        heapify(s)\\n        \\n        for factor in sorted(g):\\n            \\n            if not s:\\n                break\\n                                            \\n            x = -1\\n            \\n            while x < factor and s:\\n                x = heappop(s)\\n                                    \\n            if x >= factor:\\n                score += 1\\n                \\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom heapq import *\\n\\n\\nclass Solution:\\n    \\n    def findContentChildren(self, g, s, score = 0):\\n                        \\n        heapify(s)\\n        \\n        for factor in sorted(g):\\n            \\n            if not s:\\n                break\\n                                            \\n            x = -1\\n            \\n            while x < factor and s:\\n                x = heappop(s)\\n                                    \\n            if x >= factor:\\n                score += 1\\n                \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218918,
                "title": "simple-greedy-java",
                "content": "Runtime: 6 ms, faster than 98.79% of Java online submissions for Assign Cookies.\\nMemory Usage: 39.5 MB, less than 82.14% of Java online submissions for Assign Cookies.\\n\\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i =0;\\n        int j =0;\\n        int result=0;\\n        while(i<g.length&&j<s.length){\\n            if(g[i] <= s[j]){\\n                result++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i =0;\\n        int j =0;\\n        int result=0;\\n        while(i<g.length&&j<s.length){\\n            if(g[i] <= s[j]){\\n                result++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147401,
                "title": "c-o-n-log-n-easy-solution",
                "content": "DO Upvote if you like this solution:\\n\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int n=g.size();\\n        int m=s.size();\\n        int j=0,maxx=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<m && j<n;i++)\\n        {\\n            if(s[i]>=g[j])\\n            {\\n                maxx++;\\n                j++;\\n            }\\n        }\\nreturn maxx;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int n=g.size();\\n        int m=s.size();\\n        int j=0,maxx=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<m && j<n;i++)\\n        {\\n            if(s[i]>=g[j])\\n            {\\n                maxx++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 957257,
                "title": "java-solution",
                "content": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n\\tArrays.sort(g);\\n\\tArrays.sort(s);\\n\\tint gCounter = 0;\\n\\tint sCounter = 0;\\n\\twhile (gCounter < g.length && sCounter < s.length) {\\n\\t\\tif (g[gCounter] > s[sCounter]) {\\n\\t\\t\\tsCounter++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tgCounter++;\\n\\t\\t\\tsCounter++;\\n\\t\\t}\\n\\t}\\n\\treturn gCounter;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n\\tArrays.sort(g);\\n\\tArrays.sort(s);\\n\\tint gCounter = 0;\\n\\tint sCounter = 0;\\n\\twhile (gCounter < g.length && sCounter < s.length) {\\n\\t\\tif (g[gCounter] > s[sCounter]) {\\n\\t\\t\\tsCounter++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tgCounter++;\\n\\t\\t\\tsCounter++;\\n\\t\\t}\\n\\t}\\n\\treturn gCounter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794993,
                "title": "java-2-pointer-approach-better-than-99-95-solutions",
                "content": "Runtime: 6 ms, faster than 99.95% of Java online submissions for Assign Cookies.\\nMemory Usage: 40.1 MB, less than 85.35% of Java online submissions for Assign Cookies.\\n\\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int gpointer=0, cpointer = 0, count=0;\\n        while(gpointer<g.length && cpointer<s.length)\\n        {\\n            if(g[gpointer]<=s[cpointer])\\n            {\\n                count++;\\n                gpointer++;\\n                cpointer++;\\n            }\\n            else\\n                cpointer++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int gpointer=0, cpointer = 0, count=0;\\n        while(gpointer<g.length && cpointer<s.length)\\n        {\\n            if(g[gpointer]<=s[cpointer])\\n            {\\n                count++;\\n                gpointer++;\\n                cpointer++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 709610,
                "title": "easy-to-read-java-faster-than-99-94",
                "content": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int answer = 0;\\n        int cookie = s.length - 1;\\n        int child = g.length - 1;\\n        while(cookie >= 0 && child >=0){\\n            if(g[child] <= s[cookie]){\\n                answer++;\\n                cookie--;\\n            } \\n            child--;\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int answer = 0;\\n        int cookie = s.length - 1;\\n        int child = g.length - 1;\\n        while(cookie >= 0 && child >=0){\\n            if(g[child] <= s[cookie]){\\n                answer++;\\n                cookie--;\\n            } \\n            child--;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677225,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int assigned = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (assigned < g.size() && s[i] >= g[assigned]) {\\n                assigned++;\\n            }\\n        }\\n        return assigned;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int assigned = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (assigned < g.size() && s[i] >= g[assigned]) {\\n                assigned++;\\n            }\\n        }\\n        return assigned;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396149,
                "title": "easy-c-solution-36ms-beats-97",
                "content": "Runtime: 36 ms, faster than 97.59% of C++ online submissions for Assign Cookies.\\nMemory Usage: 10.4 MB, less than 83.33% of C++ online submissions for Assign Cookies.\\n\\n```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int res = 0;\\n        int curr = 0;\\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(curr < g.size() && s[i] >= g[curr])\\n            {\\n                curr++;\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "Runtime: 36 ms, faster than 97.59% of C++ online submissions for Assign Cookies.\\nMemory Usage: 10.4 MB, less than 83.33% of C++ online submissions for Assign Cookies.\\n\\n```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int res = 0;\\n        int curr = 0;\\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(curr < g.size() && s[i] >= g[curr])\\n            {\\n                curr++;\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4082319,
                "title": "java-best-solution-o-nlogn",
                "content": "# Intuition\\nBased on the question, we first need to match the possible ways to concent the children. We can\\'t go with $$O(n2)$$ approach as the constrains for each input is $$O(10^4)$$, so this problem must be solved in $$O(nlogn)$$. \\n\\nHow about we sort the arrays and match the possible ways.\\n\\nFirst, I has sort both the arrays g and s. Once the arrays are sorted we traverse the arrays one by one and count the values where (g<=s).\\nBut, there is an issue with the mapping, all the possible values are being mapped to wrong position.\\n\\nEg: \\ns - 5 6 7 8 - is mapped to \\ng - 7 8 9 10\\nhere 7 is mapped to 5 and 8 is mapped to 6, and we get the result as 0.\\n\\nSo, we can match the shortest value of the g(greed) array to the match position.\\n\\nwhich will look as,\\n\\ns - 5 6 7 8 - is mapped to \\ng - - -  7 8 9 10 - where the values are correctly mapped.\\n\\n# Approach\\nFirst we sort both the arrays,\\nset a counter to count the maximum content of the children.\\nwe want to iterate to the end of the arrays at the same time, So we go with while loop.\\nSo, variable $$i$$ pointer for g(greed) and $$j$$ pointer for s(size).\\n\\niterating the while loop:\\nif the value of g is less than or equal to s then we move both the pointers of g and s along with incrementing the counter.\\nelse we only move the j pointer of s to match the g value. Hoping in turn, the greater value of s will match with smaller value of g.\\n\\nfinally we return count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ + $$O(nlogn)$$ - as we sort both the arrays,\\nthe iteration is $$O(g+s)$$, but it is $$O(n)$$ less than $$O(nlogn)$$\\nSo $$O(nlogn)$$ is the time complexity\\n\\n- Space complexity:\\n$$O(1)$$ - We are not using as additional space. Only pointers to iterate.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count =0;\\n        int i=0,j=0;\\n        while(i<g.length && j<s.length){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            } else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count =0;\\n        int i=0,j=0;\\n        while(i<g.length && j<s.length){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            } else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941622,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0,count=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]>s[j]){\\n                j++;\\n            }\\n            else if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0,count=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]>s[j]){\\n                j++;\\n            }\\n            else if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863989,
                "title": "beats-98-99-users-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to efficiently distribute the available cookies to the children with the goal of maximizing the number of content children.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach involves sorting the arrays g (representing the children\\'s greed factor) and s (representing the cookie sizes) in ascending order. This allows us to start with the least greedy child and the smallest cookie. We then iterate through the arrays, comparing the current child\\'s greed factor with the available cookie size. If the cookie is large enough to satisfy the child\\'s greed, we increment the count of content children and move on to the next child. The process continues until we have either distributed all cookies or satisfied all children.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        if(s.size()==0) return 0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int cnt=0;\\n        for(int i=0;cnt<g.size() && i<s.size();i++){\\n            if(s[i]>=g[cnt]){\\n                cnt++;\\n            }       \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        if(s.size()==0) return 0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int cnt=0;\\n        for(int i=0;cnt<g.size() && i<s.size();i++){\\n            if(s[i]>=g[cnt]){\\n                cnt++;\\n            }       \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266746,
                "title": "awesome-technique-lower-bound",
                "content": "# Intuition\\nUse of lower bound to find the closet element\\n\\n# Approach\\nfirst sort the size array so that we can apply the lower bound on it.\\n\\nNow start traversing the g array and at the same time check the lower bound of same element in the s array.\\n    If you find the element make Count++ and same time remove the used element from the s array, so that we avoid using duplicate.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(s.begin(), s.end());\\n\\n        int count = 0;\\n        for (int i = 0; i < g.size(); i++){\\n            auto x = lower_bound(s.begin(), s.end(), g[i]);\\n            if (x != s.end()){\\n                count++;\\n                s.erase(x);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(s.begin(), s.end());\\n\\n        int count = 0;\\n        for (int i = 0; i < g.size(); i++){\\n            auto x = lower_bound(s.begin(), s.end(), g[i]);\\n            if (x != s.end()){\\n                count++;\\n                s.erase(x);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898290,
                "title": "c-solution-97-35-time-78-82-space-sorting-with-search-and-memorization",
                "content": "# Complexity\\n- Time complexity: O( n.log(n) )\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s);\\n};\\n/***************************************************************/\\nint Solution::findContentChildren(vector<int>& g, vector<int>& s) {\\n    sort(g.begin(), g.end());\\n    sort(s.begin(), s.end());\\n    int sizeG = g.size(), sizeS = s.size(), i, j, lastJ=0, count=0,found;\\n    for(i = 0; i < sizeG; ++i) {\\n        for(j = lastJ, found=0; j < sizeS; ++j) {\\n            if (s[j] >= g[i]) {\\n                ++count;\\n                lastJ=j+1;\\n                found = 1;\\n                break;\\n            }\\n        }\\n        if(found == 0) {\\n            break;\\n        }\\n    }\\n    return count;\\n}\\n/***************************************************************/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s);\\n};\\n/***************************************************************/\\nint Solution::findContentChildren(vector<int>& g, vector<int>& s) {\\n    sort(g.begin(), g.end());\\n    sort(s.begin(), s.end());\\n    int sizeG = g.size(), sizeS = s.size(), i, j, lastJ=0, count=0,found;\\n    for(i = 0; i < sizeG; ++i) {\\n        for(j = lastJ, found=0; j < sizeS; ++j) {\\n            if (s[j] >= g[i]) {\\n                ++count;\\n                lastJ=j+1;\\n                found = 1;\\n                break;\\n            }\\n        }\\n        if(found == 0) {\\n            break;\\n        }\\n    }\\n    return count;\\n}\\n/***************************************************************/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805372,
                "title": "easiest-solution-c-plus-plus-sort-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int ans = 0,i=0,j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int ans = 0,i=0,j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671195,
                "title": "c-easy-approach-70-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int c=0,j=-1;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<g.size();i++)\\n        {          \\n            while(++j<s.size())\\n            {\\n                if(s[j]>=g[i])\\n                { c++;\\n                break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int c=0,j=-1;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<g.size();i++)\\n        {          \\n            while(++j<s.size())\\n            {\\n                if(s[j]>=g[i])\\n                { c++;\\n                break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645847,
                "title": "sort-greedy-short-readable-c",
                "content": "```\\n  int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int count = 0 , j=-1;\\n        for(int i=0; i<g.size(); i++){\\n            while(++j<s.size()){\\n                if(s[j]>=g[i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n    return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int count = 0 , j=-1;\\n        for(int i=0; i<g.size(); i++){\\n            while(++j<s.size()){\\n                if(s[j]>=g[i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n    return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618479,
                "title": "simple-swift-solution",
                "content": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        var size = s.sorted(by: >)\\n        var counter = 0\\n        for studentGreed in g.sorted(by: >) {\\n            if let maxCookieSize = size.first, maxCookieSize >= studentGreed {\\n                size.removeFirst()\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        var size = s.sorted(by: >)\\n        var counter = 0\\n        for studentGreed in g.sorted(by: >) {\\n            if let maxCookieSize = size.first, maxCookieSize >= studentGreed {\\n                size.removeFirst()\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575462,
                "title": "python3-greedy-2-pointers-approach",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n\\t\\t\\n        res, gi, si = 0, 0, 0\\n\\t\\t\\n        while gi < len(g) and si < len(s):\\n            if s[si] >= g[gi]:\\n                res += 1\\n                gi, si = gi + 1, si + 1\\n            else:\\n                si += 1\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n\\t\\t\\n        res, gi, si = 0, 0, 0\\n\\t\\t\\n        while gi < len(g) and si < len(s):\\n            if s[si] >= g[gi]:\\n                res += 1\\n                gi, si = gi + 1, si + 1\\n            else:\\n                si += 1\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503850,
                "title": "2-pointer-approach-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=g.length-1,j=s.length-1;\\n        int ans=0;\\n        while(i>=0 && j>=0){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i--;\\n                j--;\\n            }else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=g.length-1,j=s.length-1;\\n        int ans=0;\\n        while(i>=0 && j>=0){\\n            if(g[i]<=s[j]){\\n                ans++;\\n                i--;\\n                j--;\\n            }else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495442,
                "title": "two-approaches-solved-in-c-best-solutions",
                "content": "**1st Approach(Using two pointers)**:-....***Faster one***\\n\\nclass Solution {\\npublic:\\n\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0,sizeG=g.size(),sizeS=s.size(),count=0;\\n        while(i<sizeG && j<sizeS){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n\\n**2nd Approach(Using binary search):-**\\n\\nclass Solution {\\npublic:\\n\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        if(s.size()==0)\\n            return 0;\\n        int count=0;\\n        sort(s.begin(),s.end());\\n        for(auto it:g){\\n            if(s.size()==0)\\n                break;\\n            auto gt=lower_bound(s.begin(),s.end(),it);\\n            if(gt!=s.end()){\\n                count++;\\n                s.erase(gt);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n***Please Upvote If U Liked my Solution\\uD83D\\uDE42***",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0,sizeG=g.size(),sizeS=s.size(),count=0;\\n        while(i<sizeG && j<sizeS){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2463881,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int: \\n        if len(s)==0:\\n            return 0\\n        i=0\\n        j=0\\n        c=0\\n        g.sort()\\n        s.sort()\\n        while(i!=len(g) and len(s)!=j):\\n            if g[i]<=s[j]:\\n                c+=1\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        return c\\n```\\n**Please upvote if you found it helpful**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int: \\n        if len(s)==0:\\n            return 0\\n        i=0\\n        j=0\\n        c=0\\n        g.sort()\\n        s.sort()\\n        while(i!=len(g) and len(s)!=j):\\n            if g[i]<=s[j]:\\n                c+=1\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440826,
                "title": "js-sort-clean-code",
                "content": "```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n  g.sort((a, b) => a - b);\\n  s.sort((a, b) => a - b);\\n  \\n  let child = 0;\\n  for (const cookie of s) {\\n    if (cookie >= g[child]) child++;\\n  }\\n\\n  return child;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n  g.sort((a, b) => a - b);\\n  s.sort((a, b) => a - b);\\n  \\n  let child = 0;\\n  for (const cookie of s) {\\n    if (cookie >= g[child]) child++;\\n  }\\n\\n  return child;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395370,
                "title": "o-nlogn-python",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g=sorted(g)\\n        s=sorted(s)\\n        i=0\\n        j=0\\n        c=0\\n        while i<len(g) and j<len(s):\\n            if g[i]<=s[j]:\\n                c+=1\\n                i+=1\\n            j+=1\\n        return c\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g=sorted(g)\\n        s=sorted(s)\\n        i=0\\n        j=0\\n        c=0\\n        while i<len(g) and j<len(s):\\n            if g[i]<=s[j]:\\n                c+=1\\n                i+=1\\n            j+=1\\n        return c\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212703,
                "title": "python-simple-explanation",
                "content": "\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        # the logic is to give the children the smallest size cookie available to satisfy their greed\\n        # since child list is sorted, the next child will obviously ask for size >= previous size allocated\\n        \\n        i,j = 0,0\\n        res = 0\\n        while i<len(g) and j < len(s):\\n\\n            if g[i] <= s[j]:\\n                # if greed is less than size, then give the cookie and increment size and greed pointers\\n                i += 1\\n                j += 1\\n                res +=1\\n            else:\\n                # if greed is greater than size, we can\\'t allocate so just increment the size pointer to see \\n                # if next cookie size could satisfy the greed\\n                j+=1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\nsince we are incrementing j both in if and else, we can also write it as \\n```\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()        \\n        i,j = 0,0\\n        res = 0\\n        while i<len(g) and j < len(s):\\n\\n            if g[i] <= s[j]:\\n                i += 1\\n                res +=1\\n            j+=1\\n        return res \\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        # the logic is to give the children the smallest size cookie available to satisfy their greed\\n        # since child list is sorted, the next child will obviously ask for size >= previous size allocated\\n        \\n        i,j = 0,0\\n        res = 0\\n        while i<len(g) and j < len(s):\\n\\n            if g[i] <= s[j]:\\n                # if greed is less than size, then give the cookie and increment size and greed pointers\\n                i += 1\\n                j += 1\\n                res +=1\\n            else:\\n                # if greed is greater than size, we can\\'t allocate so just increment the size pointer to see \\n                # if next cookie size could satisfy the greed\\n                j+=1\\n\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\nsince we are incrementing j both in if and else, we can also write it as \\n```\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()        \\n        i,j = 0,0\\n        res = 0\\n        while i<len(g) and j < len(s):\\n\\n            if g[i] <= s[j]:\\n                i += 1\\n                res +=1\\n            j+=1\\n        return res \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2044106,
                "title": "idea-behind-greedy-code-explained-in-plain-english-with-code",
                "content": "**IDEA** - give the largest cookie to the most greedy only if it makes him content (else why waste it ;) . So either we end up giving that cookie to the most greedy child, so `content++` and `cookie--` or otherwise we move to the next child without consuming that cookie, so no `cookie--`.\\n```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int content=0;\\n        int child = g.length-1; // start with most greedy child\\n        int cookie = s.length-1; // start with largest cookie\\n        for( ; child>=0 && cookie>=0 ; child--){\\n            if(s[cookie]>=g[child]){ // if cookie satisfies child, then only give it\\n                content++;\\n                cookie--;\\n            }\\n        }\\n        return content;\\n}\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int content=0;\\n        int child = g.length-1; // start with most greedy child\\n        int cookie = s.length-1; // start with largest cookie\\n        for( ; child>=0 && cookie>=0 ; child--){\\n            if(s[cookie]>=g[child]){ // if cookie satisfies child, then only give it\\n                content++;\\n                cookie--;\\n            }\\n        }\\n        return content;\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2014277,
                "title": "c-sort-and-then-easy-compare",
                "content": "First sort arrays, then start from bigger end. If child cannot be satisfied then move to another child with lower greedy factor. If child can have cookie, then give it away and reduce both indexes.\\n\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int FindContentChildren(int[] g, int[] s)\\n    {\\n        Array.Sort(g);\\n        Array.Sort(s);\\n\\n        int childIndex = g.Length - 1;\\n        int cookieIndex = s.Length - 1;\\n\\n        int cookiesGiven = 0;\\n        while (childIndex >= 0 && cookieIndex >= 0)\\n        {\\n            if (g[childIndex] > s[cookieIndex])\\n            {\\n                childIndex--;\\n            }\\n            else\\n            {\\n                childIndex--;\\n                cookieIndex--;\\n                cookiesGiven++;\\n            }\\n        }\\n\\n        return cookiesGiven;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int FindContentChildren(int[] g, int[] s)\\n    {\\n        Array.Sort(g);\\n        Array.Sort(s);\\n\\n        int childIndex = g.Length - 1;\\n        int cookieIndex = s.Length - 1;\\n\\n        int cookiesGiven = 0;\\n        while (childIndex >= 0 && cookieIndex >= 0)\\n        {\\n            if (g[childIndex] > s[cookieIndex])\\n            {\\n                childIndex--;\\n            }\\n            else\\n            {\\n                childIndex--;\\n                cookieIndex--;\\n                cookiesGiven++;\\n            }\\n        }\\n\\n        return cookiesGiven;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600417,
                "title": "python3-simple-and-fast-solution-beat-95",
                "content": "```\\ndef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        # TOPIC: s can random to send to children, s[any j] >= g[any i] as much as possible\\n        # HOW: sort children in decrease order and s cookies as well. since most content should match with most cookies\\n        \\n        if not g or not s or len(g) == 0 or len(s) == 0: return 0\\n    \\n        res = 0\\n        \\n        g.sort(reverse=True)\\n        s.sort(reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(g) and j < len(s):\\n            if s[j] < g[i]:\\n                # cannot meet content, cur child need higher content, so find next less content\\n                i+=1\\n            else:\\n                res += 1\\n                i+=1\\n                j+=1\\n                \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        # TOPIC: s can random to send to children, s[any j] >= g[any i] as much as possible\\n        # HOW: sort children in decrease order and s cookies as well. since most content should match with most cookies\\n        \\n        if not g or not s or len(g) == 0 or len(s) == 0: return 0\\n    \\n        res = 0\\n        \\n        g.sort(reverse=True)\\n        s.sort(reverse=True)\\n        \\n        i = 0\\n        j = 0\\n        while i < len(g) and j < len(s):\\n            if s[j] < g[i]:\\n                # cannot meet content, cur child need higher content, so find next less content\\n                i+=1\\n            else:\\n                res += 1\\n                i+=1\\n                j+=1\\n                \\n        return res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1596746,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        children = len(g)\\n        cookies = len(s)\\n        i = j = 0\\n        while i < children and j < cookies:\\n            if g[i] <= s[j]:  # cookie j is big enough for child i\\n                i += 1\\n            j += 1\\n        return i",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        children = len(g)\\n        cookies = len(s)\\n        i = j = 0\\n        while i < children and j < cookies:\\n            if g[i] <= s[j]:  # cookie j is big enough for child i\\n                i += 1\\n            j += 1\\n        return i",
                "codeTag": "Java"
            },
            {
                "id": 1595706,
                "title": "simple-java-solution-98-faster",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=0;\\n        int j=0;\\n        while(i<g.length && j<s.length){\\n            if(s[j] >= g[i]){\\n                i++;\\n            }\\n           j++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=0;\\n        int j=0;\\n        while(i<g.length && j<s.length){\\n            if(s[j] >= g[i]){\\n                i++;\\n            }\\n           j++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570190,
                "title": "c-solution-sorting-greedy-approach",
                "content": "```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(g[i]>s[j]){\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(i<g.size() && j<s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(g[i]>s[j]){\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527004,
                "title": "assign-cookies-easy-c",
                "content": "```\\nint findContentChildren(vector<int>& children, vector<int>& cookies)\\n{\\n\\tsort(children.begin(), children.end());\\n\\tsort(cookies.begin(), cookies.end());\\n\\tint child = 0, cookie = 0;\\n\\twhile (child < children.size() && cookie < cookies.size())\\n\\t{\\n\\t\\tif (children[child] <= cookies[cookie]) \\n\\t\\t\\t++child;\\n\\t\\t    ++cookie;\\n\\t}\\n\\treturn child;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findContentChildren(vector<int>& children, vector<int>& cookies)\\n{\\n\\tsort(children.begin(), children.end());\\n\\tsort(cookies.begin(), cookies.end());\\n\\tint child = 0, cookie = 0;\\n\\twhile (child < children.size() && cookie < cookies.size())\\n\\t{\\n\\t\\tif (children[child] <= cookies[cookie]) \\n\\t\\t\\t++child;\\n\\t\\t    ++cookie;\\n\\t}\\n\\treturn child;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497934,
                "title": "simple-python-faster-than-100",
                "content": "The algorithm is simple.\\n\\n1. Sort the cookies and greed factor arrays\\n2. Since the input arrays are sorted, we can then have 2 pointers. One that keeps track of the current cookie we are looking at, and another keeps track of how many children were fed.\\n3. If a cookie is too small, then we need to move on to the next cookie, if it is good then we also need to move on to the next cookie. So we always move on to the next cookie.\\n4. If a cookie is too small, then we cannot shift the pointer that keeps track of how many children have been fed. If a cookie is the right size then we can move the pointer that keeps track of the child who was properly fed.\\n\\n```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        g_len = len(g)\\n        ans = 0\\n        for size in s:\\n            # If all of the cookies have been consumed, we can just return\\n            if ans >= g_len:\\n                return ans\\n            # If the cookie is acceptable, then a cookie is consumed and a child is satisfied\\n            if size >= g[ans]:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        g_len = len(g)\\n        ans = 0\\n        for size in s:\\n            # If all of the cookies have been consumed, we can just return\\n            if ans >= g_len:\\n                return ans\\n            # If the cookie is acceptable, then a cookie is consumed and a child is satisfied\\n            if size >= g[ans]:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488346,
                "title": "swift-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        \\n        var greed = g.sorted(by: <)\\n        var answer = 0\\n\\n        s.sorted(by: <).forEach{\\n            if greed.count > 0 && $0 >= greed.first! {\\n                greed.removeFirst()\\n                answer += 1\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        \\n        var greed = g.sorted(by: <)\\n        var answer = 0\\n\\n        s.sorted(by: <).forEach{\\n            if greed.count > 0 && $0 >= greed.first! {\\n                greed.removeFirst()\\n                answer += 1\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460261,
                "title": "c-solutions-by-sorting",
                "content": "```\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n   sort(g.begin(),g.end(), greater<int>());\\n   sort(s.begin(),s.end(), greater<int>());\\n   int i=0,j=0;\\n        int c=0;\\n    while(i<g.size() && j<s.size()){\\n      if(s[j]>=g[i]){\\n          j++;\\n          i++;\\n          c++;\\n         }\\n      else if(s[j]<g[i]){\\n          i++;\\n          }\\n        }\\n        return c;\\n        \\n          \\n        \\n    }\\n    ```",
                "solutionTags": [],
                "code": "```\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n   sort(g.begin(),g.end(), greater<int>());\\n   sort(s.begin(),s.end(), greater<int>());\\n   int i=0,j=0;\\n        int c=0;\\n    while(i<g.size() && j<s.size()){\\n      if(s[j]>=g[i]){\\n          j++;\\n          i++;\\n          c++;\\n         }\\n      else if(s[j]<g[i]){\\n          i++;\\n          }\\n        }\\n        return c;\\n        \\n          \\n        \\n    }\\n    ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450826,
                "title": "c-simple-beginner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i,j,p=0;\\n        i=g.size()-1;\\n        j=s.size()-1;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        while(i>=0 && j>=0){\\n            if(s[j]>=g[i]){\\n                i--;\\n                j--;\\n                p++;\\n            }\\n            else\\n                i--;         \\n        }\\n        return p;  \\n    }\\n};\\n```\\n\\n **Please upvote if I was able to help you! You can ask your doubts in comment box .**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i,j,p=0;\\n        i=g.size()-1;\\n        j=s.size()-1;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        while(i>=0 && j>=0){\\n            if(s[j]>=g[i]){\\n                i--;\\n                j--;\\n                p++;\\n            }\\n            else\\n                i--;         \\n        }\\n        return p;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404999,
                "title": "c-using-max-heap",
                "content": "```\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        priority_queue<int>g1,s1;\\n        for(int i=0;i<g.size();i++){\\n            g1.push(g[i]);\\n        }\\n        for(int i=0;i<s.size();i++){\\n            s1.push(s[i]);\\n        }\\n        \\n        int count=0;\\n        while(!g1.empty() && !s1.empty()){\\n            if(g1.top()>s1.top())\\n                g1.pop();\\n            else if(g1.top()<=s1.top()){\\n                count++;\\n                g1.pop();\\n                s1.pop();\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        priority_queue<int>g1,s1;\\n        for(int i=0;i<g.size();i++){\\n            g1.push(g[i]);\\n        }\\n        for(int i=0;i<s.size();i++){\\n            s1.push(s[i]);\\n        }\\n        \\n        int count=0;\\n        while(!g1.empty() && !s1.empty()){\\n            if(g1.top()>s1.top())\\n                g1.pop();\\n            else if(g1.top()<=s1.top()){\\n                count++;\\n                g1.pop();\\n                s1.pop();\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1334075,
                "title": "python-solution-two-pointers-o-nlogn",
                "content": "```python\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()  # O(nlogn)\\n        s.sort()  # O(nlogn)\\n        \\n        child_point = 0\\n        cookie_point = 0\\n        counter = 0\\n        \\n        # O(n)\\n        while child_point < len(g) and cookie_point < len(s):\\n            if g[child_point] <= s[cookie_point]:\\n                counter += 1\\n                child_point += 1\\n                cookie_point += 1\\n            else:\\n                cookie_point += 1\\n            \\n        return counter\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()  # O(nlogn)\\n        s.sort()  # O(nlogn)\\n        \\n        child_point = 0\\n        cookie_point = 0\\n        counter = 0\\n        \\n        # O(n)\\n        while child_point < len(g) and cookie_point < len(s):\\n            if g[child_point] <= s[cookie_point]:\\n                counter += 1\\n                child_point += 1\\n                cookie_point += 1\\n            else:\\n                cookie_point += 1\\n            \\n        return counter\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307160,
                "title": "golang-concise-solution",
                "content": "```\\nfunc findContentChildren(g []int, s []int) int {\\n    sort.Ints(g)\\n    sort.Ints(s)\\n    \\n    kidpos := 0\\n    cookiepos := 0\\n    \\n    for kidpos < len(g) && cookiepos < len(s){\\n        if s[cookiepos] >= g[kidpos]{ // if the size of the cookie is greater than or equal to the childs greed we are moving up the child pointer to the next child \\n            kidpos++\\n        }\\n        cookiepos++\\n    }\\n    \\n    return kidpos\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findContentChildren(g []int, s []int) int {\\n    sort.Ints(g)\\n    sort.Ints(s)\\n    \\n    kidpos := 0\\n    cookiepos := 0\\n    \\n    for kidpos < len(g) && cookiepos < len(s){\\n        if s[cookiepos] >= g[kidpos]{ // if the size of the cookie is greater than or equal to the childs greed we are moving up the child pointer to the next child \\n            kidpos++\\n        }\\n        cookiepos++\\n    }\\n    \\n    return kidpos\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284524,
                "title": "c-solution-using-heap",
                "content": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        \\n        priority_queue<int> children(g.begin(),g.end());\\n        priority_queue<int> cookies(s.begin(),s.end());\\n        \\n        int count=0;\\n        while(!children.empty() && !cookies.empty()){\\n            \\n            if(cookies.top() >= children.top()){\\n                count++;\\n                cookies.pop();\\n                children.pop();\\n            }\\n            else{\\n                children.pop();\\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n//         sort(g.begin(),g.end(),greater<int>{});\\n//         sort(s.begin(),s.end(),greater<int>{});\\n        \\n//         int i=0,j=0;\\n//         int count=0;\\n//         while(i<g.size() && j<s.size()){\\n//             if(s[j] >= g[i]){\\n//                 count++;\\n//                 i++;\\n//                 j++;\\n//             }\\n//             else{\\n//                 i++;\\n//             }\\n//         }\\n        \\n//         return count;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        \\n        priority_queue<int> children(g.begin(),g.end());\\n        priority_queue<int> cookies(s.begin(),s.end());\\n        \\n        int count=0;\\n        while(!children.empty() && !cookies.empty()){\\n            \\n            if(cookies.top() >= children.top()){\\n                count++;\\n                cookies.pop();\\n                children.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 907107,
                "title": "o-nlogn-java-soluion",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n    \\n        int start1 = 0;\\n        int start2 = 0;\\n        int count =0;\\n        while(start1<g.length && start2<s.length)\\n        {\\n            if(g[start1]<=s[start2])\\n            {\\n                start1++;\\n                start2++;\\n                count++;\\n            }\\n            else\\n                start2++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n    \\n        int start1 = 0;\\n        int start2 = 0;\\n        int count =0;\\n        while(start1<g.length && start2<s.length)\\n        {\\n            if(g[start1]<=s[start2])\\n            {\\n                start1++;\\n                start2++;\\n                count++;\\n            }\\n            else\\n                start2++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893432,
                "title": "c-greedy-solution",
                "content": "## Idea\\nSort ```g``` and ```s``` in ascending order. Start with the child that needs smallest cookie and give the smallest cookie at specific time, because bigger cookie have more chances to satisfy the next child with more greediness. We greedily take this strategy until there is no candies left or all children have one cookie. \\n\\n## Implemetation\\n```\\npublic class Solution {\\n    public int FindContentChildren(int[] g, int[] s) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(g);\\n        Array.Sort(s);\\n        \\n        int i = 0;\\n        \\n        for(int j = 0; j < s.Length && i < g.Length; j++)\\n        {\\n            if(s[j] >= g[i])\\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return i;\\n    }\\n}\\n```\\n\\n## Complexity\\n* Time: O(NlogN) where N is the sum of number of children and number of candies.\\n* Space: O(1)",
                "solutionTags": [],
                "code": "```g```\n```s```\n```\\npublic class Solution {\\n    public int FindContentChildren(int[] g, int[] s) {\\n        \\n        if(s == null || s.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(g);\\n        Array.Sort(s);\\n        \\n        int i = 0;\\n        \\n        for(int j = 0; j < s.Length && i < g.Length; j++)\\n        {\\n            if(s[j] >= g[i])\\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642618,
                "title": "c-clean-commented-code-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int totalChildren = g.size();\\n        int totalCookies = s.size();\\n        \\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int currChild = 0;\\n        int currCookie = 0;\\n        \\n        int totalContentedChildren  = 0;\\n        while(currChild < totalChildren && currCookie < totalCookies){\\n            if(s[currCookie] >= g[currChild]){\\n                totalContentedChildren++;\\n                currChild++;  // since the current child is contented, move on to the next child\\n                currCookie++; // the current cookie has been eaten by a child, move on to the next cookie\\n            }else{\\n                currCookie++; // try exploring cookies of larger size to satiate the current child\\n            }\\n        }\\n        \\n        return totalContentedChildren;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int totalChildren = g.size();\\n        int totalCookies = s.size();\\n        \\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int currChild = 0;\\n        int currCookie = 0;\\n        \\n        int totalContentedChildren  = 0;\\n        while(currChild < totalChildren && currCookie < totalCookies){\\n            if(s[currCookie] >= g[currChild]){\\n                totalContentedChildren++;\\n                currChild++;  // since the current child is contented, move on to the next child\\n                currCookie++; // the current cookie has been eaten by a child, move on to the next cookie\\n            }else{\\n                currCookie++; // try exploring cookies of larger size to satiate the current child\\n            }\\n        }\\n        \\n        return totalContentedChildren;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512890,
                "title": "easy-to-understand-simple-o-nlogn-iterative-solution",
                "content": "**Please do upvote, it motivates me to write more such post\\uD83D\\uDE03**\\n\\n```\\n\\t\\tcount = 0\\n        g.sort(reverse=True)\\n        s.sort(reverse=True)\\n        g_i = 0\\n        s_i = 0\\n        while g_i < len(g) and s_i < len(s):\\n            if g[g_i] <= s[s_i]:\\n                s_i += 1\\n                count += 1\\n            g_i += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n\\t\\tcount = 0\\n        g.sort(reverse=True)\\n        s.sort(reverse=True)\\n        g_i = 0\\n        s_i = 0\\n        while g_i < len(g) and s_i < len(s):\\n            if g[g_i] <= s[s_i]:\\n                s_i += 1\\n                count += 1\\n            g_i += 1\\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432753,
                "title": "javascript-greedy-faster-99-3-space-100",
                "content": "```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n    g = g.sort((a,b) => a-b)\\n    s = s.sort((a,b) => a-b)\\n    \\n    let i=0\\n    let count = 0;\\n    let j=0\\n    while(i<s.length){\\n        if(s[i] >= g[j]){\\n            count++\\n            j++\\n        }\\n        i++\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n    g = g.sort((a,b) => a-b)\\n    s = s.sort((a,b) => a-b)\\n    \\n    let i=0\\n    let count = 0;\\n    let j=0\\n    while(i<s.length){\\n        if(s[i] >= g[j]){\\n            count++\\n            j++\\n        }\\n        i++\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260588,
                "title": "python-sort",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g, s = sorted(g), sorted(s)\\n        i = j = res = 0\\n        while i < len(g) and j < len(s):\\n            if g[i] <= s[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g, s = sorted(g), sorted(s)\\n        i = j = res = 0\\n        while i < len(g) and j < len(s):\\n            if g[i] <= s[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 247483,
                "title": "python-solution-top-100-runtime",
                "content": "```\\n class Solution(object):\\n    def findContentChildren(self, g, s):\\n    \\n        # Sort Lists\\n        g.sort()\\n        s.sort()\\n\\t\\t\\n        # List lengths\\n        g_length = len(g)\\n        s_length = len(s)\\n        \\n\\t\\t# Check if either list is empty\\n        if (g_length == 0 or s_length == 0):\\n            return 0\\n        \\n\\t\\t# indexes and counters\\n        i = s_length - 1\\n        j = g_length - 1\\n        satisfied_children = 0\\n        while ( i >= 0 and j >= 0 ):\\n            if s[i] >= g[j]:\\n                satisfied_children += 1\\n                i -= 1\\n                j -= 1\\n            elif s[i] < g[j]:\\n                j -= 1\\n                \\n        return satisfied_children\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n class Solution(object):\\n    def findContentChildren(self, g, s):\\n    \\n        # Sort Lists\\n        g.sort()\\n        s.sort()\\n\\t\\t\\n        # List lengths\\n        g_length = len(g)\\n        s_length = len(s)\\n        \\n\\t\\t# Check if either list is empty\\n        if (g_length == 0 or s_length == 0):\\n            return 0\\n        \\n\\t\\t# indexes and counters\\n        i = s_length - 1\\n        j = g_length - 1\\n        satisfied_children = 0\\n        while ( i >= 0 and j >= 0 ):\\n            if s[i] >= g[j]:\\n                satisfied_children += 1\\n                i -= 1\\n                j -= 1\\n            elif s[i] < g[j]:\\n                j -= 1\\n                \\n        return satisfied_children\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126354,
                "title": "beats-100-concise-javascript",
                "content": "``` /**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n    g.sort(function(a, b) { return a - b})\\n    s.sort(function (a, b) { return a - b })\\n    var j = 0;\\n\\n    s.forEach((element) => { \\n        if (element >= g[j]) { \\n            j++\\n        }\\n    })\\n    return j  \\n};",
                "solutionTags": [],
                "code": "``` /**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nvar findContentChildren = function(g, s) {\\n    g.sort(function(a, b) { return a - b})\\n    s.sort(function (a, b) { return a - b })\\n    var j = 0;\\n\\n    s.forEach((element) => { \\n        if (element >= g[j]) { \\n            j++\\n        }\\n    })\\n    return j  \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 94027,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Assign Cookies** https://leetcode.com/problems/assign-cookies/\\n\\n**Greedy Algorithm**\\n* Sort greed array and cookie array. Then simply walk both arrays and match cookie to greed if greed is less than cookie.\\n```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()\\n        s.sort()\\n        i, j, cnt = 0,0,0\\n        while i < len(g) and j < len(s):\\n            if g[i] <= s[j]:\\n                cnt, i, j = cnt+1, i+1, j+1\\n            else:\\n                j += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g.sort()\\n        s.sort()\\n        i, j, cnt = 0,0,0\\n        while i < len(g) and j < len(s):\\n            if g[i] <= s[j]:\\n                cnt, i, j = cnt+1, i+1, j+1\\n            else:\\n                j += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94046,
                "title": "6-lines-simple-python-code",
                "content": "```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g, s = sorted(g), sorted(s)\\n        i, j= 0, 0\\n        while i != len(g) and j != len(s):\\n            if s[j] >= g[i]:\\n                 i = i+1\\n            j += 1\\n        \\n        return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findContentChildren(self, g, s):\\n        \"\"\"\\n        :type g: List[int]\\n        :type s: List[int]\\n        :rtype: int\\n        \"\"\"\\n        g, s = sorted(g), sorted(s)\\n        i, j= 0, 0\\n        while i != len(g) and j != len(s):\\n            if s[j] >= g[i]:\\n                 i = i+1\\n            j += 1\\n        \\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94052,
                "title": "python-solution-with-explanation-o-n-log-n",
                "content": "My solution considers that in order to satisfy children with as many cookies as possible, we have to satisfy the greediest children first. The next children will be less greedy, and so our smaller cookies will have better use on them. If we can't satisfy a greedy child with our largest cookie, we skip the child and try to feed a less greedy one.\\n\\n```\\n    def findContentChildren(self, g, s):\\n\\n        # sort both beforehand\\n        g.sort()\\n        s.sort()\\n        \\n        # count the number of satisfied children\\n        satisfied_count = 0\\n        \\n        # match the largest cookies to the largest child they can satisfy (skip children if you can't satisfy them)\\n        largest_cookie = None\\n        for child_greed in reversed(g):\\n            \\n            # pop a cookie if we have one left, and aren't currently trying to feed a child with one\\n            if largest_cookie is None and len(s) > 0:\\n                largest_cookie = s.pop()\\n                \\n            # check if we can satisfy the current child with this cookie\\n            if child_greed <= largest_cookie:\\n                \\n                # if we fed the child, reset the cookie size so we can replace it with the next largest one next round\\n                satisfied_count += 1\\n                largest_cookie = None\\n        \\n        # return the total number of satisfied children\\n        return satisfied_count\\n```\\n\\nThe solution uses O(1) extra memory since the sorts are in place, and ```reversed(g)``` is an iterator over the original list, and the time complexity is O(n log n), where ```n = max( len(g), len(s) )```, due to the larger sort being the operation that grows at the fastest rate as input size increases.",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\n    def findContentChildren(self, g, s):\\n\\n        # sort both beforehand\\n        g.sort()\\n        s.sort()\\n        \\n        # count the number of satisfied children\\n        satisfied_count = 0\\n        \\n        # match the largest cookies to the largest child they can satisfy (skip children if you can't satisfy them)\\n        largest_cookie = None\\n        for child_greed in reversed(g):\\n            \\n            # pop a cookie if we have one left, and aren't currently trying to feed a child with one\\n            if largest_cookie is None and len(s) > 0:\\n                largest_cookie = s.pop()\\n                \\n            # check if we can satisfy the current child with this cookie\\n            if child_greed <= largest_cookie:\\n                \\n                # if we fed the child, reset the cookie size so we can replace it with the next largest one next round\\n                satisfied_count += 1\\n                largest_cookie = None\\n        \\n        # return the total number of satisfied children\\n        return satisfied_count\\n```\n```reversed(g)```\n```n = max( len(g), len(s) )```",
                "codeTag": "Python3"
            },
            {
                "id": 4006643,
                "title": "cpp-fast-and-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.rbegin(),g.rend());\\n        sort(s.rbegin(),s.rend());\\n        int curr=0;\\n        int total=0;\\n        int n=g.size();\\n        int m=s.size();\\n        for(int i=0;i<n;i++){\\n            if(curr<m && g[i]<=s[curr]){\\n                total++;\\n                curr++;\\n            }\\n        }\\n        return total;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.rbegin(),g.rend());\\n        sort(s.rbegin(),s.rend());\\n        int curr=0;\\n        int total=0;\\n        int n=g.size();\\n        int m=s.size();\\n        for(int i=0;i<n;i++){\\n            if(curr<m && g[i]<=s[curr]){\\n                total++;\\n                curr++;\\n            }\\n        }\\n        return total;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962504,
                "title": "simple-10-line-solution-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int n = g.size(),m = s.size(),cnt = 0,i=0;\\n        priority_queue<int> pq1;\\n        for (int i = 0; i < n; i++) pq1.push(g[i]);\\n         priority_queue<int> pq2;\\n        for (int i = 0; i < m; i++) pq2.push(s[i]);\\n        while(i < g.size()){\\n        if (pq1.empty() || pq2.empty()) break;\\n        else if(pq1.top()<=pq2.top())cnt++,pq1.pop(),pq2.pop();\\n        else if(pq1.top()>pq2.top()) pq1.pop();\\n        i++;\\n    }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int n = g.size(),m = s.size(),cnt = 0,i=0;\\n        priority_queue<int> pq1;\\n        for (int i = 0; i < n; i++) pq1.push(g[i]);\\n         priority_queue<int> pq2;\\n        for (int i = 0; i < m; i++) pq2.push(s[i]);\\n        while(i < g.size()){\\n        if (pq1.empty() || pq2.empty()) break;\\n        else if(pq1.top()<=pq2.top())cnt++,pq1.pop(),pq2.pop();\\n        else if(pq1.top()>pq2.top()) pq1.pop();\\n        i++;\\n    }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863016,
                "title": "two-pointers-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n\\n        int i =0;\\n        int j=0;\\n        int count=0;\\n        int n = g.size(),m=s.size();\\n\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n\\n        while(i<n && j<m){\\n            if(s[j]>=g[i]){\\n                count++;\\n                j++;\\n                i++;\\n            }\\n            else{\\n                if(s[j]<g[i])\\n                   j++;\\n            }\\n           \\n        }\\n\\n      return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n\\n        int i =0;\\n        int j=0;\\n        int count=0;\\n        int n = g.size(),m=s.size();\\n\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n\\n        while(i<n && j<m){\\n            if(s[j]>=g[i]){\\n                count++;\\n                j++;\\n                i++;\\n            }\\n            else{\\n                if(s[j]<g[i])\\n                   j++;\\n            }\\n           \\n        }\\n\\n      return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849691,
                "title": "two-pointers-python-beats-99-19",
                "content": "# Complexity\\n- Time complexity:\\n    - After sorting, O(g).\\n    \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\n        g.sort()\\n        s.sort()\\n\\n        a = len(g) - 1\\n        b = len(s) - 1\\n        maxs = 0\\n\\n        while a >= 0 and b >= 0:\\n            if s[b] >= g[a]:\\n                maxs += 1\\n                a -= 1\\n                b -= 1\\n            else:\\n                a -= 1\\n        return maxs\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\n        g.sort()\\n        s.sort()\\n\\n        a = len(g) - 1\\n        b = len(s) - 1\\n        maxs = 0\\n\\n        while a >= 0 and b >= 0:\\n            if s[b] >= g[a]:\\n                maxs += 1\\n                a -= 1\\n                b -= 1\\n            else:\\n                a -= 1\\n        return maxs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705924,
                "title": "greedy-very-very-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int contentChildren=0;\\n        int i =0;\\n        int j =0;\\n        while(i<g.size()&&j<s.size()){\\n            if(s[j]>=g[i])\\n            {\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return contentChildren;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int contentChildren=0;\\n        int i =0;\\n        int j =0;\\n        while(i<g.size()&&j<s.size()){\\n            if(s[j]>=g[i])\\n            {\\n                contentChildren++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return contentChildren;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692970,
                "title": "two-pointer-approach-very-simple-to-understand-typescript-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we sort the array in ascending order. Then we take two pointers lets say greed pointer and cookie pointer.\\nWe iterate over the cookie array and check if we foind a cookie that satisfies the greed of the child where out greed pointer is located, if yes the only we increment both greed pointer and cookie pointer and also the counter, if no we only increment the cookie pointer and check the condition again.\\nAfter the loop exits, we return the counter.\\n\\n**If you like my solution please upvote. It motivates me a lot.**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findContentChildren(g: number[], s: number[]): number {\\n    let gpointer = 0\\n    let spointer = 0\\n    let counter = 0\\n    g.sort((a,b) => {return (a-b)})\\n    s.sort((a,b) => {return (a-b)})\\n    while(gpointer < g.length && spointer < s.length){\\n        if(s[spointer] >= g[gpointer]){\\n            counter ++\\n            gpointer ++\\n        }\\n\\n        spointer ++\\n    }\\n\\n    return counter\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nfunction findContentChildren(g: number[], s: number[]): number {\\n    let gpointer = 0\\n    let spointer = 0\\n    let counter = 0\\n    g.sort((a,b) => {return (a-b)})\\n    s.sort((a,b) => {return (a-b)})\\n    while(gpointer < g.length && spointer < s.length){\\n        if(s[spointer] >= g[gpointer]){\\n            counter ++\\n            gpointer ++\\n        }\\n\\n        spointer ++\\n    }\\n\\n    return counter\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685279,
                "title": "easy-to-understand-c-solution-o-n-logn-greedy-approach",
                "content": "# Intuition\\nTo find the optimal result ,the best approach would be to give the cookies same amount as greed of child.Or in case the same size cookie is not there then give the nearst bigger size cookie.This would lead to optimal result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst sort the both greed and size array. After that use two pointers approach and assign cookie in greedy way.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n// SORT BOTH THE GREED AND SIZE VECTOR\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n//USING TWO POINTER APPROACH\\n        while(i<g.size() && j<s.size())\\n        {\\n// IF THE GREED AND SIZE OF COOKIE IS SAME THEN ASSIGN THE COOKIE\\n            if(g[i]==s[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n\\n            else if(g[i]<s[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n     \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n// SORT BOTH THE GREED AND SIZE VECTOR\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n//USING TWO POINTER APPROACH\\n        while(i<g.size() && j<s.size())\\n        {\\n// IF THE GREED AND SIZE OF COOKIE IS SAME THEN ASSIGN THE COOKIE\\n            if(g[i]==s[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n\\n            else if(g[i]<s[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444779,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        while(i < g.size() && j < s.size()){\\n        if(s[j] >= g[i])\\n        i++;\\n        j++;\\n        }\\n        return i;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i=0,j=0;\\n        while(i < g.size() && j < s.size()){\\n        if(s[j] >= g[i])\\n        i++;\\n        j++;\\n        }\\n        return i;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363964,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end(),greater<int>());\\n        sort(s.begin(),s.end(),greater<int>());\\n        int n = g.size(),m = s.size();\\n        int ind = 0,cnt=0;\\n        for(int i=0;i<n && ind<m;i++){\\n           if(s[ind]>=g[i]){\\n               ind++;\\n               cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n\\n        ind = len(s) -1\\n        res  = 0\\n\\n        for i in range( len(g)-1,-1,-1):\\n            if ind >= 0 and g[i] <= s[ind]:\\n                res += 1\\n                ind -=1\\n\\n        return res\\n```\\n\\n```Java []\\nimport java.util.NavigableMap;\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int result = 0;\\n        int greedIndex = 0;\\n        int sizeIndex = 0;\\n\\n        while (greedIndex < g.length && sizeIndex < s.length) {\\n            if (s[sizeIndex++] >= g[greedIndex]) {\\n                greedIndex++;\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end(),greater<int>());\\n        sort(s.begin(),s.end(),greater<int>());\\n        int n = g.size(),m = s.size();\\n        int ind = 0,cnt=0;\\n        for(int i=0;i<n && ind<m;i++){\\n           if(s[ind]>=g[i]){\\n               ind++;\\n               cnt++;\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n\\n        ind = len(s) -1\\n        res  = 0\\n\\n        for i in range( len(g)-1,-1,-1):\\n            if ind >= 0 and g[i] <= s[ind]:\\n                res += 1\\n                ind -=1\\n\\n        return res\\n```\n```Java []\\nimport java.util.NavigableMap;\\n\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int result = 0;\\n        int greedIndex = 0;\\n        int sizeIndex = 0;\\n\\n        while (greedIndex < g.length && sizeIndex < s.length) {\\n            if (s[sizeIndex++] >= g[greedIndex]) {\\n                greedIndex++;\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166332,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end(),greater<int>());\\n        sort(s.begin(),s.end(),greater<int>());\\n        int i=0,j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(s[j] >= g[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end(),greater<int>());\\n        sort(s.begin(),s.end(),greater<int>());\\n        int i=0,j=0;\\n        while(i<g.size() && j<s.size()){\\n            if(s[j] >= g[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062742,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        \\n        let ch = g.sorted()\\n        let co = s.sorted()\\n        \\n        var chi = 0\\n        var coi = 0\\n        var res = 0\\n        \\n        while chi < ch.count, coi < co.count {\\n            if ch[chi] <= co[coi] {\\n                res += 1\\n                chi += 1\\n            }\\n            coi += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findContentChildren(_ g: [Int], _ s: [Int]) -> Int {\\n        \\n        let ch = g.sorted()\\n        let co = s.sorted()\\n        \\n        var chi = 0\\n        var coi = 0\\n        var res = 0\\n        \\n        while chi < ch.count, coi < co.count {\\n            if ch[chi] <= co[coi] {\\n                res += 1\\n                chi += 1\\n            }\\n            coi += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675503,
                "title": "runtime-127-ms-memory-usage-21-1-mb",
                "content": "Runtime: 127 ms, faster than 48.84% of PHP online submissions for Assign Cookies.\\nMemory Usage: 21.1 MB, less than 88.37% of PHP online submissions for Assign Cookies.\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $g\\n     * @param Integer[] $s\\n     * @return Integer\\n     */\\n    function findContentChildren($g, $s) {\\n        sort($g);\\n        sort($s);\\n        \\n        $i = 0;\\n        $j = 0;\\n        while ($i < count($g) && $j < count($s)) {\\n            ($g[$i] <= $s[$j]) && $i++;\\n            $j++;\\n        }\\n\\n        return $i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $g\\n     * @param Integer[] $s\\n     * @return Integer\\n     */\\n    function findContentChildren($g, $s) {\\n        sort($g);\\n        sort($s);\\n        \\n        $i = 0;\\n        $j = 0;\\n        while ($i < count($g) && $j < count($s)) {\\n            ($g[$i] <= $s[$j]) && $i++;\\n            $j++;\\n        }\\n\\n        return $i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531754,
                "title": "assign-cookies",
                "content": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int cnt=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int sizeG=g.size();\\n        int sizeS=s.size();\\n        int target;\\n        for(int i=0;i<sizeS;i++)\\n        {\\n            if(s[i]>=g[0])\\n            {\\n                target=i;\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;(i<sizeS && j<sizeG);i++)\\n        {\\n            if(g[j]<=s[i])j++;\\n            {\\n                cnt++;\\n            }\\n        }\\n        return j;\\n    }\\n        \\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int cnt=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int sizeG=g.size();\\n        int sizeS=s.size();\\n        int target;\\n        for(int i=0;i<sizeS;i++)\\n        {\\n            if(s[i]>=g[0])\\n            {\\n                target=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2531213,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int i = 0, j = 0;\\n        while(j < s.size() and i < g.size())\\n        {\\n            if(s[j] >= g[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int i = 0, j = 0;\\n        while(j < s.size() and i < g.size())\\n        {\\n            if(s[j] >= g[i])\\n                i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494472,
                "title": "python-gready-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\t\\tg.sort(reverse=True)\\n\\t\\t\\ts.sort(reverse=True)\\n\\t\\t\\t\\n\\t\\t\\tcount  = 0\\n\\t\\t\\twhile g and s:\\n\\t\\t\\t\\tif s[-1] >= g[-1]:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\ts.pop()\\n\\t\\t\\t\\t\\tg.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.pop()\\n\\t\\t\\t\\n\\t\\t\\treturn count",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\t\\tg.sort(reverse=True)\\n\\t\\t\\ts.sort(reverse=True)\\n\\t\\t\\t\\n\\t\\t\\tcount  = 0\\n\\t\\t\\twhile g and s:\\n\\t\\t\\t\\tif s[-1] >= g[-1]:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\ts.pop()\\n\\t\\t\\t\\t\\tg.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.pop()\\n\\t\\t\\t\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 2489330,
                "title": "86-faster-python-solution",
                "content": "**class Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:**\\n\\t\\n        child, cookie = 0, 0\\n        g.sort()\\n        s.sort()\\n        while child != len(g) and cookie != len(s):\\n            if s[cookie] >= g[child]:\\n                child += 1\\n                cookie += 1\\n            else:\\n                cookie += 1\\n        return child",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "**class Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:**\\n\\t\\n        child, cookie = 0, 0\\n        g.sort()\\n        s.sort()\\n        while child != len(g) and cookie != len(s):\\n            if s[cookie] >= g[child]:\\n                child += 1\\n                cookie += 1\\n            else:\\n                cookie += 1\\n        return child",
                "codeTag": "Java"
            },
            {
                "id": 2488585,
                "title": "python-simple",
                "content": "For each child, we want to use the smallest cookie possible. By sorting both lists, we can start with the smallest greed value, find the smallest cookie that satisfies this value, then move on. The size_ptr variable is used to advance over the cookie_sizes list instead of removing the values of the cookies we \"used\". \\n```\\nclass Solution:\\n    def findContentChildren(self, children: list[int], cookie_sizes: list[int]) -> int:\\n        if not cookie_sizes or not children:\\n            return 0\\n        \\n        children.sort()\\n        cookie_sizes.sort()\\n        \\n        content_children = 0\\n        size_ptr = 0\\n        \\n        for child_greed in children:\\n            while size_ptr < len(cookie_sizes) and cookie_sizes[size_ptr] < child_greed:\\n                size_ptr += 1\\n            if size_ptr == len(cookie_sizes):\\n                break\\n            size_ptr += 1\\n            content_children += 1\\n        \\n        return content_children\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, children: list[int], cookie_sizes: list[int]) -> int:\\n        if not cookie_sizes or not children:\\n            return 0\\n        \\n        children.sort()\\n        cookie_sizes.sort()\\n        \\n        content_children = 0\\n        size_ptr = 0\\n        \\n        for child_greed in children:\\n            while size_ptr < len(cookie_sizes) and cookie_sizes[size_ptr] < child_greed:\\n                size_ptr += 1\\n            if size_ptr == len(cookie_sizes):\\n                break\\n            size_ptr += 1\\n            content_children += 1\\n        \\n        return content_children\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473844,
                "title": "accepted-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int i=0, j=0, out = 0;\\n        \\n        while(i<g.size() && j<s.size()) {\\n            if(s[j]>=g[i]) {\\n                out++;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int i=0, j=0, out = 0;\\n        \\n        while(i<g.size() && j<s.size()) {\\n            if(s[j]>=g[i]) {\\n                out++;\\n                i++;\\n                j++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466928,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int ans=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int j=0;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int cnt=0;\\n            for(;j<s.size();j++)\\n            {\\n                if(s[j]>=g[i])\\n                {\\n                    ans++;\\n                    cnt++;\\n                    j++;\\n                    break;\\n                }\\n            }\\n            cout<<j<<\" \";\\n            if(cnt==0)\\n                break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you find the solution useful plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s)\\n    {\\n        int ans=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int j=0;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int cnt=0;\\n            for(;j<s.size();j++)\\n            {\\n                if(s[j]>=g[i])\\n                {\\n                    ans++;\\n                    cnt++;\\n                    j++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2463195,
                "title": "javascript-simple-solution-with-two-pointers-and-sort-100",
                "content": "```\\nvar findContentChildren = function(g, s) {\\n    g = g.sort((a, b) => a - b);\\n    s = s.sort((a, b) => a - b);\\n    let cursorG = 0;\\n    let cursorS = 0;\\n    let output = 0;\\n    \\n    while (cursorS <= s.length && cursorG <= g.length) {\\n        if (s[cursorS] >= g[cursorG]) {\\n            cursorS++;\\n            cursorG++;\\n            output++;\\n        } else {\\n            cursorS++;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar findContentChildren = function(g, s) {\\n    g = g.sort((a, b) => a - b);\\n    s = s.sort((a, b) => a - b);\\n    let cursorG = 0;\\n    let cursorS = 0;\\n    let output = 0;\\n    \\n    while (cursorS <= s.length && cursorG <= g.length) {\\n        if (s[cursorS] >= g[cursorG]) {\\n            cursorS++;\\n            cursorG++;\\n            output++;\\n        } else {\\n            cursorS++;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459579,
                "title": "java-with-explanation",
                "content": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\tArrays.sort(g);\\n\\t\\tArrays.sort(s);\\n\\t\\t\\n\\t\\tint a = 0, b = 0;\\n\\t\\t\\n\\t\\twhile(a < g.length && b < s.length) {\\n\\t\\t\\tif(g[a] <= s[b]) { \\n\\t\\t\\t\\t// 1st iteration \\n\\t\\t\\t\\t// is 1 <= 3 --> no \\n\\t\\t\\t\\t// 2ns iteration\\n\\t\\t\\t\\t// is 2 <= 4 --> no\\n                                // no further comp to make in s so 2 will be answer\\n\\t\\t\\t\\ta++;\\n\\t\\t\\t\\tb++;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tb++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn a;\\n    }\\n    }\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\tArrays.sort(g);\\n\\t\\tArrays.sort(s);\\n\\t\\t\\n\\t\\tint a = 0, b = 0;\\n\\t\\t\\n\\t\\twhile(a < g.length && b < s.length) {\\n\\t\\t\\tif(g[a] <= s[b]) { \\n\\t\\t\\t\\t// 1st iteration \\n\\t\\t\\t\\t// is 1 <= 3 --> no \\n\\t\\t\\t\\t// 2ns iteration\\n\\t\\t\\t\\t// is 2 <= 4 --> no\\n                                // no further comp to make in s so 2 will be answer\\n\\t\\t\\t\\ta++;\\n\\t\\t\\t\\tb++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2442133,
                "title": "greedy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i = g.size()-1;\\n        int j = s.size()-1;  \\n        int cnt = 0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        while(i>=0 && j>= 0){\\n            if(s[j]>=g[i]){\\n                cnt++; \\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i = g.size()-1;\\n        int j = s.size()-1;  \\n        int cnt = 0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        while(i>=0 && j>= 0){\\n            if(s[j]>=g[i]){\\n                cnt++; \\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406064,
                "title": "python-92-62-faster-simplest-solution-with-explanation-beg-to-adv-greedy",
                "content": "```python\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort() # soring list g\\n        s.sort() # sorting list s\\n        # because it`ll make easy for us to figure out how many children are getting the cookies as per greedy.\\n        \\n        childi = 0 # taking variable\\n        cookiei = 0 # taking variable\\n        \\n        while cookiei < len(s) and childi < len(g): # traversing elements in the list. \\n            if s[cookiei] >= g[childi]: # checking if cookies are more or equal to a child greedy.\\n                childi += 1 # if child greedy is getting fulfilled it will be content, and will increase out counter.\\n            cookiei += 1 # if child is getting the cookie, then we are increasing both else we`ll just check in cookies could we have any to fulfill at least one child greedy for that will increase only cookie\\n        \\n        return childi # returning the number of content children.\\n        \\n```\\n***Found helpful, Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/b17ca119-4abe-4ef6-bb85-b41c58f0ef15_1660123331.6778045.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort() # soring list g\\n        s.sort() # sorting list s\\n        # because it`ll make easy for us to figure out how many children are getting the cookies as per greedy.\\n        \\n        childi = 0 # taking variable\\n        cookiei = 0 # taking variable\\n        \\n        while cookiei < len(s) and childi < len(g): # traversing elements in the list. \\n            if s[cookiei] >= g[childi]: # checking if cookies are more or equal to a child greedy.\\n                childi += 1 # if child greedy is getting fulfilled it will be content, and will increase out counter.\\n            cookiei += 1 # if child is getting the cookie, then we are increasing both else we`ll just check in cookies could we have any to fulfill at least one child greedy for that will increase only cookie\\n        \\n        return childi # returning the number of content children.\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400833,
                "title": "nlogn-java-solution",
                "content": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n\\t\\n        int count=0;\\n        int j=0;\\n        Arrays.sort(g);\\n        Arrays.sort(s);  \\n        for(int i=0;i<g.length;i++)\\n        {\\n            for(;j<s.length;){\\n                if(g[i]<=s[j])\\n                {\\n                    count++;\\n                    j++;\\n                    break;\\n                }\\n            j++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n\\t\\n        int count=0;\\n        int j=0;\\n        Arrays.sort(g);\\n        Arrays.sort(s);  \\n        for(int i=0;i<g.length;i++)\\n        {\\n            for(;j<s.length;){\\n                if(g[i]<=s[j])\\n                {\\n                    count++;\\n                    j++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2400197,
                "title": "c-solution-using-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        stable_sort(g.rbegin(),g.rend());\\n        stable_sort(s.rbegin(),s.rend());\\n        int i=0,j=0,count=0;\\n        while(j<s.size() && i<g.size())\\n        {\\n            \\n            if(s[j]>=g[i]){\\n                j++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        stable_sort(g.rbegin(),g.rend());\\n        stable_sort(s.rbegin(),s.rend());\\n        int i=0,j=0,count=0;\\n        while(j<s.size() && i<g.size())\\n        {\\n            \\n            if(s[j]>=g[i]){\\n                j++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390226,
                "title": "javascript-sorting-solution",
                "content": "```\\nvar findContentChildren = function(g, s) {\\n    g.sort((a, b) => a - b);\\n    \\n    s.sort((a, b) => a - b);\\n    \\n    let res = 0;\\n    let currChild = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (g[currChild] <= s[i]) {\\n            res++;\\n            currChild++;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findContentChildren = function(g, s) {\\n    g.sort((a, b) => a - b);\\n    \\n    s.sort((a, b) => a - b);\\n    \\n    let res = 0;\\n    let currChild = 0;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (g[currChild] <= s[i]) {\\n            res++;\\n            currChild++;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367793,
                "title": "simple-and-efficient-2-pointer-approach",
                "content": "***PLease upvote if you find it helpful***\\n\\nUsing greedy approach, we will first try to feed the child with maximum demand and then move ahead if we are able to fulfill it, otherwise, simply move to the next child until we are out of chocolates or all the children are content.\\n\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int res = 0;\\n        int g_idx = 0;\\n        int s_idx = 0;\\n        sort(s.begin(),s.end(),greater<int>());\\n        sort(g.begin(),g.end(),greater<int>());\\n        \\n        while(g_idx<g.size()&&s_idx<s.size())\\n        {\\n            if(s[s_idx]>=g[g_idx])\\n            {\\n                res++;\\n                g_idx++;\\n                s_idx++;\\n            }\\n            else\\n            {\\n                g_idx++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int res = 0;\\n        int g_idx = 0;\\n        int s_idx = 0;\\n        sort(s.begin(),s.end(),greater<int>());\\n        sort(g.begin(),g.end(),greater<int>());\\n        \\n        while(g_idx<g.size()&&s_idx<s.size())\\n        {\\n            if(s[s_idx]>=g[g_idx])\\n            {\\n                res++;\\n                g_idx++;\\n                s_idx++;\\n            }\\n            else\\n            {\\n                g_idx++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321414,
                "title": "greedy-solution-faster-than-98-submissions-java",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int cnt = 0;\\n        for(int i=0,j=0;i<g.length && j<s.length;j++){\\n            if(g[i] <= s[j]){\\n                cnt++; i++;\\n            }\\n                \\n        }\\n        return cnt;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int cnt = 0;\\n        for(int i=0,j=0;i<g.length && j<s.length;j++){\\n            if(g[i] <= s[j]){\\n                cnt++; i++;\\n            }\\n                \\n        }\\n        return cnt;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2316107,
                "title": "java-solution-easy-and-simple",
                "content": "class Solution \\n{\\n    public int findContentChildren(int[] g, int[] s) \\n    {\\n    Arrays.sort(g);\\n    Arrays.sort(s);\\n        int a=0;\\n        int b=0;\\n        while(a<g.length && b<s.length)\\n        {\\n            if(g[a]<=s[b])\\n            {\\n                a++;\\n                b++;\\n            }\\n            else\\n            {\\n                b++;\\n            }\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution \\n{\\n    public int findContentChildren(int[] g, int[] s) \\n    {\\n    Arrays.sort(g);\\n    Arrays.sort(s);\\n        int a=0;\\n        int b=0;\\n        while(a<g.length && b<s.length)\\n        {\\n            if(g[a]<=s[b])\\n            {\\n                a++;\\n                b++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2262273,
                "title": "java-easy-loop-sorting-explantion",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n         Arrays.sort(s);\\n         int i=0;\\n         int j=0;\\n         int ans=0;\\n         while (j<s.length && i<g.length){\\n             // As per question, cookies should be greater or equal to greed to assign kid\\n             if (s[j]>=g[i]){\\n                 ans++;\\n                 i++;\\n                 j++;\\n             }\\n             else {\\n                 j++;\\n             }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n         Arrays.sort(s);\\n         int i=0;\\n         int j=0;\\n         int ans=0;\\n         while (j<s.length && i<g.length){\\n             // As per question, cookies should be greater or equal to greed to assign kid\\n             if (s[j]>=g[i]){\\n                 ans++;\\n                 i++;\\n                 j++;\\n             }\\n             else {\\n                 j++;\\n             }\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256496,
                "title": "python-approach-beats-72-35",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        if g == [] or s == []:\\n            return 0\\n        else:\\n            g.sort()\\n            s.sort()\\n            out = 0\\n            for j in range(len(s)):\\n                if out < len(g) and s[j] >= g[out]:\\n                    out += 1\\n            return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        if g == [] or s == []:\\n            return 0\\n        else:\\n            g.sort()\\n            s.sort()\\n            out = 0\\n            for j in range(len(s)):\\n                if out < len(g) and s[j] >= g[out]:\\n                    out += 1\\n            return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249515,
                "title": "assign-cookies",
                "content": "\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=0;\\n        int j=0;\\n        while(i<g.length && j<s.length)\\n        {\\n            if(s[j] >= g[i])\\n                i++;\\n            \\n           j++;\\n        }\\n        return i;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int i=0;\\n        int j=0;\\n        while(i<g.length && j<s.length)\\n        {\\n            if(s[j] >= g[i])\\n                i++;\\n            \\n           j++;\\n        }\\n        return i;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2158436,
                "title": "java-greedy-approach",
                "content": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int leng=g.length,lens=0, count=0, i=0;        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        while(i<leng && lens<s.length){\\n            if(s[lens]>=g[i]){\\n                count++;\\n                i++;\\n            }\\n            lens++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int leng=g.length,lens=0, count=0, i=0;        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        while(i<leng && lens<s.length){\\n            if(s[lens]>=g[i]){\\n                count++;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2147697,
                "title": "java-easy-fast-solution",
                "content": "```\\n public int findContentChildren(int[] g, int[] s) {\\n        int returnval=0;\\n        Arrays.sort(g);\\n         Arrays.sort(s);\\n        for(int i=0;i<s.length;i++){\\n             if(g.length==returnval){\\n                 break;\\n             }            \\n            if(s[i]>=g[returnval]){\\n                returnval++;\\n            }\\n             \\n        }\\n     \\n        return returnval;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int findContentChildren(int[] g, int[] s) {\\n        int returnval=0;\\n        Arrays.sort(g);\\n         Arrays.sort(s);\\n        for(int i=0;i<s.length;i++){\\n             if(g.length==returnval){\\n                 break;\\n             }            \\n            if(s[i]>=g[returnval]){\\n                returnval++;\\n            }\\n             \\n        }\\n     \\n        return returnval;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083237,
                "title": "extremely-poor-time-complexity",
                "content": "```\\nint count = 0;\\nArrays.sort(g);\\nArrays.sort(s);\\nfor(int i=0; i<g.length; i++){\\n\\tfor(int j=0; j<s.length; j++){\\n\\t\\tif(s[j]>0 && s[j]>=g[i]){\\n\\t\\t\\tcount++;\\n\\t\\t\\ts[j]=-1*s[j];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n}\\nreturn count;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint count = 0;\\nArrays.sort(g);\\nArrays.sort(s);\\nfor(int i=0; i<g.length; i++){\\n\\tfor(int j=0; j<s.length; j++){\\n\\t\\tif(s[j]>0 && s[j]>=g[i]){\\n\\t\\t\\tcount++;\\n\\t\\t\\ts[j]=-1*s[j];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n}\\nreturn count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035809,
                "title": "this-code-will-be-understandable-to-6year-old-guy",
                "content": "class Solution {\\n\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0;\\n        for(int j=0;i<g.length && j<s.length;j++)\\n        {\\n            if(g[i]<=s[j])i++;\\n        }\\n        return i;\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i = 0;\\n        for(int j=0;i<g.length && j<s.length;j++)\\n        {\\n            if(g[i]<=s[j])i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1954775,
                "title": "c",
                "content": "```\\n    public int FindContentChildren(int[] g, int[] s) {\\n             if (s.Length == 0)\\n                return 0;\\n\\n            var count = 0;\\n            Array.Sort(g);\\n            Array.Sort(s);\\n            int i = g.Length - 1;\\n            int j = s.Length - 1;\\n\\n            while (i >= 0 && j >= 0)\\n            {\\n                if (g[i] <= s[j])\\n                {\\n                    count++;\\n                    j--;\\n                }\\n                i--;\\n            }\\n            return count;       \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FindContentChildren(int[] g, int[] s) {\\n             if (s.Length == 0)\\n                return 0;\\n\\n            var count = 0;\\n            Array.Sort(g);\\n            Array.Sort(s);\\n            int i = g.Length - 1;\\n            int j = s.Length - 1;\\n\\n            while (i >= 0 && j >= 0)\\n            {\\n                if (g[i] <= s[j])\\n                {\\n                    count++;\\n                    j--;\\n                }\\n                i--;\\n            }\\n            return count;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1917259,
                "title": "simple-python-code",
                "content": "\\n\\t`class Solution:\\n\\t\\tdef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\t\\tg.sort()\\n\\t\\t\\ts.sort()\\n\\t\\t\\tans=0\\n\\t\\t\\ti=0\\n\\t\\t\\tfor j in range(len(s)):\\n\\t\\t\\t\\tif(i<len(g) and s[j]>=g[i]):\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn ans`",
                "solutionTags": [],
                "code": "\\n\\t`class Solution:\\n\\t\\tdef findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\t\\tg.sort()\\n\\t\\t\\ts.sort()\\n\\t\\t\\tans=0\\n\\t\\t\\ti=0\\n\\t\\t\\tfor j in range(len(s)):\\n\\t\\t\\t\\tif(i<len(g) and s[j]>=g[i]):\\n\\t\\t\\t\\t\\tans+=1\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn ans`",
                "codeTag": "Java"
            },
            {
                "id": 1886091,
                "title": "java-easy-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int i=0,j=0,n1=g.length,n2=s.length,count=0;\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        while(i<n1 && j<n2){\\n            int x = g[i], y= s[i]; \\n            if(s[j]>=g[i]){\\n                count++;\\n                j++;\\n                i++;\\n            }else if(x>y){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        int i=0,j=0,n1=g.length,n2=s.length,count=0;\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        while(i<n1 && j<n2){\\n            int x = g[i], y= s[i]; \\n            if(s[j]>=g[i]){\\n                count++;\\n                j++;\\n                i++;\\n            }else if(x>y){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855832,
                "title": "elegant-c-solution",
                "content": "```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0,j=0,ans=0;\\n        while(j<s.size() && i<g.size()){\\n            if(g[i]<=s[j]){i++;ans++;}\\n            j++;\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0,j=0,ans=0;\\n        while(j<s.size() && i<g.size()){\\n            if(g[i]<=s[j]){i++;ans++;}\\n            j++;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848526,
                "title": "simplet-to-understand-faster-than-96-16-soln",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        \\n        i = 0\\n        j = 0\\n        countCookie = 0\\n        while j < len(s) and i < len(g):\\n            if s[j] >= g[i]:\\n                countCookie += 1\\n                j += 1\\n                i += 1\\n            elif s[j] <= g[i]:\\n                j += 1         \\n        return countCookie\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        g.sort()\\n        s.sort()\\n        \\n        i = 0\\n        j = 0\\n        countCookie = 0\\n        while j < len(s) and i < len(g):\\n            if s[j] >= g[i]:\\n                countCookie += 1\\n                j += 1\\n                i += 1\\n            elif s[j] <= g[i]:\\n                j += 1         \\n        return countCookie\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840471,
                "title": "c-easiest-sorting-aol",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i=0,j=0, ans=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        \\n        while(j<g.size() && i<s.size())\\n        {\\n            if(s[i]>=g[j])\\n            {\\n                ans++;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int i=0,j=0, ans=0;\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        \\n        while(j<g.size() && i<s.size())\\n        {\\n            if(s[i]>=g[j])\\n            {\\n                ans++;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833576,
                "title": "simple-python-solution-50-faster-memory-less-than-90",
                "content": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        ans=0 ; j=0 ; g.sort() ; s.sort()\\n        for i in range(len(g)):\\n            while j<len(s):\\n                if g[i]<=s[j]: ans+=1 ; s.remove(s[j]) ; break\\n                j+=1\\n        return ans\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n        ans=0 ; j=0 ; g.sort() ; s.sort()\\n        for i in range(len(g)):\\n            while j<len(s):\\n                if g[i]<=s[j]: ans+=1 ; s.remove(s[j]) ; break\\n                j+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825721,
                "title": "c-greedy-sorting-time-complexity-o-nlogn-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int gsize=g.size(), ssize=s.size();\\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int content=0, i=0, j=0;\\n        \\n        while(i<gsize && j<ssize)\\n        {\\n            if(g[i]<=s[j])\\n            {\\n                content++;\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        \\n        return content;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int gsize=g.size(), ssize=s.size();\\n        \\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        \\n        int content=0, i=0, j=0;\\n        \\n        while(i<gsize && j<ssize)\\n        {\\n            if(g[i]<=s[j])\\n            {\\n                content++;\\n                i++;\\n                j++;\\n            }\\n            else\\n                j++;\\n        }\\n        \\n        return content;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802281,
                "title": "easy-java-solution-solved-without-sorting-o-nloglogn",
                "content": "```\\nimport java.util.*;\\nimport java.util.stream.*;\\n\\npublic class Solution {\\n    private static class PurePartition {\\n        public static PurePartition head;\\n        public static PurePartition tail;\\n\\n        public MixedPartition previous;\\n        public MixedPartition next;\\n        public int unassignedG;\\n        public int unassignedS;\\n        public int c;\\n        public int leftPriority;\\n        public int rightPriority;\\n\\n        public PurePartition() {\\n            this.unassignedG = 0;\\n            this.unassignedS = 0;\\n            this.c = 0;\\n        }\\n\\n        public void leftInsertionSort() {\\n            while (this.previous != null && this.unassignedS >= this.previous.g.size()) {\\n                this.unassignedS += this.previous.s.size() - this.previous.g.size()\\n                        + this.previous.previous.unassignedS - this.previous.previous.unassignedG;\\n                this.c += this.previous.g.size() + this.previous.previous.unassignedG\\n                        + this.previous.previous.c;\\n                if (this.previous.leftChild != null) {\\n                    this.previous.leftChild.parent = this.previous.parent;\\n                }\\n                if (this.previous.parent.leftChild == this.previous) {\\n                    this.previous.parent.leftChild = this.previous.leftChild;\\n                } else if (this.previous.parent.rightChild == this.previous) {\\n                    this.previous.parent.rightChild = this.previous.leftChild;\\n                }\\n                this.previous = this.previous.previous.previous;\\n            }\\n            if (this.previous == null) {\\n                PurePartition.head = this;\\n            } else {\\n                this.previous.next = this;\\n            }\\n        }\\n\\n        public void rightInsertionSort() {\\n            while (this.next != null && this.unassignedG >= this.next.s.size()) {\\n                this.unassignedG += this.next.g.size() - this.next.s.size()\\n                        + this.next.next.unassignedG - this.next.next.unassignedS;\\n                this.c += this.next.s.size() + this.next.next.unassignedS\\n                        + this.next.next.c;\\n                if (this.next.rightChild != null) {\\n                    this.next.rightChild.parent = this.next.parent;\\n                }\\n                if (this.next.parent.rightChild == this.next) {\\n                    this.next.parent.rightChild = this.next.rightChild;\\n                } else if (this.next.parent.leftChild == this.next) {\\n                    this.next.parent.leftChild = this.next.rightChild;\\n                }\\n                this.next = this.next.next.next;\\n            }\\n            if (this.next == null) {\\n                PurePartition.tail = this;\\n            } else {\\n                this.next.previous = this;\\n            }\\n        }\\n    }\\n\\n    private static class MixedPartition {\\n        public static MixedPartition root;\\n\\n        public static void heapSort() {\\n            while (MixedPartition.root != null) {\\n                MixedPartition.root.quickSort();\\n            }\\n        }\\n\\n        public static MixedPartition mergeSort(MixedPartition left, MixedPartition right) {\\n            MixedPartition head = null;\\n            MixedPartition tail = null;\\n            int direction = 0;\\n            while (true) {\\n                if (direction == 0) {\\n                    if (left == null && right == null) {\\n                        return null;\\n                    } else if (left == null) {\\n                        head = right;\\n                        break;\\n                    } else if (right == null) {\\n                        head = left;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        head = tail = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        head = tail = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                } else if (direction == 1) {\\n                    if (left == null) {\\n                        right.parent = tail;\\n                        tail.rightChild = right;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        left.parent = tail;\\n                        tail = tail.rightChild = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        right.parent = tail;\\n                        tail = tail.rightChild = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                } else if (direction == 2) {\\n                    if (right == null) {\\n                        left.parent = tail;\\n                        tail.leftChild = left;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        left.parent = tail;\\n                        tail = tail.leftChild = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        right.parent = tail;\\n                        tail = tail.leftChild = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                }\\n            }\\n            head.parent = null;\\n            return head;\\n        }\\n\\n        public PurePartition previous;\\n        public PurePartition next;\\n        public MixedPartition parent;\\n        public MixedPartition leftChild;\\n        public MixedPartition rightChild;\\n        public ArrayList<Integer> g;\\n        public ArrayList<Integer> s;\\n        public int priority;\\n\\n        public MixedPartition() {\\n            this.g = new ArrayList<Integer>();\\n            this.s = new ArrayList<Integer>();\\n        }\\n\\n        public MixedPartition(ArrayList<Integer> g, ArrayList<Integer> s) {\\n            this.g = g;\\n            this.s = s;\\n        }\\n\\n        public void quickSort() {\\n            MixedPartition left = new MixedPartition();\\n            PurePartition middle = new PurePartition();\\n            MixedPartition right = new MixedPartition();\\n\\n            Integer pivot;\\n            if (this.g.size() <= this.s.size()) {\\n                pivot = this.g.get((new Random()).nextInt(this.g.size()));\\n            } else {\\n                pivot = this.s.get((new Random()).nextInt(this.s.size()));\\n            }\\n\\n            for (Integer i : this.g) {\\n                if (i.compareTo(pivot) < 0) {\\n                    left.g.add(i);\\n                } else if (i.compareTo(pivot) == 0) {\\n                    ++middle.unassignedG;\\n                } else {\\n                    right.g.add(i);\\n                }\\n            }\\n            for (Integer i : this.s) {\\n                if (i.compareTo(pivot) < 0) {\\n                    left.s.add(i);\\n                } else if (i.compareTo(pivot) == 0) {\\n                    ++middle.unassignedS;\\n                } else {\\n                    right.s.add(i);\\n                }\\n            }\\n\\n            middle.c = Math.min(middle.unassignedG, middle.unassignedS);\\n            middle.unassignedG -= middle.c;\\n            middle.unassignedS -= middle.c;\\n\\n            if (this.previous.unassignedG < left.s.size()\\n                    && left.g.size() > middle.unassignedS\\n                    && middle.unassignedG < right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = middle;\\n                middle.previous = left;\\n                middle.next = right;\\n                right.previous = middle;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                        + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                        + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, MixedPartition.mergeSort(left,\\n                        right)), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() < left.s.size() + middle.unassignedS\\n                    && middle.unassignedG < right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = middle;\\n                }\\n                middle.previous = this.previous.previous;\\n                middle.next = right;\\n                right.previous = middle;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                middle.unassignedS += left.s.size() - left.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                middle.c += left.g.size() + this.previous.unassignedG + this.previous.c;\\n                middle.leftInsertionSort();\\n                middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                        + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                if (middle.previous != null) {\\n                    middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                            + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                }\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, right), this.rightChild);\\n            } else if ((middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && middle.unassignedG + right.g.size() > right.s.size() + this.next.unassignedS\\n                    && left.g.size() > middle.unassignedS\\n                    && this.previous.unassignedG < left.s.size()) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = middle;\\n                middle.previous = left;\\n                middle.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = middle;\\n                }\\n                middle.unassignedG += right.g.size() - right.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                middle.c += right.s.size() + this.next.unassignedS + this.next.c;\\n                middle.rightInsertionSort();\\n                if (middle.next != null) {\\n                    middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                            + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                }\\n                middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                        + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, left), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() >= left.s.size() + middle.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG\\n                            < left.s.size() + middle.unassignedS + right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                this.previous.next = right;\\n                right.previous = this.previous;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                this.previous.unassignedG += left.g.size() - left.s.size() + middle.unassignedG - middle.unassignedS;\\n                this.previous.c += left.s.size() + middle.unassignedS + middle.c;\\n                this.previous.leftPriority = this.previous.next.next.leftPriority - this.previous.next.next.unassignedS\\n                        + this.previous.next.next.unassignedG - this.previous.next.s.size() + this.previous.next.g.size();\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, right), this.rightChild);\\n            } else if ((middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && middle.unassignedG + right.g.size() <= right.s.size() + this.next.unassignedS\\n                    && left.g.size() + middle.unassignedG + right.g.size()\\n                            > middle.unassignedS + right.s.size() + this.next.unassignedS\\n                    && this.previous.unassignedG < left.s.size()) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = this.next;\\n                this.next.previous = left;\\n                this.next.unassignedS += right.s.size() - right.g.size() + middle.unassignedS - middle.unassignedG;\\n                this.next.c += right.g.size() + middle.unassignedG + middle.c;\\n                this.next.rightPriority = this.next.previous.previous.rightPriority - this.next.previous.previous.unassignedG\\n                        + this.next.previous.previous.unassignedS - this.next.previous.g.size() + this.next.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, left), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && (middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() < left.s.size() + middle.unassignedS\\n                    && middle.unassignedG + right.g.size() > right.s.size() + this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = middle;\\n                }\\n                middle.previous = this.previous.previous;\\n                middle.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = middle;\\n                }\\n                middle.unassignedS += left.s.size() - left.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                middle.unassignedG += right.g.size() - right.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                middle.c += left.g.size() + this.previous.unassignedG + this.previous.c\\n                        + right.s.size() + this.next.unassignedS + this.next.c;\\n                middle.leftInsertionSort();\\n                middle.rightInsertionSort();\\n                if (middle.next != null) {\\n                    middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                            + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                }\\n                if (middle.previous != null) {\\n                    middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                            + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            } else if (right.g.size() <= this.next.unassignedS\\n                    && middle.unassignedG + right.g.size() <= right.s.size() + this.next.unassignedS\\n                    && left.g.size() + middle.unassignedG + right.g.size()\\n                            <= middle.unassignedS + right.s.size() + this.next.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG + right.g.size()\\n                            <= left.s.size() + middle.unassignedS + right.s.size() + this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = this.next;\\n                }\\n                this.next.previous = this.previous.previous;\\n                this.next.unassignedS += this.s.size() - this.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                this.next.c += this.g.size() + this.previous.unassignedG + this.previous.c;\\n                this.next.leftInsertionSort();\\n                if (this.next.previous != null) {\\n                    this.next.rightPriority = this.next.previous.previous.rightPriority - this.next.previous.previous.unassignedG\\n                            + this.next.previous.previous.unassignedS - this.next.previous.g.size() + this.next.previous.s.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            } else if (this.previous.unassignedG >= left.s.size()\\n                    && this.previous.unassignedG + left.g.size() >= left.s.size() + middle.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG\\n                            >= left.s.size() + middle.unassignedS + right.s.size()\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG + right.g.size()\\n                            >= left.s.size() + middle.unassignedS + right.s.size() + this.next.unassignedS) {\\n                this.previous.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = this.previous;\\n                }\\n                this.previous.unassignedG += this.g.size() - this.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                this.previous.c += this.s.size() + this.next.unassignedS + this.next.c;\\n                this.previous.rightInsertionSort();\\n                if (this.previous.next != null) {\\n                    this.previous.leftPriority = this.previous.next.next.leftPriority - this.previous.next.next.unassignedS\\n                            + this.previous.next.next.unassignedG - this.previous.next.s.size() + this.previous.next.g.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            }\\n        }\\n    }\\n\\n    public int findContentChildren(int[] g, int[] s) {\\n        if (g.length == 0 || s.length == 0) {\\n            return 0;\\n        }\\n\\n        MixedPartition.root = new MixedPartition(new ArrayList<Integer>(Arrays.stream(g).boxed().collect(Collectors.toList())),\\n                new ArrayList<Integer>(Arrays.stream(s).boxed().collect(Collectors.toList())));\\n        PurePartition.head = new PurePartition();\\n        PurePartition.tail = new PurePartition();\\n        PurePartition.head.next = MixedPartition.root;\\n        MixedPartition.root.previous = PurePartition.head;\\n        MixedPartition.root.next = PurePartition.tail;\\n        PurePartition.tail.previous = MixedPartition.root;\\n        PurePartition.head.leftPriority = 0;\\n        PurePartition.tail.rightPriority = 0;\\n\\n        MixedPartition.heapSort();\\n        return PurePartition.head.c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nimport java.util.stream.*;\\n\\npublic class Solution {\\n    private static class PurePartition {\\n        public static PurePartition head;\\n        public static PurePartition tail;\\n\\n        public MixedPartition previous;\\n        public MixedPartition next;\\n        public int unassignedG;\\n        public int unassignedS;\\n        public int c;\\n        public int leftPriority;\\n        public int rightPriority;\\n\\n        public PurePartition() {\\n            this.unassignedG = 0;\\n            this.unassignedS = 0;\\n            this.c = 0;\\n        }\\n\\n        public void leftInsertionSort() {\\n            while (this.previous != null && this.unassignedS >= this.previous.g.size()) {\\n                this.unassignedS += this.previous.s.size() - this.previous.g.size()\\n                        + this.previous.previous.unassignedS - this.previous.previous.unassignedG;\\n                this.c += this.previous.g.size() + this.previous.previous.unassignedG\\n                        + this.previous.previous.c;\\n                if (this.previous.leftChild != null) {\\n                    this.previous.leftChild.parent = this.previous.parent;\\n                }\\n                if (this.previous.parent.leftChild == this.previous) {\\n                    this.previous.parent.leftChild = this.previous.leftChild;\\n                } else if (this.previous.parent.rightChild == this.previous) {\\n                    this.previous.parent.rightChild = this.previous.leftChild;\\n                }\\n                this.previous = this.previous.previous.previous;\\n            }\\n            if (this.previous == null) {\\n                PurePartition.head = this;\\n            } else {\\n                this.previous.next = this;\\n            }\\n        }\\n\\n        public void rightInsertionSort() {\\n            while (this.next != null && this.unassignedG >= this.next.s.size()) {\\n                this.unassignedG += this.next.g.size() - this.next.s.size()\\n                        + this.next.next.unassignedG - this.next.next.unassignedS;\\n                this.c += this.next.s.size() + this.next.next.unassignedS\\n                        + this.next.next.c;\\n                if (this.next.rightChild != null) {\\n                    this.next.rightChild.parent = this.next.parent;\\n                }\\n                if (this.next.parent.rightChild == this.next) {\\n                    this.next.parent.rightChild = this.next.rightChild;\\n                } else if (this.next.parent.leftChild == this.next) {\\n                    this.next.parent.leftChild = this.next.rightChild;\\n                }\\n                this.next = this.next.next.next;\\n            }\\n            if (this.next == null) {\\n                PurePartition.tail = this;\\n            } else {\\n                this.next.previous = this;\\n            }\\n        }\\n    }\\n\\n    private static class MixedPartition {\\n        public static MixedPartition root;\\n\\n        public static void heapSort() {\\n            while (MixedPartition.root != null) {\\n                MixedPartition.root.quickSort();\\n            }\\n        }\\n\\n        public static MixedPartition mergeSort(MixedPartition left, MixedPartition right) {\\n            MixedPartition head = null;\\n            MixedPartition tail = null;\\n            int direction = 0;\\n            while (true) {\\n                if (direction == 0) {\\n                    if (left == null && right == null) {\\n                        return null;\\n                    } else if (left == null) {\\n                        head = right;\\n                        break;\\n                    } else if (right == null) {\\n                        head = left;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        head = tail = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        head = tail = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                } else if (direction == 1) {\\n                    if (left == null) {\\n                        right.parent = tail;\\n                        tail.rightChild = right;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        left.parent = tail;\\n                        tail = tail.rightChild = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        right.parent = tail;\\n                        tail = tail.rightChild = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                } else if (direction == 2) {\\n                    if (right == null) {\\n                        left.parent = tail;\\n                        tail.leftChild = left;\\n                        break;\\n                    } else if (left.priority >= right.priority) {\\n                        left.parent = tail;\\n                        tail = tail.leftChild = left;\\n                        left = left.rightChild;\\n                        direction = 1;\\n                    } else if (left.priority < right.priority) {\\n                        right.parent = tail;\\n                        tail = tail.leftChild = right;\\n                        right = right.leftChild;\\n                        direction = 2;\\n                    }\\n                }\\n            }\\n            head.parent = null;\\n            return head;\\n        }\\n\\n        public PurePartition previous;\\n        public PurePartition next;\\n        public MixedPartition parent;\\n        public MixedPartition leftChild;\\n        public MixedPartition rightChild;\\n        public ArrayList<Integer> g;\\n        public ArrayList<Integer> s;\\n        public int priority;\\n\\n        public MixedPartition() {\\n            this.g = new ArrayList<Integer>();\\n            this.s = new ArrayList<Integer>();\\n        }\\n\\n        public MixedPartition(ArrayList<Integer> g, ArrayList<Integer> s) {\\n            this.g = g;\\n            this.s = s;\\n        }\\n\\n        public void quickSort() {\\n            MixedPartition left = new MixedPartition();\\n            PurePartition middle = new PurePartition();\\n            MixedPartition right = new MixedPartition();\\n\\n            Integer pivot;\\n            if (this.g.size() <= this.s.size()) {\\n                pivot = this.g.get((new Random()).nextInt(this.g.size()));\\n            } else {\\n                pivot = this.s.get((new Random()).nextInt(this.s.size()));\\n            }\\n\\n            for (Integer i : this.g) {\\n                if (i.compareTo(pivot) < 0) {\\n                    left.g.add(i);\\n                } else if (i.compareTo(pivot) == 0) {\\n                    ++middle.unassignedG;\\n                } else {\\n                    right.g.add(i);\\n                }\\n            }\\n            for (Integer i : this.s) {\\n                if (i.compareTo(pivot) < 0) {\\n                    left.s.add(i);\\n                } else if (i.compareTo(pivot) == 0) {\\n                    ++middle.unassignedS;\\n                } else {\\n                    right.s.add(i);\\n                }\\n            }\\n\\n            middle.c = Math.min(middle.unassignedG, middle.unassignedS);\\n            middle.unassignedG -= middle.c;\\n            middle.unassignedS -= middle.c;\\n\\n            if (this.previous.unassignedG < left.s.size()\\n                    && left.g.size() > middle.unassignedS\\n                    && middle.unassignedG < right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = middle;\\n                middle.previous = left;\\n                middle.next = right;\\n                right.previous = middle;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                        + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                        + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, MixedPartition.mergeSort(left,\\n                        right)), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() < left.s.size() + middle.unassignedS\\n                    && middle.unassignedG < right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = middle;\\n                }\\n                middle.previous = this.previous.previous;\\n                middle.next = right;\\n                right.previous = middle;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                middle.unassignedS += left.s.size() - left.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                middle.c += left.g.size() + this.previous.unassignedG + this.previous.c;\\n                middle.leftInsertionSort();\\n                middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                        + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                if (middle.previous != null) {\\n                    middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                            + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                }\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, right), this.rightChild);\\n            } else if ((middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && middle.unassignedG + right.g.size() > right.s.size() + this.next.unassignedS\\n                    && left.g.size() > middle.unassignedS\\n                    && this.previous.unassignedG < left.s.size()) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = middle;\\n                middle.previous = left;\\n                middle.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = middle;\\n                }\\n                middle.unassignedG += right.g.size() - right.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                middle.c += right.s.size() + this.next.unassignedS + this.next.c;\\n                middle.rightInsertionSort();\\n                if (middle.next != null) {\\n                    middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                            + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                }\\n                middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                        + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, left), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() >= left.s.size() + middle.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG\\n                            < left.s.size() + middle.unassignedS + right.s.size()\\n                    && right.g.size() > this.next.unassignedS) {\\n                this.previous.next = right;\\n                right.previous = this.previous;\\n                right.next = this.next;\\n                this.next.previous = right;\\n                this.previous.unassignedG += left.g.size() - left.s.size() + middle.unassignedG - middle.unassignedS;\\n                this.previous.c += left.s.size() + middle.unassignedS + middle.c;\\n                this.previous.leftPriority = this.previous.next.next.leftPriority - this.previous.next.next.unassignedS\\n                        + this.previous.next.next.unassignedG - this.previous.next.s.size() + this.previous.next.g.size();\\n                right.priority = Math.max(right.previous.leftPriority + right.s.size(), right.next.rightPriority + right.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, right), this.rightChild);\\n            } else if ((middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && middle.unassignedG + right.g.size() <= right.s.size() + this.next.unassignedS\\n                    && left.g.size() + middle.unassignedG + right.g.size()\\n                            > middle.unassignedS + right.s.size() + this.next.unassignedS\\n                    && this.previous.unassignedG < left.s.size()) {\\n                this.previous.next = left;\\n                left.previous = this.previous;\\n                left.next = this.next;\\n                this.next.previous = left;\\n                this.next.unassignedS += right.s.size() - right.g.size() + middle.unassignedS - middle.unassignedG;\\n                this.next.c += right.g.size() + middle.unassignedG + middle.c;\\n                this.next.rightPriority = this.next.previous.previous.rightPriority - this.next.previous.previous.unassignedG\\n                        + this.next.previous.previous.unassignedS - this.next.previous.g.size() + this.next.previous.s.size();\\n                left.priority = Math.max(left.previous.leftPriority + left.s.size(), left.next.rightPriority + left.g.size());\\n                MixedPartition.root = MixedPartition.mergeSort(MixedPartition.mergeSort(this.leftChild, left), this.rightChild);\\n            } else if ((this.previous.unassignedG >= left.s.size() || left.g.size() <= middle.unassignedS)\\n                    && (middle.unassignedG >= right.s.size() || right.g.size() <= this.next.unassignedS)\\n                    && this.previous.unassignedG + left.g.size() < left.s.size() + middle.unassignedS\\n                    && middle.unassignedG + right.g.size() > right.s.size() + this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = middle;\\n                }\\n                middle.previous = this.previous.previous;\\n                middle.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = middle;\\n                }\\n                middle.unassignedS += left.s.size() - left.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                middle.unassignedG += right.g.size() - right.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                middle.c += left.g.size() + this.previous.unassignedG + this.previous.c\\n                        + right.s.size() + this.next.unassignedS + this.next.c;\\n                middle.leftInsertionSort();\\n                middle.rightInsertionSort();\\n                if (middle.next != null) {\\n                    middle.leftPriority = middle.next.next.leftPriority - middle.next.next.unassignedS\\n                            + middle.next.next.unassignedG - middle.next.s.size() + middle.next.g.size();\\n                }\\n                if (middle.previous != null) {\\n                    middle.rightPriority = middle.previous.previous.rightPriority - middle.previous.previous.unassignedG\\n                            + middle.previous.previous.unassignedS - middle.previous.g.size() + middle.previous.s.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            } else if (right.g.size() <= this.next.unassignedS\\n                    && middle.unassignedG + right.g.size() <= right.s.size() + this.next.unassignedS\\n                    && left.g.size() + middle.unassignedG + right.g.size()\\n                            <= middle.unassignedS + right.s.size() + this.next.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG + right.g.size()\\n                            <= left.s.size() + middle.unassignedS + right.s.size() + this.next.unassignedS) {\\n                if (this.previous.previous != null) {\\n                    this.previous.previous.next = this.next;\\n                }\\n                this.next.previous = this.previous.previous;\\n                this.next.unassignedS += this.s.size() - this.g.size() + this.previous.unassignedS - this.previous.unassignedG;\\n                this.next.c += this.g.size() + this.previous.unassignedG + this.previous.c;\\n                this.next.leftInsertionSort();\\n                if (this.next.previous != null) {\\n                    this.next.rightPriority = this.next.previous.previous.rightPriority - this.next.previous.previous.unassignedG\\n                            + this.next.previous.previous.unassignedS - this.next.previous.g.size() + this.next.previous.s.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            } else if (this.previous.unassignedG >= left.s.size()\\n                    && this.previous.unassignedG + left.g.size() >= left.s.size() + middle.unassignedS\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG\\n                            >= left.s.size() + middle.unassignedS + right.s.size()\\n                    && this.previous.unassignedG + left.g.size() + middle.unassignedG + right.g.size()\\n                            >= left.s.size() + middle.unassignedS + right.s.size() + this.next.unassignedS) {\\n                this.previous.next = this.next.next;\\n                if (this.next.next != null) {\\n                    this.next.next.previous = this.previous;\\n                }\\n                this.previous.unassignedG += this.g.size() - this.s.size() + this.next.unassignedG - this.next.unassignedS;\\n                this.previous.c += this.s.size() + this.next.unassignedS + this.next.c;\\n                this.previous.rightInsertionSort();\\n                if (this.previous.next != null) {\\n                    this.previous.leftPriority = this.previous.next.next.leftPriority - this.previous.next.next.unassignedS\\n                            + this.previous.next.next.unassignedG - this.previous.next.s.size() + this.previous.next.g.size();\\n                }\\n                MixedPartition.root = MixedPartition.mergeSort(this.leftChild, this.rightChild);\\n            }\\n        }\\n    }\\n\\n    public int findContentChildren(int[] g, int[] s) {\\n        if (g.length == 0 || s.length == 0) {\\n            return 0;\\n        }\\n\\n        MixedPartition.root = new MixedPartition(new ArrayList<Integer>(Arrays.stream(g).boxed().collect(Collectors.toList())),\\n                new ArrayList<Integer>(Arrays.stream(s).boxed().collect(Collectors.toList())));\\n        PurePartition.head = new PurePartition();\\n        PurePartition.tail = new PurePartition();\\n        PurePartition.head.next = MixedPartition.root;\\n        MixedPartition.root.previous = PurePartition.head;\\n        MixedPartition.root.next = PurePartition.tail;\\n        PurePartition.tail.previous = MixedPartition.root;\\n        PurePartition.head.leftPriority = 0;\\n        PurePartition.tail.rightPriority = 0;\\n\\n        MixedPartition.heapSort();\\n        return PurePartition.head.c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797915,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n         int ans=0;\\n        int i=g.size()-1;\\n        sort(g.begin(),g.end());\\n         sort(s.rbegin(),s.rend());\\n        if(g.size()==0||s.size()==0)  return 0;\\n        auto it=s.begin();\\n        while(i>=0){\\n            \\n            if(g[i]<=*it) { ans++;  \\n                if(it==s.end()-1) return ans;\\n                           \\n                           it++;\\n        }     i--;    }\\n           \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n         int ans=0;\\n        int i=g.size()-1;\\n        sort(g.begin(),g.end());\\n         sort(s.rbegin(),s.rend());\\n        if(g.size()==0||s.size()==0)  return 0;\\n        auto it=s.begin();\\n        while(i>=0){\\n            \\n            if(g[i]<=*it) { ans++;  \\n                if(it==s.end()-1) return ans;\\n                           \\n                           it++;\\n        }     i--;    }\\n           \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768030,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int count=0;\\n        int i=0,j=0;\\n        \\n        while(i<g.length && j<s.length)\\n        {\\n            if(g[i]<=s[j])\\n            {\\n                i++;\\n                j++;\\n                count++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        \\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        \\n        int count=0;\\n        int i=0,j=0;\\n        \\n        while(i<g.length && j<s.length)\\n        {\\n            if(g[i]<=s[j])\\n            {\\n                i++;\\n                j++;\\n                count++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744162,
                "title": "assign-cookieas-solution-java",
                "content": "class Solution {\\n  public int findContentChildren(int[] g, int[] s) {\\n    Arrays.sort(g);\\n    Arrays.sort(s);\\n\\n    int i = 0;\\n    for (int j = 0; i < g.length && j < s.length; ++j)\\n      if (g[i] <= s[j])\\n        ++i;\\n\\n    return i;\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int findContentChildren(int[] g, int[] s) {\\n    Arrays.sort(g);\\n    Arrays.sort(s);\\n\\n    int i = 0;\\n    for (int j = 0; i < g.length && j < s.length; ++j)\\n      if (g[i] <= s[j])\\n        ++i;\\n\\n    return i;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1716464,
                "title": "assign-cookies-c-solution-with-explanation",
                "content": "**Approach:**\\n\\n1. Sort both the greed and cookies in ascending order.\\n1. Then check whether the lowest cookie can satisfy the lowest greedy kid.\\n1. If it doesn\\'t, check for next cookie which has just greater satisfaction.\\n1. If it does satisfy, *assign the cookie* or we can say move to next cookie and next greedy child.\\n\\n**C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        // if you don\\'t have cookies, you can\\'t assign\\n\\t\\tif (s.empty())\\n            return 0;\\n        \\n\\t\\t// sort the greed\\n        sort(g.begin(), g.end());\\n\\t\\t\\n\\t\\t// sort the cookies satisfaction value\\n        sort(s.begin(), s.end());\\n        \\n\\t\\t// count of children\\n        int count = 0;\\n        \\n\\t\\t// iterator to cookies\\n        auto s_it = s.begin();\\n\\t\\t\\n\\t\\t// let\\'s loop for every child\\n        for (auto g_it = g.begin(); g_it != g.end();)\\n        {\\n\\t\\t\\t// if you still have cookies\\n            if (s_it != s.end())\\n            {\\n\\t\\t\\t\\t// if the cookies satisfy the child\\n                if ((*s_it) >= (*g_it))\\n                {\\n\\t\\t\\t\\t\\t// increase count and move to next greedy child\\n                    count++;\\n                    g_it++;\\n                }\\n\\t\\t\\t\\t// move to next cookie\\n                s_it++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        // if you don\\'t have cookies, you can\\'t assign\\n\\t\\tif (s.empty())\\n            return 0;\\n        \\n\\t\\t// sort the greed\\n        sort(g.begin(), g.end());\\n\\t\\t\\n\\t\\t// sort the cookies satisfaction value\\n        sort(s.begin(), s.end());\\n        \\n\\t\\t// count of children\\n        int count = 0;\\n        \\n\\t\\t// iterator to cookies\\n        auto s_it = s.begin();\\n\\t\\t\\n\\t\\t// let\\'s loop for every child\\n        for (auto g_it = g.begin(); g_it != g.end();)\\n        {\\n\\t\\t\\t// if you still have cookies\\n            if (s_it != s.end())\\n            {\\n\\t\\t\\t\\t// if the cookies satisfy the child\\n                if ((*s_it) >= (*g_it))\\n                {\\n\\t\\t\\t\\t\\t// increase count and move to next greedy child\\n                    count++;\\n                    g_it++;\\n                }\\n\\t\\t\\t\\t// move to next cookie\\n                s_it++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703493,
                "title": "my-python-solution",
                "content": "class Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\n        i, j = 0, 0\\n        g, s = sorted(g), sorted(s)\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i +=1\\n            j += 1\\n        return i",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\\n\\t\\n        i, j = 0, 0\\n        g, s = sorted(g), sorted(s)\\n        while i < len(g) and j < len(s):\\n            if s[j] >= g[i]:\\n                i +=1\\n            j += 1\\n        return i",
                "codeTag": "Java"
            },
            {
                "id": 1694220,
                "title": "c-solved-using-multiset",
                "content": "int content{0};\\n        \\n        std::multiset<int> greed, cookies;\\n        \\n        for(int i=0; i<g.size(); i++)\\n        {\\n            greed.insert(g[i]);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            cookies.insert(s[i]);\\n        }\\n        \\n        std::multiset<int>::iterator git = greed.begin(), cit = cookies.begin();\\n        \\n        while(git != greed.end() && cit != cookies.end())\\n        {\\n            if(*cit >= *git)\\n            {\\n                content++;\\n                git++;\\n                cit++;\\n            }\\n            else\\n            {\\n                cit++;\\n            }         \\n        }\\n        \\n        return content;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "int content{0};\\n        \\n        std::multiset<int> greed, cookies;\\n        \\n        for(int i=0; i<g.size(); i++)\\n        {\\n            greed.insert(g[i]);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            cookies.insert(s[i]);\\n        }\\n        \\n        std::multiset<int>::iterator git = greed.begin(), cit = cookies.begin();\\n        \\n        while(git != greed.end() && cit != cookies.end())\\n        {\\n            if(*cit >= *git)\\n            {\\n                content++;\\n                git++;\\n                cit++;\\n            }\\n            else\\n            {\\n                cit++;\\n            }         \\n        }\\n        \\n        return content;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1656921,
                "title": "1-min-to-understand-greedy-java-solution",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int childIndex = 0;\\n        int cookieIndex = 0;\\n        int satisfied = 0;\\n        while (childIndex < g.length && cookieIndex < s.length) {\\n            if (s[cookieIndex] >= g[childIndex]) {\\n                childIndex++;\\n                cookieIndex++;\\n                satisfied++;\\n            } else {\\n                cookieIndex++;\\n            }\\n        }\\n        return satisfied;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int childIndex = 0;\\n        int cookieIndex = 0;\\n        int satisfied = 0;\\n        while (childIndex < g.length && cookieIndex < s.length) {\\n            if (s[cookieIndex] >= g[childIndex]) {\\n                childIndex++;\\n                cookieIndex++;\\n                satisfied++;\\n            } else {\\n                cookieIndex++;\\n            }\\n        }\\n        return satisfied;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643042,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int i=0,j=0,count=0;\\n        while(i!=g.size() && j!=s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        int i=0,j=0,count=0;\\n        while(i!=g.size() && j!=s.size()){\\n            if(g[i]<=s[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632708,
                "title": "easy-c-solution",
                "content": "**If you like the solution please upvote it**\\n     \\n\\t\\n    class Solution {\\n    public:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n       sort(s.begin(),s.end());\\n       sort(g.begin(),g.end());\\n        int count=0,c=0;\\n         for(int i=0;i<s.size();i++)\\n          {\\n            for(int j=c;j<g.size();j++)\\n            {\\n             if(s[i]>=g[j]) \\n              {\\n               count++;\\n                c++;\\n               break;\\n              }\\n            } \\n          }\\n      return count;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n       sort(s.begin(),s.end());\\n       sort(g.begin(),g.end());\\n        int count=0,c=0;\\n         for(int i=0;i<s.size();i++)\\n          {\\n            for(int j=c;j<g.size();j++)\\n            {\\n             if(s[i]>=g[j]) \\n              {\\n               count++;\\n                c++;\\n               break;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1626517,
                "title": "easy-c-solution-using-2-pointer",
                "content": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0, j = 0, n1 = g.size(), n2 = s.size(), ans = 0;\\n        while(i<n1 && j<n2){\\n            if(g[i] <= s[j]){\\n                i++;j++;ans++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        int i = 0, j = 0, n1 = g.size(), n2 = s.size(), ans = 0;\\n        while(i<n1 && j<n2){\\n            if(g[i] <= s[j]){\\n                i++;j++;ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621901,
                "title": "easy-c-solution-with-2-pointers-time-90-memory-77",
                "content": "```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        //After sorting we will check from the beginning of arrays\\n        \\n        int a=0;\\n        int b=0;\\n        \\n        while( a<g.size() && b<s.size()){\\n            if(g[a]<=s[b]){\\n                a++;\\n                b++;\\n            }\\n            else{\\n                b++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        sort(g.begin(), g.end());\\n        sort(s.begin(), s.end());\\n        //After sorting we will check from the beginning of arrays\\n        \\n        int a=0;\\n        int b=0;\\n        \\n        while( a<g.size() && b<s.size()){\\n            if(g[a]<=s[b]){\\n                a++;\\n                b++;\\n            }\\n            else{\\n                b++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613230,
                "title": "simple-java-solution-optimized",
                "content": "found this approach on leetcode-discussion\\n```\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count = 0, i = 0, j = 0, m = g.length, n = s.length;\\n        while (i < m && j < n) {\\n            if (g[i] > s[j]) j++;  // find next larger cookie\\n            else {  // assign the min content to the min cookie;\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n```",
                "solutionTags": [],
                "code": "```\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int count = 0, i = 0, j = 0, m = g.length, n = s.length;\\n        while (i < m && j < n) {\\n            if (g[i] > s[j]) j++;  // find next larger cookie\\n            else {  // assign the min content to the min cookie;\\n                count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601990,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i=0, j=0;\\n        for(j=0; j<s.length && i<g.length; j++)\\n            if(s[j] >= g[i])\\n                i++;\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n        Arrays.sort(g);\\n        Arrays.sort(s);\\n        int i=0, j=0;\\n        for(j=0; j<s.length && i<g.length; j++)\\n            if(s[j] >= g[i])\\n                i++;\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575606,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int n1 = g.size();\\n        int n2 = s.size();\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        if(n2 == 0)\\n            return 0;\\n        int i = 0,j = 0,c = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(g[i] <= s[j])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int n1 = g.size();\\n        int n2 = s.size();\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        if(n2 == 0)\\n            return 0;\\n        int i = 0,j = 0,c = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(g[i] <= s[j])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529753,
                "title": "java-o-nlogn-6ms",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) \\n    {\\n        int j=0,i=0,c=0; \\n        int n=g.length,m=s.length;\\n        Arrays.sort(g); Arrays.sort(s);\\n       while(i<n && j<m)\\n       {\\n           if(s[j]>=g[i])\\n           { \\n               c++; i++; j++;\\n           }\\n           else if(s[j]<g[i])\\n               j++;   \\n       }\\n        return c;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findContentChildren(int[] g, int[] s) \\n    {\\n        int j=0,i=0,c=0; \\n        int n=g.length,m=s.length;\\n        Arrays.sort(g); Arrays.sort(s);\\n       while(i<n && j<m)\\n       {\\n           if(s[j]>=g[i])\\n           { \\n               c++; i++; j++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1431760,
                "title": "o-n-log-n-c",
                "content": "int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int p1 = g.size()-1;\\n        int p2 = s.size()-1;\\n        int satisfactory = 0;\\n\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        \\n        while(p1>=0 && p2>=0)\\n        {\\n            if(s[p2]>=g[p1])\\n            {\\n               satisfactory+=1; \\n                p2--;\\n                p1--;\\n            }\\n            else\\n            {\\n                p1--;\\n            }\\n        }\\n        return satisfactory;\\n    }",
                "solutionTags": [],
                "code": "int findContentChildren(vector<int>& g, vector<int>& s) {\\n        \\n        int p1 = g.size()-1;\\n        int p2 = s.size()-1;\\n        int satisfactory = 0;\\n\\n        sort(g.begin(),g.end());\\n        sort(s.begin(),s.end());\\n        \\n        while(p1>=0 && p2>=0)\\n        {\\n            if(s[p2]>=g[p1])\\n            {\\n               satisfactory+=1; \\n                p2--;\\n                p1--;\\n            }\\n            else\\n            {\\n                p1--;\\n            }\\n        }\\n        return satisfactory;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427789,
                "title": "java-with-14-efficiency-easy-with-explanation",
                "content": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n\\t\\n\\t\\n        //here we are sorting the arrays bcz after that it will become  possible\\n\\t\\t//for more no. of childrens to fulfill there feeds\\n\\t\\t\\n\\t\\t//how?\\n\\t\\t\\n\\t\\t//ans: in sorted array (g) children with less feed will appear first and cookies with smaller sizes too(s)\\n\\t\\t//now the first child if have feed <=size[i] cookie he?she will get satisfied \\n\\t\\t// and the cookies with larger size will remain for childrens with larger feed\\n\\t\\t\\n\\t\\t\\n\\t\\tArrays.sort(g);\\n        Arrays.sort(s);\\n\\t\\t\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n\\t\\t\\n        while (i < g.length && j < s.length) {\\n\\t\\t\\n            if (g[i] <= s[j]) \\n\\t\\t\\t{\\n                count++;\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\telse {\\n\\n                j++;\\n            }\\n            \\n        }\\n        return count;\\n              \\n    }\\n}    \\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int findContentChildren(int[] g, int[] s) {\\n\\t\\n\\t\\n        //here we are sorting the arrays bcz after that it will become  possible\\n\\t\\t//for more no. of childrens to fulfill there feeds\\n\\t\\t\\n\\t\\t//how?\\n\\t\\t\\n\\t\\t//ans: in sorted array (g) children with less feed will appear first and cookies with smaller sizes too(s)\\n\\t\\t//now the first child if have feed <=size[i] cookie he?she will get satisfied \\n\\t\\t// and the cookies with larger size will remain for childrens with larger feed\\n\\t\\t\\n\\t\\t\\n\\t\\tArrays.sort(g);\\n        Arrays.sort(s);\\n\\t\\t\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n\\t\\t\\n        while (i < g.length && j < s.length) {\\n\\t\\t\\n            if (g[i] <= s[j]) \\n\\t\\t\\t{\\n                count++;\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\telse {\\n\\n                j++;\\n            }\\n            \\n        }\\n        return count;\\n              \\n    }\\n}    \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1948286,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1754591,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1567265,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1886550,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1567977,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1718630,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 2074106,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 2015440,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1980452,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1959068,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1948286,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1754591,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1567265,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1886550,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1567977,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1718630,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 2074106,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 2015440,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1980452,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            },
            {
                "id": 1959068,
                "content": [
                    {
                        "username": "coderrsc",
                        "content": "who the f*** have  3 * 10^4  children"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "Your comment is logical. The question statement could be better modified to replace \\'parent\\' with school headmaster or coach etc who has such a high number of children under his guidance."
                    },
                    {
                        "username": "raaven_4321",
                        "content": "\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06"
                    },
                    {
                        "username": "Veloscocity",
                        "content": "I do"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[@coderrsc](/coderrsc) lol we are very awesome parents"
                    },
                    {
                        "username": "coderrsc",
                        "content": "[@ComprehensiveDuck](/ComprehensiveDuck)  Read the very first line bro"
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "Orphanages maybe"
                    },
                    {
                        "username": "NKH1701",
                        "content": "hahahaha"
                    },
                    {
                        "username": "ozans",
                        "content": "If the question states that the arrays are not ordered, that might make it more descriptive. Thanks for preparing the questions :)"
                    },
                    {
                        "username": "mertekren",
                        "content": "# so true. dont give 2 examples with perfectly ordered examples"
                    },
                    {
                        "username": "Joy4fun",
                        "content": "What if each child can get more than 1 cookies? Still each cookie can only be assigned to 1 child."
                    },
                    {
                        "username": "DeHuff",
                        "content": "This is poorly written, it should more directly state that you can only give each child 1 cookie. It is not clear what the restrictions are from the read me."
                    },
                    {
                        "username": "funcode",
                        "content": "The Greedy algorithm is :\\nalways give the person who has smallest requirement smallest cookies;\\n\\nObviously, the persons who get cookies in Greedy algorithm are in continuous ascending order by requirement and starting from the person who has smallest requirement.\\nLet A donates the optimal result set  sorted by requirement and size is n, then A can be converted into the set that contains the persons who are in continuous ascending order by requirement and starting from the person who has \\nsmallest requirement.\\nLet B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\\nObviously,  k <= n. The Greedy algorithm is correct only if k == n.\\nFollowing is the proof for k == n.\\nI will use contradiction to demonstrate k can't be less than n.\\n\\nlemma: Ai >= Bi, i is in {1 ... k}, this lemma can be gotten directly from Greedy Algorithm which is \\nalways giving the person who has smallest requirement smallest cookies;\\n\\nBy lemma, we can get Ak+1 >= Bk.\\nif Ak+1 > Bk, B1...Bk, Ak+1, ... An can form new optimal result, but this is the contradicted with the size only being k for the result gotten from Greedy Algorithm.\\nif Ak+1 == Bk, there must be An-1 == Bk. let's say the continuous same requirement person in B is from Bj ... Bk, so Aj...Ak also are same and Ak+1 ... An also same, it means Bj...Bk,Ak+1,...An still can form new optimal result, this is contracdicted with the size only is k for the result gotten from Greedy Algorithm.\\nSo, k == n."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dhtmlkitchen](/dhtmlkitchen)  They meant \"denotes\". A lemma is \"A thing we assume to be true for the purpose of this proof\", its a maths term.   "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"Let B donates the result set sorted by requirement gotten from Greedy algorithm and size is k.\"\\n\\nWhat? \\n\\nAnd what is lemma?"
                    },
                    {
                        "username": "shivam1100",
                        "content": "What if two children have same greed factor?"
                    },
                    {
                        "username": "k_praphull",
                        "content": "Then any one of them get cookies"
                    },
                    {
                        "username": "farial_mahmod",
                        "content": "The key point to solve this using two pointers is that cookies are to be greater than or equal to the children number inside the loops."
                    },
                    {
                        "username": "subarna98",
                        "content": "Please help me understand why this is failing. I am using brute force to find the smallest cookie that will satisfy a child. This is passing 18/21 cases.\\n\\n `class Solution {\\npublic:\\n    int findContentChildren(vector<int>& g, vector<int>& s) {\\n        int ans=0,index=-1;\\n        int n=g.size();\\n        int m=s.size();\\n\\n        if(m==0)\\n        return 0;\\n        vector<int> vis(m,0);\\n\\n        for(auto it:g){\\n            int mini=INT_MAX;\\n            for(int i=0;i<m;i++){\\n                if(vis[i]==1)\\n                continue;\\n                if(s[i]>=it){\\n                    mini=min(mini,s[i]);\\n                    index=i;\\n                }\\n            }\\n            if(index!=-1)\\n            vis[index]=1;\\n        }\\n        for(auto it:vis){\\n            if(it==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this not working for a test case in which we need to output 960 but 955 is being output?\nIf I sort the vector, then it works, but why is that? I am using bruteforce approach which should check all possible combinations, so why there is a difference of 5 in my output?\n\n```cpp\nint findContentChildren(vector<int> g, vector<int> s)\n\t{\n\t\tset<int> receivers;\n\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\t//cout << \"Cookie #\" << i << \" of size \" << s[i] << endl;\n\t\t\tfor (int j = 0; j < g.size(); j++)\n\t\t\t{\n\t\t\t\t//cout << \"Checking child #\" << j << \" with greed \" << g[j] << endl;\n\t\t\t\t\n\t\t\t\tif  (receivers.find(j) == receivers.end() && s[i] >= g[j])\n\t\t\t\t{\n\t\t\t\t\t//cout << \"Added #\" << j << endl;\n\t\t\t\t\treceivers.insert(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn receivers.size();\n\t}\n```"
                    },
                    {
                        "username": "mafishere",
                        "content": "[@bparanj](/bparanj) Thank you very much, I understood from the example."
                    },
                    {
                        "username": "bparanj",
                        "content": "The provided code doesn\\'t guarantee to satisfy the maximum number of children, because it doesn\\'t always satisfy the child with the least \"greed\" factor first. Specifically, it loops over the cookies, then for each cookie, it loops over the children and assigns the cookie to the first child it encounters whose \"greed\" is less than or equal to the cookie size. The issue arises from the fact that a cookie could be given to a child with a higher \"greed\" factor, while a child with a lower \"greed\" factor could remain unsatisfied.\\n\\nConsider an example:\\n\\n- `g = [1, 2, 3]`, `s = [3, 1, 2]` - greed factors and cookie sizes are the same but not in the same order. \\n\\nWith the existing code, here\\'s how the distribution might look:\\n\\n- Cookie of size 3 goes to child with greed 1.\\n- Cookie of size 1 goes to child with greed 2.\\n- Cookie of size 2 cannot satisfy any remaining child (with greed 3).\\n\\nAlthough all children could be satisfied, only 2 children get cookies because of how the cookies are distributed.\\n\\nSorting both the greed factor and size arrays in increasing order ensures that each cookie goes to the child with the smallest possible \"greed\" factor that it can satisfy. In other words, each cookie goes to the \"least greedy\" child it can satisfy, thereby maximizing the number of satisfied children. This is why the code works when you sort the vectors.\\n\\nIn the sorted version of the example above:\\n\\n- `g = [1, 2, 3]`, `s = [1, 2, 3]` (both sorted in increasing order).\\n\\nThe distribution now looks like:\\n\\n- Cookie of size 1 goes to child with greed 1.\\n- Cookie of size 2 goes to child with greed 2.\\n- Cookie of size 3 goes to child with greed 3.\\n\\nNow all children get cookies."
                    },
                    {
                        "username": "NikithK",
                        "content": "What if there is some cookies that will be wasted? For example if there are three children with a greed factors of 1,2,3 and cookie size of 1,3. Should a cookie be given to the child with a greed factor of 2 or greed factor of 3?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Split Concatenated Strings",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1567358,
                "content": [
                    {
                        "username": "hl1117",
                        "content": "Input:\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n\"cba\"\\nExpected:\\n\"cab\"\\nWhy \"cab\" is the expected output?\\n\"cba\" is greater than \"cab\"\\n"
                    },
                    {
                        "username": "Student2091",
                        "content": "Title. I got 2 WA for 2 versions of what I think the question is, and still don\\'t really understand what the question wants. \\n\\nAm I just really that bad at understanding the question? \\nIt is really frustrating to code up 2 different solutions and they turn out to be completely irrelevant to the question."
                    }
                ]
            },
            {
                "id": 1576627,
                "content": [
                    {
                        "username": "hl1117",
                        "content": "Input:\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n\"cba\"\\nExpected:\\n\"cab\"\\nWhy \"cab\" is the expected output?\\n\"cba\" is greater than \"cab\"\\n"
                    },
                    {
                        "username": "Student2091",
                        "content": "Title. I got 2 WA for 2 versions of what I think the question is, and still don\\'t really understand what the question wants. \\n\\nAm I just really that bad at understanding the question? \\nIt is really frustrating to code up 2 different solutions and they turn out to be completely irrelevant to the question."
                    }
                ]
            }
        ]
    },
    {
        "title": "Coin Path",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1738419,
                "content": [
                    {
                        "username": "luckymaster",
                        "content": "Can we Solve this problem with Dijkstra Shortest Path? I tried but only 198/226 Test case are passing."
                    },
                    {
                        "username": "luckymaster",
                        "content": "What is maxJump for,  is the number of Jumps I have to take to reach last index, or its the range of my jump from any index i.\\n\\nFor Example\\nInput: coins = [1,2,4,-1,2], maxJump = 1\\nOutput: []\\n\\nWhy output is empty, I can take 1 jump from each index and reach the last.\\n?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@isakovi](/isakovi)  Thanks\\n"
                    },
                    {
                        "username": "isakovi",
                        "content": "You can't jump to an index with `-1` as its value\n\n> You can jump to any index `i` of the array `coins` if `coins[i] != -1`\n\nSo index 3 (or 4 in the problem statement) has `-1` in it, therefore we cannot reach the last index"
                    }
                ]
            },
            {
                "id": 1715760,
                "content": [
                    {
                        "username": "luckymaster",
                        "content": "Can we Solve this problem with Dijkstra Shortest Path? I tried but only 198/226 Test case are passing."
                    },
                    {
                        "username": "luckymaster",
                        "content": "What is maxJump for,  is the number of Jumps I have to take to reach last index, or its the range of my jump from any index i.\\n\\nFor Example\\nInput: coins = [1,2,4,-1,2], maxJump = 1\\nOutput: []\\n\\nWhy output is empty, I can take 1 jump from each index and reach the last.\\n?"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@isakovi](/isakovi)  Thanks\\n"
                    },
                    {
                        "username": "isakovi",
                        "content": "You can't jump to an index with `-1` as its value\n\n> You can jump to any index `i` of the array `coins` if `coins[i] != -1`\n\nSo index 3 (or 4 in the problem statement) has `-1` in it, therefore we cannot reach the last index"
                    }
                ]
            }
        ]
    }
]