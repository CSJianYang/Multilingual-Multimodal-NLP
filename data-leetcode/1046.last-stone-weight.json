[
    {
        "title": "Last Stone Weight",
        "question_content": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\tIf x == y, both stones are destroyed, and\n\tIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\n&nbsp;\nExample 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\nExample 2:\nInput: stones = [1]\nOutput: 1\n&nbsp;\nConstraints:\n\t1 <= stones.length <= 30\n\t1 <= stones[i] <= 1000",
        "solutions": [
            {
                "id": 294956,
                "title": "java-c-python-priority-queue",
                "content": "# **Explanation**\\nPut all elements into a priority queue.\\nPop out the two biggest, push back the difference,\\nuntil there are no more two elements left.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Java, PriorityQueue**\\n```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\\n\\n**C++, priority_queue**\\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\\n**Python, using heap, O(NlogN) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\\n\\n**Python, using binary insort, O(N^2) time**\\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int lastStoneWeight(int[] A) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> b - a);\\n        for (int a : A)\\n            pq.offer(a);\\n        while (pq.size() > 1)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n    }\\n```\n```cpp\\n    int lastStoneWeight(vector<int>& A) {\\n        priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        h = [-x for x in A]\\n        heapq.heapify(h)\\n        while len(h) > 1 and h[0] != 0:\\n            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))\\n        return -h[0]\\n```\n```py\\n    def lastStoneWeight(self, A):\\n        A.sort()\\n        while len(A) > 1:\\n            bisect.insort(A, A.pop() - A.pop())\\n        return A[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921100,
                "title": "simple-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/fc5f29d9-7e2e-4f5b-a3d9-2c5654652b76_1649292145.9654834.png)\\n\\n```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int lastStoneWeight(vector<int>& stones) \\n    {\\n        priority_queue<int> pq(stones.begin(),stones.end());\\n        while(pq.size()>1)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x!=y) pq.push(y-x);\\n        }\\n        return pq.empty()? 0 : pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921241,
                "title": "python-beginner-friendly-optimisation-process-with-explanation",
                "content": "### Introduction\\n\\nGiven an array of stones `stones`, we repeatedly \"smash\" (i.e., compare) the two heaviest stones together until there is at most one stone left. If the two heaviest stones are of the same weight, both stones are \"destroyed\" (i.e., both weights become 0), otherwise, a stone with the absolute weight difference of both stones will remain.\\n\\nNote that the order in which the stones are \"smashed\" needs to be followed strictly. Otherwise, we will not end up with the correct weight of the remaining stone, if any.\\n\\n```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\\n\\n---\\n\\n### Base Approach - Sort and Insert\\n\\nSince we are required to \"smash\" the two heaviest stones, we need to know which two stones are the heaviest, and for all iterations. As such, we will first have to sort the stones in order by weight in order to compare the two heaviest stones.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\nAll that remains now is how we can insert the stone from the \"smashing\" of the two heaviest stones back into `stones`. The simplest method is to loop through `stones` and insert the stone in the correct index.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**, where `n` is the length of `stones`, due to the nested inserts.\\n**SC: O(1)**, no additonal data structures are used.\\n\\n---\\n\\n### Slight Optimisation - Binary Search Insert\\n\\nAn \"optimisation\" from the above method to find the index to insert the remaining stone is to binary search for the index to insert to instead of looping through `stones` manually. This involves Python\\'s [bisect library](https://docs.python.org/3/library/bisect.html) which has a pre-written function to help us do just that.\\n\\nNote that we only need to change one portion of the code; the remaining code logic is the same.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(n<sup>2</sup>)**. Even though binary searching for the index to insert to takes O(logn) time, the insert function alone takes O(n) time because it needs to shift all the elements after the index to the right by 1. As such, the overall time complexity for `insort_left()` is O(n).\\n**SC: O(1)**, as discussed above.\\n\\n---\\n\\n### Data Structure - Heap Implementation\\n\\nUnfortunately, due to the implementation of the list data structure, even the binary search optimisation cannot break free of the O(n) insert. If only there was a data structure that could help us sort and insert automatically without having to rely on a heavier insert function...\\n\\nPython has an in-built [heap library](https://docs.python.org/3/library/heapq.html) that is perfect for this task. Essentially, all we need to do is insert the elements, and the heap will settle the sorting order for us. Unfortunately, Python\\'s heap library implements a min-heap instead of a max-heap, whereby popping will give us the lightest stone instead of the heaviest stone.\\n\\nA standard (very common!) workaround is to **negate all the weight values of the stones**. This way, the heaviest stone has the most negative value, and hence becomes the smallest value in the heap. Then, all we have to do after obtaining the value from the heap is to un-negate the value to use it in our calculations.\\n\\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\\n\\n**TC: O(nlogn)**; `heappush()` and `heappop()` both have O(logn) time complexity, and are both nested in the while loop. Note: `heapify()` runs in O(n) time, hence the time complexity is not affected.\\n**SC: O(1)**; both the negation and the heapify are done in-place.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```text\\narr = [2, 7, 4, 1, 8, 1]\\n\\nCORRECT METHOD\\n1) Smash 8 and 7 -> arr = [2, 4, 1, 1, 1]\\n2) Smash 4 and 2 -> arr = [2, 1, 1, 1]\\n3) Smash 2 and 1 -> arr = [1, 1, 1]\\n4) Smash 1 and 1 -> arr = [1]\\n\\nWRONG METHOD #1 (according to index ordering)\\n1) Smash 2 and 7 -> arr = [5, 4, 1, 8, 1]\\n2) Smash 5 and 4 -> arr = [1, 1, 8, 1]\\n3) Smash 1 and 1 -> arr = [8, 1]\\n4) Smash 8 and 1 -> arr = [7]\\n\\nWRONG METHOD #2 (in ascending order)\\n1) Smash 1 and 1 -> arr = [2, 7, 4, 8]\\n2) Smash 2 and 4 -> arr = [2, 7, 8]\\n3) Smash 2 and 7 -> arr = [5, 8]\\n4) Smash 5 and 8 -> arr = [3]\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # we need to insert the remaining stone (s1-s2) into the list\\n                pass\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # loop through stones to find the index to insert the stone\\n                for i in range(len(stones)+1):\\n                    if i == len(stones) or stones[i] >= s1-s2:\\n                        stones.insert(i, s1-s2)\\n                        break\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while stones:\\n            s1 = stones.pop()  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                # the remaining stone will be s1-s2\\n                # binary-insert the remaining stone into stones\\n                insort_left(stones, s1-s2)\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```\n```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # first, negate all weight values in-place\\n        for i, s in enumerate(stones):\\n            stones[i] = -s\\n        heapify(stones)  # pass all negated values into the min-heap\\n        while stones:\\n            s1 = -heappop(stones)  # the heaviest stone\\n            if not stones:  # s1 is the remaining stone\\n                return s1\\n            s2 = -heappop(stones)  # the second-heaviest stone; s2 <= s1\\n            if s1 > s2:\\n                heappush(stones, s2-s1)  # push the NEGATED value of s1-s2; i.e., s2-s1\\n            # else s1 == s2; both stones are destroyed\\n        return 0  # if no more stones remain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448875,
                "title": "c-explained-easy-solution-priority-queue",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- #### To solve this problem, we can use a priority queue to keep track of the heaviest stones. \\n- #### At each turn, we can pop the two heaviest stones from the heap, smash them together according to the given rules, and then push the resulting stone (if any) back onto the heap. \\n- #### We repeat this process until there is at most one stone left in the heap.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- #### In this code, we first create the priority queue by negating the values of the stones. \\n- #### We then loop until there is at most one stone left in the heap. Inside the loop, we pop the two heaviest stones from the queue and check whether they are equal or not.\\n    1. #### If they are not equal, we calculate the weight of the resulting stone and push it back onto the Queue (priority queue heapify itself after every push operation).\\n- #### Finally, we return the weight of the last remaining stone (or 0 if there are no stones left).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/8044a3f7-5e30-4954-bb50-1485656ecab5_1682302010.1464121.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        priority_queue<int>pq(a.begin(),a.end());\\n\\n        while(pq.size() > 1)\\n        {\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n\\n            if(a != b)\\n                pq.push(abs(a-b));\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575674,
                "title": "java-simple-to-complex-solutions-explained-0-ms-top-100-time-100-memory-2-lines-of-code-only",
                "content": "At every step of the algorithm, we need to know the top heaviest stone.\\nThe most efficient way to retrieve the max for large input sizes is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator:\\n\\nO(n log (n)) time O(n) space \\n1 ms time 37.5 MB space\\n91% time 100% space\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\\n\\nBut we can do better, right? If you have done a few of these problems you might know to use BucketSort with has constant access and no typical \"sorting\", we can do O(n) time. \\n\\nHowever, it is more accurate to say the time would be O(n + maxStoneWeight) because we will build a bucket for every possible weight. And usually a O(n + 1000) would be a great solution, but the test cases here have a very short input size. the number of stones goes only from 0 to 30, so this solution actually performs worse than O(n) since n is at most 30! O(30) == O(1030) but 30 < 1030. Both have the same complexity, but the first runs faster, and you might have not noticed why unless you check the inputs given in the tests.\\n\\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\\n\\nRuns even slower! Remember to not always apply a solution that seems faster because you didn\\'t consider your context or use cases. here the number of stones is much smaller than the weight of the stones.\\n\\nSo if we know that the number of stones is quite small, can we do even better than the PriorityQueue? What is a very fast sorting algorithm for small sets, better than building a heap? Sort in place in the array! Don\\'t waste time building new objects or copies of the input.\\n\\nO( n^2 log(n) ) because for every stone n, we sort the array O(nlog(n))\\nO(1) space, no extra space, sort in place\\n**0 ms time 36.9 MB\\tspace\\nfaster than 100% and less space used than 100% of other solutions**\\n\\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\\n\\nAnd just for fun, let\\'s mangle it into **2 lines**:\\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```\\n\\nEDIT: \\nTo be completely clear, if the input size was unrestricted and not less than 30 stones, BucketSort would be the best solution because it runs in O(maxStoneWeight). If the stones weight is not unrestricted, then BucketSort cannot work as you would need 2,147,483,647 buckets. In that case, PriorityQueue would be the best solution.\\n\\n**In an interview, you should only discuss either BucketSort or PriorityQueue (max head) solutions**. The only reason I mentioned the sorting solution, which is much worse than the two other solutions, is because the input size in the tests of this challenge are so small that this solution is faster.",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i : stones) {\\n            queue.add(i);\\n        }\\n        int x;\\n        int y;\\n        while(queue.size() > 1) {\\n            y = queue.poll();\\n            x = queue.poll();\\n            if(y > x) {\\n                queue.offer(y-x);   \\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n```\n```\\n    int[] buckets = new int[1001];\\n    for(int stone: stones)\\n      buckets[stone]++;\\n    int i = 1000;\\n    int j;\\n    while(i > 0) {\\n      if(buckets[i] == 0) {\\n        i--;\\n      } else {\\n        buckets[i] = buckets[i] % 2;\\n        if(buckets[i] != 0) {\\n          j = i-1;\\n          while(j > 0 && buckets[j] == 0)\\n            j--;\\n          if(j == 0)\\n            return i;\\n          buckets[i - j]++;\\n          buckets[j]--;\\n          i--;\\n        }\\n      }\\n    }\\n    return 0;\\n```\n```\\n  public static int lastStoneWeight(int[] stones) {\\n    Arrays.sort(stones);\\n    for(int i=stones.length-1; i>0; i--) {\\n      stones[i-1] = stones[i] - stones[i-1];\\n      Arrays.sort(stones);\\n    }\\n    return stones[0];\\n  }\\n```\n```\\n    for(int i=stones.length; i>0; stones[i-1] = i==stones.length? stones[i-1] : stones[i] - stones[i-1], Arrays.sort(stones), i--);\\n    return stones[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921254,
                "title": "a-solid-explanation",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Last Stone Weight** \\n\\nOkay, so first of all let\\'s understand the problem\\n\\n**We have 2 stones x & y**\\n\\n![image](https://assets.leetcode.com/users/images/e062b588-f311-49ea-9aa0-c19e720eb38a_1649295151.330421.png)\\n\\nAnd There could be 2 Possiblities :\\n* If both the stones x & y have same weight, then **` x == y, both stones are destroyed`**\\n\\n\\n* If they are not equal, then stone y always be greater then stone x, therefore **`x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.`** \\n\\n```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\\n\\nI hope problem statement is absolute clear, now let\\'s talk about how we gonna solve this problem.\\n\\n**Let\\'s take an example,**\\n\\n**Input**: stones = [2,7,4,1,8,1]\\n**Output**: 1\\n\\nThe very Brute force Idea came in our mind is, why don;t we just sort that array, such that we will have bigger values in the end, and to maintain that highest value in the end, we always gonna sort them once both of the stones will collide. \\n\\nWhat I mean is, let\\'s take our input array:\\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\\n\\nNow what we gonna do is, collide the 2 stones and get their difference i.e. `y - x`\\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\\nNow we gonna put that one in our array & maintain the order by sorting it back again\\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\\nSo, we gonna perform the same step for all. Well it\\'s not a great approach to go with, as our Time Complexity will be much higher.\\n\\nLet\\'s code it up, then we gonna analysis it\\'s space & time complexity:-\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN) * BigO(N) => BigO(N^2logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\nWell, now you say. Dude, let;s optimise it. \\nYes, we just goona do that stuff now!!\\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\\n\\nOkay, so we gonna take the same example & now you\\'ll ask which heap do we have to use??\\n**minHeap OR maxHeap??**\\n\\nAs, you can see we want highest value at the first & lowest value in the last. So, we gonna use **maxHeap**\\n\\nLet\\'s create our maxHeap and use the same example i.e. **`[2,7,4,1,8,1]`** to fill our heap.\\n\\nSo, our first job is, let\\'s fill our heap.\\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\\n\\nNow let\\'s fill our heap,\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\n\\nNow it\\'s time to get the stone x & y using our heap & after calculating **`y - x`** put the new difference in our stack\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nNow put that **1** into our heap & again calculate the result of stone x & y\\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\\nSo, we gonna perform the same step until & unless only 1 elemnent left in our stack.\\n\\nI hope so, ladies - n - gentlemen, approach is absolute clear, **then let\\'s code it up:**\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN)\\n\\n* **Space Complexity :-** BigO(N)\\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```\\n\\n*Heap is a specialized tree-based data structure* that is essentially almost *complete binary tree.* There are so many operations possible with **max and min heaps like -**\\n\\n`insert(), delete(), update(), findMinElement(), findMaxElement(), etc`\\n\\nAnd time complexity depends on the operation you perform on the heap.\\n\\n**`Heap Sort has O(nlog n) time complexities for all the cases ( best case, average case, and worst case).`**\\n\\n**Let us understand the reason why.** The height of a complete binary tree containing n elements is **log n**\\n\\nIn the worst case scenario, we will need to move an element from the root to the leaf node making a multiple of **log(n)** comparisons and swaps.\\n\\nDuring the `build_max_heap` stage, we do that for **n/2** elements so the worst case complexity of the `build_heap` step is **n/2xlog n ~ nlog n**.\\n\\nDuring the sorting step, we exchange the root element with the last element and heapify the root element. For each element, this again takes **log n** worst time because we might have to bring the element all the way from the root to the leaf. Since we repeat this n times, the `heap_sort` step is also **nlog n.**\\n\\nAlso since the `build_max_heap` and `heap_sort` steps are executed one after another, the algorithmic complexity is not multiplied and it remains in the order of **nlog n**.",
                "solutionTags": [],
                "code": "```\\nAt the end of the game, there is at most one stone left.\\n\\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.\\n```\n```\\n[2,7,4,1,8,1]\\n\\nLet\\'s sort it:\\n\\n[1,1,2,4,7,8]\\n```\n```\\n[1,1,2,4,7,8]  -->  y = 8      &      x = 7\\n\\nThus,\\ny - x    -->  8 - 7 = 1\\n```\n```\\n[1,1,2,4]          add => 1   in our array\\n\\n[1,1,2,4,1]          now again sort it,\\n\\n[1,1,1,2,4]\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        \\n        for(int i = stones.length - 1; i > 0; i--){\\n            stones[i - 1] = stones[i] - stones[i - 1];\\n            Arrays.sort(stones);\\n        }\\n        return stones[0];\\n    }\\n}\\n```\n```\\nFor Optimising it, we gonna use the help of Heap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|     |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                 ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|     |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                   ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|     |\\n|  7  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                     ^\\n|     |\\n|\\t  |\\t\\t\\n|     |  \\n|  7  |\\n|  4  |\\n|  2  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                       ^\\n|     |\\n|\\t  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                         ^\\n|     |\\n|  8  |\\t\\t\\n|  7  |  \\n|  4  |\\n|  2  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           ^\\n|  8  |\\n|  7  |\\t\\t\\n|  4  |  \\n|  2  |\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 8\\n|     |\\t\\t    x = 7\\n|  4  |      \\n|  2  |         and their result will be y - x => 8 - 7 = 1\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\n                Array           [2,7,4,1,8,1]\\n\\t\\t\\t\\t                           \\n|     |         y = 4\\n|     |\\t\\t    x = 2\\n|     |      \\n|  1  |         and their result will be y - x => 4 - 2 = 2\\n|  1  |\\n|  1  |\\n--------\\nmaxHeap\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int v : stones){\\n            maxHeap.offer(v);\\n        }\\n        int x;\\n        int y;\\n        while(maxHeap.size() > 1){\\n            y = maxHeap.poll();\\n            x = maxHeap.poll();\\n            if(y > x){\\n                maxHeap.offer(y - x);\\n            }\\n        }\\n        if(maxHeap.size() == 0) return 0;\\n        return maxHeap.poll();\\n    }\\n}\\n```\n```\\nTime Complexity Explanation\\'s may be still if I\\'m wrong, correct me then, THANKS <^^>\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294993,
                "title": "java-python-3-easy-code-using-priorityqueue-heapq-w-brief-explanation-and-analysis",
                "content": "Sort stones descendingly in PriorityQueue, then pop out pair by pair, compute the difference between them and add back to PriorityQueue.\\n\\nNote: since we already know the first poped out is not smaller, it is not necessary to use Math.abs().\\n\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\\n\\nIn case you want to optimize the time performance, refer to the following version, which does NOT put `0` into the PriorityQueue:\\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```\\n\\n**Analysis:**\\n\\nTime: O(nlogn), space: O(n), where n = stones.length.\\n\\n----\\n\\n**Q & A:**\\n\\nQ: If not adding zeroes in the queue when polling out two elements are equal, is the result same as the above code?\\n\\nA: Yes. 0s are always at the end of the PriorityQueue. No matter a positive deduct 0 or 0 deduct 0, the result is same as NOT adding 0s into the PriorityQueue.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\n    public int lastStoneWeight(int[] stones) {\\n    //  PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        var q = new PriorityQueue<Integer>(stones.length, Comparator.reverseOrder());  // Credit to @YaoFrankie.\\n        for (int st : stones) { \\n            q.offer(st); \\n        }\\n        while (q.size() > 1) {\\n            q.offer(q.poll() - q.poll());\\n        }\\n        return q.peek();\\n    }\\n```\n```\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        q = [-stone for stone in stones]\\n        heapq.heapify(q)\\n        while (len(q)) > 1:\\n            heapq.heappush(q, heapq.heappop(q) - heapq.heappop(q))\\n        return -q[0]\\n```\n```java\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(stones.length, Comparator.reverseOrder());\\n        IntStream.of(stones).forEach(pq::offer);\\n        while (pq.size() > 1) {\\n            int diff = pq.poll() - pq.poll();\\n            if (diff > 0) {\\n                pq.offer(diff);\\n            }\\n        }\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n```\n```python\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(hp := [-s for s in stones])\\n        while len(hp) > 1:\\n            if (diff := heappop(hp) - heappop(hp)) != 0:\\n                heappush(hp, diff)\\n        return -heappop(hp) if hp else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 294925,
                "title": "c-multiset-and-priority-queue",
                "content": "#### Approach 1: Multiset\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\\n#### Approach 2: Priority Queue\\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```\\n#### Complexity Analysys\\n- Time: O(n log n) to sort stones.\\n- Memory: O(n) for the multiset/queue.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& st) {\\n  multiset<int> s(begin(st), end(st));\\n  while (s.size() > 1) {\\n    auto w1 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    auto w2 = *prev(s.end());\\n    s.erase(prev(s.end()));\\n    if (w1 - w2 > 0) s.insert(w1 - w2);\\n  }\\n  return s.empty() ? 0 : *s.begin();\\n}\\n```\n```\\nint lastStoneWeight(vector<int>& st) {\\n  priority_queue<int> q(begin(st), end(st));\\n  while (q.size() > 1) {\\n    auto w1 = q.top(); q.pop();\\n    auto w2 = q.top(); q.pop();\\n    if (w1 - w2 > 0) q.push(w1 - w2);\\n  }\\n  return q.empty() ? 0 : q.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360047,
                "title": "super-simple-o-n-java-solution-using-bucket-sort-and-two-pointers",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }\\n\\n        int slow = buckets.length - 1;   //start from the big to small\\n        while (slow > 0) {\\n\\t\\t// If the number of stones with the same size is even or zero, \\n\\t\\t// these stones can be totally destroyed pair by pair or there is no such size stone existing, \\n\\t\\t// we can just ignore this situation.\\n\\t\\t\\n        // When the number of stones with the same size is odd, \\n\\t\\t// there should leave one stone which is to smash with the smaller size one.\\n            if (buckets[slow]%2 != 0) {\\n                int fast = slow - 1;\\n                while (fast > 0 && buckets[fast] == 0) {\\n                    fast--;\\n                }\\n                if (fast == 0) break;\\n                buckets[fast]--;\\n                buckets[slow - fast]++;\\n            }\\n            slow--;\\n        }\\n        return slow;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int[] buckets = new int[1001];\\n        for (int i = 0; i < stones.length; i++) {\\n            buckets[stones[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1923171,
                "title": "javascript-faster-than-95-easy-to-understand-with-comments",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```\\n\\nIts okay if you did not get the solution in the first try, don\\'t give up!\\nPlease do UPVOTE if you find it helpfull.... I know this is not the best solution to this problem but this is what I came up with.\\nHappy C0d1ng!! Cheers!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length>1){\\n        stones.sort((a,b)=>b-a); //sort the remaining stones in decending order;\\n        stones[1]=stones[0]-stones[1]; //smash the first and second stones ie the stones with largest weight ans assign the remaining stone weight to 1st index\\n        stones.shift();//shift the array to get rid of the 0 index\\n    }\\n    return stones[0] //return the 0 index value ie the resultl\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922652,
                "title": "c-java-python-6-line-approach-question-clarifications-heap-cheatsheet",
                "content": "If you are already familiar with priority_queue in C++ skip to the Approach section at the end\\n### C++ Heap Guide/Cheatsheet\\nIn C++ [priority_queue](https://www.cplusplus.com/reference/queue/priority_queue/) is the implementation for heaps. If you have never used priority_queue before, you can get started by reading this cheatsheet and solving this problem. However, you still should read about [heaps](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/resources/lecture-4-heaps-and-heap-sort/) and how they work so that you know when and where to use them.\\n\\n1. **Introduction**\\n* Why heaps?\\nHeap as a container gives you fast insertion of any element as well as reads and deletion of either the minimum-most or maximum-most element. Also it does not provide random access to any other element in the heap\\n* Where to use?\\nBased on this advantage, some major use cases for heaps are BFS, Djikstra, Current median of stream of elements\\n\\n2. **Initialising**\\n\\t```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\\n\\tThis last operation takes O(n) time where n is size of array a.\\n\\n3. **Important operations**\\n\\t```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\\n - Always make sure that heap is not empty prior to top() and pop() methods\\n - *Time* - push() and pop() takes O(logn) time, the other three require O(1) time.\\n___\\n</br>\\n\\n### Question Clarifications\\nSome people have misinterpreted the question a bit, for example [here](https://leetcode.com/problems/last-stone-weight/discuss/1922217)\\nNote, the question states that you always have to pick the two largest stones and then find the minimum-most stone. Its however not necessary that if you had the freedom to pick any two stones, that picking the largest would give you smallest stone at the end. It actually wont, consider the following example -\\n> [25, 23, 16, 16, 16]\\n\\n* If you picked the largest two every time you would end up with 14.\\n* However with freedom to pick any stone you can end with 0. By picking following stones at each step -\\n\\t```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\\n\\nAnother clarification, is the question states find the minimum most possible stone after only one stone remains. Since there can be only one pair of largest stones possible at each step and you do not have the element of choice, you can only have one way of smashing the stones and hence only one possibility of last stone remaining, which being the only candidate for being the minimum-most will also be the answer.\\n___\\n</br>\\n\\n### Approach\\nOnce we are aware of how to use the priority queue and the above facts the approach is straightforward as the question instructs us what to do. We need the two largest elements at each step for our operation, since heaps give the fastest access to the extremes its our go to here. The pseudo-code is as follows -\\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```\\n\\nC++/Java/Python code based on above pseudo code\\n\\n<iframe src=\"https://leetcode.com/playground/kocCUYy5/shared\" frameBorder=\"0\" width=\"800\" height=\"370\"></iframe>\\n\\nComplexity - Time: O(nlogn), Space: O(n)\\n\\nWould also like to add the common heap operations and code for Java and Python along with complexity to this cheatsheet, please mention them if you are familiar with them.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n\\t// 1. max heap -> for popping largest element\\n\\t\\tpriority_queue<int> pq;     // replace int with any other type or a struct based on need\\n\\t// 2. min heap -> for popping minimum element\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq;\\n\\t// 3. custom heaps in case of custom ordering (here we are creating min heap based on second property)\\n\\t\\tstruct comp {\\n\\t\\t\\tbool operator()(pair<int, int> a, pair<int, int> b) {\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tpriority_queue<int, vector<int>, comp> pq;\\n\\t// 4. If you already have an array and want to initialise using it\\n\\t\\tpriority_queue<int, vector<int>, greater<int>> pq(a.begin(), a.end());\\n\\t```\n```cpp\\n\\tpq.push(10);           // adds element to heap\\n\\tint cur = pq.top();    // returns top element, does NOT pop though\\n\\tpq.pop()               // pops top element, does NOT return the value of top element though\\n\\tpq.size()              // return size of heap\\n\\tpq.empty()             // returns true if heap is empty else false\\n\\t```\n```text\\n\\t(25, 16) -> (23, 16) -> (16, 9)  -> (7, 7)\\n\\tleaves 9 -> leaves 7 -> leaves 7 -> leaves 0\\n\\t```\n```text\\n\\tInitialise heap using the array (use 4th option above)\\n\\tKeep smashing as long as there is 2 or more stones (use size() method)\\n\\t\\tPick the two largest and remove them from heap (use top() and pop())\\n\\t\\tif their difference is positive add new stone to our heap (use push())\\n\\t\\n\\tIf there is a stone remaining in heap return it or else return 0 (use empty() and top())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575360,
                "title": "python3-heapq-priority-queue",
                "content": "Since we want the two largest stones each time, and heapq.pop() gives us the smallest each time, we just need to make every value of stones negative at the beginning.\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-val for val in stones]\\n        heapq.heapify(stones)\\n        while len(stones) > 1:\\n            x1 = heapq.heappop(stones)\\n            x2 = heapq.heappop(stones)\\n            if x1 != x2:\\n                heapq.heappush(stones,x1-x2)\\n        if len(stones) == 0:\\n            return 0\\n        return -stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449430,
                "title": "java-easy-solution-explained-similar-questions-beginner-friendly",
                "content": "# Intuition\\nSince we need to choose heaviest two stones everytime, this is a clear hint to go for heap data structure. In java we implement heap via priority queue.\\n\\nSimilar questions for heap i faced in interviews.\\nLC 347[ Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)\\nLC 215[ Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\nLC 23 [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n\\n\\n---\\n# Approach\\n1) Make a heap via priority queue, we need to make a max heap as we need heaviest stone collision first.\\n2) Add stones[] to heap\\n3) Now run a while loop till there are two elements remaining in the hea[] i.e ```while(heap.size()>1)``` Two elements because each collision needs two stones atleast. \\n- pick top 2 stones and calculate their difference\\n- if difference!=0 we need back to heap other both stones are destroyed.\\n4) Once outside the loop, check for size!=0 i.e once stone remains return that or return zero.\\n\\n---\\n# Complexity\\n- Time complexity:\\nO(nlogn) : Building of heap intially nlogn, Then since we poll and push again to the heap, it needs to rebuild which takes logn(heapify) everytime.\\n\\n- Space complexity:\\nO(n) at max we will have n elements in heap.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n\\n---\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```while(heap.size()>1)```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //setting decreasing order of the heap or max heap\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b) -> b-a);\\n        for(int each: stones)\\n            heap.add(each);\\n\\n        while(heap.size()>1){\\n            int top1 = heap.poll();\\n            int top2 = heap.poll();\\n            int diff = Math.abs(top1-top2);\\n\\n            if(diff!=0){\\n                heap.add(diff);\\n            }\\n        }\\n\\n        if(heap.size()!=0){\\n            return heap.poll();\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921223,
                "title": "c-simulation-100-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nTo solve this problem, we can conduct an actual simulation of the described process. Since we always need to use the heaviest stones, we can use a heap data structure for easy access to max elements.\\n\\nTime: **O(nlogn)** - for the heap\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Last Stone Weight.\\nMemory Usage: 7.6 MB, less than **34.27%** of C++ online submissions for Last Stone Weight.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& s) {\\n         make_heap(s.begin(), s.end());\\n        \\n         while (s.size() > 1) {\\n            int x = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            int y = s.front();\\n            pop_heap(s.begin(), s.end());\\n            s.pop_back();\\n            \\n            if (x == y) continue;\\n            \\n            s.push_back(x - y);\\n            push_heap(s.begin(), s.end());\\n        }\\n        \\n        return s.size() ? s.front() : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921769,
                "title": "java-best-intuitive-solution-priority-queue-1ms-99-faster",
                "content": "**Code**\\n```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```\\n\\n**Explanation**\\nWe were required to do operations each time on largest elements, and for that we can use max heap which can use used by reverting the order of priority queue available in Collections framework in java.\\n- Push all elements in priority queue.\\n- Iterate while the size of priority queue becomes equal to or less than 1.\\n- Pop two largest element from top and perform following checks\\n\\t- if both are equal then we don\\'t need to do anything.\\n\\t- else we add the difference of `f` and `s` to the priority queue.\\n- Now return 0 if size of `pq` is 0 otherwise return top element.\\n\\nHere\\'s how it works:-\\n\\n![image](https://assets.leetcode.com/users/images/89bb3992-f3ba-410e-a071-62c44831876a_1649307957.4194489.png)\\n\\n\\nHope it helps,\\nIf it does do upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\npublic int lastStoneWeight(int[] stones) {\\n\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int st: stones)\\n\\t\\tpq.offer(st);\\n\\n\\twhile(pq.size() > 1) {\\n\\t\\tint f = pq.poll();\\n\\t\\tint s = pq.poll();\\n\\t\\tif(f != s) \\n\\t\\t\\tpq.offer(f-s);\\n\\t}\\n\\n\\treturn pq.isEmpty() ? 0 : pq.peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563863,
                "title": "easy-to-understand-heap-based-faster-simple-python-solution",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-i for i in stones]\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            first = abs(heapq.heappop(stones))\\n            second = abs(heapq.heappop(stones))\\n            if first != second:\\n                heapq.heappush(stones, -abs(first - second))\\n                \\n        # this compact return statement way is great ^_^\\n        return abs(stones[0]) if len(stones) else 0\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1470255,
                "title": "simple-javascript-soluton-recursion",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    stones.sort((a,b) => a-b);\\n    let a = stones.pop();\\n    let b = stones.pop();\\n    stones.push(Math.abs(a-b));\\n    return lastStoneWeight(stones);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222221,
                "title": "java-solution-let-s-learn-when-to-use-heap-priority-queue",
                "content": "# Intuition\\nAs soon as we understand that we need to repeatedly get a maximum/minimum value from an array, we can use Heap (Priority Queue).\\n\\nYou can use Minimum Heap like this:\\n***PriorityQueue<Integer> minHeap = new PriorityQueue<>();***\\n\\nOr you can use Maximum Heap this way:\\n***PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());***\\n\\nAs you can see, if you want to change your heap from min to max you can simply reverse it by adding ***Comparator.reverseOrder()***;\\n\\nGiven this knowledge we can start implementing our solution.\\n\\n# Approach\\n1. Initialize max heap, because we need the biggest stones.\\n2. Add all stones from our initial array to the heap.\\n3. While size of our heap is not equal to one we need to remove two stones and confirm if they are equal (then we will add 0 to our heap) or x != y (then we will add y - x to the heap (the biggest stone minus second one)).\\n4. The last element from the heap will be our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\text{ }log \\\\text{ } n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```\\n![4x5hdv.jpeg](https://assets.leetcode.com/users/images/d8917be9-a9ce-4b97-a3ee-8b99901cf5af_1677435627.74426.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            maxHeap.add(stone);\\n        }\\n        while (maxHeap.size() != 1) {\\n            int y = maxHeap.remove();\\n            int x = maxHeap.remove();\\n            if (x == y) maxHeap.add(0);\\n            if (x != y) maxHeap.add(y - x);\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448738,
                "title": "easy-solution-of-java-c-beginner-friendly-arraylist",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\\nC++\\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public int lastStoneWeight(int[] stones)\\n{\\n\\t\\tArrayList<Integer> listStones = new ArrayList<>();\\n\\t\\tfor (int a : stones)\\n\\t\\t\\tlistStones.add(a);\\n\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\tint len = listStones.size();\\n\\n\\t\\t\\tif (len == 1 || len == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tCollections.sort(listStones);\\n\\t\\t\\tmin = listStones.get(len - 2);\\n\\t\\t\\tmax = listStones.get(len - 1);\\n\\n\\t\\t\\tif (min < max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmax = max - min;\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.add(max);\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if (min == max)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t\\tlistStones.remove(listStones.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        if(listStones.size()==1)\\n            return listStones.get(0);\\n        return 0;\\n\\t}\\n}\\n```\n```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922257,
                "title": "2-approaches-sorting-max-heap-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***Brute force solution*** //not recommended.\\n- Here every iteration we\\u2019re sorting the array & changing the last 2 values.\\n- As the last 2 are the max elements, so ***x=stones[n-2]*** & ***y=stones[n-1].***\\n- We\\u2019ll replace x with 0 (as all elements will be greater than 0), and y with y-x.\\n- Return the last element after n iteration.\\n- **Time complexity:** O(n^2logn).\\n\\n### Solution 02\\n\\n- Using ***Max Heap.***\\n- Max heap keeps the maximum element on top.\\n- First, we\\u2019ll push all the elements of stones to our max heap.\\n- Now until the size of our heap won\\u2019t became 1 we\\u2019ll continue this operation:\\n    - Take the top element to y & pop that element. `y = q.top(); q.pop();`\\n    - Similarly, put the next element to x & pop it. `x = q.top(); q.pop();`\\n    - Now smallest element will destroy & we\\u2019ll push y-x to our heap again. In the case of same weight elements, it will automatically push 0. `q.push(y-x);`\\n    - When the size of the heap became 1 we\\u2019ll break the loop and return top element.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size(), ans, count = 0;\\n        \\n        if(n == 1) return stones[0];\\n        \\n        while(count != n-1){\\n            sort(stones.begin(), stones.end());\\n            stones[n-1] = stones[n-1] - stones[n-2];\\n            stones[n-2] = 0;\\n            count++;\\n        }\\n        return stones[n-1];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> q;\\n        int x, y;\\n        \\n        for(auto x:stones)\\n            q.push(x);\\n        \\n        while(q.size() != 1){\\n            y = q.top();\\n            q.pop();\\n            x = q.top();\\n            q.pop();\\n\\n            q.push(y-x);\\n        }\\n        \\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922285,
                "title": "shortest-solution-using-min-heap-priorityqueue",
                "content": "**Step 1:** Put the array into a min heap. To avoid creating a custom comparer, let\\'s just revert priorities (`-x`).\\n**Step 2:** Get the two \"heaviest\" stones from the heap and smash them together. If there is something left, put it back into the heap.\\n\\n```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic int LastStoneWeight(int[] stones)\\n{\\n    var q = new PriorityQueue<int, int>(stones.Select(x => (x, -x)));\\n    \\n    while (q.Count > 1)\\n    {\\n        int a = q.Dequeue() - q.Dequeue();\\n        if (a != 0) q.Enqueue(a, -a);\\n    }\\n        \\n    return (q.Count == 0) ? 0 : q.Peek();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494003,
                "title": "java-100-time-100-space",
                "content": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        Arrays.sort(stones);\\n        int y = stones.length-1;\\n        int x = stones.length-2;\\n        while(x>=0){\\n            if(stones[x]==stones[y]){\\n                stones[x] = 0;\\n                stones[y] = 0;\\n            }else{\\n                stones[y] -= stones[x];\\n                stones[x] = 0;\\n            }\\n            Arrays.sort(stones);\\n            if(stones[x]==0)break;\\n        }\\n        return stones[y];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921204,
                "title": "python-6-lines-sortedlist-clean",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        sl = SortedList(stones)\\n        while len(sl) >= 2:\\n            y = sl.pop()\\n            x = sl.pop()\\n            if y > x: sl.add(y - x)  # Note that sl is a SortedList\\n        return sl.pop() if len(sl) else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365807,
                "title": "c-priority-queue-100-time-short-easy-to-understand",
                "content": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npriority_queue<int> pq(v.begin(),v.end());\\n        \\n        while(true)\\n        {\\n            if(pq.size() ==0)   return 0;\\n            if(pq.size() ==1)   return pq.top();\\n            int a = pq.top();\\n            pq.pop();\\n            int b = pq.top();\\n            pq.pop();\\n            if(a!=b)    pq.push(abs(a-b));\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854146,
                "title": "python-heap-explained-with-easy-code",
                "content": "# Naive Approach\\nThe naive approach to solve the question, would be:\\n\\n1. Sort the array in decreasing order\\n2. Pop the first two elements, subtract them.\\n3. If the difference is 0, then do nothing. Else, append the difference in the array\\n4. Repeat the step 1, 2 and 3 until there is only one item left in the array\\n5. The only item left in the array is the answer\\n\\nHowever, the time complexity would be high because sorting is performed (N-1) times. The time complexity would be O(N<sup>2</sup>).\\n\\n---\\n\\n\\n# Optimal Approach\\nThe optimal approach uses a very important Data Structure, Heap. Heap is a Complete Binary Tree.\\nFirst, let\\'s understand what is a <b>Complete Binary Tree</b>. \\n*[Skip if you know that already]*\\n\\n### Complete Binary Tree\\n1. <b>Definition 1</b>\\nA complete binary tree is a binary tree where all the levels, except the last level must be completely filled. The last level may or may not be filled completely. The last level MUST be filled from left to right.\\n2. <b>Definition 2</b>\\nA Complete Binary Tree is a Tree, where every level in the tree is required to be filled with maximum nodes, except the last level. The last level may not be completely filled but all the nodes in the last level must be towards the left of the tree.\\n\\n## Heap\\nHeap Data Strucutre, is a Complete Binary Tree, which satisfies the <b>Heap Property</b>. We are going to discuss the heap properties in a moment. There are two types of Heaps: <b>MaxHeap</b> and <b>MinHeap</b>.\\n\\n## MaxHeap\\nProperty for a MaxHeap is \"<b>The value of every node is less than or equal to its parent</b>\". Therefore, in a MaxHeap, the maximum value resides as the root node. Here is a valid MaxHeap:\\n<table width = \"100%\">\\n<tr>\\n<td><img src = \"https://assets.leetcode.com/users/images/22cb76cb-8d54-4e4a-8947-d500f0c7c0f3_1669561918.8131528.png\" style =\"text-align: center; margin: 0; width: 100%;\" /></td>\\n</tr>\\n<tr>\\n<td>This is a valid MaxHeap Tree because:\\n<ol>\\n<li>It is a complete binary tree. Every level is completely filled except the last level which is completely left aligned.</li>\\n<li>Every Node is less than or equal to its parent node.</li>\\n</ol>\\n</td>\\n</tr>\\n</table>\\n\\n## MinHeap\\nMinHeap is just opposite of MaxHeap. The Heap Property for a MinHeap is \"<b>The value of every node is greater than or equal to its parent</b>\". Therefore, in a MinHeap, the minimum value resides as the root node.\\n\\n---\\n\\n# Why Heap?\\n\\nAs you just saw, in a MaxHeap, the maximum element is guaranteed to be on the top of the tree, or in a MinHeap, the minimum element is guaranteed to be on the top of the tree. In an sorted array, each time, we inserted, removed or updated an element in the array, the whole array needs to be sorted again to keep the array in order. It was a very time costly operation. In heaps, we can remove, insert or update an element in the heap in `log N`.\\n\\n### How is it so fast?\\nThis high performace is achieved because a Heap Tree can be written in an array (list) in such a way that, the traversals are easy as compared to that in a normal array. \\nFor example, let\\'s write the above mentioned MaxHeap in the array.:\\n<table>\\n<tr>\\n<td>100</td>\\n<td>17</td>\\n<td>39</td>\\n<td>15</td>\\n<td>13</td>\\n<td>36</td>\\n<td>25</td>\\n<td>14</td>\\n<td>9</td>\\n</tr>\\n</table>\\n\\nLet the indices be 1, 2, 3, 4... and so on. If, I ask you to look at the array and tell me the parent of 36 in the Heap, how would you do it?\\nWell, there\\'s a simple trick. Get the index of 36, which is 6. Floored Division of the index by 2 would give the index of its parent. Hence, its parent is at index 3, i.e. 39. You can try that for other elements as well.... You can also do the opposite, i.e. multiply and index by 2 to get the index of left child, and add 1 to it to get the index of right child.\\nThis holds true, as long as the tree is a Complete Binary Tree.\\n\\nNow, how things work is... say you want to insert an element 19 in the array (or heap). The algorithm goes like:\\n1. Add 19 to the next available position in the heap, i.e. 19 would be added as the left child of 13 (Consider the tree diagram above). \\n**Important:** Note that, in the array notation of the heap, the element would be added to the last of the array. Actually, there is no data structure like Complete Binary Tree getting involved here, it\\'s just for visualisation. All the operations we do are on the array.\\n2. Find the parent of 19 and compare both the numbers. Here, the parent is 13 and 13 < 19. Since, it is a Max Heap, larger number remains on top. So, we swap 13 with 19.\\n3. Now, again we find the parent of 19, which would be 17 this time. Again, 17 < 19. So, 17 and 19 are swapped.\\n4. Again the parent of 19 is 100, but 100 > 19, so no more swapping is done, and we have our element inserted.\\n\\nSimilarily there are deletion operations, which can also be performed in `log N` time. But, we are not going deeper into this.\\n\\n---\\n\\n# Heap in Python\\nPython provides an inbuilt module for dealing with heap data structure, namely \\'heapq\\'. It has various functions which are going to help us throughout the program. Thus, we need to import it to use it. The library can be used to create MinHeap. But, we can use the properties of MaxHeap if we multiply every value in the MinHeap with -1. Then, the negative value of every node acts as a MaxHeap.\\nLet\\'s code:\\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```\\n\\nIt took sweats to create this post. Please upvote, if you found it helpful. Happy Leetcoding!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        \\n\\t\\t#    First, import the heapq module. Specifically the functions heapify, heappop and heappush\\n        from heapq import heapify, heappop, heappush\\n        \\n\\t\\t#    Initialize an empty array, which we would use as heap\\n        heap = []\\n        for stone in stones:\\n\\t\\t\\n\\t\\t#    We would add the negative values of the given list in the Heap\\n            heap.append(-stone)\\n        \\n\\t\\t#    heapify function from the heapq module, takes an array as parameter, arranges the contents\\n\\t\\t#    of the array in such a way that the array becomes a minheap\\n        heapify(heap)\\n        \\n        while len(heap) > 1:\\n\\t\\t\\n\\t\\t#    heappop function from the heapq module, takes an array (heap) as parameter, and removes\\n\\t\\t#    the root of the minheap, returns the value, and then makes the necessary arrangement so\\n\\t\\t#    that the heap does not lose its properties.\\n            x = heappop(heap)\\n            y = heappop(heap)\\n            \\n\\t\\t#    if the two minimum values from the heap are not equal, then subtract the larger value (smaller\\n\\t\\t#    magnitude) from the smaller value (larger magnitude). Add the difference back to the heap\\n            if x != y:\\n\\t\\t\\t\\n\\t\\t#    heappush function, from the heapq module, takes an array (heap) as parameter, and adds\\n\\t\\t#    the second parameter to the array, maintaining the heap properties of the array.\\n                heappush(heap, x - y)\\n        \\n\\t\\t#    if heap is not empty then, return the first item in the heap multiplied by -1\\n        if heap:\\n            return -heap[0]\\n\\t\\t\\t\\n\\t\\t#    if heap was empty, then return 0\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448720,
                "title": "priority-queue-max-heap-clean-code-easy-explaination",
                "content": "# Intuition\\nIf you reached here it\\'s for sure you not able to get to the solution in the first place dont worry I did the same mistake. \\n\\nJust read the question nicely, It says every time you have to pick the stones with largest weight, so for sure you might have sorted the Array and applied a greedy approach,but you\\'ll have to perform sort operation everytime you perform a operation. \\n\\nSo priority queue uses a Data structure called Max heap for the implemenation where the top node is always the maximum and we can get it in 0(1) time.\\n\\nYou can see the code we just pop two top stones with heigest weight and put a stone again in it.\\n\\n# Approach\\nSimple thinking, Heap Data structure greedy.\\n\\n# Complexity\\n- Time complexity:\\nCreation of priority-0(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n = stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++) pq.push(stones[i]);\\n        while(pq.size()>=2)\\n        {\\n           int x = pq.top(); pq.pop();\\n           int y = pq.top(); pq.pop();\\n           if(x!=y) pq.push(abs(x-y));\\n\\n        }if(pq.size()==0) return 0;\\n        return pq.top();\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123710,
                "title": "javascript-simple-priority-queue",
                "content": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575358,
                "title": "easy-c-solution-using-priority-queue",
                "content": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "solutionTags": [],
                "code": "1. Create a Priority queue (pq)\\n2. as long as size of pq > 1:\\n* every time pop two elements \\n* subtract second from first\\n* if res of subtractions is non-zero push this result back into pq\\nCODE:\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n     priority_queue<int> pq;\\n      for(auto i : stones)        pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top(); pq.pop();\\n          int b = pq.top(); pq.pop();\\n          if(a  - b > 0)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1921745,
                "title": "rust-heap-and-matching",
                "content": "Code is short thanks to Rust\\'s pattern matching:\\n```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        loop {\\n            match (heap.pop(), heap.pop()) {\\n                (Some(a), Some(b)) => if a > b {\\n                    heap.push(a - b);\\n                }\\n                (Some(a), None) => return a,\\n                (None, _) => return 0,\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576384,
                "title": "python-solution-simplest-2-line",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) > 1: stones.append(stones.pop(stones.index(max(stones))) - stones.pop(stones.index(max(stones))))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354141,
                "title": "java-4-liner-explained",
                "content": "**Idea:**\\n* Push all stones in a max-heap\\n* Poll two stones, and push their difference back into the heap\\n* Do this till there\\'s only 1 stone left\\n\\n>**T/S:** O(n lg n)/O(n), where n = size(stones)\\n```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n\\tvar maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\t\\n\\tfor (var stone : stones)\\n\\t\\tmaxHeap.add(stone);\\n\\n\\twhile (maxHeap.size() > 1)\\n\\t\\tmaxHeap.offer(maxHeap.poll() - maxHeap.poll());\\n\\t\\t\\n\\treturn maxHeap.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449074,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "We can see that after two stones break we need to replace them back in the array. Where depends on how much they broke down, and it isn\\'t always guaranteed to be the end. This points toward a data structure that allows us to restructure efficiently, and that would be a Max Heap.\\n\\nA max heap is a tree structure that keeps the largest value on top, and for each child the same holds true. When we pop from a heap, the heap will restructure itself to maintain the same dynamics. So 2 pops from a max heap will result in us receiving the 2 largest stones. Pushing back on the heap will place the stones in their correct spot.\\n\\nNote: A lot of built-in heaps are min heap implementations, to utilize them, we must push the negative weights of the stones on the heap to maintain a max heap structure.\\n\\nTime Complexity: $$O(nlogn)$$. Where $$n$$ is the size of the heap/stones array. It will take $$n*log(n)$$ time to create the initial heap, then up to $$log(n)$$ time to place the broken-down stones back into the heap.\\n\\nSpace Complexity: $$O(n)$$. Where $$n$$ is the size of the stones array, to maintain our heap data structure with up to $$n$$ stones inside.\\n\\n\\n```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```py\\n# written by ColeB2\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        # initialize an empty array to hold our heap, python uses\\n        # arrays, and the heapq module to handle min Heaps. We will\\n        # use negative values of the stones to convert to a max heap.\\n        heap = []\\n        # loop through each stone in our stones array\\n        for stone in stones:\\n            # push the negative value of the stone onto the heap.\\n            # heappush takes the heap array, and the value to push\\n            # onto the heap. -stone will allow the min heap to act\\n            # as a max heap instead.\\n            heapq.heappush(heap, -stone)\\n        # We need at least 2 stones to smash together, so we loop while\\n        # our heap has at least 2 stones inside.\\n        while len(heap) >= 2:\\n            # pop both stones off, the 1st is the largest stone.\\n            stone1 = heapq.heappop(heap)\\n            stone2 = heapq.heappop(heap)\\n            # if the second stone is bigger, since we are using negative\\n            # values, the second being bigger, means they are not\\n            # the same size, and the first is larger. This means\\n            # the stone won\\'t be completely destroyed, so we need\\n            # co calculate the difference to add onto the heap.\\n            if stone2 > stone1:\\n                # Add onto the heap the difference of stones 1 and 2.\\n                heapq.heappush(heap, stone1 - stone2)\\n        # remembering that we used negative values of the stones, we \\n        # must return the absolute value of the remaining stone if it\\n        # exists, else 0 as the question asks.\\n        return abs(heap[0]) if heap else 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        // initialize a priority_queue in c++\\n        priority_queue<int> pq;\\n        // push the positive value of the stone onto the priority_queue\\n        for (int x : stones) pq.push(x); \\n        // We need at least 2 stones to smash together, so we loop while\\n        // our heap has at least 2 stones inside.\\n        while (pq.size() >= 2) {\\n            // pop both stones off, the 1st is the largest stone.\\n            int y = pq.top(); pq.pop();\\n            int x = pq.top(); pq.pop();\\n            // if the stones are not same, then the stone of weight x is detroyed\\n            // and the stone of weight y has new weight y - x.\\n            if (x != y) pq.push(y - x);\\n        }\\n        // if there are no stones left, return 0\\n        if (pq.size() == 0) return 0;\\n        // return the weight of the last remaining stone\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575369,
                "title": "python-solution-4-lines",
                "content": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            stones.append(stones.pop() - stones.pop()) \\n        return stones[0]\\n\\t\\t\\n\\t\\t\\n\\t\\tFollow me for more intresting programming questions :\\n\\t\\t\\t\\t\\t\\t\\thttps://www.github.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.instagaram.com/shubhamthrills\\n\\t\\t\\t\\t\\t\\t\\thttps://www.linkedin.com/in/shubhamsagar\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n#Another Possible approch [If you don\\'t want to decrease the length of loop every time]\\n\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #stones=[2,7,4,1,8,1]\\n        for i in range(len(stones) - 1):\\n            stones.sort()\\n            temp=stones[-1] - stones[-2]\\n            stones[-2]=-1\\n            stones[-1]=temp\\n        return (stones[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921692,
                "title": "simple-solution-using-arraylist-java-self-explanatory",
                "content": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }\\n        \\n       \\n       \\n        while(ar.size()>1){\\n             \\n        Collections.sort(ar);\\n            \\n            int y = ar.get(ar.size()-1);\\n            ar.remove(new Integer(y));\\n            \\n            int x = ar.get(ar.size()-1);\\n            ar.remove(new Integer(x));\\n            \\n            if(x!=y){\\n                ar.add(y-x);\\n            }\\n           \\n            \\n        }\\n        \\n        if(ar.isEmpty()){\\n            return 0;\\n        }else{\\n            return ar.get(0);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        ArrayList<Integer> ar = new ArrayList<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            ar.add(stones[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714283,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while (stones.length > 1) {\\n        let max1 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max1),1);\\n        let max2 = Math.max(...stones);\\n        stones.splice(stones.indexOf(max2),1);\\n        if (max1 !== max2) stones.push(Math.abs(max1-max2));       \\n    }\\n    return stones[0] || 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575519,
                "title": "c-countsort-bucketsort-solution",
                "content": "Since range of the elements is limited to integers between 1 and 1000, we can easily extend a bucket sort / count sort technique to this problem.\\n\\n1. Keep count of elements (in say array `arr`) against the indexes derived from their values. So, if we see a value `x`, we increment `arr[x]`. Thus each index is marking the bucket of the index value.\\n2. Start from the highest index 1000 and gradually come down to the lowest index 1, smashing rocks along the way. I use two pointers `lo` and `hi` to point to the two rocks that will be smashed in the current iteration. If there are multiple occurrences of a rock, `lo` and `hi` might point to the same index / bucket.\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```\\n\\n+ Uses extra linear space in the order of the range of elements.\\n+ Runs in linear time in the order of the number of elements.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int arr[1010] = {0};\\n        \\n        for(auto num: stones)\\n            arr[num]++;\\n        \\n        int hi = 1000, lo = hi;\\n        while(lo > 0 && hi > 0) {\\n            while(hi > 0 && arr[hi] < 1)\\n                hi--;\\n            \\n            if(hi < 1)\\n                break;\\n            \\n            lo = arr[hi] > 1 ? hi : hi-1;\\n            while(lo > 0 && arr[lo] < 1)\\n                    lo--;\\n            \\n            if(lo < 1)\\n                break;\\n            \\n            // smash!\\n            arr[hi-lo]++;\\n            arr[hi]--;\\n            arr[lo]--;\\n        }\\n        \\n        return hi * (arr[hi] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498199,
                "title": "1046-javascript-recursive-one-liner",
                "content": "> Runtime: **64 ms**, faster than *52.83%* of JavaScript online submissions\\n> Memory Usage: **35.2 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst lastStoneWeight = s =>\\n  1 === s.length\\n    ? s[0]\\n    : lastStoneWeight(s.sort((a, b) => a - b).concat(s.pop() - s.pop()));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448997,
                "title": "python3-easy-solution-with-explanation-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        #first sort the list\\n        stones.sort()\\n\\n        while stones:\\n            #most heaviest stone\\n            s1 = stones.pop()\\n\\n            #if list is empty after removing one stone i.e s1 then \\n            #return s1\\n            if not stones: return s1\\n\\n            #second heaviest stone s2 where s2 <= s1\\n            s2 = stones.pop()\\n\\n            #if s1 > s2 then element to be inserted is s1-s2 as given in the \\n            #problem statement\\n            if s1 > s2:\\n\\n                #using Insort_left Function Of Bisect Module\\n                #we will insert s1-s2 at correct position \\n                insort_left(stones, s1-s2)\\n\\n            #else s1 == s2 and as we are continously popping elements \\n            #both the stones are destroyed if they are same\\n\\n        #if no more stones remaining return 0 \\n        return 0 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921076,
                "title": "java-easy-and-fast-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int count = stones.length-1;\\n        while(count!=0)\\n        {\\n            if(stones[stones.length-1]==stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=0;\\n                stones[stones.length-2]=0;\\n            }\\n            if(stones[stones.length-1]!=stones[stones.length-2])\\n            {\\n                stones[stones.length-1]=stones[stones.length-1] - stones[stones.length-2];\\n                stones[stones.length-2]=0;\\n            }\\n            Arrays.sort(stones);\\n            count--;\\n        }\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n \\xA0 \\xA0return stones[stones.length-1]\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772788,
                "title": "go-heap-solution",
                "content": "Cause all I do is dance.\\n```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int {return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool {return h[i] > h[j]}\\nfunc (h IntHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}\\nfunc (h *IntHeap) Push(x interface{}) {*h = append(*h, x.(int))}\\nfunc (h *IntHeap) Pop() interface{} {\\n    n := len(*h)\\n    x := (*h)[n-1]\\n    *h = (*h)[0:n-1]\\n    return x\\n}\\n\\nfunc lastStoneWeight(stones []int) int {\\n    pq := IntHeap(stones)\\n    heap.Init(&pq)\\n    for pq.Len() > 1 {\\n        x, y := heap.Pop(&pq).(int), heap.Pop(&pq).(int)\\n        if x != y {\\n            heap.Push(&pq, x-y)\\n        }\\n    }\\n    \\n    if pq.Len() == 0 {\\n        return 0\\n    }\\n    \\n    return heap.Pop(&pq).(int)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450508,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        while len(stones)>1:\\n            y=stones.pop(-1)\\n            x=stones.pop(-1)\\n            if x!=y:\\n                stones.append(y-x)\\n            stones.sort()\\n        return stones[0] if len(stones)>=1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449734,
                "title": "python-elegant-short-max-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n * \\\\log_2 {n})$$\\n- Space complexity: $$O(n)$$\\n\\n# Maximum heap code\\n```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\\n\\n# Solution code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MaxHeap:\\n    def __init__(self, data: List[int]):\\n        self.data = [-num for num in data]\\n        heapq.heapify(self.data)\\n\\n    def push(self, item: int):\\n        heapq.heappush(self.data, -item)\\n\\n    def pop(self) -> int:\\n        return -heapq.heappop(self.data)\\n\\n    def __len__(self) -> int:\\n        return len(self.data)\\n\\n    def __bool__(self) -> bool:\\n        return len(self) != 0\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heap = MaxHeap(stones)\\n\\n        while len(heap) > 1:\\n            first, second = heap.pop(), heap.pop()\\n            if first != second:\\n                heap.push(abs(first - second))\\n\\n        return heap.pop() if heap else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449269,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while True:\\n            stones = sorted(stones,reverse = True)\\n            if len(stones) == 1:\\n                return stones[0]\\n            elif len(stones) == 0:\\n                return 0\\n            first = stones.pop(0)\\n            sec = stones.pop(0)\\n            if first == sec:\\n                continue\\n            else:\\n                stones.append(first-sec)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593690,
                "title": "js-heap-easy-understanding",
                "content": "Solution 1 - O(n^2*logn)\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\\n\\nSolution 2 - O(n*logn)\\n\\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n\\n    while(stones.length > 1) {\\n        stones.sort((a, b) => a - b);\\n        let x = stones.pop();\\n        let y = stones.pop();\\n        \\n        if(x === y) continue;\\n        else stones.push(Math.abs(x - y));\\n    }\\n    \\n    return stones;\\n}\\n```\n```\\nclass Heap {\\n    constructor(stones) {\\n        this.heap = stones;\\n        this.size = stones.length;\\n        this.heapify(0);\\n    }\\n    right(pos) {\\n        return 2 * pos + 2;\\n    }\\n    left(pos) {\\n        return 2 * pos + 1;\\n    }\\n    isleaf(pos) {\\n        if (2 * pos + 1 >= this.size) return true;\\n        return false;\\n    }\\n    swap(a, b) {\\n        let temp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = temp;\\n    }\\n    fix(pos) {\\n        if (this.isleaf(pos)) return;\\n        let left = this.left(pos);\\n        let right = this.right(pos);\\n        let bigger = left;\\n        if (right < this.size)\\n            bigger = this.heap[left] > this.heap[right] ? left : right;\\n        if (this.heap[pos] < this.heap[bigger]) {\\n            this.swap(pos, bigger);\\n            this.fix(bigger);\\n        }\\n    }\\n    heapify(pos) {\\n        if (this.isleaf(pos)) return;\\n        this.heapify(this.left(pos));\\n        this.heapify(this.right(pos));\\n        this.fix(pos);\\n    }\\n    delete() {\\n        this.swap(0, --this.size);\\n        this.fix(0);\\n        return this.heap[0];\\n    }\\n    insert(val) {\\n        this.size++;\\n        this.heap[this.size - 1] = val;\\n        this.heapify(0);\\n    }\\n    peek() {\\n        return this.heap[0];\\n    }\\n}\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function (stones) {\\n    const heap = new Heap(stones);\\n    while (heap.size > 1) {\\n        let x = heap.peek();\\n        heap.delete();\\n        let y = heap.peek();\\n        heap.delete();\\n        const res = x - y;\\n        if (res > 0) heap.insert(res);\\n    }\\n    if (heap.size) return heap.peek();\\n    return 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921399,
                "title": "c-100-shortest-and-easiest-without-using-any-data-structure",
                "content": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```\\nUPVOTE IF YOU LIKE IT!!\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\u2714without using priority_queue\\n\\u2714all you need to do is sorting the array each time you modify it.\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>&s) {\\n        sort(s.begin(),s.end());\\n        while(s.size()>1){\\n            int i=s.size()-1;\\n            int x=s[i],y=s[i-1];\\n            s.pop_back();\\n            s.pop_back();\\n            if(x!=y)s.push_back(x-y);\\n            sort(s.begin(),s.end());\\n        }\\n        if(s.size()==0)return 0;\\n        return s[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576377,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, nums: List[int]) -> int:        \\n        if not nums:\\n            return 0\\n        \\n        elif len(nums) == 1:\\n            return nums[0]\\n        \\n        elif len(nums) == 2:\\n            return abs(nums[0] - nums[1])\\n        \\n        else:\\n            max1 = max(nums)\\n            nums.remove(max1)\\n            max2 = max(nums)\\n            nums.remove(max2)\\n        \\n            if max1 != max2:\\n                val = abs(max1-max2)\\n                nums.append(val)\\n\\n        val = self.lastStoneWeight(nums)\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360024,
                "title": "o-nlogn-and-o-n-algo",
                "content": "O(n*log(n)) Using Priority Queue\\nO(n) bucket sort\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n\\n\\nPriorith Queue:\\n```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\\n\\nBucket Sort: O(n)\\n\\n\\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```\\n\\nworst case like \\n[1,1,1,1,1,1000] in this case the while(i>0) will run 1000^2 times if we don\\'t cache lastJ otherwise 1000 times and if (j==0) then i will be surely that last element where >0 frequency is there \\n",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * O(n*log(n))\\n * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightPriorityQueue {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        System.out.println(Printer.toString(stones));\\n\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for (int i = 0; i < stones.length; i++)\\n            pq.offer(stones[i]);\\n\\n        while (pq.size() >= 2) {\\n\\n            int s1 = pq.poll();\\n            int s2 = pq.poll();\\n\\n            if (s1 != s2)\\n                pq.offer(s1 - s2);\\n\\n        }\\n\\n        /*\\n        for (int i = 0; i < stones.length - 1; ++i)\\n            pq.offer(pq.poll() - pq.poll());\\n        return pq.poll();\\n         */\\n\\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```\n```\\n\\n/**\\n * We can apply bucket sort to make it work in linear time.\\n * Since\\n * 1 <= stones.length <= 30\\n * 1 <= stones[i] <= 1000\\n * Algorithm:\\n * 1. Find the maximum value in the stones array.\\n * 2. Create that many buckets; bucket[max]\\n * 3. Count the frequency of each bucket\\n * 4. Run backward from bucket for each element from max to 0\\n * <p>\\n * a. if this bucket has even frequency; then they will destroy each other; move back\\n * b. If this bucket has odd frequency[i]; then we need to find another bucket[j] and then update the bucket whose value is [i-j]+1\\n * As well decrease the frequency of this buckets as we used both of the stones.\\n * <p>\\n * Keep doing this, at the end the bucket which has frequency > 0 and its odd is your value.\\n * <p>\\n *\\n * <p>\\n * Complexity:\\n * Space: O(max) ; since 1 <= stones[i] <= 1000 then O(1000) is constant => O(1)\\n * <p>\\n * Time: O(n) {bucket frequency} + the maximum value of stones= 1000 and the max length of stones is 30 [1 <= stones.length <= 30[.\\n * In wost scenario; all stones are duplicate Or unique or flatten like [1,1,1,1,1000]\\n * <p>\\n * at max the loop will run 1000 time. Hence constant\\n * <p>\\n * Space: O(1)\\n * Time: O(n+1000) => O(n)\\n * <p>\\n * * Runtime: 1 ms, faster than 97.26% of Java online submissions for Last Stone Weight.\\n * * Memory Usage: 34.1 MB, less than 100.00% of Java online submissions for Last Stone Weight.\\n */\\nclass LastStoneWeightBucketSort {\\n\\n    public int lastStoneWeight(int[] stones) {\\n        if (null == stones || stones.length == 0)\\n            return 0;\\n\\n        /**\\n         * Find Max\\n         */\\n        int max = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            max = Math.max(max, stones[i]);\\n\\n        /**\\n         * Create \\'max\\' number of buckets; max+1 since array has max as value\\n         */\\n        int buckets[] = new int[max + 1];\\n\\n        /**\\n         * Count frequency\\n         */\\n        for (int i = 0; i < stones.length; i++)\\n            buckets[stones[i]]++;\\n\\n\\n        int i = max;\\n        int lastJ = max;\\n\\n        /**\\n         * Run backward\\n         */\\n        while (i > 0) {\\n\\n            /**\\n             * If this weight store is present\\n             */\\n            if (buckets[i] > 0) {\\n\\n                /**\\n                 * if frequency = even, they will destroy each other\\n                 */\\n                if (buckets[i] % 2 == 0) {\\n                    buckets[i] = 0;\\n                    i--;\\n                    continue;\\n                } else {\\n                    /**\\n                     * Otherwise find a stone whose frequency is not 0\\n                     */\\n                    int j = i - 1 > lastJ ? lastJ : i - 1;\\n                    while (j > 0 && buckets[j] == 0) j--;\\n\\n                    /**\\n                     * If no bucket left, then [i] is last stone\\n                     */\\n                    if (j == 0) {\\n                        return i;\\n//                        break;\\n                    } else {\\n                        lastJ = j;\\n\\n                        /**\\n                         * Utilize both of the stones\\n                         */\\n                        buckets[j]--;\\n                        buckets[i]--;\\n\\n                        /**\\n                         * create a new stone of i-j difference\\n                         */\\n                        buckets[i - j]++;\\n\\n\\n                        if (i - j > j) {\\n                            i = i - j;\\n                        } else {\\n                            i = j;\\n                        }\\n\\n                    }\\n                }\\n            } else\\n                i--;\\n        }\\n\\n\\n//        for (int x = 0; x < buckets.length; x++)\\n//            if (buckets[x] > 0 && buckets[x] % 2 != 0)\\n//                return x;\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450031,
                "title": "two-appraoches-heapq-and-sorting",
                "content": "# Heap  Approach : TC : (NLogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\\n# Sorting Approach ,TC:---->N*(N*LogN)\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        list1=[-x for x in stones]\\n        while len(list1)>1:\\n            heapq.heapify(list1)\\n            a,b=heapq.heappop(list1),heapq.heappop(list1)\\n            heapq.heappush(list1,-(abs(a-b)))\\n        return abs(list1[0])\\n```\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones)>1:\\n            stones.sort()\\n            a,b=stones.pop(),stones.pop()\\n            stones.append(abs(a-b))\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449192,
                "title": "100-beats-easy-c-solution-just-see-for-yourself",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort in descending order and going through the first two elements and repeating the process.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple. Follow the following steps to understand the approach.\\n\\n1)Sort the stones vector in descending order.\\n2)store the difference of first two numbers(stones[0] and stones[1]) in res.\\n3)If res is 0 then remove stones[0] and stones[1]. If res is not equal to zero which is a positve integer, then remove the front element in the vector and replace the res value with front element in the vector. (Since we need to remove 1st two elements and push the positve integer, instead of that am removing one element and replacing the other).\\n4)Repeat the steps until stones vector is having atleast 2 elements.\\n5)If there is an element in the stones vector, then that is our answer else return 0.\\n\\n# Complexity\\n- Time complexity: O(N*NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(), stones.end(), greater<int>());\\n        int i = 0;\\n        while (i<stones.size() && (i+1)<stones.size()){\\n            int res = stones[i] - stones[i+1];\\n            if (res != 0){\\n                stones.erase(stones.begin());\\n                stones[0] = res;\\n                sort(stones.begin(), stones.end(), greater<int>());\\n            }\\n            else{\\n                stones.erase(stones.begin(), stones.begin()+2);\\n            }\\n        }\\n        if (stones.size()){\\n            return stones[0];\\n        }\\n        return 0;\\n    }\\n};\\n\\n//                         (sorted)         (updated vector)\\n//[2, 7, 4, 1, 8, 1] = [8, 7, 4, 2, 1, 1] -> [1, 4, 2, 1, 1] = [4, 2, 1, 1, 1] ->\\n// [2, 1, 1, 1] -> [1, 1, 1] -> \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448759,
                "title": "easy-java-soluton-using-priorityqueue-with-explanation-intuition",
                "content": "# PLEASE UPVOTE\\n\\n![Screenshot 2023-04-24 at 06.29.54.png](https://assets.leetcode.com/users/images/877f6529-7103-45dc-a713-d2c71c40566d_1682298023.9539728.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Priority Queue to sort at every operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inserting the whole array to Priorty Queue,\\n2. Popping the first two elements from the pq (MAX and second MAX),\\n3. adding the difference back to pq,\\n4. repeating 2 & 3.\\n5. return max when loop completes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n*sorting at every input and operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<stones.length;i++){\\n            pq.add(stones[i]);\\n        }\\n        int p,q;\\n        while(pq.size()>1){\\n            p=pq.poll();\\n            q=pq.poll();\\n            // System.out.println(\\xF7p+\" \"+q);\\n            pq.add(p-q);\\n        }\\n        return pq.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314775,
                "title": "c-priorityqueue-net6",
                "content": "Use c# PriorityQueue\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        PriorityQueue<int, int> queue = new();\\n        foreach(int s in stones)\\n        {\\n            queue.Enqueue(s,-s);\\n        }\\n        while(queue.Count >1)\\n        {\\n            int stone1 = queue.Dequeue();\\n            int stone2 = queue.Dequeue();\\n            if(stone1 != stone2)\\n            {\\n                int newStone = stone1 - stone2;\\n                newStone = newStone > 0 ? newStone : newStone * -1;\\n                queue.Enqueue(newStone, -newStone);\\n            }\\n        }\\n        if(queue.Count ==0)\\n        {\\n            return 0;\\n        }\\n        return queue.Dequeue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661271,
                "title": "c-88",
                "content": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> stoneList = new List<int>(stones);\\n        return stoneHelper(stoneList);\\n    }\\n    \\n    public int stoneHelper(List<int> stones) {\\n        \\n        if(stones.Count == 0 )\\n            return 0;\\n        else if (stones.Count == 1)\\n            return stones[0];\\n        else  {\\n            int max = stones.Max();\\n            stones.Remove(max);\\n            \\n            int sMax = stones.Max();\\n            stones.Remove(sMax);\\n\\n            if (sMax < max) {\\n                stones.Add(max-sMax);\\n            }\\n            return stoneHelper(stones); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518940,
                "title": "javascript-priority-queue-solution-o-n",
                "content": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```\\n\\n* 70/70 cases passed (56 ms)\\n* Your runtime beats 84.25 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n  const heap = new MaxHeap(stones);\\n  while (heap.size() > 1) {\\n    const max1 = heap.poll();\\n    const max2 = heap.poll();\\n    if (max1 > max2) heap.offer(max1 - max2);\\n  }\\n  return heap.size() === 1 ? heap.poll() : 0;\\n};\\n\\nclass MaxHeap {\\n  constructor(data = []) {\\n    this.data = data;\\n    this.comparator = (a, b) => b - a;\\n    this.heapify();\\n  }\\n\\n  // O(nlog(n)). In fact, O(n)\\n  heapify() {\\n    if (this.size() < 2) return;\\n    for (let i = 1; i < this.size(); i++) {\\n      this.bubbleUp(i);\\n    }\\n  }\\n\\n  // O(1)\\n  peek() {\\n    if (this.size() === 0) return null;\\n    return this.data[0];\\n  }\\n\\n  // O(log(n))\\n  offer(value) {\\n    this.data.push(value);\\n    this.bubbleUp(this.size() - 1);\\n  }\\n\\n  // O(log(n))\\n  poll() {\\n    if (this.size() === 0) return null;\\n    const result = this.data[0];\\n    const last = this.data.pop();\\n    if (this.size() !== 0) {\\n      this.data[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return result;\\n  }\\n\\n  // O(log(n))\\n  bubbleUp(index) {\\n    while (index > 0) {\\n      const parentIndex = (index - 1) >> 1;\\n      if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(log(n))\\n  bubbleDown(index) {\\n    const lastIndex = this.size() - 1;\\n    while (true) {\\n      const leftIndex = index * 2 + 1;\\n      const rightIndex = index * 2 + 2;\\n      let findIndex = index;\\n      if (\\n        leftIndex <= lastIndex &&\\n        this.comparator(this.data[leftIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = leftIndex;\\n      }\\n      if (\\n        rightIndex <= lastIndex &&\\n        this.comparator(this.data[rightIndex], this.data[findIndex]) < 0\\n      ) {\\n        findIndex = rightIndex;\\n      }\\n      if (index !== findIndex) {\\n        this.swap(index, findIndex);\\n        index = findIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  // O(1)\\n  swap(index1, index2) {\\n    [this.data[index1], this.data[index2]] = [\\n      this.data[index2],\\n      this.data[index1]\\n    ];\\n  }\\n\\n  // O(1)\\n  size() {\\n    return this.data.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494982,
                "title": "rust-binary-heap",
                "content": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        let mut heap = BinaryHeap::from(stones);\\n        while let Some(stone) = heap.pop() {\\n            match heap.pop() {\\n                Some(val)   => heap.push(stone - val),\\n                None        => return stone,\\n            }       \\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036497,
                "title": "java-don-t-worry-my-solution-is-best-100-92-39-6-mb",
                "content": "\\t*   class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\twhile (list.size() > 1) {\\n\\t\\t\\t\\t\\tint a = list.size();\\n\\t\\t\\t\\t\\tif (list.get(a - 1) > list.get(a - 2)) {\\n\\t\\t\\t\\t\\t\\tlist.add(( list.get(a - 1) -list.get(a - 2)));\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tlist.remove(a-2);\\n\\t\\t\\t\\t\\t\\tCollections.sort(list);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlist.remove(a - 1);\\n\\t\\t\\t\\t\\t\\tlist.remove(a -2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (list.size()==1){\\n\\t\\t\\t\\t\\treturn list.get(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic  int lastStoneWeight(int[] stones) {\\n\\t\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tfor (int a : stones) {\\n\\t\\t\\t\\t\\tlist.add(a);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2825881,
                "title": "java-runtime-1ms-faster-than-99-49-queue-and-iterative-solutions",
                "content": "PriorityQueue solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\\n\\nWithout extra space solution:\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c808e6a5-e57b-427e-98eb-31b4ffa029bb_1668743243.4978485.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Queue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int i : stones) queue.offer(i);\\n\\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int next = queue.poll();\\n            if (first != next) {\\n                queue.offer(first - next);\\n            }\\n        }\\n        return queue.isEmpty() ? 0 : queue.poll();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if (stones.length == 1) return stones[0];\\n        Arrays.sort(stones);\\n        int last = stones.length - 1;\\n        int prev = stones.length - 2;\\n        while (stones[last] != 0) {\\n            if (stones[prev] == 0) return stones[last];\\n            stones[last] = stones[last] - stones[prev];\\n            stones[prev] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596771,
                "title": "c-easy-priority-queue-solution-100-time",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n\\n\\tpriority_queue<int>pq;\\n\\tfor(auto x: stones)\\n\\t{\\n\\t\\tpq.push(x);\\n\\t}\\n\\n\\twhile(!p.empty())\\n\\t{\\n\\t\\tint y = pq.top();\\n\\t\\tif(pq.size()==1)return y;\\n\\t\\tpq.pop();\\n\\t\\tint rem = abs(y - pq.top());\\n\\t\\tpq.pop();\\n\\t\\tpq.push(rem);\\n\\n        }\\n        return 0;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524599,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\\n        use std::collections::BinaryHeap;\\n\\n        let mut h = BinaryHeap::from(stones);\\n        while h.len() > 1 {\\n            let s1 = h.pop().unwrap();\\n            let s2 = h.pop().unwrap();\\n            h.push(s1 - s2)\\n        }\\n        h.pop().unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833091,
                "title": "python-heapq",
                "content": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\"\"\"\\nChoose two heaviest stones and smash them together\\n\\nx==y: destroyed\\nx != y, new weight is difference, return weight of stome\\n\\nApproach:\\nuse max heap, get difference\\n\"\"\"\\nimport heapq\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [-x for x in stones]\\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            stone1 = -(heapq.heappop(stones))\\n            stone2 = -(heapq.heappop(stones))\\n            \\n            if stone1 == stone2: continue\\n            heapq.heappush(stones,-(abs(stone1-stone2)))\\n            \\n        if len(stones) == 0: return 0\\n        return -(heapq.heappop(stones))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488945,
                "title": "c-vector-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1){\\n            sort(stones.begin(),stones.end(),greater<int>());\\n            if(stones[0] == stones[1])\\n                stones.erase(stones.begin(),stones.begin()+2);\\n            else{\\n                stones.push_back(abs(stones[0] - stones[1]));\\n                stones.erase(stones.begin(),stones.begin()+2);         \\n            }\\n        }\\n        if(!stones.empty())\\n            return stones[0];\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649893,
                "title": "c-easy-short-faster-than-100-priority-queue",
                "content": "![image](https://assets.leetcode.com/users/images/e3870a6c-2992-4394-80e6-0251c9344bc1_1664696002.4909544.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn q.top();\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint lastStoneWeight(vector<int>& st) {\\n\\t\\t\\t\\tint n=st.size();\\n\\t\\t\\t\\tpriority_queue<int>q;\\n\\t\\t\\t\\tfor(auto i: st) q.push(i);\\n\\t\\t\\t\\twhile(q.size()!=1){\\n\\t\\t\\t\\t\\tint x=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tint y=q.top();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tq.push(max(x,y)-min(x,y));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1922870,
                "title": "c-naive-solution",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        sort(stones.begin(),stones.end());\\n        int a=stones.size()-1;\\n        if(a==0){\\n            return stones[a];\\n        }\\n        for(int i=0;i<stones.size();i++){\\n            sort(stones.begin(),stones.end());\\n            if(stones[a]>0 && stones[a-1]>0){\\n                stones[a]=stones[a]-stones[a-1];\\n                stones[a-1]=0;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return stones[a];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922210,
                "title": "java-priority-queue",
                "content": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n\\n        while (queue.size() > 1) {\\n            queue.offer(queue.poll() - queue.poll());\\n        }\\n\\n        return queue.isEmpty() ? 0 : queue.peek();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921123,
                "title": "very-easy-code-with-explanation",
                "content": "**step 1  create a priority queue\\nstep 2 Put all elements into a priority queue.\\nstep 3 take two bigest element \\npush the difference into queue until\\ntwo more element left.**\\n\\n**Complexity\\nTime O(NlogN)\\nSpace O(N)**\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }\\n      return pq.empty()?0:pq.top();  \\n        \\n    }\\n};\\n\\nif(ishelpfull)\\n(upvote);\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& nums) {\\n       priority_queue<int> pq;\\n      for(auto i : nums)      \\n          pq.push(i);\\n      while(pq.size() > 1)\\n      {\\n          int a = pq.top();\\n          pq.pop();\\n          int b = pq.top(); \\n          pq.pop();\\n       if(a>b)\\n              pq.push(a-b);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1921120,
                "title": "last-stone-weight-python-easy-48-ms",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while(len(stones)>1):\\n            p = max(stones)\\n            pi= stones.index(p)\\n            stones.pop(pi)\\n            q = max(stones)\\n            qi = stones.index(q)\\n            stones.pop(qi)\\n            stones.append(p-q)\\n        return stones[0]    \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1378654,
                "title": "java-easy-solution-o-nlogn-time-complexity-priority-queue",
                "content": "The efficient way to retrieve the max from array is to use a max heap, which in Java is a PriorityQueue (min heap) with a reverse comparator.\\n\\n Follow 4 Easy steps-\\n**Step1** : Create a max priority queue.\\n**Step2** : Add all the elements to queue.\\n**Step3** : Remove two max element at a time, find the difference and then add into the queue.\\n**Step4** : Check if queue is empty return 0, else return the element\\n\\n\\n```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\\n\\nTime Complexity - ```o(nlogn)```\\nSpace Complexity - ```o(n)```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        \\n        // Create a max priority queue         \\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        // Add all the elements to queue        \\n        for(int i : stones) {\\n        \\tqueue.add(i);\\n        }\\n        \\n        // Remove two max element at a time, find the difference and then add into the queue         \\n        while(queue.size() > 1) {\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            int num = num1 - num2;\\n            queue.add(num);\\n        }\\n        \\n        // Check if queue is empty return 0, else return the element         \\n        if(queue.isEmpty()) {\\n        \\treturn 0;\\n        }\\n        return queue.poll();\\n    }\\n```\n```o(nlogn)```\n```o(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 594316,
                "title": "javascript-99-time",
                "content": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "solutionTags": [],
                "code": "It\\'s not optimal but it\\'s efficient without using a priority queue. Just array manipulation \\n\\n```/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    let size = stones.length;\\n     \\n    while(size >= 2){\\n        stones.sort((a,b)=> { return a-b })\\n        \\n        x = stones.pop(); \\n        y = stones.pop();\\n        \\n        if(x == y){\\n            size -= 2;\\n        }else{\\n            size -= 1; \\n            stones.unshift(x - y); \\n        }\\n    }\\n    \\n    return stones;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 575384,
                "title": "c-solution-with-explanation",
                "content": "**Priority Queue Implementation**\\n* Make  a priority queue(binary max heap) which automatically arrange the element in sorted order.\\n* Then pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal  we dont have to push anything , if not equal push difference of both in queue.\\n* Do the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            pq.push(stones[i]);\\n        }\\n        int m1,m2;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()==1)\\n                return pq.top();\\n            m1=pq.top();\\n            pq.pop();\\n            m2=pq.top();\\n            pq.pop();\\n            \\n            if(m1!=m2)\\n                pq.push(m1-m2);\\n        }\\n            return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549801,
                "title": "golang-using-container-heap",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"container/heap\"\\n)\\n\\nfunc lastStoneWeight(stones []int) int {\\n\\tpq := IntHeap(stones)\\n\\theap.Init(&pq)\\n\\tfor pq.Len() > 1 {\\n\\t\\theap.Push(&pq, heap.Pop(&pq).(int)-heap.Pop(&pq).(int))\\n\\n\\t}\\n\\treturn heap.Pop(&pq).(int)\\n}\\n\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t// Push and Pop use pointer receivers because they modify the slice\\'s length,\\n\\t// not just its contents.\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 467505,
                "title": "python-very-simple-solution-95-fast",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        while len(stones) > 1:\\n            stones.sort()\\n            x, y = stones[-2], stones[-1]\\n            stones = stones[:-2]\\n       \\n            if x != y:\\n                stones.append(y - x)\\n                \\n        return stones[0] if stones else 0",
                "codeTag": "Java"
            },
            {
                "id": 437380,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\t\\t\\tstones.sort()\\n\\t\\t\\twhile len(stones)>1:\\n\\t\\t\\t\\tt = stones.pop()\\n\\t\\t\\t\\tu = stones.pop()\\n\\t\\t\\t\\tif t==u:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.append(t-u)\\n\\t\\t\\t\\t\\tstones.sort()\\n\\t\\t\\treturn stones[0] if stones else 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 3449828,
                "title": "better-than-100-in-runtime-simple-c-approach",
                "content": "# Approach\\nAlright, in this I am using Priority Queue. In this first I am adding all elements of the vector \"stones\" in the priority queue called \"pq\". Now I am initializing a while loop, setting the condition that, the size of \"pq\" must be greater than 1. I am simply checking the top 2 elements and doing the required manipulations in the question. In the end, if size of \"pq\" is 0, return 0; else we should return the top element of the same.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        int n=stones.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(stones[i]);\\n        }    \\n        while(pq.size()>1)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            if(a!=b)\\n            {\\n                int c=a-b;\\n                pq.push(c);\\n            }\\n        }\\n        if(pq.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int l=pq.top();\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449596,
                "title": "java-easy-solution-lbeginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        //creating a heap to store elements in descending order\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i = 0 ; i < stones.length; i ++){\\n            q.add(stones[i]);\\n        }\\n        while(q.size() > 1){\\n            int x = q.poll();\\n            int y = q.poll();\\n            if(x == y){\\n                continue;\\n            }else{\\n                q.add(Math.abs(y - x));\\n            }\\n        }\\n        if(q.size() == 1){\\n            return q.poll();\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448701,
                "title": "easy-java-solution-using-maxheap-beginner-friendly",
                "content": "# Intuition\\nNeed to maitain a DS to get top-2 stone, PriorityQueue is best for this\\n\\n# Approach\\n1. Push all elments in prioriyQueue as MaxHeap.\\n2. Pick top 2 elements form maxHeap, if there is only one element left then that is answer.\\n3. If both element are same, no action needed and continue the process.\\n4. If both element are different, push the differece again.\\n5. Answer will be if only one stone is left or no stone is left, **In case of only one stone is left, that is the answer, if no stoner are left, 0 is the answer.**\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((stone1, stone2) -> stone2 - stone1);\\n\\n        for(int stone: stones) {\\n            maxHeap.add(stone);\\n        }\\n\\n        while(!maxHeap.isEmpty()) {\\n            // take haviest stone\\n            int y = maxHeap.poll();\\n            if(maxHeap.isEmpty()) {\\n                // if the was only one stone left, so that is answer\\n                return y;\\n            } else {\\n                // take second haviest stone\\n                int x = maxHeap.poll();\\n                // if both are no equal then push the difference, no action needed for equal\\n                if(x != y) {\\n                    maxHeap.add(y - x);\\n                }\\n            }\\n        }\\n\\n        // if no stone left in heap\\n        return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448681,
                "title": "daily-leetcoding-challenge-april-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3425201,
                "title": "c-simple-solution-with-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n\\n        var heap = new PriorityQueue<int, int>();\\n        \\n        foreach (var stone in stones)\\n            heap.Enqueue(stone, 0 - stone);\\n\\n        while (heap.Count > 1)\\n        {\\n            var newStone = heap.Dequeue() - heap.Dequeue();\\n            if (newStone > 0)\\n                heap.Enqueue(newStone, 0 - newStone);\\n        }\\n        \\n        return heap.Count > 0 ? heap.Dequeue() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375538,
                "title": "java-heap-fight-of-the-stones",
                "content": "\\n```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Heap\\n{\\n    int [] heap;\\n    int size;\\n    Heap(int[] stones)\\n    {\\n        heap = new int[stones.length];\\n        size = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            addStone(stones[i]);\\n    }\\n    public int removeMax() //size--\\n    {\\n        int answ = heap[0];\\n        if (size > 0) {\\n            heap[0] = heap[size - 1];\\n            size--;\\n        }\\n        siftDown();\\n        return answ;\\n    }\\n    public void addStone(int stone) //size++\\n    {\\n        size++;\\n        heap[size - 1] = stone;\\n        siftUp();\\n    }\\n\\n    public int[] changePlace(int child, int[] start)\\n    {\\n        int tmp;\\n\\n        tmp = heap[child];\\n        heap[child] = heap[start[0]];\\n        heap[start[0]] = tmp;\\n        start[0] = child;\\n        return new int[]{getLeftChild(start[0]), getRightChild(start[0])};\\n    }\\n\\n    public void siftDown()\\n    {\\n        int []start = new int[]{0};\\n        int []leftAndRight = new int[2];\\n        leftAndRight[0] = getLeftChild(start[0]);\\n        leftAndRight[1] = getRightChild(start[0]);\\n        int tmp;\\n        while (true)\\n        {\\n            if (leftAndRight[0] < size && leftAndRight[1] < size)\\n            {\\n                if(heap[leftAndRight[0]] >= heap[leftAndRight[1]] && heap[start[0]] <= heap[leftAndRight[0]])\\n                    leftAndRight = changePlace(leftAndRight[0], start);\\n                else if(heap[leftAndRight[1]] > heap[leftAndRight[0]] && heap[start[0]] <= heap[leftAndRight[1]])\\n                    leftAndRight = changePlace(leftAndRight[1], start);\\n                else\\n                    break;\\n            }\\n            else if (leftAndRight[0] < size && heap[start[0]] <= heap[leftAndRight[0]])\\n                leftAndRight = changePlace(leftAndRight[0], start);\\n            else if (leftAndRight[1] < size && heap[start[0]] <= heap[leftAndRight[1]])\\n                leftAndRight = changePlace(leftAndRight[1], start);\\n            else\\n                break;\\n        }\\n    }\\n\\n    public void siftUp()\\n    {\\n        int child = size - 1;\\n        int parent = getParent(child);\\n        int tmp;\\n        while (parent > -1 && heap[parent] < heap[child])\\n        {\\n            tmp = heap[child];\\n            heap[child] = heap[parent];\\n            heap[parent] = tmp;\\n            child = parent;\\n            parent = getParent(child);\\n        }\\n    }\\n\\n    public int getParent(int child)\\n    {\\n        return (child - 1) / 2;\\n    }\\n\\n    public int getLeftChild(int parent)\\n    {\\n        return parent * 2 + 1;\\n    }\\n\\n    public int getRightChild(int parent)\\n    {\\n        return parent * 2 + 2;\\n    }\\n}\\n\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Heap heap = new Heap(stones);\\n        int diff;\\n        while (heap.size > 1)\\n        {\\n            diff = Math.abs(heap.removeMax() - heap.removeMax());\\n            if (diff != 0)\\n                heap.addStone(diff);\\n        }\\n        if (heap.size > 0)\\n            return heap.removeMax();\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224561,
                "title": "using-heap-1ms-java-beat",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/1296130b-2e6f-4f1a-b8dc-344f9b151589_1677230001.423075.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:stones)\\n            pq.add(i);\\n\\n        int x;\\n        int y;\\n\\n        while(pq.size()>1){\\n\\n             x=pq.poll();\\n             y=pq.poll();\\n\\n            if(x>y)\\n                pq.add(x-y);\\n\\n            }\\n            \\n        return pq.isEmpty()?0:pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188840,
                "title": "golang-maxheap",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lastStoneWeight(stones []int) int {\\n    maxHeap := &MaxHeap{}\\n\\n    for _, stone := range stones {\\n        heap.Push(maxHeap, stone)\\n    }\\n\\n    for maxHeap.Len() > 1 {\\n        stone1 := heap.Pop(maxHeap).(int)\\n        stone2 := heap.Pop(maxHeap).(int)\\n\\n        if stone1 != stone2 {\\n            heap.Push(maxHeap, stone1 - stone2)\\n        }\\n    }\\n\\n    res := 0\\n    if maxHeap.Len() == 1 {\\n        res = (*maxHeap)[0]\\n    }\\n    return res\\n}\\n\\ntype MaxHeap []int\\n\\nfunc (h MaxHeap) Len() int           { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h MaxHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *MaxHeap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *MaxHeap) Pop() interface{} {\\n    x := (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027670,
                "title": "python-heapq-min-with-negative-values-equivalent-to-heap-max",
                "content": "https://leetcode.com/submissions/detail/875123729/  \\nRuntime: **29 ms**, faster than 94.25% of Python3 online submissions for Last Stone Weight.  \\nMemory Usage: 13.8 MB, less than 61.08% of Python3 online submissions for Last Stone Weight.  \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = [-s for s in stones]\\n        heapify(s)\\n        while len(s)>1:\\n            heapq.heappush(s, -abs(heappop(s) - heappop(s)))\\n        return -s[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907947,
                "title": "kotlin-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun lastStoneWeight(stones: IntArray): Int {\\n        val h = PriorityQueue<Int> { a, b -> b.compareTo(a) }\\n        stones.forEach { h.add(it) }\\n\\n        while (h.size > 1) { \\n            h.add(h.poll() - h.poll())\\n        }\\n \\n        return h.poll()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168036,
                "title": "javascript-using-maxpriorityqueue",
                "content": "Finally, there\\'s a Max/MinPriorityQueue for JavaScript!\\n\\nadd -> enqueue( )\\nremove -> dequeue( )\\nhighest number (peek) -> front( )\\n.element -> actual value\\n\\n```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lastStoneWeight = function(stones) {\\n    const m = new MaxPriorityQueue()\\n    for(const w of stones) m.enqueue(w)\\n    \\n    while(m.size() > 1){\\n        const diff = m.dequeue().element - m.dequeue().element\\n        if(diff > 0) m.enqueue(diff)\\n    }\\n \\n    return m.size() === 0 ? 0 : m.front().element\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1922969,
                "title": "c-solution-with-image-explanation-no-extra-space",
                "content": "![image](https://assets.leetcode.com/users/images/2926ac92-fc16-4e57-ba90-57edfee68604_1649334079.7444394.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        while(stones.size() > 1) {\\n            sort(stones.begin(), stones.end());\\n            int n = stones.size();\\n            \\n            if(stones[n - 2] == stones[n - 1]) {\\n                stones.pop_back();\\n                stones.pop_back();\\n            }\\n            else {\\n                stones[n - 2] = stones[n - 1] - stones[n - 2];\\n                stones.pop_back();\\n            }\\n        }\\n        return stones.empty() ? 0:stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922677,
                "title": "python-simple-python-solution-using-three-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Apporach 1 Using Priority Queue :-\\n# Runtime: 39 ms, faster than 55.89% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.1 MB, less than 13.28% of Python3 online submissions for Last Stone Weight.\\n\\n\\tfrom queue import PriorityQueue\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tpq = PriorityQueue()\\n\\n\\t\\t\\tfor stone in stones:\\n\\t\\t\\t\\tpq.put(-stone)\\n\\n\\t\\t\\twhile pq.qsize() >= 2:\\n\\t\\t\\t\\tfirst_heavy = -(pq.get())\\n\\t\\t\\t\\tsecond_heavy = -(pq.get())\\n\\n\\t\\t\\t\\tif first_heavy == second_heavy:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpq.put(-(first_heavy - second_heavy))\\n\\n\\t\\t\\tif pq.qsize() == 1:\\n\\t\\t\\t\\treturn -pq.get()\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 2 Using Sorting :-\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\twhile len(stones)>1:\\n\\n\\t\\t\\t\\tsort_stones = sorted(stones)\\n\\n\\t\\t\\t\\tsmall_num, large_num = sort_stones[-2], sort_stones[-1]\\n\\n\\t\\t\\t\\tif small_num == large_num :\\n\\n\\t\\t\\t\\t\\tstones = sort_stones[:-2]\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(small_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.remove(large_num)\\n\\n\\t\\t\\t\\t\\tsort_stones.append(large_num - small_num)\\n\\n\\t\\t\\t\\t\\tstones = sort_stones\\n\\n\\t\\t\\tif len(stones)==1:\\n\\n\\t\\t\\t\\treturn stones[0]\\n\\n\\t\\t\\telse:\\n\\n\\t\\t\\t\\treturn 0\\n\\n# Approach 3 Using SortedList:\\n# Runtime: 47 ms, faster than 7.84% of Python3 online submissions for Last Stone Weight.\\n# Memory Usage: 14.2 MB, less than 8.03% of Python3 online submissions for Last Stone Weight.\\nfrom sortedcontainers import SortedList\\n\\n\\tclass Solution:\\n\\t\\tdef lastStoneWeight(self, stones: List[int]) -> int:\\n\\n\\t\\t\\tstones = SortedList(stones)\\n\\n\\t\\t\\twhile len(stones) > 1:\\n\\n\\t\\t\\t\\tlast = stones.pop(-1)\\n\\t\\t\\t\\tsecond_last = stones.pop(-1)\\n\\n\\t\\t\\t\\tif last == second_last:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tstones.add(last - second_last)\\n\\n\\t\\t\\tif len(stones) > 0:\\n\\t\\t\\t\\treturn stones[0]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 0\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 1922512,
                "title": "simplest-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```\\nTC : O(nlogn)     \\nSC : O(N)\\nIf you like the solution please upvote. :)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;  //create max heap having maximum element at top\\n        for(int x:stones)               //insert all elements into priority queue \\n            pq.push(x);\\n        while(pq.size()>1){        //iterate until size is equal to 1\\n            int fval=pq.top();      //fval is first max val\\n            pq.pop();\\n            int sval=pq.top();     //sval is second max val\\n            pq.pop();\\n            if(fval==sval){          //if both equal simply push 0 since both stones destroyed\\n                pq.push(0);\\n            }\\n            else if(fval>sval){         //if both not equal substract small val to larger  one and insert \\n                pq.push(fval-sval);\\n            }\\n        }\\n        return pq.top();       //finally return top value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357203,
                "title": "easy-python-solution-99-91",
                "content": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 16 ms, faster than 99.91% of Python3 online submissions for Last Stone Weight.\\nMemory Usage: 14.1 MB, less than 78.97% of Python3 online submissions for Last Stone Weight.\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) != 1:\\n            stones.sort()\\n            if len(stones)>2:\\n                if stones[-1]==stones[-2]:\\n                    del stones[-1]\\n                    del stones[-1]\\n                elif stones[-1]>stones[-2]:\\n                    stones[-1]-=stones[-2]\\n                    del stones[-2]\\n            else:\\n                return stones[-1]-stones[-2]        \\n        return stones[0]",
                "codeTag": "Java"
            },
            {
                "id": 709185,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    while(stones.length > 1) {\\n        stones.sort((a,b) => b-a);\\n\\n        let first = stones.shift();\\n        let second = stones.shift();\\n\\n        if(first !== second) {\\n            stones.push(Math.abs(first-second));\\n        }\\n    }\\n\\n    if(stones.length == 0) {\\n        return 0;\\n    }\\n\\n    return stones[0];\\n};\\n\\n// Runtime (64ms) - Faster than 65.95% of Javascript submissions\\n// Memory Usage ( 34.1 MB ) - Less than 79% of Javascript submissions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674125,
                "title": "java-heap",
                "content": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\\n        for (int st : stones) {\\n            pq.offer(st);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll(), y = pq.poll();\\n            int rem = x - y;\\n            if (rem > 0) pq.offer(rem);\\n        }\\n        \\n        return pq.size() > 0 ? pq.poll() : 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464917,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    if(stones.length < 2) return stones;\\n    while(stones.length > 1){\\n        let index1 = stones.indexOf(Math.max(...stones));\\n        let stone1 = stones.splice(index1,1);\\n        let index2 = stones.indexOf(Math.max(...stones));\\n        let stone2 = stones.splice(index2,1);\\n        stones.push(stone1-stone2);        \\n    }\\n    return stones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398322,
                "title": "c-minimum-heap-using-c-sorteddictionary",
                "content": "The algorithm can be solved using minimum heap. To convert maximum two numbers to minimum two numbers, negative value is used instead. \\n\\nHere are highlights:\\n1. Understand C# SortedDictionary can be used to impelement minimum heap first; \\n2. Apply all ement value to negative one, so maximum heap turns into a minimum heap problem;\\n3. Get familiar with IEnumberable First API and it can be used to get the minimum one from the heap. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// Oct.4, 2019\\n        /// Implement a maximum heap - \\n        /// what I can do is to use negative value \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public int LastStoneWeight(int[] stones)\\n        {\\n            var sorted = new SortedDictionary<int, int>();\\n\\n            // put all numbers into minimum heap - default - negative value\\n            foreach (var number in stones)\\n            {\\n                var key = number * (-1);\\n                if (!sorted.ContainsKey(key))\\n                {\\n                    sorted.Add(key, 0);\\n                }\\n\\n                sorted[key]++; \\n            }\\n\\n            while (!((sorted.Keys.Count == 1 && sorted[sorted.Keys.ToList()[0]] == 1) || sorted.Keys.Count == 0))\\n            {\\n                // get minimum two values from minimum heap\\n                var key = sorted.Keys.First();\\n                var hasAtLeastTwo = sorted[key] > 1;\\n                if (hasAtLeastTwo)\\n                {\\n                    sorted[key] -= 2;\\n                    if(sorted[key] == 0)\\n                    {\\n                        sorted.Remove(key);\\n                    }\\n                }\\n                else \\n                {\\n                    var minimum = key;\\n                    sorted.Remove(key);\\n                    var next = sorted.Keys.First();\\n                    sorted[next]--;\\n\\n                    if (sorted[next] == 0)\\n                    {\\n                        sorted.Remove(next);\\n                    }\\n\\n                    var diff = Math.Abs(minimum - next);\\n                    var newKey = diff * (-1);\\n\\n                    if (newKey == 0)\\n                        continue;\\n\\n                    if (!sorted.ContainsKey(newKey))\\n                    {\\n                        sorted.Add(newKey, 0);\\n                    }\\n\\n                    sorted[newKey]++;\\n                }                \\n            }\\n\\n            if (sorted.Keys.Count == 0)\\n                return 0;\\n\\n            return sorted.Keys.ToList()[0] * (-1);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294929,
                "title": "simple-binary-search-based-solution-o-nlogn",
                "content": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "``` csharp\\npublic class Solution {\\n  public int LastStoneWeight(int[] stones)\\n        {\\n            if (stones.Length == 2)\\n            {\\n                return Math.Abs(stones[1] - stones[0]);\\n            }\\n\\n            Array.Sort(stones);\\n            List<int> s = new List<int>(stones);\\n\\n            while (s.Count > 1)\\n            {\\n                int first = s.ElementAt(s.Count - 1);\\n                int second = s.ElementAt(s.Count - 2);\\n                int smash = first - second;\\n                s.RemoveAt(s.Count - 1);\\n                s.RemoveAt(s.Count - 1);\\n\\n                if (smash != 0)\\n                {\\n                    int index = s.BinarySearch(smash);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n                    s.Insert(index, smash);\\n                }\\n            }\\n\\n            return s.FirstOrDefault();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294884,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a, b) -> b - a);\\n        \\n        for (int stone : stones) {\\n            pq.offer(stone);\\n        }\\n        \\n        while (pq.size() > 1) {\\n            int x = pq.poll();\\n            int y = pq.poll();\\n            if (x != y) {\\n                pq.offer(x - y);\\n            }\\n        }\\n        \\n        return pq.isEmpty() ? 0 : pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451705,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of priorityQueue(But this question also we can slove the help of Arraylist)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n     PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder()) ;\\n     for(int i=0;i<stones.length;i++)  {\\n         queue.add(stones[i]);\\n     }\\n     while(queue.size()>1){\\n         int val2=queue.poll();\\n         int val1=queue.poll();\\n         if(val2>val1){\\n             queue.offer(val2-val1);\\n         }\\n     }\\n     if(queue.size()==0) return 0;\\n     return queue.poll();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451178,
                "title": "java-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In this code we first sort the stones to get the 2 heaviest stones at the end of the array.\\n- Now we repetedly smashes(calculates the diff of the two heaviest stones,then setting the heaviest stone with that diff and second heaviest stone with 0) the two heaviest stones until there is only one stone left.\\n- Again sort the stones after the smash.\\n- This loop ends when the weigth of the second heaviest stone is 0.\\n- This indicates that there is only one stone left.\\n# Complexity\\n- Time complexity: O(n^2 log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        if(stones.length == 1) return stones[0];\\n        int n = stones.length;\\n        while(stones[n - 2] > 0){\\n            int diff = stones[n - 1] - stones[n - 2];\\n            stones[n - 2] = 0;\\n            stones[n - 1] = diff;\\n            Arrays.sort(stones);\\n        }\\n        return stones[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449600,
                "title": "c-priority-queue",
                "content": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(auto &i: stones){\\n            pq.push(i);\\n        }\\n        int a,b;\\n        while(pq.size()>1){\\n            a  = pq.top();pq.pop();\\n            b  = pq.top();pq.pop();\\n            if(a!=b){\\n                pq.push(abs(a-b));\\n            }\\n        }\\n        if(pq.empty())return 0;\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449106,
                "title": "c-solution-heap-easy-and-explained",
                "content": "# Explanation\\n- At any point of time we need largest 2 stones that\\'s why I used priority queue.\\n- If the diffrence of these two stones is > 0, the we push it in the queue.\\n- And if diffrence is 0, i.e. both stones are destroyed\\n- At the end of the loop is the queue is empty, i.e. all the stones were destroyed during the game, that means we have to return 0\\n- Else we just return the last stone that\\'s left in the queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/c2726930-6086-475f-aea7-648d6c6f15c6_1682309289.295028.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq(stones.begin(),stones.end());    \\n        while(pq.size()>1){\\n            int s1=pq.top();\\n            pq.pop();\\n            int s2=pq.top();\\n            pq.pop();\\n            if(s1-s2){\\n                pq.push(s1-s2);\\n            }            \\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448970,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 155 videos for leetcode questions as of April 24, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n![aaaaaaa.webp](https://assets.leetcode.com/users/images/d6a4c7b9-262c-497c-b943-a950c6ebdb9f_1682305218.8948395.webp)\\n\\n\\n# Intuition\\nUse heap to store stones.\\n\\n# Approach\\n- This is Python algorithm. Other languages might be different.\\n\\n1. Initialize a variable stones as a heap of negative values of the input stones list using list comprehension. This is done to create a min heap where the most negative value (i.e., the largest absolute value) will be at the root of the heap.\\n\\n2. Convert the stones list into a heap using the heapify function from the heapq module.\\n\\n3. While the length of stones is greater than 1, perform the following steps in a loop:\\n\\n    - Pop the two smallest (most negative) values from the heap and store them in variables s1 and s2.\\n    - Check if s1 and s2 are not equal. If they are not equal, calculate the difference between s1 and s2 and negate it (to maintain the negative value) before pushing it back to the heap using the heappush function.\\n\\n4. After the loop, if the stones heap is not empty, return the negation of the root value (the only remaining value in the heap), which represents the last stone weight. Otherwise, return 0 to indicate that all stones have been destroyed.\\n\\n---\\n\\n\\n**If you don\\'t understand the algorithm, let\\'s check my video solution.\\nThere is my channel link under picture in LeetCode profile.**\\nhttps://leetcode.com/niits/\\n\\n\\n---\\n\\n# Complexity\\n- Time complexity: O(n log n)\\nn is the number of elements in the input stones list. This is because the heapify function has a time complexity of O(n) and the while loop iterates n/2 times at most (since two elements are popped from the heap in each iteration), and each iteration involves push and pop operations on the heap which take O(log n) time. Therefore, the overall time complexity is dominated by the heapify function, resulting in O(n log n) time complexity.\\n\\n- Space complexity: O(n)\\nThe stones list is modified in place by converting it into a heap using heapify. No additional data structures are used, and the variables used in the code have constant space requirements. Therefore, the space complexity is proportional to the size of the input stones list, i.e., O(n).\\n\\n# Python\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        if len(stones) == 1:\\n            return stones[0]\\n        \\n        stones = [-s for s in stones]\\n        heapq.heapify(stones)\\n\\n        while len(stones) > 1:\\n            s1 = -(heapq.heappop(stones))\\n            s2 = -(heapq.heappop(stones))\\n\\n            if s1 != s2:\\n                heapq.heappush(stones, -(s1-s2))\\n        \\n        return -(stones[0]) if stones else 0\\n```\n```\\n/**\\n * @param {number[]} stones\\n * @return {number}\\n */\\nvar lastStoneWeight = function(stones) {\\n    const queue = new MaxPriorityQueue();\\n    \\n    for (stone of stones) queue.enqueue(stone)\\n    \\n    while (queue.size() > 1) {\\n        let first = queue.dequeue().element;\\n        let second = queue.dequeue().element;\\n        if (first !== second) queue.enqueue(first-second)\\n    }\\n    \\n    return queue.size() === 0 ? 0 : queue.front().element   \\n};\\n```\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        \\n        for (int stone : stones) {\\n            queue.offer(stone);\\n        }\\n        \\n        while (queue.size() > 1) {\\n            int first = queue.poll();\\n            int second = queue.poll();\\n            \\n            if (first != second) {\\n                queue.offer(first - second);\\n            }\\n        }\\n        \\n        return queue.size() == 0 ? 0 : queue.peek();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int, vector<int>> queue;\\n        int s1, s2;\\n        \\n        for(auto s1:stones)\\n            queue.push(s1);\\n        \\n        while(queue.size() != 1){\\n            s2 = queue.top();\\n            queue.pop();\\n            s1 = queue.top();\\n            queue.pop();\\n\\n            queue.push(s2-s1);\\n        }\\n        \\n        return queue.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448700,
                "title": "java-priority-queue-beats-98-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n  public int lastStoneWeight(int[] stones) {\\n    int x = 0, y = 0;\\n    var queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n    for (var stone : stones)\\n      queue.offer(stone);\\n    \\n    while (!queue.isEmpty()) {\\n      y = queue.poll();\\n      if (queue.isEmpty()) return y;\\n\\n      x = queue.poll();\\n      if (x != y) queue.offer(y - x);\\n    }\\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448500,
                "title": "c-easy-and-readable-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/8deee7e3-6578-4e6c-98c0-c9b2ceadefe8_1682281633.5742104.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {\\n        List<int> ls = stones.ToList();\\n        while (ls.Count > 1)\\n        {\\n            ls = ls.OrderByDescending(s => s).ToList();\\n            int a = ls[0];\\n            int b = ls[1];\\n            if (a == b)\\n            {\\n                ls.RemoveAt(1);\\n                ls.RemoveAt(0);\\n            }\\n            else\\n            {\\n                ls[1] = a - b;\\n                ls.RemoveAt(0);\\n            }\\n        }\\n        return ls.Count > 0 ? ls.First() : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376991,
                "title": "simple-solution-with-priority-queue",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```\\n\\n![87473a41-9c53-4e65-967e-15f92ebc9310_1677233624.267395.jpeg](https://assets.leetcode.com/users/images/00e56b65-7f40-4a62-9ee2-6d272278b5b0_1680578844.8665698.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n= stones.length;\\n        if(n==1) return stones[0];\\n        Queue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.offer(stones[i]);\\n        }\\n        while(pq.size()>1)\\n        {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            int diff = Math.max(a,b) - Math.min(a,b);\\n            if(diff>0)\\n                pq.offer(diff);\\n        }\\n        int weight = 0;\\n        if(!pq.isEmpty())\\n        {\\n            weight= pq.poll();\\n        }\\n        return weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233363,
                "title": "c-priority-queue",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }\\n            else\\n            {\\n                pq.push(y-x);\\n            }\\n        }\\n        if(!pq.empty()) return pq.top();\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int>pq (stones.begin(),stones.end());\\n        while(pq.size()>=2)\\n        {\\n            int y=pq.top();\\n            pq.pop();\\n            int x=pq.top();\\n            pq.pop();\\n            if(x==y)\\n            {\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3135101,
                "title": "0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int n=stones.length;\\n        while(n>1){\\n            Arrays.sort(stones);\\n            int x=stones[n-1]-stones[n-2];\\n            n--;\\n            stones[n-1]=x;\\n        }\\n        return stones[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094838,
                "title": "java-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue=new PriorityQueue<Integer>(Collections.reverseOrder()); \\n\\n        for(int i :stones){\\n            queue.add(i);\\n        } \\n\\n        while(!queue.isEmpty()){\\n            int x=queue.poll();\\n            if(queue.isEmpty()){\\n                return x;\\n            }\\n            int y=queue.poll();\\n\\n            queue.add(x-y);\\n        }\\n        return queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868752,
                "title": "beats-98-heapq-python",
                "content": "\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```\\n\\n**Upvote if you like the solution.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = [ -n for n in stones]\\n        heapq.heapify(stones)\\n        while len(stones) >=2:\\n            diff = heapq.heappop(stones) - heapq.heappop(stones)\\n            print(diff)\\n            if diff != 0:\\n                heapq.heappush(stones,diff)\\n        return -stones[0] if len(stones) == 1 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543347,
                "title": "simple-c-solution-while-loop-accepted",
                "content": "In the following code ...we are using a while loop when the size of array /vector is greater than 1..and sorting the vector at each itetation and then storing the value of the last two maximum elements in variable \\' a \\'. then we pop the last two elements of that array ..and append that value .and again in while loop we sort again and repeat the process\\nat last we return the only value in the vector which is the LAST STONE WEIGHT\\n\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones)\\n   {while(stones.size()>1){\\n       sort(stones.begin(),stones.end());\\n          int a=stones[stones.size()-1]-stones[stones.size()-2];\\n           stones.pop_back();\\n           stones.pop_back();\\n           stones.push_back(a);\\n       }\\n        return stones[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447318,
                "title": "python-easy-tc-o-n-sc-o-1-without-heap",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        while len(stones) >= 2:\\n            stones.sort(reverse = True)\\n            first = stones.pop(0)\\n            second = stones.pop(0)\\n            if first == second:\\n                continue\\n            else:\\n                stones.append(first-second)\\n        if stones:\\n            return stones[0]\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433222,
                "title": "java-easiest-solution-3ms-runtime-beginner-friendly-approach-high-runtime-easy-approch",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i: stones){\\n            arr.add(i);\\n        }\\n        while(arr.size() > 1){\\n            Collections.sort(arr);   \\n            int size = arr.size();\\n            int max = arr.get(size-1);\\n            int min = arr.get(size-2);\\n            arr.remove(size-1);\\n            arr.remove(size-2);\\n            if(min != max){\\n                max = max - min;\\n                arr.add(max);\\n            }\\n        }\\n        return arr.size()==1?arr.get(0):0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922172,
                "title": "easiest-simplest-explained-solution",
                "content": "**Priority Queue Implementation**\\n\\nMake a priority queue(binary max heap) which automatically arrange the element in sorted order.\\nThen pick the first element (which is maximum) and 2nd element(2nd max) , if both are equal we dont have to push anything , if not equal push difference of both in queue.\\nDo the above steps till queue size is equal to 1, then return last element. If queue becomes empty before reaching size==1 then return 0.\\n```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Please upvote , if u like my solution :)\\nint lastStoneWeight(vector<int>& nums) {\\n        priority_queue<int> q;\\n        int ans = 0;\\n        for(auto it:nums){\\n            q.push(it);\\n        }\\n        while(true){\\n            if(q.size()==1 || q.size()==0) break;\\n            int v1 = q.top(); q.pop();\\n            int v2 = q.top(); q.pop();\\n            if(v1 != v2){\\n                q.push(v1-v2);\\n            }\\n        }\\n        if(q.size()) ans = q.top();\\n        return ans;\\n    }\\n// Please upvote , if u like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921987,
                "title": "simple-java-solution-using-priority-queue",
                "content": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }\\n        while(!q.isEmpty()){\\n            int x=q.poll();\\n            int y=q.poll();\\n            if(x!=y){\\n                q.add(Math.abs(x-y));\\n            }\\n            if(q.size()==1){\\n                return q.poll();\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones.length==1)return stones[0];\\n        if(stones.length==2)return Math.abs(stones[0]-stones[1]);\\n        PriorityQueue<Integer> q=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int s:stones){\\n            q.add(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1921944,
                "title": "java-basic-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++){\\n\\t\\t//Add elements to the priority queue\\n            q.add(stones[i]);\\n        }\\n        int i = q.peek();\\n        int j = i;\\n        while(!q.isEmpty()){\\n            //Get max element\\n            i = q.poll();\\n            if(q.isEmpty()){\\n                break;\\n            }else{\\n                // get second max element\\n                j = q.poll();\\n            }\\n            // check if x != y\\n            if(i != j){\\n                // y = y - x\\n                i = i-j;\\n                q.add(i);\\n            }else if(i == j && q.isEmpty()){\\n                return 0;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921911,
                "title": "priority-queue-understandable-c-easy-solution",
                "content": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "int lastStoneWeight(vector<int>& stones) {\\n        \\n         priority_queue<int>pd(stones.begin(),stones.end());\\n        \\n        while(1){\\n            \\n            if(pd.size()==0)\\n                return 0;\\n            \\n            if(pd.size()==1){ \\n                return pd.top();\\n            \\n            \\n                pd.pop();}\\n            \\n            int t=pd.top();\\n              pd.pop();\\n            int m=pd.top();\\n               pd.pop();\\n            \\n            if(t!=m){ \\n                pd.push(abs(t-m));}\\n               \\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1921822,
                "title": "simple-easy-to-understand-beats-100-c-submissions",
                "content": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int lastStoneWeight(vector<int>& s) {\\n        int n = s.size();\\n        if(n == 1) return s[0];\\n        sort(s.begin(), s.end());\\n        int i = n-1;\\n        while(i >= 1){\\n            if(s[i-1] == s[i])\\n                i = i - 2;\\n            else{\\n                s[i-1] = s[i] - s[i-1];\\n                i = i -1;\\n                int j = i;\\n                while( j > 0 and s[j-1] > s[j] ){\\n                    swap( s[j-1] , s[j] );\\n                    j--;\\n                }\\n            }\\n        }\\n        if( i == 0 )\\n            return s[i];\\n        else \\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921283,
                "title": "c-faster-than-100-00",
                "content": "Runtime: 68 ms, faster than 100.00% of C# online submissions for Last Stone Weight.\\nMemory Usage: 39.3 MB, less than 5.42% of C# online submissions for Last Stone Weight.\\n\\n```\\npublic class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }\\n            else\\n            {\\n                list[1] = f-s;\\n                list.RemoveAt(0);\\n            }\\n        }\\n        return list.Count() > 0 ? list.First() : 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int LastStoneWeight(int[] stones) {        \\n        var list = stones.ToList();\\n        \\n        while(list.Count() >  1)\\n        {\\n            list = list.OrderByDescending(x=>x).ToList();\\n            int f = list[0], s = list[1];\\n            if(f == s)\\n            {\\n                list.RemoveAt(0);\\n                list.RemoveAt(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1921069,
                "title": "python-heap",
                "content": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        heapify(max_heap := [-s for s in stones])\\n        \\n        while len(max_heap) > 1:\\n            x = -heappop(max_heap)\\n            y = -heappop(max_heap)\\n            z = x - y\\n            heappush(max_heap, -z) if z else None\\n        \\n        return 0 if not max_heap else -max_heap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792538,
                "title": "java-not-the-best-solution-but-easy-to-understand-1ms-beats-98-48",
                "content": "Disclaimer: This is NOT the most efficient or best way to solve this problem, but in my opinion, it is the easiest way to understand. \\n\\nBasically, if the array is sorted, you want to compare the last two elements until the second to last element becomes zero (because the problem states that at most, there is one stone left).\\n\\nThen, you can just keep iterating through the array using a while loop, while comparing the last two values and changing them accordingly. You need to sort it each time so that the new largest values keep shifting to the right as the smaller stones are being \"destroyed\" aka set to zero. Then, when only one stone remains, you can return that value!\\n\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```\\n\\t\\nThis runs in 1ms and beats 98.48% of the people.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n        int len = stones.length;\\n        \\n        if (len == 1)\\n            return stones[0];\\n        \\n        while (stones[len-2] != 0)\\n        {\\n            int x = stones[len-2];\\n            int y = stones[len-1];\\n            \\n            if (x == y)\\n            {\\n                stones[len-1] = 0;\\n                stones[len-2] = 0;\\n            }\\n            else\\n            {\\n                stones[len-1] = y - x;\\n                stones[len-2] = 0;\\n            }\\n\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[len-1];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171395,
                "title": "c-detailed-explanation-easy-solution",
                "content": "Firstly,we will maintain a priority_queue(max-heap);\\nWHY?\\nBecause the max-heap will keep the heaviest stone by weight on top,as we are allowed to pick the two heaviest elements.\\nNow everytime we need to pick two largest stones,operate on them and then push the result(if non-zero i.e when the stones have unequal weights,we will have to insert the absolute value of the differences into the array).Hmm,so lets think of the data structure which will continuously keep the heaviest stone by weight on top,even after we insert something in the array???Did u guess it??\\nYes,thats a priority-queue,a max-heap by default in C++.\\nSo we will pick the top two elements,pop them out of the queue,if they are equal in weights,they will destroy themselves,so no need to insert a new element into the queue,\\nelse    we will insert the absolute difference of the two into the queue and still end up with the heaviest stone on top due to the nature of priority-queue.\\nTill when do we need to do this,till the priority-queue\\'s size is greater than 1.\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<stones.size();i++){\\n            pq.push(stones[i]);\\n        }\\n        while(pq.size()>1){\\n            int curr=pq.top();\\n            pq.pop();\\n            int curr2=pq.top();\\n            pq.pop();\\n            if(curr!=curr2){\\n                pq.push(abs(curr-curr2));\\n            }\\n        }\\n        return pq.empty()?0:pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115372,
                "title": "java-simple-and-easy-to-understand-solution-using-maxheap-1-ms-faster-than-91-16-with-comments",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        /*\\n          Intituation\\n          Here we are using maxHeap,\\n          property of maxHeao:- \\n           The root node has the maximum value.\\n        */\\n        \\n        //maxHeap\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        //store all stones, maxHeap\\n        for(int stone : stones) maxHeap.add(stone);\\n        \\n        //iterate till it size is greater than 1\\n        while(maxHeap.size() > 1){\\n            //get first two maximum stone\\n            int stone1 = maxHeap.remove();\\n            int stone2 = maxHeap.remove();\\n            \\n            //add the resultant smashed stone in maxHeap\\n            maxHeap.add(Math.abs(stone1 - stone2));\\n        }\\n        \\n        //last left stone\\n        return maxHeap.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841406,
                "title": "go-sorted-array-solution-0ms",
                "content": "We use two standard library functions:\\n\\n**sort.Ints():** sorts an integer slice\\n**sort.SearchInts():** returns the index in which the integer value should be inserted in a sorted slice. \\n\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc lastStoneWeight(stones []int) int {\\n\\tsort.Ints(stones)\\n\\n\\tfor len(stones) >= 2 {\\n\\t\\tstone := stones[len(stones)-1] - stones[len(stones)-2]\\n\\t\\tstones = stones[:len(stones)-2]\\n\\t\\tif stone > 0 {\\n\\t\\t\\t// push stone in sorted list\\n\\t\\t\\tidx := sort.SearchInts(stones, stone)\\n\\t\\t\\tif idx >= len(stones) {\\n\\t\\t\\t\\tstones = append(stones, stone)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstones = append(stones[:idx], append([]int{stone}, stones[idx:]...)...)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif len(stones) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\treturn stones[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638675,
                "title": "most-efficient-c-solution-using-multiset-0-ms-7-8-mb-100-100",
                "content": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "solutionTags": [],
                "code": "```\\nint lastStoneWeight(vector<int>& stones) {\\n        multiset<int, greater<int>> s;\\n        for(auto val: stones) s.insert(val);\\n        while(s.size()>=2){\\n            auto itr = s.begin();\\n            itr++;\\n            int temp = *s.begin()-*itr;\\n\\n            s.erase(s.begin());\\n            s.erase(s.begin());\\n            if(temp>0) s.insert(temp);\\n        }\\n        return *s.begin();\\n    }\\n\\t\\n\\t\\n\\tThe algorithm uses multiset which keeps the values sorted in descending order.\\n\\tThe substraction of first two values is kept in temp which is inserted if its value > 0.\\n\\tThe only value left at last is the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 622601,
                "title": "python-3-heap-max-heap",
                "content": "##### as the question it self said pick the largest 2 elements ,by changing the signs +ve to -ve a min heap will behave as a max heap and performing the operations \\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```\\n**hope who ever watches understand it :)**",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones=list(stones[i]*(-1) for i in range(len(stones)))\\n        heapq.heapify(stones)\\n        while len(stones)>1 :\\n            x=heapq.heappop(stones)\\n            y=heapq.heappop(stones)\\n            if x!=y :\\n                heapq.heappush(stones,x-y)\\n            print(stones)\\n        if len(stones)==0 :\\n            return 0\\n        return -(stones[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576555,
                "title": "java-solution-with-o-1-space-and-using-arrays-sort",
                "content": "Idea is to keep the max elements at the end all the time, and keep smashing the stones, till we are left with one at stones[stones.length - 1].\\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```\\n\\nAny feedback is appreciated :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length < 1) {\\n            return 0;\\n        }\\n        if(stones.length == 1) {\\n            return stones[0];\\n        }\\n        Arrays.sort(stones);\\n        int i = stones.length - 2;\\n        int j = stones.length - 1;\\n        while(i >= 0 && j >= 0 && stones[i] != 0) {\\n            stones[i] = stones[j] - stones[i];\\n            stones[j] = 0;\\n            Arrays.sort(stones);\\n        }\\n        return stones[j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576350,
                "title": "java-simple-and-clean-in-place-solution-beats-100-time",
                "content": "Since input constraints are certain and we only change values of 2 items in an already sorted array , there is no need to worry about sorting the array again in each iteration. \\n\\nThe main logic is that when you smash 2 stones both will lose weight at the amount of the lighter one. If 2 has the same weight, they both will become 0 weight as called destroyed. Here is the code \\n\\n```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```\\n\\nRuntime: 0 ms\\nMemory Usage: 37 MB",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int lastStoneWeight(int[] stones) {\\n        Arrays.sort(stones);\\n\\n        if (stones.length == 0){\\n            return 0;\\n        }\\n\\n        if(stones.length == 1){\\n            return stones[0];\\n        }\\n\\t\\t\\n\\t\\t//Smash until all stones smashed and there is no pair to smash (There will be only 1 stone or none)\\n        while (stones[stones.length - 2] > 0) {\\n            stones[stones.length - 1] -= stones[stones.length - 2];\\n            stones[stones.length - 2] -= stones[stones.length - 2];\\n            Arrays.sort(stones);\\n        }\\n        \\n        return stones[stones.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575344,
                "title": "java-priority-queue-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0){\\n            return 0;\\n        }\\n        \\n        Comparator<Integer> comparator = (o1, o2) -> o2-o1;\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(comparator);\\n        for(int stone : stones){\\n            queue.offer(stone);\\n        }\\n        \\n        while(queue.size() > 1){\\n            int num1 = queue.poll();\\n            int num2 = queue.poll();\\n            if(num1!= num2){\\n                queue.offer(num1-num2);\\n            }\\n        }\\n        \\n        return queue.isEmpty()?0: queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465787,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer>queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int item : stones)queue.add(item);\\n        while (queue.size()>1){\\n            int i1 = queue.poll();\\n            int i2 = queue.poll();\\n            if (i1!=i2)queue.add(Math.abs(i1-i2));\\n        }\\n        return queue.isEmpty()?0:queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426273,
                "title": "python-beginner-99-81-fast-100-memo-simple-sort-loop-explained",
                "content": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef lastStoneWeight(self, stones: List[int]) -> int:\\n\\tfor i in range(len(stones)-1):                # loop till the lastone remain\\n\\t\\tstones.sort()                             # smash the heaviest, the heaviest to end of the list\\n\\t\\tstones[-2] = abs(stones[-2] - stones[-1]) # y-x / 0 doent matter which one is bigger\\n\\t\\tstones.pop()                              # Destroy the stone \\n\\treturn stones[0]                              # return the only element in the list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 423312,
                "title": "python-100-100-simple-6-liner-with-max-heapq-o-nlogn",
                "content": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq as h\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        for i in range(len(stones)):stones[i]*=-1\\n        heapq.heapify(stones)\\n        while len(stones)>1:\\n            a, b = abs(h.heappop(stones)), abs(h.heappop(stones))\\n            if a!=b:    h.heappush(stones, b-a)\\n        return abs(stones[0]) if stones else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419535,
                "title": "java-implementation-using-max-heap-priority-queue-with-explanation",
                "content": "basic idea is to sort the array using a max heap(Priority Queue). Then we pop the largest two values and subtract(smash) them, then push the result back to the heap \\n\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int lastStoneWeight(int[] stones) {\\n    \\n    //max heap using priority queue    \\n    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> o2-o1);\\n    \\n    //sorting using max heap    \\n    for(int stone : stones)\\n    queue.offer(stone);   \\n    \\n    // remove the largest two values and subtract them. Add the result back to the heap\\n    while(queue.size()>1)\\n    queue.offer(queue.poll()-queue.poll());\\n        \\n    return queue.poll();    \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 396108,
                "title": "easy-c-solution-0ms-beats-100-using-priority-queue",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Last Stone Weight.\\nMemory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Last Stone Weight.\\n\\n```\\nint lastStoneWeight(vector<int>& stones) {\\n        \\n        priority_queue<int> pq;\\n        int n = stones.size();\\n        \\n        for(int i=0; i<n; i++)\\n            pq.push(stones[i]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n                return pq.top();\\n            \\n            int y = pq.top();\\n            pq.pop();\\n            \\n            int x = pq.top();\\n            pq.pop();\\n            \\n            if(x != y)\\n                pq.push(y - x);\\n        }\\n        \\n        if(pq.size() == 0)\\n            return 0;\\n        return pq.top();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 382436,
                "title": "priority-queue-with-javascript",
                "content": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tfunction PriorityQueue() {\\n\\t\\tthis.heap = [null];\\n\\t\\tthis.insert = function(value) {\\n\\t\\t\\tthis.heap.push(value);\\n\\t\\t\\tlet currentNodeIdx = this.heap.length - 1;\\n\\t\\t\\tlet currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\twhile (\\n\\t\\t\\t  this.heap[currentNodeParentIdx] &&\\n\\t\\t\\t  value > this.heap[currentNodeParentIdx]\\n\\t\\t\\t) {\\n\\t\\t\\t  let parent = this.heap[currentNodeParentIdx];\\n\\t\\t\\t  this.heap[currentNodeParentIdx] = value;\\n\\t\\t\\t  this.heap[currentNodeIdx] = parent;\\n\\t\\t\\t  currentNodeIdx = currentNodeParentIdx;\\n\\t\\t\\t  currentNodeParentIdx = Math.floor(currentNodeIdx / 2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n\\t\\tthis.remove = function() {\\n\\t\\t  if (this.heap.length < 3) {\\n\\t\\t\\tconst toReturn = this.heap.pop();\\n\\t\\t\\tthis.heap[0] = null;\\n\\t\\t\\treturn toReturn;\\n\\t\\t  }\\n\\t\\t  const toRemove = this.heap[1];\\n\\t\\t  this.heap[1] = this.heap.pop();\\n\\t\\t  let currentIdx = 1;\\n\\t\\t  let [left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t  let currentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  while (this.heap[currentChildIdx] && this.heap[currentIdx] < this.heap[currentChildIdx]) {\\n\\t\\t\\tlet currentNode = this.heap[currentIdx]\\n\\t\\t\\tlet currentChildNode = this.heap[currentChildIdx];\\n\\t\\t\\tthis.heap[currentChildIdx] = currentNode;\\n\\t\\t\\tthis.heap[currentIdx] = currentChildNode;\\n\\t\\t\\t currentIdx = currentChildIdx;\\n\\t\\t\\t[left, right] = [2*currentIdx, 2*currentIdx + 1];\\n\\t\\t\\tcurrentChildIdx = this.heap[right] && \\n\\t\\t\\t  this.heap[right] >= this.heap[left] ? right : left;\\n\\t\\t  }\\n\\t\\t  return toRemove;\\n\\t\\t}\\n\\t}\\n\\n\\tvar lastStoneWeight = function(stones) {\\n\\t\\tconst pq = new PriorityQueue();\\n\\t\\tfor(let i=0; i<stones.length; i++){\\n\\t\\t\\tpq.insert(stones[i]);\\n\\t\\t}\\n\\t\\twhile(pq.heap.length > 2){\\n\\t\\t\\tlet x = pq.remove();\\n\\t\\t\\tlet y = pq.remove();\\n\\t\\t\\tif(x != y){\\n\\t\\t\\t\\tlet max = Math.max(x, y);\\n\\t\\t\\t\\tlet min = Math.min(x, y);\\n\\t\\t\\t\\tlet z = max - min;\\n\\t\\t\\t\\tpq.insert(z);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pq.remove();\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 305460,
                "title": "python-use-heapq",
                "content": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        stones = [-1*i for i in stones]\\n        while len(stones)>1:\\n            heapq.heapify(stones)\\n            s1 = heapq.heappop(stones)\\n            s2 = heapq.heappop(stones)\\n            dlt = s1-s2\\n            if dlt != 0:\\n                heapq.heappush(stones,dlt)\\n        return -1*stones[0] if stones else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 300230,
                "title": "intuitive-c-solution-100-run-time-100-memory",
                "content": "```class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }\\n            else\\n            {\\n                stones[stones.size()-2] = stones[stones.size()-1] - stones[stones.size()-2];\\n                \\n                stones.erase(stones.begin() + stones.size()-1);                \\n            }\\n        }\\n        \\n        if(stones.size() == 1)\\n            return stones[0];\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {        \\n        while(stones.size() > 1)\\n        {\\n            sort(stones.begin(),stones.end());\\n            int y = stones[stones.size()-1];\\n            int x = stones[stones.size()-2];\\n            \\n            if(x == y)\\n            {\\n                stones.erase(stones.begin() + stones.size()-1);\\n                stones.erase(stones.begin() + stones.size()-1); // removes the two biggest numbers.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 297053,
                "title": "c-0ms-faster-than-100-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> qu(stones.begin(),stones.end());\\n        \\n        while(qu.size() != 0 && qu.size() != 1){\\n            int temp1 = qu.top();\\n            qu.pop();\\n            int temp2 = qu.top();\\n            qu.pop();\\n            \\n            if(temp2 != temp1) qu.push(temp1 - temp2); \\n        }\\n        \\n        if(!qu.size()) return 0;\\n        else return qu.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296057,
                "title": "1046-php-solutions-using-sort-and-priority-queue",
                "content": "The two solutions seem to be pretty equivalent speed-wise.\\n\\nHere\\'s a sort-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\\n\\nAnd here\\'s a priority queue-based solution.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        while (1 < count($stones)) {\\n            rsort($stones, SORT_NUMERIC);\\n            $outcome = array_shift($stones) - array_shift($stones);\\n            if (0 < $outcome) array_push($stones, $outcome);\\n        }\\n        return $stones[0] ?? 0;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer[] $stones\\n     * @return Integer\\n     */\\n    function lastStoneWeight($stones)\\n    {\\n        $pq = new SplPriorityQueue();\\n        $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\\n        foreach ($stones as $stone) $pq->insert($stone, $stone);\\n        while (1 < $pq->count()) {\\n            $outcome = $pq->extract() - $pq->extract();\\n            if (0 < $outcome) $pq->insert($outcome, $outcome);\\n        }\\n        return $pq->current() ?? 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295468,
                "title": "simple-c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) \\n    {\\n        for(int i=stones.size()-1; i>=1;)\\n        { \\n            sort(stones.begin(),stones.end());\\n            \\n            auto iNum           = stones[i];\\n            auto iM1Num         = stones[i-1];\\n            auto temp           = iNum - iM1Num;\\n\\n            stones.pop_back();\\n            stones.pop_back();\\n\\n             if(iNum  != iM1Num)\\n                stones.push_back(temp);\\n\\n            i = stones.size()-1;\\n        }\\n        return stones.size() > 0 ? stones[0] : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295449,
                "title": "python-solution-heapq-beats-100-time-and-memory-20-ms",
                "content": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def lastStoneWeight(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        heapq.heapify(stones)\\n        \\n        while len(stones) > 1:\\n            largest = heapq.nlargest(2, stones)\\n            diff = abs(largest[0] - largest[1])\\n    \\n            for item in largest:\\n                stones.remove(item)\\n                \\n            if diff > 0:\\n                heapq.heappush(stones, diff)\\n            \\n        if stones:\\n            return stones[0]\\n        return 0\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 295107,
                "title": "java-solution-using-priorityqueue",
                "content": "* Store all elements in the Priority Queue in decreasing order.\\n* Each time, poll 2 elements from the Priority Queue until its size is 1 and add the absolute difference between the 2 elements back to the queue.\\n* Return 0 if the PriorityQueue is empty or return the last element remaining in the PriorityQueue\\n```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int lastStoneWeight(int[] stones) {\\n        if(stones == null || stones.length == 0)\\n            return 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++)\\n            pq.add(stones[i]);\\n        while(pq.size() > 1) {\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            if(a - b != 0)\\n                pq.add(Math.abs(a - b));\\n        }\\n        if(pq.size() == 1)\\n            return pq.poll();\\n        else\\n            return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295005,
                "title": "java-simplest-easiest-priority-queue",
                "content": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int s : stones) {\\n            queue.add(s);\\n        }\\n        while (queue.size() > 1) {\\n            int weight1 = queue.poll();\\n            int weight2 = queue.poll();\\n            queue.add(weight1 - weight2);\\n        }\\n        return queue.size() == 0? 0 : queue.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294959,
                "title": "python-4-liner",
                "content": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones.sort()\\n        for _ in range(len(stones) - 1):\\n            bisect.insort(stones, stones.pop() - stones.pop())\\n        return stones[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294949,
                "title": "easy-and-concise-c",
                "content": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }\\n        return a[0];\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& a) {\\n        \\n        if(!a.size())\\n            return 0;\\n        int i,j = a[0];\\n        int n = a.size();\\n        \\n        while(a.size()>1)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[1]=a[0]-a[1];\\n            a.erase(a.begin());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4105275,
                "title": "beats-100-of-c-users",
                "content": "![image.png](https://assets.leetcode.com/users/images/606b6310-cfdc-4d82-9375-496a448765e6_1695990050.8100019.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Simple application on priority queues. \\n* All we just need to get the biggest two elements in the priority queue, and then check if both are equal, get rid of both of them, else, insert the new stone with the new value. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Create a priority queue of integers. \\n* insert all elements in it. \\n* while there are still some stones :\\n    * get the top element with biggest value. \\n    * remove it from the queue\\n    * if there are no more stones, return that stone. \\n    * else get the second stone. \\n    * check if both are equal, then just continue. \\n    * else check which is smaller, then subtract it from the bigger, then insert the result in the queue again.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* O(n + m), where n is the number of node, and m is the largest possible value. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n* O(n) for the priority queue. \\n# Code\\n```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define DPSolver ios_base ::sync_with_stdio(0), cin.tie(0), cout.tie(0);\\n\\nint lastStoneWeight(vector<int> &stones)\\n{\\n    DPSolver;\\n    priority_queue<int> pq;\\n    for (auto stone : stones)\\n        pq.push(stone);\\n\\n    while (pq.size())\\n    {\\n        int top1 = pq.top();\\n        pq.pop();\\n        if (pq.empty())\\n            return top1;\\n        int top2 = pq.top();\\n        pq.pop();\\n        if (top1 <= top2)\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top2 -= top1;\\n                pq.push(top2);\\n            }\\n        }\\n        else\\n        {\\n            if (top1 == top2)\\n                continue;\\n            else\\n            {\\n                top1 -= top2;\\n                pq.push(top1);\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3996347,
                "title": "c-solution-using-maxheap-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nput all the elements in a maxheap and keep comparing the top two elements until the heap is empty or only one element is left in heap.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> pq;\\n        for(int x: stones){\\n            pq.push(x);\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            int m = pq.top();\\n            pq.pop();\\n            if(pq.empty()) ans = m;\\n            if(!pq.empty()){\\n                if(m == pq.top()){\\n                    pq.pop();\\n                }\\n                else if(pq.top() < m){\\n                    m = m - pq.top();\\n                    pq.pop();\\n                    pq.push(m);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935461,
                "title": "0ms-solution-c-maxheap",
                "content": "# Intuition\\nThe problem asks us to repeatedly smash the two largest stones until there is either one stone left or no stones left. To do this efficiently, we can use a max-heap (priority_queue) to always select the two largest stones for smashing.\\n\\n# Approach\\n1. Initialize a max-heap (priority_queue) called maxheap.\\n2. Add all the stones to the maxheap.\\n3. Continue the following steps until there is either one stone or no stones left:\\n   a. Check if the size of maxheap is 1. If so, return the value of the last remaining stone as it is the final result.\\n   b. Check if the size of maxheap is 0. If so, return 0 because all stones have been smashed and there are no stones left.\\n   c. Pop the first largest stone (maxheap.top()) from maxheap and store it in the variable \\'first\\'.\\n   d. Pop the second largest stone (maxheap.top()) from maxheap and store it in the variable \\'second\\'.\\n   e. Check if \\'first\\' is not equal to \\'second\\'. If they are not equal, it means they can be smashed into a smaller stone.\\n   f. Push the difference between \\'first\\' and \\'second\\' back into maxheap to represent the smashed stone.\\n4. Return the result obtained from step 3a.\\n\\n# Complexity\\n- Time complexity:\\n  - Inserting all n stones into the maxheap initially takes O(n * log(n)) time.\\n  - In each iteration, we perform constant time operations until the size of maxheap reduces to 1 or 0. Therefore, the overall time complexity is O(n * log(n)) where n is the number of stones.\\n- Space complexity:\\n  - The space complexity is O(n) to store the maxheap, where n is the number of stones.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n        priority_queue<int> maxheap;\\n        for(auto elm: stones)\\n        {\\n            maxheap.push(elm);\\n        }\\n        while(true)\\n        {\\n            if(maxheap.size()==1)\\n            return maxheap.top();\\n            if(maxheap.size()==0)\\n            return 0;\\n            int first=maxheap.top();\\n            maxheap.pop();\\n            int second= maxheap.top();\\n            maxheap.pop();\\n            if(first!=second)\\n            {\\n                maxheap.push((first-second));\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478482,
                "title": "python-simple-clean-solution-using-python-library",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        s = SortedList(stones)\\n        while len(s) > 1:\\n            y = s.pop()\\n            x = s.pop()\\n\\n            if x != y:\\n                y -= x\\n                s.add(y)\\n        if s:\\n            return s[0]\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478283,
                "title": "0ms-runtime-c-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& A) {\\n          priority_queue<int> pq(begin(A), end(A));\\n        while (pq.size() > 1) {\\n            int x = pq.top(); pq.pop();\\n            int y = pq.top(); pq.pop();\\n            if (x > y) pq.push(x - y);\\n        }\\n        return pq.empty() ? 0 : pq.top();\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451681,
                "title": "easy-c-solution-beats-100-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n            /* please upvote if found solution helpful \\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       priority_queue<int>sequence(stones.begin(),stones.end());\\n\\n       //using priority queue to get access to heighest weight values direcly\\n\\n       while(sequence.size()>1){\\n           int a=sequence.top();\\n           sequence.pop();\\n           int b=sequence.top();\\n           sequence.pop();\\n\\n           //now we have got the top two values\\n           //now we want to reduce their weight if they are not equal\\n           if(a!=b){\\n               sequence.push(abs(a-b));\\n           }\\n       }\\n       return sequence.empty() ?  0 :  sequence.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451440,
                "title": "easy-solution-in-c-simple-using-loop-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n5 5\\n[1 1 2 4 7 8] \\n[1 1 2 4 0 1]  \\n\\n4 5\\n[0 1 1 1 2 4] \\n[0 1 1 1 0 2]\\n\\n3 5\\n[0 0 1 1 1 2]\\n[0 0 1 1 0 1]  \\n\\n2 5\\n[0 0 0 1 1 1 ]\\n[0 0 0 1 0 0]\\n\\n1 5\\n[0 0 0 0 0 1]\\n[0 0 0 0 0 1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(vector<int>& stones) {\\n       int i=stones.size()-1;\\n       int j=stones.size()-1;\\n       while(j>0){\\n            sort(stones.begin(),stones.end());\\n            if(stones[i]==stones[i-1]){\\n                stones[i]=0;\\n                stones[i-1]=0;\\n            }\\n            else{\\n                stones[i]=stones[i]-stones[i-1];\\n                stones[i-1]=0;\\n            }\\n            j--;\\n       }\\n        int k=stones.size()-1;\\n        return stones[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451266,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            list.add(stones[i]);\\n        }\\n\\n        while (list.size() > 1) {\\n            Collections.sort(list);\\n            int x = list.get(list.size() - 2);\\n            int y = list.get(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            list.remove(list.size() - 1);\\n            if (x != y) {\\n                list.add(y - x);\\n            }\\n        }\\n\\n        return list.isEmpty() ? 0 : list.get(0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450669,
                "title": "java-priorityqueue-1-ms",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( nlog(n) )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        int res=0;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: stones){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty()){\\n            if(pq.size()==1){\\n                return pq.poll();\\n            }\\n            int f=pq.poll();\\n            int s=pq.poll();\\n            if(Math.abs(f-s)!=0){\\n                pq.add(Math.abs(f-s));\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449920,
                "title": "most-optimised-solution-with-detailed-explanation-clean-code",
                "content": "\\n\\n# Approach\\nWe are given an array of integers stones where stones[i] is the weight of the ith stone. We need to play a game with the stones, where on each turn, we choose the heaviest two stones and smash them together. The result of this smash is:\\n\\n- If x == y, both stones are destroyed.\\n- If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\\nThe game continues until there is at most one stone left, and we need to return the weight of the last remaining stone. If there are no stones left, we need to return 0.\\n\\nTo solve this problem, we can simulate the game using a priority queue (heap) in C++. The priority queue can be used to keep track of the heaviest stones.\\n\\nWe can start by inserting all the stones into the priority queue. The priority queue will automatically sort the stones in descending order based on their weight. Therefore, the heaviest stone will be at the front of the queue.\\n\\nIn each turn of the game, we can remove the two heaviest stones from the priority queue using the top() method. We can then smash the stones together according to the rules of the game and insert the resulting stone (if any) back into the priority queue using the push() method.\\n\\nWe can continue this process until there is only one stone left in the priority queue, which will be the result of the game. We can then return the weight of this stone using the top() method.\\n\\nIf there are no stones left in the priority queue, we need to return 0.\\n\\nHere is the step-by-step process of the algorithm:\\n\\n1. Create a priority queue pq and insert all the stones into it.\\n2. While pq has more than 1 stone:\\n- Remove the two heaviest stones y and x from pq.\\n- If x != y, calculate the difference y - x and insert it back into pq.\\n3. Return the weight of the last remaining stone in pq (using the top() method) if there is one, otherwise return 0.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lastStoneWeight(std::vector<int>& stones) {\\n        std::sort(stones.rbegin(), stones.rend());\\n        while (stones.size() > 1) {\\n            int y = stones[0]; \\n            int x = stones[1];\\n            stones.erase(stones.begin(), stones.begin()+2);\\n            if (x != y) {\\n                stones.insert(std::upper_bound(stones.begin(), stones.end(), y-x, std::greater<int>()), y-x);\\n            }\\n        }\\n        return stones.empty() ? 0 : stones[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449625,
                "title": "simple-priorityqueue-question-java-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int lastStoneWeight(int[] stones) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i = 0; i < stones.length; i++) q.offer(stones[i]);\\n        while(q.size() > 1) {\\n            int a = q.poll();\\n            int b = q.poll();\\n            q.offer(a-b);\\n        }\\n        if(q.isEmpty()) return 0;\\n        else return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872390,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1828053,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872557,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1566055,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872394,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576558,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1575436,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872441,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872758,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1872432,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "So storm is over after series of \\'Hard\\' problems :-)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@phamtuan199911](/phamtuan199911) true!!"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "It\\'s just the calm before another storms"
                    },
                    {
                        "username": "preeyankk",
                        "content": "Definitely looks like an easy problem :D"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Upvote if you like Mondays (Easy problem days)."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/last-stone-weight/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Array-Based Simulation\n\n  \n**Approach 2:** Sorted Array-Based Simulation\n\n  \n**Approach 3:** Heap-Based Simulation\n\n  \n**Approach 4:** Bucket Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Still mind is upside-down from yesterday\\'s problem"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "[@raviraushanweb](/raviraushanweb) plz share ur recurrence code"
                    },
                    {
                        "username": "raviraushanweb",
                        "content": "That was a dynamic programming question. I solved quickly using recursion but to come up with TLE free solution took hours "
                    },
                    {
                        "username": "hkg3468",
                        "content": "![image](https://assets.leetcode.com/users/images/bcac7955-f4b5-49e6-b8e5-11278b172245_1648561587.3895273.png)\\n"
                    },
                    {
                        "username": "_gainsville",
                        "content": "You don\\'t need `!max_heap.isEmpty()` because if the size is not 1, it is for sure not empty."
                    },
                    {
                        "username": "mbrav",
                        "content": "Simple Python solution. Not efficient at all since we sort the array on every loop. \\n\\n```\\nclass Solution:\\n    def lastStoneWeight(self, stones: List[int]) -> int:\\n        stones = sorted(stones, reverse=True)\\n        while len(stones) > 1:\\n            if stones[0] == stones[1]:\\n                del stones[0]\\n                del stones[0]\\n            else:\\n                new_stone = max(stones[0], stones[1]) - min(stones[0], stones[1])\\n                del stones[0]\\n                stones[0] = new_stone\\n            stones = sorted(stones, reverse=True)\\n        return stones.pop() if len(stones) else 0\\n```"
                    },
                    {
                        "username": "rujustas",
                        "content": "while(max_heap.size() > 1) would be shorter"
                    },
                    {
                        "username": "roma-glushko",
                        "content": "Really enjoyed solving this problem via implementing a custom heap. \\nDecided that heaps deserve a bit of place in my technical notes, so I wrote a little blog post about this data structure:\\n\\nhttps://www.romaglushko.com/blog/heapify/\\n\\nI hope this helps someone \\uD83D\\uDE4C\\n\\nHappy interview cracking everyone \\uD83D\\uDC4B"
                    },
                    {
                        "username": "renetchi",
                        "content": "So the trend is to start the week with easy mode, then end the week with hard mode"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "Use max-heap. \\nAfter insert all element in max heap\\npop out two element every time\\n[8, 7,4,2,1,1] : 8 ! = 7 y = (8-7) = 1\\nInsert 1 into heap\\n[4, 2,1,1,1] : 4 ! = 2 y = (4-2) = 2\\nInsert into heap 2 \\n[2, 1 , 1,1] 2 ! = 1 y = (2-1) = 1\\nInsert into heap 1\\n[1 1,1 ] 1 == 1 don\\'t insert\\n[1]  length of heap is one return heap\\n\\n\\nI hope , it will help someone. "
                    },
                    {
                        "username": "anwendeng",
                        "content": "C++ solution using priority_queue can be done!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "beats 100% https://leetcode.com/problems/last-stone-weight/solutions/3448838/beats-100-easy-c-solution-using-priority-queue/"
                    }
                ]
            },
            {
                "id": 1576588,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1992059,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1940250,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872810,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872776,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872771,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872765,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872538,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872524,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            },
            {
                "id": 1872450,
                "content": [
                    {
                        "username": "joshuako",
                        "content": "we know there\\'s many ways to destroy the stones.\\n\\nlets say stones are [8, 7, 1]\\nif we destroy 8 with 7 first: [8-7, 1] -> [1, 1] -> [0]\\nif we destroy 7 with 1 first: [8, 7-1] -> [8, 6] -> [2]\\n\\nthe priority queue (heap) solution relies heavily on the knowledge that we must destroy the biggest stone first (with the next biggest stone) and repeat it exhaustively.\\n\\nanybody can help enlighten me on this?"
                    },
                    {
                        "username": "lampuiho",
                        "content": "It\\'s part of the question that you must destroy the largest 2 stones at each turn."
                    },
                    {
                        "username": "viveksharma14",
                        "content": "It\\'s intuitive only if you know heap , so first learn heap then solve it.\\nIf u know heap and wondering how youll solve it then tip is \\nreverse sort heap and all elements in heap then remove diff btwn greatest 2 and add in heap keep on doing it until while(heap.size()>1) this condition fails"
                    },
                    {
                        "username": "mochiball",
                        "content": "Finally an easy problem !!!!"
                    },
                    {
                        "username": "gehlotyash7",
                        "content": "Code not running\n\ndef stone(l1):\n\n    while len(l1)>1:\n        l2 = sorted(l1, reverse=True)\n\n        if l2[0]==l2[1]:\n            del l2[:1]\n\n        else:\n            y = l2[0]\n            x = l2[1]\n            z = y-x\n            del l2[:2]\n            l2.append(z)\n        l1=l2\n    return l1"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "No need to return the list. Just return the only element in the list and 0 if not. You can also have the if statement as \\'del l2[:2]\\'."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "hard => hard => hard => easy \\uD83D\\uDE17\\uD83D\\uDE17"
                    },
                    {
                        "username": "palak-agg",
                        "content": "This question made me remember Huffman Encoding :|"
                    },
                    {
                        "username": "palak-agg",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) Because there also we consecutively pick the minimum 2 elements, add them to form a new node till we cover all the nodes. So, I found a bit similarity between the two questions. "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "How??"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What is expected complexity here?"
                    },
                    {
                        "username": "brinuke",
                        "content": "$O(n^2)$"
                    },
                    {
                        "username": "mdakram28",
                        "content": "This problem looks like a medium/hard problem but it is easy. IDK why i spent so much time thinking of a solution better than `Nlog(N)`."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Discount after 2 hard problems? 😂"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Don\\'t overthink, it\\'s easy. I just brute-forced my way through."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Using a heap is not overthinking, it\\'s just thinking"
                    }
                ]
            }
        ]
    }
]