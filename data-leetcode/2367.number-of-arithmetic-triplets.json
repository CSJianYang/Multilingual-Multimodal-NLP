[
    {
        "title": "Number of Arithmetic Triplets",
        "question_content": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\n\ti < j < k,\n\tnums[j] - nums[i] == diff, and\n\tnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.\n&nbsp;\nExample 1:\n\nInput: nums = [0,1,4,6,7,10], diff = 3\nOutput: 2\nExplanation:\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \n\nExample 2:\n\nInput: nums = [4,5,6,7,8,9], diff = 2\nOutput: 2\nExplanation:\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 200\n\t0 <= nums[i] <= 200\n\t1 <= diff <= 50\n\tnums is strictly increasing.",
        "solutions": [
            {
                "id": 2390637,
                "title": "check-n-diff-and-n-2-diff",
                "content": "**C++**\\n```cpp\\nint arithmeticTriplets(vector<int>& nums, int diff) {\\n    int cnt[201] = {}, res = 0;\\n    for (auto n : nums) {\\n        if (n >= 2 * diff)\\n            res += cnt[n - diff] && cnt[n - 2 * diff];\\n        cnt[n] = true;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint arithmeticTriplets(vector<int>& nums, int diff) {\\n    int cnt[201] = {}, res = 0;\\n    for (auto n : nums) {\\n        if (n >= 2 * diff)\\n            res += cnt[n - diff] && cnt[n - 2 * diff];\\n        cnt[n] = true;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392136,
                "title": "c-easy-hashmap-solution-with-explanation",
                "content": "# Hashing Technique.\\n\\n**O(N) space and O(N) Time :**\\n\\n1. Simply first store all the elements of array in a map or a set.\\n2. Now again traverse the array and see for every element say \\'x\\', if there are two more elements present in map i.e x+diff and x-diff.\\n3. If present then increment the count by 1.\\n4. Return the count variable.\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,bool> mp;\\n        \\n        // Mark every elem presence in map.\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        \\n        \\n        // For every element say \\'elm\\' check if there exist both numbers, (elm + diff) and (elm - diff) inside map. If yes then increment cnt\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        \\n\\t\\t\\n\\t\\t// Happy return :)\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,bool> mp;\\n        \\n        // Mark every elem presence in map.\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        \\n        \\n        // For every element say \\'elm\\' check if there exist both numbers, (elm + diff) and (elm - diff) inside map. If yes then increment cnt\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        \\n\\t\\t\\n\\t\\t// Happy return :)\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390635,
                "title": "java-python-3-hashset-o-n-codes-w-analysis",
                "content": "Credit to **@dms6** for the improvement from 2 pass to 1 pass.\\n\\n```java\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int cnt = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num - diff) && seen.contains(num - diff * 2)) {\\n                ++cnt;\\n            }\\n            seen.add(num);\\n        }\\n        return cnt;\\n    }\\n```\\n\\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = set()\\n        cnt = 0\\n        for num in nums:\\n            if num - diff in seen and num - diff * 2 in seen:\\n                cnt += 1\\n            seen.add(num)\\n        return cnt\\n```\\n\\nMake the above shorter: - Credit to **@SunnyvaleCA**\\n\\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = set(nums)\\n        return sum(num - diff in seen and num - diff * 2 in seen for num in seen)\\n```\\n\\nOr 1 liner (time `O(n ^ 2)`:\\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum( n+diff in nums and n+diff*2 in nums for n in nums )\\n```\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int cnt = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num - diff) && seen.contains(num - diff * 2)) {\\n                ++cnt;\\n            }\\n            seen.add(num);\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = set()\\n        cnt = 0\\n        for num in nums:\\n            if num - diff in seen and num - diff * 2 in seen:\\n                cnt += 1\\n            seen.add(num)\\n        return cnt\\n```\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = set(nums)\\n        return sum(num - diff in seen and num - diff * 2 in seen for num in seen)\\n```\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum( n+diff in nums and n+diff*2 in nums for n in nums )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2395275,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390585,
                "title": "java-easy-hashset",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for( int num : nums){\\n            set.add(num);\\n        }\\n       \\n        int ans = 0;\\n            for( int num : nums){\\n                if(( set.contains(num + diff ) && set.contains(num + 2 * diff) ) ){\\n                    ans++;\\n                    \\n                }\\n            }\\n        \\n        return ans;\\n            \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for( int num : nums){\\n            set.add(num);\\n        }\\n       \\n        int ans = 0;\\n            for( int num : nums){\\n                if(( set.contains(num + diff ) && set.contains(num + 2 * diff) ) ){\\n                    ans++;\\n                    \\n                }\\n            }\\n        \\n        return ans;\\n            \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390787,
                "title": "a-generic-dynamic-programming-a-i-diff-intuition-updated",
                "content": "**This Approach even works if the array is unsorted or elements are negative or diff is negative**\\n\\n**Similar to [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/).**\\nWe simply save the value for every we have seen till now in a array and our count will be `cnt[A[i]]= cnt[A[i]-diff]+1` which is typical Dynamic Programming,\\nthat we exactly do in **Longest Increasing subsequence.**\\n\\nOn the way get count for `A[i]-diff` Value and increase result if sequence length till this number is `>=3`.\\n\\n# This Question is a simpler version of this:\\n+ [1027. Longest Arithmetic Subsequence](https://leetcode.com/problems/longest-arithmetic-subsequence/)\\n\\n**Intuition**:\\n\\nWe compute answer on the way. But how??\\nBasically lets say the sequence is `[a,b,c] is a AP` with `diff of k`.\\nSo lets say we are at **b** element , so which element should be pick actually which will make **AP** with **b**???\\nIf we know the **diff** , then its easy for us to predict the number we are looking for, and that number is **b-diff**.\\n\\n# So we simply do this for every element we encounter and if the AP length till that element>=3 , then we will get an extra pair.\\n\\n**Talking about unique Pairs**:\\nWe always get unique pairs by default. \\nBecause if we considered indices [1,2,3], then we are not even considering its count again in the process. \\n# C++     \\n\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n        int dp[201]{};\\n        int res=0;\\n        for(auto i:nums){ \\n\\t\\t\\tdp[i]= i>=diff? dp[i-diff]+1 : 1;\\n            if(dp[i]>=3) res++; \\n        }\\n        return res;\\n    }\\n\\t\\n# Using Hashmap\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n       unordered_map<int,int> dp;\\n       int res=0;\\n       for(auto i:nums) \\n\\t       if((dp[i]=dp[i-diff]+1)>=3) res++;\\n       return res;\\n    }\\n**Worst Time** - O(`200`)\\n**Worst Space** - O(`201`)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "**This Approach even works if the array is unsorted or elements are negative or diff is negative**\\n\\n**Similar to [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/).**\\nWe simply save the value for every we have seen till now in a array and our count will be `cnt[A[i]]= cnt[A[i]-diff]+1` which is typical Dynamic Programming,\\nthat we exactly do in **Longest Increasing subsequence.**\\n\\nOn the way get count for `A[i]-diff` Value and increase result if sequence length till this number is `>=3`.\\n\\n# This Question is a simpler version of this:\\n+ [1027. Longest Arithmetic Subsequence](https://leetcode.com/problems/longest-arithmetic-subsequence/)\\n\\n**Intuition**:\\n\\nWe compute answer on the way. But how??\\nBasically lets say the sequence is `[a,b,c] is a AP` with `diff of k`.\\nSo lets say we are at **b** element , so which element should be pick actually which will make **AP** with **b**???\\nIf we know the **diff** , then its easy for us to predict the number we are looking for, and that number is **b-diff**.\\n\\n# So we simply do this for every element we encounter and if the AP length till that element>=3 , then we will get an extra pair.\\n\\n**Talking about unique Pairs**:\\nWe always get unique pairs by default. \\nBecause if we considered indices [1,2,3], then we are not even considering its count again in the process. \\n# C++     \\n\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n        int dp[201]{};\\n        int res=0;\\n        for(auto i:nums){ \\n\\t\\t\\tdp[i]= i>=diff? dp[i-diff]+1 : 1;\\n            if(dp[i]>=3) res++; \\n        }\\n        return res;\\n    }\\n\\t\\n# Using Hashmap\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n       unordered_map<int,int> dp;\\n       int res=0;\\n       for(auto i:nums) \\n\\t       if((dp[i]=dp[i-diff]+1)>=3) res++;\\n       return res;\\n    }\\n**Worst Time** - O(`200`)\\n**Worst Space** - O(`201`)",
                "codeTag": "Unknown"
            },
            {
                "id": 2464020,
                "title": "beginner-friendly-python-javascript-java-solutions",
                "content": "\\n```python []\\nclass Solution(object):\\n    def arithmeticTriplets(self, nums, diff):\\n        count = 0\\n        for num in nums:\\n            if num + diff in nums and num + diff*2 in nums:\\n                count += 1\\n        return count\\n```\\n\\n```javascript []\\nvar arithmeticTriplets = function(nums, diff) {\\n    let count = 0\\n    for(let num of nums){\\n        if(nums.includes(num + diff) && nums.includes(num + diff*2)){\\n            count++\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n```java []\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set set = new HashSet();\\n        for(int num: nums)    set.add(num);\\n        int count = 0;\\n        for(int num : nums){\\n            if(set.contains(num + diff) && set.contains(num + diff*2)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution(object):\\n    def arithmeticTriplets(self, nums, diff):\\n        count = 0\\n        for num in nums:\\n            if num + diff in nums and num + diff*2 in nums:\\n                count += 1\\n        return count\\n```\n```javascript []\\nvar arithmeticTriplets = function(nums, diff) {\\n    let count = 0\\n    for(let num of nums){\\n        if(nums.includes(num + diff) && nums.includes(num + diff*2)){\\n            count++\\n        }\\n    }\\n    return count;\\n};\\n```\n```java []\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set set = new HashSet();\\n        for(int num: nums)    set.add(num);\\n        int count = 0;\\n        for(int num : nums){\\n            if(set.contains(num + diff) && set.contains(num + diff*2)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390567,
                "title": "brute-force-3-loop-s-optimized-o-n",
                "content": "**Contest Submission**\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[j]-nums[i])==diff && (nums[k]-nums[j])==diff){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**After Contest Thinking**\\nhere constrains are for nums[i] is 0 to 200 inclusive so let\\'s create array of 201 size and mark it one in arr if it\\'s present in nums.\\nthen traverse nums and check if `nums[i] - diff >= 0 and nums[i] + diff <= 200` and also check for `nums[i] - diff & nums[i] + diff` is present in nums by checking marking in array.\\nAnd `i < j < k` always satisfy because given nums is in sorted order.\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int arr[201] = {0};\\n        for(auto it : nums){\\n            arr[it]++;\\n        }\\n        int ans=0;\\n        for(auto it : nums){\\n            if(it-diff>=0 && it+diff<=200 && arr[it-diff] && arr[it+diff]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nTime Complexity : O(N+N) ~ O(N)\\nSpace Complexity : O(N)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[j]-nums[i])==diff && (nums[k]-nums[j])==diff){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int arr[201] = {0};\\n        for(auto it : nums){\\n            arr[it]++;\\n        }\\n        int ans=0;\\n        for(auto it : nums){\\n            if(it-diff>=0 && it+diff<=200 && arr[it-diff] && arr[it+diff]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime Complexity : O(N+N) ~ O(N)\\nSpace Complexity : O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390495,
                "title": "c-using-map-with-explanation-very-easy-and-simple-to-understand-solution",
                "content": "<b> Up Vote if you like the solution\\n# Check for the nums[i] -diff and nums[i] - 2*diff, if these are present in the map or not. If present count a triplet. Then strore the current number in map for future use.\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto i: nums){\\n            if(mp.find(i-diff) != mp.end() && mp.find(i-2*diff) != mp.end()) ans = ans + mp[i-diff]* mp[i-2*diff];\\n            mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto i: nums){\\n            if(mp.find(i-diff) != mp.end() && mp.find(i-2*diff) != mp.end()) ans = ans + mp[i-diff]* mp[i-2*diff];\\n            mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416116,
                "title": "python-easy-solution",
                "content": "```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        ans = 0\\n        for i in range(len(nums)):  # nums = [0,1,4,6,7,10],  diff = 3\\n            j = nums[i] - diff  # 4 - 3 = 1 (when i ==2)\\n            k = diff + nums[i]  # 3 + 4 = 7 (when i ==2)\\n            if j in nums and k in nums: # 1 and 7 is there in the list\\n                ans +=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        ans = 0\\n        for i in range(len(nums)):  # nums = [0,1,4,6,7,10],  diff = 3\\n            j = nums[i] - diff  # 4 - 3 = 1 (when i ==2)\\n            k = diff + nums[i]  # 3 + 4 = 7 (when i ==2)\\n            if j in nums and k in nums: # 1 and 7 is there in the list\\n                ans +=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2441623,
                "title": "easy-hashmap-solution-and-got-54ms",
                "content": "```\\nvar arithmeticTriplets = function(nums, diff) {\\n    \\n    let hash = new Map();\\n    let count = 0;\\n\\n    for(let i=0; i<nums.length; i++){\\n        let temp = nums[i] - diff;\\n        \\n        if(hash.has(temp) && hash.has(temp - diff)){\\n            count++;\\n        }\\n        hash.set(nums[i] , \"Hard choices easy life, Easy choices hard life.\");\\n    }\\n    \\n    return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/0409357d-240c-4fc2-b343-a5d9e2c0ac12_1660781858.852448.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arithmeticTriplets = function(nums, diff) {\\n    \\n    let hash = new Map();\\n    let count = 0;\\n\\n    for(let i=0; i<nums.length; i++){\\n        let temp = nums[i] - diff;\\n        \\n        if(hash.has(temp) && hash.has(temp - diff)){\\n            count++;\\n        }\\n        hash.set(nums[i] , \"Hard choices easy life, Easy choices hard life.\");\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391418,
                "title": "java-c-brute-force-to-set",
                "content": "The brute force method is pretty fast here, but using a set is preferable\\n\\n### Java Brute Force\\n```java\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\n### C++ Brute Force\\n```\\nint arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            for (int j = i + 1; j < nums.size() - 1; j++) {\\n                for (int k = j + 1; k < nums.size(); k++) {\\n                    if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\n### Java Set\\n\\n```\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num - diff) && set.contains(num - diff * 2))\\n                count++;\\n            \\n            set.add(num);\\n        }\\n        return count;\\n    }\\n```\\n\\n### C++ Set\\n\\n```\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count = 0;\\n        set<int> set;\\n        for (int num : nums) {\\n            if (set.find(num - diff) != set.end() && set.find(num - diff * 2) != set.end())\\n                count++;\\n            \\n            set.insert(num);\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Ordered Set"
                ],
                "code": "```java\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\nint arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count = 0;\\n\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            for (int j = i + 1; j < nums.size() - 1; j++) {\\n                for (int k = j + 1; k < nums.size(); k++) {\\n                    if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num - diff) && set.contains(num - diff * 2))\\n                count++;\\n            \\n            set.add(num);\\n        }\\n        return count;\\n    }\\n```\n```\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count = 0;\\n        set<int> set;\\n        for (int num : nums) {\\n            if (set.find(num - diff) != set.end() && set.find(num - diff * 2) != set.end())\\n                count++;\\n            \\n            set.insert(num);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643436,
                "title": "easy-java-solution-straight-forward-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length -2 ; i++){\\n            for(int j = i+1; j < nums.length -1; j ++){\\n                for(int k = j+1; k < nums.length ; k ++){\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length -2 ; i++){\\n            for(int j = i+1; j < nums.length -1; j ++){\\n                for(int k = j+1; k < nums.length ; k ++){\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550583,
                "title": "beats-99-3-java-solution-binary-search-map-3-pointers",
                "content": "# 3 Different JAVA Solutions \\n\\n**Solution Using Binary Search (Time Complexity : O(nlog(n)) , Space Complexity : O(1))**\\n```\\nclass Solution {\\n    public static boolean BinarySearch(int[] arr, int key){\\n        int low = 0 , high = arr.length-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(arr[mid]==key) return true;\\n            else if(arr[mid]<key) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return false;\\n    }\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i=0;i<nums.length-2;i++){\\n            boolean next = BinarySearch(nums,nums[i]+diff);\\n            boolean nextnext = BinarySearch(nums,nums[i]+2*diff);\\n            if(next && nextnext) count++;\\n        }\\n        return count;\\n    }\\n    \\n    // Time Complexity : O(nlog(n))\\n    // Space Complexity : O(1)\\n}\\n```\\n\\n**Solution Using Map (Time Complexity : O(n) , Space Complexity : O(n))**\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) map.put(nums[i],i);\\n        for(int k : nums) count += (map.containsKey(k+diff) && map.containsKey(k+2*diff)) ? 1 : 0;\\n        return count;\\n    }\\n    \\n    // Time Complexity : O(log(n))\\n    // Space Complexity : O(n)\\n\\n}\\n```\\n\\n**Solution Using 3-Pointers (Time Complexity : O(n) , Space Complexity : O(1))**\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int pointer1 =  0 , pointer2 = 1 , pointer3 = 2;\\n        while(pointer3 < nums.length){\\n            int compare = nums[pointer2]-nums[pointer1];\\n            if(compare==diff){\\n                compare = nums[pointer3]-nums[pointer2];\\n                if(compare==diff){\\n                    pointer1++;\\n                    pointer2++;\\n                    pointer3++;\\n                    count++;\\n                }\\n                else if(compare<diff) pointer3++;\\n                else{\\n                    pointer1++;pointer2++;\\n                    pointer3 = Math.max(pointer3,pointer2+1);\\n                }\\n            }\\n            else if(compare<diff){\\n                pointer2++;\\n                pointer3 = Math.max(pointer3,pointer2+1);\\n            }\\n            else{\\n                pointer1++;\\n                pointer2 = Math.max(pointer2,pointer1+1);\\n                pointer3 = Math.max(pointer3,pointer2+1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean BinarySearch(int[] arr, int key){\\n        int low = 0 , high = arr.length-1;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            if(arr[mid]==key) return true;\\n            else if(arr[mid]<key) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return false;\\n    }\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i=0;i<nums.length-2;i++){\\n            boolean next = BinarySearch(nums,nums[i]+diff);\\n            boolean nextnext = BinarySearch(nums,nums[i]+2*diff);\\n            if(next && nextnext) count++;\\n        }\\n        return count;\\n    }\\n    \\n    // Time Complexity : O(nlog(n))\\n    // Space Complexity : O(1)\\n}\\n```\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++) map.put(nums[i],i);\\n        for(int k : nums) count += (map.containsKey(k+diff) && map.containsKey(k+2*diff)) ? 1 : 0;\\n        return count;\\n    }\\n    \\n    // Time Complexity : O(log(n))\\n    // Space Complexity : O(n)\\n\\n}\\n```\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int pointer1 =  0 , pointer2 = 1 , pointer3 = 2;\\n        while(pointer3 < nums.length){\\n            int compare = nums[pointer2]-nums[pointer1];\\n            if(compare==diff){\\n                compare = nums[pointer3]-nums[pointer2];\\n                if(compare==diff){\\n                    pointer1++;\\n                    pointer2++;\\n                    pointer3++;\\n                    count++;\\n                }\\n                else if(compare<diff) pointer3++;\\n                else{\\n                    pointer1++;pointer2++;\\n                    pointer3 = Math.max(pointer3,pointer2+1);\\n                }\\n            }\\n            else if(compare<diff){\\n                pointer2++;\\n                pointer3 = Math.max(pointer3,pointer2+1);\\n            }\\n            else{\\n                pointer1++;\\n                pointer2 = Math.max(pointer2,pointer1+1);\\n                pointer3 = Math.max(pointer3,pointer2+1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    // Time Complexity : O(n)\\n    // Space Complexity : O(1)\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403970,
                "title": "c-multiple-approach-bruteforce-to-optimized-easy-explanation",
                "content": "\\n\\t// Brute force \\n\\t// we will check condition for k only if nums[j]-nums[i]==diff\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i+1;j<nums.size()-1;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[j]-nums[i]==diff)\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<nums.size();k++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(nums[k]-nums[j]==diff)\\n\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans ;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\t// O(n) Using maps \\n\\t//nums[j] and nums[k] can be written as nums[j]=nums[i]+diff --(1)\\n\\t// and nums[k]=nums[j]+diff \\n\\t// nums[k]=nums[i]+2*diff from equation (1)\\n\\t// create a map to store element of array\\n\\t// check two conditon if(nums[i]+diff) is in map and nums[i]+2*diff is in map\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tmap<int,int>m;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tm[nums[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &i:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif( m[i+diff] && m[i+2*diff])\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t};\\n\\n\\t// single pass\\n\\t// if there is some number x for which x-diff and x-2*diff is present in map then there will always be a triplet \\n\\t//  we can write the given equation as nums[j]=nums[k]-diff and nums[i]=nums[k]-2*diff\\n\\t// suppose we are having some number nums[k] and \\n\\t// if we can somehow find nums[k]-diff and nums[k]-2*diff \\n\\t// this means we have found nums[i] and nums[j] for some nums[k] which is required triplet \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tmap<int,int>m;\\n\\n\\t\\t\\tfor(auto &i:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i-diff>=0 && m[i-diff] && m[i-2*diff])\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n\\t// O(n) Using sets \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tset<int>s(nums.begin(),nums.end());\\n\\t\\t\\tfor(auto &i:nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.find(i+diff)!=s.end() && s.find(i+2*diff)!=s.end())\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint arithmeticTriplets(vector<int>& nums, int diff) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-2;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i+1;j<nums.size()-1;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[j]-nums[i]==diff)\\n\\t\\t\\t\\t\\tfor(int k=j+1;k<nums.size();k++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(nums[k]-nums[j]==diff)\\n\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2393465,
                "title": "python-easy-understand-solution-o-n-space-o-n-time",
                "content": "Use a set to memorize each interger is exist or not. \\n```python\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        s = set(nums)\\n        count = 0\\n        for num in nums:\\n            if (num + diff) in s and (num + diff + diff) in s:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        s = set(nums)\\n        count = 0\\n        for num in nums:\\n            if (num + diff) in s and (num + diff + diff) in s:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390488,
                "title": "java-easy-solution-using-hashmap",
                "content": "For each element check element + diff && element + 2 * diff exist in map.\\n```\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int i : nums){\\n            if(map.containsKey(i+diff) && map.containsKey(i+diff+diff)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "For each element check element + diff && element + 2 * diff exist in map.\\n```\\npublic int arithmeticTriplets(int[] nums, int diff) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i : nums){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int count = 0;\\n        for(int i : nums){\\n            if(map.containsKey(i+diff) && map.containsKey(i+diff+diff)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390665,
                "title": "common-difference-a-p-c",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans = 0;\\n        for(int j = 1;j<nums.size()-1;j++){\\n            int i = j-1, k = j+1;\\n            \\n            while(i>=0 &&  k<nums.size()){\\n                \\n                if(nums[j]-nums[i] == diff && nums[k]-nums[j] == diff)\\n                {\\n                    ans++;\\n                    i--;\\n                    k++;\\n                }\\n                else if(nums[k]-nums[j]<diff){\\n                    k++;\\n                }\\n                else\\n                    i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans = 0;\\n        for(int j = 1;j<nums.size()-1;j++){\\n            int i = j-1, k = j+1;\\n            \\n            while(i>=0 &&  k<nums.size()){\\n                \\n                if(nums[j]-nums[i] == diff && nums[k]-nums[j] == diff)\\n                {\\n                    ans++;\\n                    i--;\\n                    k++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3524009,
                "title": "my-arithmetictriplets",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n  let count = 0;\\n\\n  for (let j = 1; j < nums.length - 1; j++) {\\n    for (let i = 0; i < j; i++) {\\n      for (let k = j + 1; k < nums.length; k++) {\\n        if (nums[j] - nums[i] === diff && nums[k] - nums[j] === diff) count++;\\n      }\\n    }\\n  }\\n  \\n  return count++;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n  let count = 0;\\n\\n  for (let j = 1; j < nums.length - 1; j++) {\\n    for (let i = 0; i < j; i++) {\\n      for (let k = j + 1; k < nums.length; k++) {\\n        if (nums[j] - nums[i] === diff && nums[k] - nums[j] === diff) count++;\\n      }\\n    }\\n  }\\n  \\n  return count++;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2801398,
                "title": "c-unordered-map-easy-to-understand-no-of-arithmetic-tripplet",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        unordered_map<int,bool>mp;\\n        int count=0;\\n\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=true;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\nif it helps plz. don\\'t forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        unordered_map<int,bool>mp;\\n        int count=0;\\n\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=true;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\nif it helps plz. don\\'t forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792389,
                "title": "using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n      int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(binary_search(nums.begin(),nums.end(),nums[i]+diff) && binary_search(nums.begin(),nums.end(),nums[i]+2*diff))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n      int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(binary_search(nums.begin(),nums.end(),nums[i]+diff) && binary_search(nums.begin(),nums.end(),nums[i]+2*diff))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498311,
                "title": "python-95-fast-and-97-memory",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        dic = {} # store nums[i]\\n        quest = {} # store require number you possible find after nums[i]\\n        count = 0 # count answer\\n        for i in nums:\\n            dic[i] = True \\n            if i in quest: count += 1 # meet damand \\n            if i - diff in dic: quest[i + diff] = True\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        dic = {} # store nums[i]\\n        quest = {} # store require number you possible find after nums[i]\\n        count = 0 # count answer\\n        for i in nums:\\n            dic[i] = True \\n            if i in quest: count += 1 # meet damand \\n            if i - diff in dic: quest[i + diff] = True\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457669,
                "title": "simple-and-easy-c-solution-using-hashmap",
                "content": "Time Complexity: O(n)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        unordered_map<int, bool> data;\\n        for (int num:nums)\\n            data[num]=true;\\n        \\n        for (int num: nums)\\n            if (data[num-diff] && data[num+diff])\\n                count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        unordered_map<int, bool> data;\\n        for (int num:nums)\\n            data[num]=true;\\n        \\n        for (int num: nums)\\n            if (data[num-diff] && data[num+diff])\\n                count++;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399813,
                "title": "swift-one-liner-also-optimized-alternates",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        nums.filter { nums.contains($0+diff) && nums.contains($0+diff*2) }.count\\n    }\\n}\\n```\\n\\n**Two-Liner, much faster approach (accepted answer)**\\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        let set = Set(nums)\\n        return nums.filter { set.contains($0+diff) && set.contains($0+diff*2) }.count\\n    }\\n}\\n```\\nThe complexity of `.contains()` is improved from **O(n)** to **O(1)** between the One-Liner and Two-Liner. Much better! \\n\\n---\\n\\n**More Optimized approach (accepted answer)** \\nBreak out of loop early when it becomes impossible to create Arithmetic Triplet.\\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        // Constraints:\\n        //  1) 3 <= nums.length <= 200\\n        //  2) 0 <= nums[i] <= 200\\n        //  3) 1 <= diff <= 50\\n        //  4) nums is strictly increasing.\\n        let set = Set(nums)\\n        var counter = 0, max = nums.last! - diff * 2 + 1\\n        for n in nums {\\n            guard n < max else { break }\\n            if set.contains(n + diff) && set.contains(n + diff*2) {\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        nums.filter { nums.contains($0+diff) && nums.contains($0+diff*2) }.count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        let set = Set(nums)\\n        return nums.filter { set.contains($0+diff) && set.contains($0+diff*2) }.count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        // Constraints:\\n        //  1) 3 <= nums.length <= 200\\n        //  2) 0 <= nums[i] <= 200\\n        //  3) 1 <= diff <= 50\\n        //  4) nums is strictly increasing.\\n        let set = Set(nums)\\n        var counter = 0, max = nums.last! - diff * 2 + 1\\n        for n in nums {\\n            guard n < max else { break }\\n            if set.contains(n + diff) && set.contains(n + diff*2) {\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391706,
                "title": "python-easy-solution-for-beginners-using-slightly-optimized-brute-force",
                "content": "##### This solution is slightly better than pure brute force as it calls the 3rd loop only if a condition is met.\\n\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] - nums[i] == diff:\\n                    for k in range(j+1, len(nums)):\\n                        if nums[k] - nums[j] == diff:\\n                            res += 1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "##### This solution is slightly better than pure brute force as it calls the 3rd loop only if a condition is met.\\n\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        res = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] - nums[i] == diff:\\n                    for k in range(j+1, len(nums)):\\n                        if nums[k] - nums[j] == diff:\\n                            res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3981363,
                "title": "java-10000-beats-3-solution-hashset-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int low = 0 , high = 1 , count = 0;\\n        Set<Integer> temp = new HashSet<>();\\n        for(int i : nums) temp.add(i);\\n        while(nums.length>high){\\n            if(nums[high]-nums[low]==2*diff && temp.contains(diff+nums[low])) count++;\\n            if(nums[high] - nums[low] < 2 * diff) high++;\\n            else low++;   \\n        }\\n        return count;\\n\\n\\n//        Using HASHSET   (Another Solution)\\n\\n        // int count = 0;\\n        // Set<Integer> temp = new HashSet<>();\\n        // for(int i : nums) temp.add(i);  // UPVOTE ME(PLEASE)...\\n        // for(int i : nums){\\n        //     if(temp.contains(i+diff) && temp.contains((i+diff)+diff)) count++;\\n        // }\\n        // return count;\\n    }\\n}\\n\\n//       Another solutions (Using ARRAYLIST) --> ( Try this one also)\\n\\n        // int count = 0;\\n        // List<Integer> temp = new ArrayList<>();\\n        // for(int i=0; i<nums.length; i++) temp.add(nums[i]);\\n        // for(int i : nums) if(temp.contains(i+diff) && temp.contains((i+diff)+diff)) count++;\\n        // return count;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int low = 0 , high = 1 , count = 0;\\n        Set<Integer> temp = new HashSet<>();\\n        for(int i : nums) temp.add(i);\\n        while(nums.length>high){\\n            if(nums[high]-nums[low]==2*diff && temp.contains(diff+nums[low])) count++;\\n            if(nums[high] - nums[low] < 2 * diff) high++;\\n            else low++;   \\n        }\\n        return count;\\n\\n\\n//        Using HASHSET   (Another Solution)\\n\\n        // int count = 0;\\n        // Set<Integer> temp = new HashSet<>();\\n        // for(int i : nums) temp.add(i);  // UPVOTE ME(PLEASE)...\\n        // for(int i : nums){\\n        //     if(temp.contains(i+diff) && temp.contains((i+diff)+diff)) count++;\\n        // }\\n        // return count;\\n    }\\n}\\n\\n//       Another solutions (Using ARRAYLIST) --> ( Try this one also)\\n\\n        // int count = 0;\\n        // List<Integer> temp = new ArrayList<>();\\n        // for(int i=0; i<nums.length; i++) temp.add(nums[i]);\\n        // for(int i : nums) if(temp.contains(i+diff) && temp.contains((i+diff)+diff)) count++;\\n        // return count;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934773,
                "title": "using-set-2-liner-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)   CAUSE WE HAVE USED SET DATA STRUCTURE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n\\n        int count =0;\\n\\n        // JUST CONVERTING ARRAY TO SET\\n        set<int>s(nums.begin(),nums.end());\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s.find(nums[i]-diff)!=s.end()  && s.find(nums[i]-2*diff)!=s.end())\\n            // SET .END HONE SE PEHLE (nums[i]-diff) YE VALUE SET MEIN MILI YA NAHI\\n            {\\n                count++;\\n            }\\n        }   \\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n\\n        int count =0;\\n\\n        // JUST CONVERTING ARRAY TO SET\\n        set<int>s(nums.begin(),nums.end());\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s.find(nums[i]-diff)!=s.end()  && s.find(nums[i]-2*diff)!=s.end())\\n            // SET .END HONE SE PEHLE (nums[i]-diff) YE VALUE SET MEIN MILI YA NAHI\\n            {\\n                count++;\\n            }\\n        }   \\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408166,
                "title": "fastest-solution-with-java-1ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0; \\n        Set<Integer> list = new HashSet<>();\\n        for(int a : nums){\\n            if(list.contains(a-diff) && list.contains(a-diff*2)) count++;\\n            list.add(a);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0; \\n        Set<Integer> list = new HashSet<>();\\n        for(int a : nums){\\n            if(list.contains(a-diff) && list.contains(a-diff*2)) count++;\\n            list.add(a);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344055,
                "title": "easy-python-solution-binary-search-solution",
                "content": "# Intution:-\\n **PLEASE UPVOTE\\uD83D\\uDC4D\\uD83D\\uDC4D IF YOU LIKE THE SOLUTION**\\n## Binary Search\\nUse binary search to find out if nums[i]+diff and nums[i]+2*diff is present in array or not if both are present in array increment the count by 1 if any one of them is not present in array continue:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)*O(logN)*O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def binarysearch(self,nums,val):\\n        s,e=0,len(nums)-1\\n        while s<=e:\\n            mid=(s+e)//2\\n            if nums[mid]==val:\\n                return True\\n            elif nums[mid]>val:\\n                e=mid-1\\n            else:\\n                s=mid+1\\n        return False\\n\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n=len(nums)\\n        cnt=0\\n        for i in range(n-2):\\n            x=self.binarysearch(nums[i+1:],nums[i]+diff)\\n            y=self.binarysearch(nums[i+1:],nums[i]+(2*diff))\\n            if x and y:\\n                cnt+=1\\n        \\n        return cnt\\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/1775bb26-61ef-4f25-b092-4f3caa72dde2_1679837717.4766757.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def binarysearch(self,nums,val):\\n        s,e=0,len(nums)-1\\n        while s<=e:\\n            mid=(s+e)//2\\n            if nums[mid]==val:\\n                return True\\n            elif nums[mid]>val:\\n                e=mid-1\\n            else:\\n                s=mid+1\\n        return False\\n\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n=len(nums)\\n        cnt=0\\n        for i in range(n-2):\\n            x=self.binarysearch(nums[i+1:],nums[i]+diff)\\n            y=self.binarysearch(nums[i+1:],nums[i]+(2*diff))\\n            if x and y:\\n                cnt+=1\\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171363,
                "title": "two-simple-and-fast-map-and-array-based-solutions",
                "content": "# Approach\\nEach number can have only one potenial triplet and the numbers should go in sequential order. So we just need to check that. If array we can check forward values, if map we need to fill it with data and check backwards. Map solution is a bit slower per leetcode tests, looks like map.has is not that optimized as array.includes. Array version beats up to 90% by speed and memory as well. \\n\\n\\n# Array solution\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n    let count = 0;\\n    //The third triplet element\\n    let diff2 = 2 * diff;\\n    for (let i = 0; i < nums.length; i++) {\\n        /**\\n        * Checking if there is second and third triplet elements in array\\n        * Starting from the next element in array for the second \\n        * And from the +2 for the third to optimize search\\n        * && excludes second check if first failed\\n        */\\n        if (nums.includes(nums[i] + diff, i +1) && nums.includes(nums[i] + diff2, i + 2)) {\\n            count++\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n# MAP solution\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n    let map = new Map();\\n    let count = 0;\\n\\n    for(let i = 0; i < nums.length; i++){\\n        /**\\n        * For Map we need to fill it with the data so we check two \\n        * previous numbers backwards\\n        */\\n        let prev = nums[i] - diff;\\n        \\n        if(map.has(prev) && map.has(prev - diff)){\\n            count++;\\n        }\\n        map.set(nums[i] , 1);\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n    let count = 0;\\n    //The third triplet element\\n    let diff2 = 2 * diff;\\n    for (let i = 0; i < nums.length; i++) {\\n        /**\\n        * Checking if there is second and third triplet elements in array\\n        * Starting from the next element in array for the second \\n        * And from the +2 for the third to optimize search\\n        * && excludes second check if first failed\\n        */\\n        if (nums.includes(nums[i] + diff, i +1) && nums.includes(nums[i] + diff2, i + 2)) {\\n            count++\\n        }\\n    }\\n    return count;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function (nums, diff) {\\n    let map = new Map();\\n    let count = 0;\\n\\n    for(let i = 0; i < nums.length; i++){\\n        /**\\n        * For Map we need to fill it with the data so we check two \\n        * previous numbers backwards\\n        */\\n        let prev = nums[i] - diff;\\n        \\n        if(map.has(prev) && map.has(prev - diff)){\\n            count++;\\n        }\\n        map.set(nums[i] , 1);\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676955,
                "title": "python-o-n-two-pointers-approach",
                "content": "We can take advantage of the fact that the array is already sorted to find arithmetic triples quickly.\\nThe big idea is that if either `nums[j] - nums[i]` or `nums[k] - nums[j]` is not equal to diff, we increment the appropriate index.\\n\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n = len(nums)\\n        count = 0\\n        i, j, k = 0, 1, 2\\n        while i < n and j < n and k < n:\\n            if nums[j] - nums[i] < diff:\\n\\t\\t\\t\\t# diff is too small: increment j so that we get a larger diff\\n                j += 1\\n            elif nums[j] - nums[i] > diff:\\n\\t\\t\\t\\t# diff is too big: increment i so that we get a smaller diff\\n                i += 1\\n            else:\\n\\t\\t\\t\\t# we might have found a triple, so now check nums[k] - nums[j]\\n                if nums[k] - nums[j] < diff:\\n\\t\\t\\t\\t\\t# diff is too small\\n                    k += 1\\n                elif nums[k] - nums[j] > diff:\\n\\t\\t\\t\\t\\t# diff is too big\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\t# found a triple\\n                    count += 1\\n\\t\\t\\t\\t\\t# increment k so that we get closer to breaking the loop\\n\\t\\t\\t\\t\\t# i\\'m actually not sure if this has to be k,\\n\\t\\t\\t\\t\\t# or if we could increment j instead\\n                    k += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n = len(nums)\\n        count = 0\\n        i, j, k = 0, 1, 2\\n        while i < n and j < n and k < n:\\n            if nums[j] - nums[i] < diff:\\n\\t\\t\\t\\t# diff is too small: increment j so that we get a larger diff\\n                j += 1\\n            elif nums[j] - nums[i] > diff:\\n\\t\\t\\t\\t# diff is too big: increment i so that we get a smaller diff\\n                i += 1\\n            else:\\n\\t\\t\\t\\t# we might have found a triple, so now check nums[k] - nums[j]\\n                if nums[k] - nums[j] < diff:\\n\\t\\t\\t\\t\\t# diff is too small\\n                    k += 1\\n                elif nums[k] - nums[j] > diff:\\n\\t\\t\\t\\t\\t# diff is too big\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\t# found a triple\\n                    count += 1\\n\\t\\t\\t\\t\\t# increment k so that we get closer to breaking the loop\\n\\t\\t\\t\\t\\t# i\\'m actually not sure if this has to be k,\\n\\t\\t\\t\\t\\t# or if we could increment j instead\\n                    k += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613151,
                "title": "c-naive-approach-solution",
                "content": "int arithmeticTriplets(vector<int>& nums, int diff) {\\n\\n         int ans = 0 ;\\n        for(int i = 0 ; i < nums.size()-2 ; i++)\\n        {\\n            for(int j = i+1 ; j < nums.size()-1 ; j++)\\n            {\\n                if(nums[i]+diff==nums[j])\\n                {\\n                for(int k = j +1; k < nums.size(); k++)\\n                  {\\n                    if(nums[j]+diff==nums[k])\\n                       ans++;\\n                  }\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "int arithmeticTriplets(vector<int>& nums, int diff) {\\n\\n         int ans = 0 ;\\n        for(int i = 0 ; i < nums.size()-2 ; i++)\\n        {\\n            for(int j = i+1 ; j < nums.size()-1 ; j++)\\n            {\\n                if(nums[i]+diff==nums[j])\\n                {\\n                for(int k = j +1; k < nums.size(); k++)\\n                  {\\n                    if(nums[j]+diff==nums[k])\\n                       ans++;\\n                  }\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2561071,
                "title": "c-sharp-solution",
                "content": "```\\nint count = 0;\\nHashSet<int> hash_num = new HashSet<int>();\\nforeach(int num in nums)\\n{\\n\\tif(hash_num.Contains(num - diff) && hash_num.Contains(num - 2 * diff))\\n\\t\\tcount++;\\n\\thash_num.Add(num);  \\n}\\nreturn count;\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nint count = 0;\\nHashSet<int> hash_num = new HashSet<int>();\\nforeach(int num in nums)\\n{\\n\\tif(hash_num.Contains(num - diff) && hash_num.Contains(num - 2 * diff))\\n\\t\\tcount++;\\n\\thash_num.Add(num);  \\n}\\nreturn count;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390811,
                "title": "c-using-set-o-n2",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int count=0;\\n        int n= nums.size();\\n        set<int> s;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(nums[i]);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]-nums[i]==diff && s.find(nums[i]-diff)!=s.end())\\n                    count++;\\n            }\\n        }\\n        return count;\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int count=0;\\n        int n= nums.size();\\n        set<int> s;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(nums[i]);\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]-nums[i]==diff && s.find(nums[i]-diff)!=s.end())\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3364806,
                "title": "java-easy-set-solution-100-o-n",
                "content": "```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0, k = 1, result = 0;\\n\\n        for(int num : nums)\\n            set.add(num);\\n\\n        while(k < nums.length) {\\n            if(nums[k] - nums[i] == 2 * diff && set.contains(diff + nums[i]))\\n                ++result;\\n            \\n            if(nums[k] - nums[i] < 2 * diff)\\n                ++k;\\n            else\\n                ++i;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n// nums[j] - nums[i] == diff\\n// nums[k] - nums[j] == diff\\n// num[j] = diff + num[i]\\n// num[j] = num[k] - diff\\n// diff + num[i] = num[k] - diff\\n// 2diff = num[k] - num[i]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0, k = 1, result = 0;\\n\\n        for(int num : nums)\\n            set.add(num);\\n\\n        while(k < nums.length) {\\n            if(nums[k] - nums[i] == 2 * diff && set.contains(diff + nums[i]))\\n                ++result;\\n            \\n            if(nums[k] - nums[i] < 2 * diff)\\n                ++k;\\n            else\\n                ++i;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n// nums[j] - nums[i] == diff\\n// nums[k] - nums[j] == diff\\n// num[j] = diff + num[i]\\n// num[j] = num[k] - diff\\n// diff + num[i] = num[k] - diff\\n// 2diff = num[k] - num[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259630,
                "title": "single-pass",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int trip = 0;\\n        for(int i=0;i<nums.size();i++){\\n          int find = nums[i]+diff;\\n          if(count(nums.begin(),nums.end(),find)>0){\\n            int find2 = find+diff;\\n            if(count(nums.begin(),nums.end(),find2)>0){\\ntrip++;\\n            }\\n          }\\n        }\\n        return trip;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int trip = 0;\\n        for(int i=0;i<nums.size();i++){\\n          int find = nums[i]+diff;\\n          if(count(nums.begin(),nums.end(),find)>0){\\n            int find2 = find+diff;\\n            if(count(nums.begin(),nums.end(),find2)>0){\\ntrip++;\\n            }\\n          }\\n        }\\n        return trip;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165248,
                "title": "runtime-52-ms-beats-57-18-memory-13-9-mb-beats-55-96-beginner-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] +diff in nums and nums[i]+diff*2 in nums:\\n                res+=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        res = 0\\n\\n        for i in range(len(nums)):\\n            if nums[i] +diff in nums and nums[i]+diff*2 in nums:\\n                res+=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114586,
                "title": "beats-97-36-number-of-arithmetic-triplets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                for k in range(len(nums)):\\n                    if i<j and j<k and nums[j]-nums[i]==diff and nums[k]-nums[j]==diff:\\n                        count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                for k in range(len(nums)):\\n                    if i<j and j<k and nums[j]-nums[i]==diff and nums[k]-nums[j]==diff:\\n                        count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001558,
                "title": "o-n-set-reduce-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function(nums, diff) {\\n    const set = new Set();\\n\\n    return nums.reduce((acc, num) => {\\n        set.add(num);\\n\\n        if (set.has(num - diff) && set.has(num - 2 * diff)) {\\n            return acc + 1;\\n        }\\n\\n        return acc;\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} diff\\n * @return {number}\\n */\\nvar arithmeticTriplets = function(nums, diff) {\\n    const set = new Set();\\n\\n    return nums.reduce((acc, num) => {\\n        set.add(num);\\n\\n        if (set.has(num - diff) && set.has(num - 2 * diff)) {\\n            return acc + 1;\\n        }\\n\\n        return acc;\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835593,
                "title": "3-loops-java-easy-to-understand",
                "content": "# Intuition\\n\\nDon\\'t forget to upvote if you found it useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n^3)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]-nums[i]==diff){\\n                    for(int k=j+1;k<nums.length;k++){\\n                        if(nums[k]-nums[j]==diff)\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]-nums[i]==diff){\\n                    for(int k=j+1;k<nums.length;k++){\\n                        if(nums[k]-nums[j]==diff)\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812563,
                "title": "100-faster-typescript-easy-to-understand",
                "content": "Let me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\n\\n```\\nconst arithmeticTriplets = (nums: number[], diff: number): number => {\\n    let sum = 0;\\n    let hash = new Set();\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if (hash.has(nums[i] - diff) && hash.has(nums[i] - diff - diff)) {\\n            sum++;\\n        }\\n        \\n        hash.add(nums[i]);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst arithmeticTriplets = (nums: number[], diff: number): number => {\\n    let sum = 0;\\n    let hash = new Set();\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        if (hash.has(nums[i] - diff) && hash.has(nums[i] - diff - diff)) {\\n            sum++;\\n        }\\n        \\n        hash.add(nums[i]);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643233,
                "title": "o-n-solution-java",
                "content": "```\\n public int arithmeticTriplets(int[] nums, int diff) {\\n        int n = nums.length;\\n        int res =0;\\n        boolean arr[] = new boolean[nums[n-1]+diff+1];\\n        for(int num:nums){\\n            arr[num]= true;\\n        }\\n        for(int i=0;i<n-2;i++){\\n            int val = nums[i];\\n            int val2 = val+ diff;\\n            int val3 = val2+diff;\\n            if(arr[val2] && arr[val3]){\\n                res++;\\n            }\\n        }\\n        return res;   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int arithmeticTriplets(int[] nums, int diff) {\\n        int n = nums.length;\\n        int res =0;\\n        boolean arr[] = new boolean[nums[n-1]+diff+1];\\n        for(int num:nums){\\n            arr[num]= true;\\n        }\\n        for(int i=0;i<n-2;i++){\\n            int val = nums[i];\\n            int val2 = val+ diff;\\n            int val3 = val2+diff;\\n            if(arr[val2] && arr[val3]){\\n                res++;\\n            }\\n        }\\n        return res;   \\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2569064,
                "title": "first-sc-o-1-solution-tc-o-n-cpp-c-java",
                "content": "**Please upvote If you like**\\n\\n**CPP**\\n\\n\\tunsigned short int count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < nums.size() && j < nums.size() && k < nums.size()) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n\\n\\n\\n**Java**\\n\\n\\n\\tint count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < nums.length && j < nums.length && k < nums.length) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n\\t\\n\\t\\n**C**\\n\\n\\tunsigned short int count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < numsSize && j < numsSize && k < numsSize) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;",
                "solutionTags": [],
                "code": "**Please upvote If you like**\\n\\n**CPP**\\n\\n\\tunsigned short int count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < nums.size() && j < nums.size() && k < nums.size()) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n\\n\\n\\n**Java**\\n\\n\\n\\tint count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < nums.length && j < nums.length && k < nums.length) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n\\t\\n\\t\\n**C**\\n\\n\\tunsigned short int count = 0,\\n\\ti = 0,\\n\\tj = i + 1,\\n\\tk = j + 1;\\n\\twhile (i < numsSize && j < numsSize && k < numsSize) {\\n\\n\\t\\tif (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n\\t\\t\\tcount++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tk++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (i == j) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] < diff) {\\n\\t\\t\\tj++;\\n\\t\\t} else if (nums[j] - nums[i] > diff) {\\n\\t\\t\\ti++;\\n\\t\\t} else if (j == k) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] < diff) {\\n\\t\\t\\tk++;\\n\\t\\t} else if (nums[k] - nums[j] > diff) {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2498656,
                "title": "javascript-hashmap-solution-o-n",
                "content": "```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\n    let sum = 0;\\n    let hash = new Set();\\n    \\n    for (let numIndex = 0; numIndex < nums.length; numIndex++) {\\n        const currentNum = nums[numIndex];\\n        \\n        if (hash.has(currentNum - diff) && hash.has(currentNum - diff - diff)) {\\n            sum++;\\n        }\\n        \\n        hash.add(currentNum);\\n    }\\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\n    let sum = 0;\\n    let hash = new Set();\\n    \\n    for (let numIndex = 0; numIndex < nums.length; numIndex++) {\\n        const currentNum = nums[numIndex];\\n        \\n        if (hash.has(currentNum - diff) && hash.has(currentNum - diff - diff)) {\\n            sum++;\\n        }\\n        \\n        hash.add(currentNum);\\n    }\\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2455687,
                "title": "java-most-easiest-solution-with-explanation",
                "content": "//This is a two pointer simple approach. Take a variable count to keep a count of the triplets.\\n//initialiaze i=0; and then take a while loop which will run till i is less than nums.length-2.\\n//inside this while loop take two variable j = i+1 and k = j+1;\\n\\n\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int i=0;\\n        \\n        while(i<nums.length-2){\\n            int j = i+1, k=j+1;\\n           \\n\\t\\t   //run the loop till the element on j gives the required difference.\\n            while(j<nums.length-1 && nums[j]-nums[i]<diff){\\n                j++;\\n            }\\n            //run the loop till the element on k gives the required difference.\\n            while(k<nums.length && nums[k]-nums[j]<diff){\\n                k++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now if all i,j and k satisfy the requirement increase count and also the value of i.\\n            if(j<nums.length-1 && k<nums.length && nums[j]-nums[i]==diff && nums[k]-nums[j]==diff){\\n                count++;\\n                i++;\\n            }\\n\\t\\t\\t// if all the above conditions are false then just increase i.\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        // return count to get the answer.\\n       return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int i=0;\\n        \\n        while(i<nums.length-2){\\n            int j = i+1, k=j+1;\\n           \\n\\t\\t   //run the loop till the element on j gives the required difference.\\n            while(j<nums.length-1 && nums[j]-nums[i]<diff){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2437987,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered Set***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int n = nums.size();\\n        \\n        // insert all the elements into the set\\n        \\n        unordered_set<int> s;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        int count = 0;\\n        \\n        // iterate over array\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int a = nums[i];\\n            \\n            int b = nums[i] + diff;\\n            \\n            int c = nums[i] + 2 * diff;\\n            \\n            // if b, c are present in set then sequence is found\\n            \\n            if(s.count(b) && s.count(c))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int n = nums.size();\\n        \\n        // insert all the elements into the set\\n        \\n        unordered_set<int> s;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        int count = 0;\\n        \\n        // iterate over array\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int a = nums[i];\\n            \\n            int b = nums[i] + diff;\\n            \\n            int c = nums[i] + 2 * diff;\\n            \\n            // if b, c are present in set then sequence is found\\n            \\n            if(s.count(b) && s.count(c))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419177,
                "title": "c-0ms-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int cnt = 0;\\n        unordered_set<int>set;\\n        for(int i=0;i<nums.size();i++){\\n            set.insert(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(set.find(nums[i]+diff)!=set.end() && set.find(nums[i]+diff+diff)!=set.end()){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n![image](https://assets.leetcode.com/users/images/c7c704cd-cd3b-4ea7-9632-922156b0e064_1660386459.1353939.png)\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int cnt = 0;\\n        unordered_set<int>set;\\n        for(int i=0;i<nums.size();i++){\\n            set.insert(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2415108,
                "title": "python-elegant-short-two-solutions-o-n-and-o-n-log-n-binary-search",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tleft, right = 0, len(nums) - 1\\n\\n\\t\\t\\tfor j, num in enumerate(nums):\\n\\t\\t\\t\\tif self.binary_search(nums, num - diff, left, j - 1) != -1 and \\\\\\n\\t\\t\\t\\t   self.binary_search(nums, num + diff, j + 1, right) != -1:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count\\n\\n\\t\\t@staticmethod\\n\\t\\tdef binary_search(nums: List[int], target: int, left: int, right: int) -> int:\\n\\t\\t\\twhile left <= right:\\n\\t\\t\\t\\tmid = (left + right) // 2\\n\\n\\t\\t\\t\\tif nums[mid] == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\tif nums[mid] > target:\\n\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\n\\t\\t\\treturn -1\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\t\\tuniq_nums = set(nums)\\n\\t\\t\\treturn sum(num + diff in uniq_nums and num + 2 * diff in uniq_nums for num in nums)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n*log(n))\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tleft, right = 0, len(nums) - 1\\n\\n\\t\\t\\tfor j, num in enumerate(nums):\\n\\t\\t\\t\\tif self.binary_search(nums, num - diff, left, j - 1) != -1 and \\\\\\n\\t\\t\\t\\t   self.binary_search(nums, num + diff, j + 1, right) != -1:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count\\n\\n\\t\\t@staticmethod\\n\\t\\tdef binary_search(nums: List[int], target: int, left: int, right: int) -> int:\\n\\t\\t\\twhile left <= right:\\n\\t\\t\\t\\tmid = (left + right) // 2\\n\\n\\t\\t\\t\\tif nums[mid] == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\tif nums[mid] > target:\\n\\t\\t\\t\\t\\tright = mid - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\n\\t\\t\\treturn -1\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\t\\tuniq_nums = set(nums)\\n\\t\\t\\treturn sum(num + diff in uniq_nums and num + 2 * diff in uniq_nums for num in nums)",
                "codeTag": "Java"
            },
            {
                "id": 2395182,
                "title": "c-simple-2-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n    int count=0;\\n    for(int i=0;i<nums.size()-2;i++){\\n        int start = i+1,end = nums.size()-1;\\n        while(start < end){\\n            if(nums[start]-nums[i] == diff && nums[end]-nums[start] == diff){\\n                count++;\\n\\n                break;\\n            }\\n            if(nums[start]-nums[i] < diff) start++;\\n            else if(nums[start]-nums[i] == diff && nums[end]-nums[start]>diff) end--;\\n            else break;\\n        }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n    int count=0;\\n    for(int i=0;i<nums.size()-2;i++){\\n        int start = i+1,end = nums.size()-1;\\n        while(start < end){\\n            if(nums[start]-nums[i] == diff && nums[end]-nums[start] == diff){\\n                count++;\\n\\n                break;\\n            }\\n            if(nums[start]-nums[i] < diff) start++;\\n            else if(nums[start]-nums[i] == diff && nums[end]-nums[start]>diff) end--;\\n            else break;\\n        }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395073,
                "title": "c-hashset",
                "content": "\\tpublic int ArithmeticTriplets(int[] nums, int diff) \\n\\t\\t{\\n\\t\\t\\tvar hashset = new HashSet<int>();\\n\\t\\t\\tfor(int i = 0; i < nums.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\thashset.Add(nums[i]);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(hashset.Contains(nums[i] + diff) && hashset.Contains(nums[i] + 2*diff))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int ArithmeticTriplets(int[] nums, int diff) \\n\\t\\t{\\n\\t\\t\\tvar hashset = new HashSet<int>();\\n\\t\\t\\tfor(int i = 0; i < nums.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\thashset.Add(nums[i]);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.Length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(hashset.Contains(nums[i] + diff) && hashset.Contains(nums[i] + 2*diff))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2394871,
                "title": "c-o-n-map-easy-to-understand-commented-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        \\n// we check in the map if the number with the current number\\'s difference & its 2x difference exists or not, if it does not, we simply push the current number into the map. If they do, we have successfully found a triplet so we update our answer.\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mp[nums[i] - diff] && mp[nums[i] - 2 * diff]){ \\n                ans++;\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        \\n// we check in the map if the number with the current number\\'s difference & its 2x difference exists or not, if it does not, we simply push the current number into the map. If they do, we have successfully found a triplet so we update our answer.\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mp[nums[i] - diff] && mp[nums[i] - 2 * diff]){ \\n                ans++;\\n            }\\n            mp[nums[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392829,
                "title": "c-solution-using-unordered-map-faster",
                "content": "```\\n  int cnt = 0;\\n        unordered_map<int,bool> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }   \\n        return cnt;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  int cnt = 0;\\n        unordered_map<int,bool> mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }   \\n        return cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391872,
                "title": "latest-solution-detailed-explanation-2-approaches",
                "content": "# BIG IDEA: SAY YOU ARE GIVEN SINGLE NUMBER 6 AND DIFF = 3 , WHAT OTHER TWO NUMBERS DO YOU NEED TO SATISY CONDITIONS GIVEN IN THE PROBLEM? YOU NEED 6- DIFF AND 6 + DIFF. SO WE ARE SIMPLY DOING THAT, THE THING IS YOU ONLY NEED TO IDENTIFY THIS AND THEN THE QUESTION IS A CAKEWALK.\\n# FIRST APPROACH \\n# NOTE: AS IT IS GIVEN ITS A STRICTLY INCREASING SEQUENCE, WE KNOW BINARY SEARCH COULD BE APPLIED, SO FOR EVERY ELEMENT X IN ARRAY WE SEARCH FOR *X+DIFF AND X-DIFF*.\\n\\n```\\nclass Solution:\\n\\n        \\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        def binarysearch(array, start, end , target):\\n        \\n            while start <= end:\\n                \\n                \\n            \\n                mid = start + (end-start)//2\\n                \\n                if len(nums) == mid:\\n                    return \\n \\n                \\n                if array[mid] == target:\\n                    return True\\n            \\n                elif array[mid] > target:\\n                    return binarysearch(array,start,mid-1,target)\\n            \\n                elif array[mid] < target:\\n                    return binarysearch (array, mid +1 , end , target)\\n            \\n                \\n            return False\\n        \\n        count = 0 \\n        \\n        for num in nums:\\n            x_plus_diff = binarysearch(nums,0 , len(nums), num +diff)\\n            x_minus_diff = binarysearch(nums,0, len(nums), num - diff)\\n            # print(x_plus_diff, x_minus_diff)\\n            \\n            if x_plus_diff == True and x_minus_diff == True:\\n                count +=1\\n                \\n        return count\\n```\\n\\n# SECOND APPROACH\\n# THIS APPROACH USES EXTRA SPACE OF O(N) AND WE AGAIN SIMPLY SEARCH FOR IF \"X+DIFF\" AND \"X-DIFF\" EXIST.\\n```\\n        hashmap = {}\\n        \\n        for  i in nums :\\n            \\n            hashmap[i] = 1\\n            \\n        count = 0\\n        \\n        for num in nums:\\n            \\n            if num + diff in hashmap and num - diff in hashmap:\\n                count = count +1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n\\n        \\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        def binarysearch(array, start, end , target):\\n        \\n            while start <= end:\\n                \\n                \\n            \\n                mid = start + (end-start)//2\\n                \\n                if len(nums) == mid:\\n                    return \\n \\n                \\n                if array[mid] == target:\\n                    return True\\n            \\n                elif array[mid] > target:\\n                    return binarysearch(array,start,mid-1,target)\\n            \\n                elif array[mid] < target:\\n                    return binarysearch (array, mid +1 , end , target)\\n            \\n                \\n            return False\\n        \\n        count = 0 \\n        \\n        for num in nums:\\n            x_plus_diff = binarysearch(nums,0 , len(nums), num +diff)\\n            x_minus_diff = binarysearch(nums,0, len(nums), num - diff)\\n            # print(x_plus_diff, x_minus_diff)\\n            \\n            if x_plus_diff == True and x_minus_diff == True:\\n                count +=1\\n                \\n        return count\\n```\n```\\n        hashmap = {}\\n        \\n        for  i in nums :\\n            \\n            hashmap[i] = 1\\n            \\n        count = 0\\n        \\n        for num in nums:\\n            \\n            if num + diff in hashmap and num - diff in hashmap:\\n                count = count +1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390772,
                "title": "java-easy-to-understand-for-loop",
                "content": "1. Assume all number can be the first number of triplet\\n2. if map[num - diff] == 1, it means that num is the second number of triplet\\n\\tor map[num - diff] == 2, it means that num is the third number of triplet\\n\\t...\\n3. so, just need to count how many map[num] >= 3 (inside a triplet)\\n\\nin case 1, 2 triplets are [1,4,7] & [4, 7, 10], map[10] == 4 > 3, so 10 is also inside a triplet\\n(map[1]  == 1, map[4] == 2, map[7] == 3, map[10] == 4)\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int result = 0;\\n        int[] map = new int[201];\\n        \\n        for(int num: nums) {\\n            map[num] = 1;\\n            \\n            if(num - diff >= 0) {\\n                map[num] += map[num - diff];\\n            }\\n            \\n            if(map[num] >= 3) result += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int result = 0;\\n        int[] map = new int[201];\\n        \\n        for(int num: nums) {\\n            map[num] = 1;\\n            \\n            if(num - diff >= 0) {\\n                map[num] += map[num - diff];\\n            }\\n            \\n            if(map[num] >= 3) result += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390713,
                "title": "easy-c-looop-basic-approach-no-extra-space-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int c=0;\\n        for(int i=0;i<n-2;++i)\\n            for(int j=i+1;j<n-1;++j)\\n                for(int k=j+1;k<n;++k)\\n                    if(nums[j]-nums[i] == diff && nums[k]-nums[j] == diff)\\n                        c++;\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int c=0;\\n        for(int i=0;i<n-2;++i)\\n            for(int j=i+1;j<n-1;++j)\\n                for(int k=j+1;k<n;++k)\\n                    if(nums[j]-nums[i] == diff && nums[k]-nums[j] == diff)\\n                        c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3895816,
                "title": "iteratively-simple-solution-java-c-python-clean-codes-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s a breakdown of the code:\\n\\n1. int ans = 0;: This initializes a variable ans to store the count of arithmetic triplets found in the vector.\\n\\n2. The code uses three nested for loops to iterate through all possible combinations of three indices i, j, and k within the nums vector.\\n3. The outermost loop (i) iterates from the beginning of the vector (0) up to the third-to-last element (nums.size() - 2). This is because the code is looking for triplets, and the last two elements can\\'t form a triplet with any other element.\\n4. The middle loop (j) iterates from the next index after i (i + 1) up to the second-to-last element (nums.size() - 1). This ensures that j is always ahead of i.\\n5. The innermost loop (k) iterates from the index after j (j + 1) up to the last element (nums.size()). This ensures that k is always ahead of both i and j.\\n6. The code checks whether the differences between nums[j] and nums[i] and between nums[k] and nums[j] are both equal to the given diff. If this condition is met, it means that the current combination of i, j, and k forms an arithmetic triplet with the specified difference.\\n7. If the condition in step 3 is satisfied, the ans variable is incremented, indicating that a valid arithmetic triplet has been found.\\n8. After all possible combinations have been checked, the function returns the final value of ans, which represents the total count of arithmetic triplets found in the nums vector.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`However, it\\'s important to note that this code has a time complexity of O(n^3), where n is the size of the nums vector. This is because it uses three nested loops, resulting in a cubic time complexity, which could be quite slow for larger input vectors. There are more efficient algorithms to solve this problem with better time complexity.`\\n\\n\\n\\n```C++ []\\nclass Solution \\n{\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int ans=0;\\n       for(int i=0;i<nums.size()-2;i++)\\n       {\\n           for(int j=i+1;j<nums.size()-1;j++)\\n           {\\n               for(int k=j+1;k<nums.size();k++)\\n               {\\n                   if((nums[j]-nums[i]==diff) && (nums[k]-nums[j]==diff))\\n                   {\\n                       ans++;\\n                   }\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) \\n    {\\n      int ans=0;\\n      for(int i=0;i<nums.length-2;i++)\\n      {\\n          for(int j=i+1;j<nums.length-1;j++)\\n          {\\n              for(int k=j+1;k<nums.length;k++)\\n              {\\n                  if((nums[j]-nums[i]==diff) && (nums[k]-nums[j]==diff))\\n                  ans++;\\n              }\\n          }\\n      }    \\n    \\n    return ans;\\n    }\\n\\n}\\n```\\n```Python []\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        ans=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                for k in range(len(nums)):\\n                    if i<j and j<k and nums[j]-nums[i]==diff and nums[k]-nums[j]==diff:\\n                       ans+=1 \\n                       #in python, ans++ don\\'t work\\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution \\n{\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int ans=0;\\n       for(int i=0;i<nums.size()-2;i++)\\n       {\\n           for(int j=i+1;j<nums.size()-1;j++)\\n           {\\n               for(int k=j+1;k<nums.size();k++)\\n               {\\n                   if((nums[j]-nums[i]==diff) && (nums[k]-nums[j]==diff))\\n                   {\\n                       ans++;\\n                   }\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) \\n    {\\n      int ans=0;\\n      for(int i=0;i<nums.length-2;i++)\\n      {\\n          for(int j=i+1;j<nums.length-1;j++)\\n          {\\n              for(int k=j+1;k<nums.length;k++)\\n              {\\n                  if((nums[j]-nums[i]==diff) && (nums[k]-nums[j]==diff))\\n                  ans++;\\n              }\\n          }\\n      }    \\n    \\n    return ans;\\n    }\\n\\n}\\n```\n```Python []\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        ans=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                for k in range(len(nums)):\\n                    if i<j and j<k and nums[j]-nums[i]==diff and nums[k]-nums[j]==diff:\\n                       ans+=1 \\n                       #in python, ans++ don\\'t work\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848870,
                "title": "go-two-pointers-time-complexity-o-n-and-space-complexity-o-1",
                "content": "# Intuition\\n\\n##### Analyzing the problem, the following points can be emphasized:\\n1. We are given an array of integers sorted in ascending order.\\n1. We need to find pairs of values that will match the condition `y - x = diff && z - y = diff`.\\n1. This means that there is no need to look for a pair `z - y = diff` if we did not find `y - x = diff`.\\nThe way to find the pairs is identical, so we can use the same approach to confirm the finding of the desired pair.\\n\\n##### From the description, I can suggest the following solutions:\\n- Brute force with complexity: time $$O(n^3)$$, space $$O(1)$$\\n- Using a hash map with complexity: time $$O(n)$$, space $$O(n)$$\\n- Using the two pointer method with complexity: time $$O(n)$$, space $$O(1)$$\\n\\nPersonally, I like the option with complexity time $$O(n)$$ and space $$O(1)$$ aka the two pointer method.\\nIf you want me to describe other implementations, let me know and I\\'ll add them.\\n\\n# Approach\\nMethod of two pointers, about the fact that we have pointers and we move them (masterful explanation).Usually these pointers are called `r`ight & `l`eft And that\\'s what we\\'re going to do!\\n\\nInstead of parsing the whole code, I want to focus on how we move the pointers to find all the `unique arithmetic triplets`.\\n\\nSince the search for the first pair of values \\u200B\\u200Bis no different from the search for another pair. Then, having figured out the rules for finding the first pair, we can apply them to the search for the next pair.\\n\\n##### We remember that we have a sorted array. Therefore, we can offer:\\n\\n- If the statement `diff > r - l` is true, then\\nwe can assume that the value of `r` is not large enough and we need to move the right pointer `r` forward.\\n- If the statement `diff < r - l` is true, then the value of `r` has become larger than necessary and must be reduced by shifting the left pointer `l` forward.\\n\\nPseudocode:\\n```\\nif diff > nums[r] - nums[l]\\n    r++\\nelse if diff < nums[r] - nums[l]\\n    l++\\nelse \\n    // we have found a pair that matches the condition\\n```\\n\\nUsing our pseudocode, check the condition for finding the first pair:\\n```\\n// example\\nnums[0,1,4]; diff=3\\nl = 0; r = 1\\n\\n// The first check will shift the right pointer\\nif diff > nums[r] - nums[l] // 3 > 1\\n    r++ // r = 2\\n\\n// The second check will shift the left pointer\\nif diff < nums[r] - nums[l] // 3 < 4\\n    l++ // l = 1\\n\\n// The last check will fulfill the condition\\nif diff == nums[r] - nums[l] // 3 == 3\\n // we can start looking for the next pair that matches the condition\\n```\\n\\nAs you can see, we found the first pair in O(n). And since the further search will continue from the current pointers, the time complexity will remain $$O(n)$$.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\nThis algorithm can be better, if you know how, then let me know, I\\'ll take it into account with pleasure.\\n\\n```\\nfunc arithmeticTriplets(nums []int, diff int) int {\\n  triplets := 0\\n  i, j, k := 0, 1, 2\\n\\n  for i < len(nums) - 2 && j < len(nums) - 1 && k < len(nums) {\\n    // Search for the first pair. Left pointer = i, right pointer = j\\n    if !foundPair(diff, &i, &j, &nums) {\\n      continue\\n    }\\n    // We found the first pair\\n\\n    // Search for the second pair. Left pointer = j, right pointer = k\\n    if !foundPair(diff, &j, &k, &nums) {\\n      continue\\n    }\\n    // We found the second pair\\n\\n    // Which means we can move the pointers to the right and increase the value of triplets\\n    i++\\n    j++\\n    k++\\n    triplets++\\n  }  \\n\\n  return triplets\\n}\\n\\nfunc foundPair(diff int, l, r *int, nums *[]int) bool {\\n  value := (*nums)[*r] - (*nums)[*l]\\n\\n  if diff > value {\\n    *r++\\n\\n    return false\\n  }\\n\\n  if diff < value {\\n    *l++\\n\\n    return false\\n  }\\n\\n  return true\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nif diff > nums[r] - nums[l]\\n    r++\\nelse if diff < nums[r] - nums[l]\\n    l++\\nelse \\n    // we have found a pair that matches the condition\\n```\n```\\n// example\\nnums[0,1,4]; diff=3\\nl = 0; r = 1\\n\\n// The first check will shift the right pointer\\nif diff > nums[r] - nums[l] // 3 > 1\\n    r++ // r = 2\\n\\n// The second check will shift the left pointer\\nif diff < nums[r] - nums[l] // 3 < 4\\n    l++ // l = 1\\n\\n// The last check will fulfill the condition\\nif diff == nums[r] - nums[l] // 3 == 3\\n // we can start looking for the next pair that matches the condition\\n```\n```\\nfunc arithmeticTriplets(nums []int, diff int) int {\\n  triplets := 0\\n  i, j, k := 0, 1, 2\\n\\n  for i < len(nums) - 2 && j < len(nums) - 1 && k < len(nums) {\\n    // Search for the first pair. Left pointer = i, right pointer = j\\n    if !foundPair(diff, &i, &j, &nums) {\\n      continue\\n    }\\n    // We found the first pair\\n\\n    // Search for the second pair. Left pointer = j, right pointer = k\\n    if !foundPair(diff, &j, &k, &nums) {\\n      continue\\n    }\\n    // We found the second pair\\n\\n    // Which means we can move the pointers to the right and increase the value of triplets\\n    i++\\n    j++\\n    k++\\n    triplets++\\n  }  \\n\\n  return triplets\\n}\\n\\nfunc foundPair(diff int, l, r *int, nums *[]int) bool {\\n  value := (*nums)[*r] - (*nums)[*l]\\n\\n  if diff > value {\\n    *r++\\n\\n    return false\\n  }\\n\\n  if diff < value {\\n    *l++\\n\\n    return false\\n  }\\n\\n  return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596650,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans = 0 ;\\n      \\n        for(int i=0 ;i<nums.size()-2 ;i++){\\n            int count = 0 ;\\n            for(int j=i+1 ; j<nums.size() ;j++){\\n                 \\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count==2){\\n                ans++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans = 0 ;\\n      \\n        for(int i=0 ;i<nums.size()-2 ;i++){\\n            int count = 0 ;\\n            for(int j=i+1 ; j<nums.size() ;j++){\\n                 \\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3576270,
                "title": "faster-than-100-c-very-easy-logic-with-explanation",
                "content": "**Proof :**_please upvote if you liked my solution_\\n![image](https://assets.leetcode.com/users/images/5a09d233-c846-4b86-9c48-d5ec8f70b000_1685382160.8579662.png)\\n\\n**Logic:** \\nIf you have attempted 2sum leetcode question this code will be quite easy for you.The simple logic behind the code is that there for every element **i**, if there are elements **i+diff** and **i+diff+diff**  in the array then, they form an arithmetic triplet.we only need to make sure that all the three elements do not share same indexes in the array.There is no chance of triplets repeating as we are not iterating over the array again.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> map1; // Map to store the index of each number\\n        vector<int> ans; // Vector to store the indices of the arithmetic triplets\\n\\n        // Populating the map with the index of each number\\n        for (int i = 0; i < nums.size(); i++) {\\n            map1[nums[i]] = i;\\n        }\\n\\n        // Finding arithmetic triplets\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (map1.find(nums[i] + diff) != map1.end()) { // If nums[i]+diff exists in the map\\n                if (map1[nums[i] + diff] != i && map1.find(nums[i] + diff + diff) != map1.end()) { // If nums[i]+diff and nums[i]+diff+diff exist in the map\\n                    if (map1[nums[i] + diff + diff] != i && map1[nums[i] + diff + diff] != map1[nums[i] + diff]) { // If the indices are distinct\\n                        ans.push_back(i); // Pushing the indices of the arithmetic triplet\\n                        ans.push_back(map1[nums[i] + diff]);\\n                        ans.push_back(map1[nums[i] + diff + diff]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans.size() / 3; // Dividing the total number of indices by 3 to get the count of arithmetic triplets\\n    }\\n};\\n```\\n**Flowchart:**\\n\\n![image](https://assets.leetcode.com/users/images/09b61dc1-a487-4049-9208-f4834604f71a_1685382126.0904884.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int, int> map1; // Map to store the index of each number\\n        vector<int> ans; // Vector to store the indices of the arithmetic triplets\\n\\n        // Populating the map with the index of each number\\n        for (int i = 0; i < nums.size(); i++) {\\n            map1[nums[i]] = i;\\n        }\\n\\n        // Finding arithmetic triplets\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (map1.find(nums[i] + diff) != map1.end()) { // If nums[i]+diff exists in the map\\n                if (map1[nums[i] + diff] != i && map1.find(nums[i] + diff + diff) != map1.end()) { // If nums[i]+diff and nums[i]+diff+diff exist in the map\\n                    if (map1[nums[i] + diff + diff] != i && map1[nums[i] + diff + diff] != map1[nums[i] + diff]) { // If the indices are distinct\\n                        ans.push_back(i); // Pushing the indices of the arithmetic triplet\\n                        ans.push_back(map1[nums[i] + diff]);\\n                        ans.push_back(map1[nums[i] + diff + diff]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans.size() / 3; // Dividing the total number of indices by 3 to get the count of arithmetic triplets\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331251,
                "title": "c-easy-solution-with-loops",
                "content": "\\n# Complexity\\n- Time complexity: 6 ms.Beats 65.9% solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:8.6 Mb.Beats 88.98% solutions.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++)\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                if(nums[j]-nums[i]==diff){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[j]-nums[i]==diff and nums[k]-nums[j]==diff)\\n                    count++;\\n                 }\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++)\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                if(nums[j]-nums[i]==diff){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[j]-nums[i]==diff and nums[k]-nums[j]==diff)\\n                    count++;\\n                 }\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331229,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: 89 ms.Beats 66.24% of other solutions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 38.1 Mb.Beats 85.99% of others.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int count=0;\\n    public int ArithmeticTriplets(int[] nums, int diff) {\\n        for(int i=0;i<nums.Length-2;i++)\\n            for(int j=i+1;j<nums.Length-1;j++){\\n                if(nums[j]-nums[i]==diff){\\n                    for(int k=j+1;k<nums.Length;k++){\\n                        if(nums[k]-nums[j]==diff)\\n                        count++;\\n                    }\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int count=0;\\n    public int ArithmeticTriplets(int[] nums, int diff) {\\n        for(int i=0;i<nums.Length-2;i++)\\n            for(int j=i+1;j<nums.Length-1;j++){\\n                if(nums[j]-nums[i]==diff){\\n                    for(int k=j+1;k<nums.Length;k++){\\n                        if(nums[k]-nums[j]==diff)\\n                        count++;\\n                    }\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235456,
                "title": "java-1ms-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int x = 0;\\n        int l = 0;\\n        int  k;\\n        for (int i = 0; i < nums.length; i++) {\\n            k = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[j] - k == diff) {\\n                    x++;\\n                    k = nums[j];\\n                }\\n                if(x == 2){\\n                    l++;\\n                    break;\\n                }\\n            }\\n            x = 0;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int x = 0;\\n        int l = 0;\\n        int  k;\\n        for (int i = 0; i < nums.length; i++) {\\n            k = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[j] - k == diff) {\\n                    x++;\\n                    k = nums[j];\\n                }\\n                if(x == 2){\\n                    l++;\\n                    break;\\n                }\\n            }\\n            x = 0;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107773,
                "title": "hashset-n-diff-and-n-2-diff",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen=set()\\n        c=0\\n        for n in nums:\\n            seen.add(n)\\n            if n-diff in seen and n-2*diff in seen:\\n                c+=1\\n        return c\\n        \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen=set()\\n        c=0\\n        for n in nums:\\n            seen.add(n)\\n            if n-diff in seen and n-2*diff in seen:\\n                c+=1\\n        return c\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896991,
                "title": "java-solution-using-hashset",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n         for(int n: nums){\\n           set.add(n);\\n         }\\n         int count =0;\\n         for(int n:nums){\\n             if(set.contains(n+diff) && set.contains(n+(2*diff)))\\n             count++;\\n         }\\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n         for(int n: nums){\\n           set.add(n);\\n         }\\n         int count =0;\\n         for(int n:nums){\\n             if(set.contains(n+diff) && set.contains(n+(2*diff)))\\n             count++;\\n         }\\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675213,
                "title": "100-faster-c-simple",
                "content": "![image](https://assets.leetcode.com/users/images/1408c3f5-e53c-4766-adc5-f66963609103_1665212620.8311636.png)\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        vector<int> hash(305,0); // for storing cnt of each element in the array\\n        for(int i = 0 ; i < nums.size();i++){\\n            hash[nums[i]]++; // storing cnt\\n        }\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.size();i++){\\n             if(hash[nums[i] + diff] > 0 && hash[nums[i] + diff + diff] > 0) // as array is sorted - > ![image](https://assets.leetcode.com/users/images/524cf4f9-57df-4ee6-9a86-567aa16b69c1_1665212577.6177518.png)\\ni < j < k for all nums[i] < nums[j] < nums[j] \\n                  sum++; \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        vector<int> hash(305,0); // for storing cnt of each element in the array\\n        for(int i = 0 ; i < nums.size();i++){\\n            hash[nums[i]]++; // storing cnt\\n        }\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.size();i++){\\n             if(hash[nums[i] + diff] > 0 && hash[nums[i] + diff + diff] > 0) // as array is sorted - > ![image](https://assets.leetcode.com/users/images/524cf4f9-57df-4ee6-9a86-567aa16b69c1_1665212577.6177518.png)\\ni < j < k for all nums[i] < nums[j] < nums[j] \\n                  sum++; \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583168,
                "title": "python-o-n-log-n-time-o-1-space-solution-with-comments",
                "content": "Here is my optimized code that has:\\nTime: O(n log n)\\nSpace: O(1)\\n\\n```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n-2):\\n            num0 = nums[i]  # current num\\n            num1 = num0 + diff  # expected nums[j]\\n            j = bisect_left(nums, num1, i+1, n-1)  # time cost O(log n)\\n            if num1 != nums[j]:  # num1 not found\\n                continue\\n            num2 = num1 + diff  # expected nums[k]\\n            k = bisect_left(nums, num2, j+1, n)\\n            if k==n or num2 != nums[k]:  # num2 not found\\n                continue\\n            ans += 1  # triplet i,j,k is good\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n-2):\\n            num0 = nums[i]  # current num\\n            num1 = num0 + diff  # expected nums[j]\\n            j = bisect_left(nums, num1, i+1, n-1)  # time cost O(log n)\\n            if num1 != nums[j]:  # num1 not found\\n                continue\\n            num2 = num1 + diff  # expected nums[k]\\n            k = bisect_left(nums, num2, j+1, n)\\n            if k==n or num2 != nums[k]:  # num2 not found\\n                continue\\n            ans += 1  # triplet i,j,k is good\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2562600,
                "title": "simple-java-code",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            int j=i+1,check=0;\\n            while(j<nums.length){\\n                if(nums[j]-nums[i]==diff){\\n                    check=1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(check==1){\\n                int temp =nums[j];\\n                j=j+1;\\n                while(j<nums.length){\\n                    if(nums[j]-temp==diff)count++;\\n                j++;\\n                }\\n                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            int j=i+1,check=0;\\n            while(j<nums.length){\\n                if(nums[j]-nums[i]==diff){\\n                    check=1;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if(check==1){\\n                int temp =nums[j];\\n                j=j+1;\\n                while(j<nums.length){\\n                    if(nums[j]-temp==diff)count++;\\n                j++;\\n                }\\n                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547534,
                "title": "python-linear-fast-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        # a variable to store number of triplets\\n        # initializing with 0\\n        counterOfUniqueArithmeticTriplet = 0\\n        \\n        # create a set of number in the nums list\\n        _set = set(nums)\\n        \\n         # for each num in nums \\n        # we will try to find if we have num - diff in the _set\\n        # and we also have num + diff in the set\\n        # if we have both that makes a triplet for us\\n        # Example from Input: nums = [0,1,4,6,7,10], diff = 3\\n        # when num = 4,\\n        # remaining = 4 - diff => 4 - 3 = 1\\n        # nextToFind = 4 + diff => 4 + 3 = 7\\n        # and both are present in nums, we can increment counterOfUniqueArithmeticTriplet\\n        # as we have found a unique triplet\\n        for num in nums:\\n            remaining = num - diff\\n            nextToFind = num + diff\\n            \\n            # if both are in nums we increment counterOfUniqueArithmeticTriplet\\n            if remaining in nums and nextToFind in nums:\\n                counterOfUniqueArithmeticTriplet += 1\\n        return counterOfUniqueArithmeticTriplet\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        \\n        # a variable to store number of triplets\\n        # initializing with 0\\n        counterOfUniqueArithmeticTriplet = 0\\n        \\n        # create a set of number in the nums list\\n        _set = set(nums)\\n        \\n         # for each num in nums \\n        # we will try to find if we have num - diff in the _set\\n        # and we also have num + diff in the set\\n        # if we have both that makes a triplet for us\\n        # Example from Input: nums = [0,1,4,6,7,10], diff = 3\\n        # when num = 4,\\n        # remaining = 4 - diff => 4 - 3 = 1\\n        # nextToFind = 4 + diff => 4 + 3 = 7\\n        # and both are present in nums, we can increment counterOfUniqueArithmeticTriplet\\n        # as we have found a unique triplet\\n        for num in nums:\\n            remaining = num - diff\\n            nextToFind = num + diff\\n            \\n            # if both are in nums we increment counterOfUniqueArithmeticTriplet\\n            if remaining in nums and nextToFind in nums:\\n                counterOfUniqueArithmeticTriplet += 1\\n        return counterOfUniqueArithmeticTriplet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546438,
                "title": "brute-force-solution-of-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int arithmeticTriplets(int[] nums, int diff) {\\n\\t\\t   int count = 0;\\n\\t\\t\\tfor(int i= 0; i< nums.length ; i++){\\n\\t\\t\\t\\tfor( int j = i+1; j < nums.length ; j++){\\n\\t\\t\\t\\t\\tfor( int k = j+1; k < nums.length ; k++){\\n\\t\\t\\t\\t\\t\\tif(i < j && j < k &&\\n\\t\\t\\t\\t\\t\\t  nums[j] - nums[i] == diff &&\\n\\t\\t\\t\\t\\t\\t  nums[k] - nums[j] == diff){\\n\\t\\t\\t\\t\\t\\t   count++;   \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int arithmeticTriplets(int[] nums, int diff) {\\n\\t\\t   int count = 0;\\n\\t\\t\\tfor(int i= 0; i< nums.length ; i++){\\n\\t\\t\\t\\tfor( int j = i+1; j < nums.length ; j++){\\n\\t\\t\\t\\t\\tfor( int k = j+1; k < nums.length ; k++){\\n\\t\\t\\t\\t\\t\\tif(i < j && j < k &&\\n\\t\\t\\t\\t\\t\\t  nums[j] - nums[i] == diff &&\\n\\t\\t\\t\\t\\t\\t  nums[k] - nums[j] == diff){\\n\\t\\t\\t\\t\\t\\t   count++;   \\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2544913,
                "title": "fully-explained-o-n-3-o-n-2-and-o-n-solutions",
                "content": "## **1. O(n^3)**\\n\\nThe straightforward way is to have three nested loops and then check the conditions. But ofcourse this won\\'t be an efficient approach and will give TLE in case of large input. \\n\\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0;\\n        for i,num1 in enumerate(nums):\\n            for j,num2 in enumerate(nums):\\n                for k, num3 in enumerate(nums):\\n                    if(i < j and j < k): \\n                        if(num2 - num1 == diff and num3 - num2 == diff): count += 1\\n        \\n        return count\\n```\\n\\n## **2. O(n^2)**\\n\\nTo make the code more efficient, what we can do is maintain a set of all the elements.\\n\\ne.g. nums = [0,1,4,6,7,10], diff = 3\\n\\nSo we will have a set = {0,1,4,6,7,10}\\n\\t\\nAnd now, instead of three nested loops, we can have only two. Such that when we got a pair with a difference of 3, then we can check if a set contains any element that can be the third number to make it a triplet. \\n\\t\\ne.g. if first loop currently points to number = 1 And second loop points to number = 4 then we see their diff is 3 which is same as the diff we want\\n\\t\\t So now, all we want is to find a third number such that \\n\\t\\t\\t 4 - third number = diff\\n\\t\\tSo, rearranging this equation, we get \\n\\t\\t\\t4 + diff = thirdNumber\\n\\t\\t\\t\\nHence, we seach in the set whether (4 + diff) is present or not.\\n\\t\\t\\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\tcount = 0\\n\\ts = set(nums)\\n\\n\\tfor i, num1 in enumerate(nums):\\n\\t\\tfor j, num2 in enumerate(nums):\\n\\t\\t\\tif(i != j and num2 - num1 == diff):\\n\\t\\t\\t\\tif((diff + num2) in s): count += 1\\n\\treturn count\\n```\\n\\n## **3. O(n) - Using Largest value of triplet to find other two values**\\n\\nI couldn\\'t think of this solution so had to head over to the dicussion page to see how can we do this problem with O(n) complexity. \\n\\n[votrubac](https://leetcode.com/votrubac) shared a beautiful approach where we are using the largest value of a triplet to find the other two values and if both exist in the array, then we have a valid triplet.\\n\\nSo, we will use arr[k] to get back arr[j] and arr[i]\\n\\nWE are given that :\\n\\t\\n\\t\\tarr[j] - arr[i] = diff  && arr[k] - arr[j] = diff\\n\\t\\nSo, from arr[k] - arr[j] = diff, we get: \\n\\t\\t\\n\\t\\tarr[j] = arr[k] - diff    // This will be the formula to get arr[j] using arr[k] ---- (a)\\n\\nNow, if we substitute this value of arr[j] in arr[j] - arr[i] = diff:\\n\\tarr[k] - diff - arr[i] = diff\\n\\tarr[i] = arr[k]  - diff - diff\\n\\t\\n\\t\\tarr[i] = arr[k] - (2 * diff)  // This will be the formula to get arr[i] using arr[k] ---- (b)\\n\\t\\n\\nSo we will use (a) and (b) to get values of other two values of a triplet for a particular number.\\n\\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num3 in enumerate(nums):\\n            num2 = num3 - diff\\n            num1 = num3 - (2 * diff)\\n            if(num1 in s and num2 in s): count += 1\\n                \\n        return count\\n```\\n\\n\\n\\n## **4. O(n) - Using smallest value of triplet to find other two values**\\n\\nSo, if we can use the largest number to get back the other two numbers, can we do the other way around as well? Lets try to use the smallest number of a triplet to find other two numbers i.e., using a[i] to find a[j] and a[k]\\n\\nFirst condition is \\n\\t\\t\\n\\t\\tarr[j] - arr[i] = diff\\n\\nFrom this we get\\n\\t\\n\\t\\tarr[j] = arr[i] + diff //This is how we will find arr[j] using arr[i]   -----  (a)\\n\\t\\nAnd the second condition is \\n\\t\\n\\t\\tarr[k] - arr[j] = diff\\n\\t\\t\\nSubstituting the value of arr[j] from (a) \\n\\t\\n\\t\\tarr[k] - (arr[i] + diff) = diff\\n\\t\\tarr[k] - arr[i] - diff = diff\\n\\t\\tarr[k] = diff + arr[i] + diff\\n\\t\\tarr[k] = (2 * diff) + arr[i]  //This is how we will find arr[k] using arr[i] ------ (b)\\n\\t\\t\\nSo, we will use (a) and (b) to get the other two values in the triplet using the smallest value of triplet.\\n\\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num1 in enumerate(nums):\\n            num2 = num1 + diff\\n            num3 = num1 + (2 * diff)\\n            if(num2 in s and num3 in s): count += 1\\n\\t\\t\\t\\n        return count\\n```\\n\\n\\n## **5. O(n) - Using middle value of triplet to find other two values**\\n\\nSo we were able to use the smallest and the largest value in a triplet to find other two values. Can we now use the middle element i.e., arr[j] to get back other two numbers in triplet? Let\\'s see.\\n\\nFirst condition is \\n\\t\\t\\n\\t\\tarr[j] - arr[i] = diff\\n\\nFrom this we get\\n\\t\\n\\t\\tarr[i] = arr[j] - diff //This is how we will find arr[i] using arr[j]   -----  (a)\\n\\t\\nAnd the second condition is \\n\\t\\n\\t\\tarr[k] - arr[j] = diff\\n\\t\\t\\nThis gives us: \\n\\t\\n\\t\\tarr[k] = arr[j] + diff //This is how we will find arr[k] using arr[j]   -----  (b)\\n\\t\\t\\nSo, we will use (a) and (b) to get the other two values in the triplet using the middle value of triplet.\\n\\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num2 in enumerate(nums):\\n            num1 = num2 - diff\\n            num3 = num2 + diff\\n            if(num1 in s and num3 in s): count += 1\\n                \\n        return count\\n```\\n\\n\\nPHEW! That was a lot to write but all thanks to [votrubac](https://leetcode.com/votrubac) for the O(n) approach. Here is his post -> https://leetcode.com/problems/number-of-arithmetic-triplets/discuss/2390637/Check-n-diff-and-n-2-*-diff",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0;\\n        for i,num1 in enumerate(nums):\\n            for j,num2 in enumerate(nums):\\n                for k, num3 in enumerate(nums):\\n                    if(i < j and j < k): \\n                        if(num2 - num1 == diff and num3 - num2 == diff): count += 1\\n        \\n        return count\\n```\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\tcount = 0\\n\\ts = set(nums)\\n\\n\\tfor i, num1 in enumerate(nums):\\n\\t\\tfor j, num2 in enumerate(nums):\\n\\t\\t\\tif(i != j and num2 - num1 == diff):\\n\\t\\t\\t\\tif((diff + num2) in s): count += 1\\n\\treturn count\\n```\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num3 in enumerate(nums):\\n            num2 = num3 - diff\\n            num1 = num3 - (2 * diff)\\n            if(num1 in s and num2 in s): count += 1\\n                \\n        return count\\n```\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num1 in enumerate(nums):\\n            num2 = num1 + diff\\n            num3 = num1 + (2 * diff)\\n            if(num2 in s and num3 in s): count += 1\\n\\t\\t\\t\\n        return count\\n```\n```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count = 0\\n        s = set(nums)\\n        \\n        for i, num2 in enumerate(nums):\\n            num1 = num2 - diff\\n            num3 = num2 + diff\\n            if(num1 in s and num3 in s): count += 1\\n                \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2519100,
                "title": "c-0ms-solution-using-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n       \\n        int count = 0;\\n        \\n        for(int i = 0 ; i<nums.size()-2 ; i++)\\n        {\\n           int j = i+1 ;\\n            while(j<nums.size()-1 && nums[j]-nums[i] < diff)\\n                j++;           \\n            \\n            if( j== nums.size()-1 || nums[j]-nums[i] != diff)\\n                continue;\\n            \\n            int k = j+1;\\n            \\n            while(k<nums.size() && nums[k]-nums[j] < diff)\\n                k++;\\n            \\n            if(k < nums.size() && nums[k] - nums[j] == diff)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e58a0d68-d248-4019-9eb4-a63d9d8c7d1f_1662123854.7306361.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n       \\n        int count = 0;\\n        \\n        for(int i = 0 ; i<nums.size()-2 ; i++)\\n        {\\n           int j = i+1 ;\\n            while(j<nums.size()-1 && nums[j]-nums[i] < diff)\\n                j++;           \\n            \\n            if( j== nums.size()-1 || nums[j]-nums[i] != diff)\\n                continue;\\n            \\n            int k = j+1;\\n            \\n            while(k<nums.size() && nums[k]-nums[j] < diff)\\n                k++;\\n            \\n            if(k < nums.size() && nums[k] - nums[j] == diff)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458261,
                "title": "java-beats-69-lol-easy-and-simple-solution",
                "content": "```\\nint ans = 0;\\n        //we take an answer that we will be returning ;\\n        \\n        for(int i = nums.length-1 ; i >=0  ; i--){//for the first element of the triplet\\n          \\n            meow :\\n            for(int j = nums.length-1 ; j >=0  ; j--){//for the second element of the triplet ;\\n             if(nums[i] - nums[j] == diff){\\n                 for(int k = j ; k >= 0 ; k --){//for the third element of triplet ;\\n                     if(nums[j] - nums[k] == diff){\\n                         ans++ ;\\n                         break meow ;//breaks and starts for another first element because we want triplet only ;\\n                     }\\n                 }\\n             }\\n          }\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nint ans = 0;\\n        //we take an answer that we will be returning ;\\n        \\n        for(int i = nums.length-1 ; i >=0  ; i--){//for the first element of the triplet\\n          \\n            meow :\\n            for(int j = nums.length-1 ; j >=0  ; j--){//for the second element of the triplet ;\\n             if(nums[i] - nums[j] == diff){\\n                 for(int k = j ; k >= 0 ; k --){//for the third element of triplet ;\\n                     if(nums[j] - nums[k] == diff){\\n                         ans++ ;\\n                         break meow ;//breaks and starts for another first element because we want triplet only ;\\n                     }\\n                 }\\n             }\\n          }\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2426088,
                "title": "java-solution-simple-solution",
                "content": "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int x : nums) {\\n            set.add(x);\\n        }\\n        \\n        int ans = 0;\\n        for (int x : nums) {\\n            if (set.contains(x - diff) && set.contains(x + diff)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int x : nums) {\\n            set.add(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2416232,
                "title": "java-o-n-beats-100-0ms-3-pointers",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int p1=0;\\n        int p2=1;\\n        int p3=2;\\n        int count=0;\\n        while(p3<nums.length){\\n            int compare = nums[p2]-nums[p1];\\n            if(compare==diff){\\n                compare = nums[p3]-nums[p2];\\n                if(compare==diff){\\n                    p1++;\\n                    p2++;\\n                    p3++;\\n                    count++;\\n                }else if(compare<diff){\\n                    p3++;\\n                }else{\\n                    p1++;\\n                    p2++;\\n                    p3=Math.max(p3, p2+1);\\n                }\\n            }else if(compare<diff){\\n                    p2++;\\n                    p3=Math.max(p3, p2+1);\\n            }else{\\n                p1++;\\n                p2=Math.max(p2, p1+1);\\n                p3=Math.max(p3, p2+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int p1=0;\\n        int p2=1;\\n        int p3=2;\\n        int count=0;\\n        while(p3<nums.length){\\n            int compare = nums[p2]-nums[p1];\\n            if(compare==diff){\\n                compare = nums[p3]-nums[p2];\\n                if(compare==diff){\\n                    p1++;\\n                    p2++;\\n                    p3++;\\n                    count++;\\n                }else if(compare<diff){\\n                    p3++;\\n                }else{\\n                    p1++;\\n                    p2++;\\n                    p3=Math.max(p3, p2+1);\\n                }\\n            }else if(compare<diff){\\n                    p2++;\\n                    p3=Math.max(p3, p2+1);\\n            }else{\\n                p1++;\\n                p2=Math.max(p2, p1+1);\\n                p3=Math.max(p3, p2+1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410795,
                "title": "java-easy-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n      int count = 0;\\n      HashSet<Integer> set = new HashSet<>();\\n       for(int num : nums) {\\n         if(set.contains(num - diff) && set.contains(num - diff * 2))\\n           count ++;\\n         \\n         set.add(num);\\n       }\\n      return count;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n      int count = 0;\\n      HashSet<Integer> set = new HashSet<>();\\n       for(int num : nums) {\\n         if(set.contains(num - diff) && set.contains(num - diff * 2))\\n           count ++;\\n         \\n         set.add(num);\\n       }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410146,
                "title": "2-javascript-solutions-both-faster-than-100-00-memory-less-than-100-00",
                "content": "```\\nvar arithmeticTriplets = function(nums, diff) {\\n    //Approach 2 using Map - TC:O(N) SC:O(N)\\n    let count = 0;\\n    \\n    let map = new Map();\\n    for(let i=0; i<nums.length; i++)\\n        map.set(nums[i],1);\\n    \\n    for(let i = 0; i<nums.length; i++){\\n        let curr = nums[i];\\n        if(map.has(curr+diff) && map.has(curr+diff+diff))\\n            count++;\\n    }\\n    return count;\\n    \\n    \\n    //Approach 1 using Binary Search- TC:O(NLogN) SC:O(1)\\n    /*\\n    let count = 0;\\n    let end = nums.length-1;\\n    \\n    function BinarySearch(s,num,e){\\n        \\n        while(s<=e){\\n            let mid = Math.floor((s+e)/2);\\n            if(nums[mid] > num)\\n                e--;\\n            else if(nums[mid] < num)\\n                s++;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    \\n    for(let i = 0; i<nums.length-2; i++){\\n        \\n        let n = diff+nums[i];\\n        \\n        let index = BinarySearch(i+1, n,end);\\n        \\n        if(index != -1){\\n            let secondIndex = BinarySearch(index+1,nums[index]+diff,end);\\n            if(secondIndex!= -1)\\n                count++;\\n        }\\n    }\\n    \\n    return count;\\n    */\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nvar arithmeticTriplets = function(nums, diff) {\\n    //Approach 2 using Map - TC:O(N) SC:O(N)\\n    let count = 0;\\n    \\n    let map = new Map();\\n    for(let i=0; i<nums.length; i++)\\n        map.set(nums[i],1);\\n    \\n    for(let i = 0; i<nums.length; i++){\\n        let curr = nums[i];\\n        if(map.has(curr+diff) && map.has(curr+diff+diff))\\n            count++;\\n    }\\n    return count;\\n    \\n    \\n    //Approach 1 using Binary Search- TC:O(NLogN) SC:O(1)\\n    /*\\n    let count = 0;\\n    let end = nums.length-1;\\n    \\n    function BinarySearch(s,num,e){\\n        \\n        while(s<=e){\\n            let mid = Math.floor((s+e)/2);\\n            if(nums[mid] > num)\\n                e--;\\n            else if(nums[mid] < num)\\n                s++;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    \\n    for(let i = 0; i<nums.length-2; i++){\\n        \\n        let n = diff+nums[i];\\n        \\n        let index = BinarySearch(i+1, n,end);\\n        \\n        if(index != -1){\\n            let secondIndex = BinarySearch(index+1,nums[index]+diff,end);\\n            if(secondIndex!= -1)\\n                count++;\\n        }\\n    }\\n    \\n    return count;\\n    */\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402462,
                "title": "o-n-3-solution-for-beginners",
                "content": "```\\n\\nlet arr = []\\n    for (let i=0;i<=nums.length-3;i++){\\n        for(let j=i+1;j<=nums.length-2;j++){\\n            for(let k = j+1;k<=nums.length-1;k++){\\n                if(nums[j]-nums[i]==diff && nums[k]-nums[j]==diff){\\n                    arr.push([nums[i],nums[j],nums[k]]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.length;\\n\\t\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nlet arr = []\\n    for (let i=0;i<=nums.length-3;i++){\\n        for(let j=i+1;j<=nums.length-2;j++){\\n            for(let k = j+1;k<=nums.length-1;k++){\\n                if(nums[j]-nums[i]==diff && nums[k]-nums[j]==diff){\\n                    arr.push([nums[i],nums[j],nums[k]]);\\n                }\\n            }\\n        }\\n    }\\n    return arr.length;\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401700,
                "title": "java-easy-solution-using-2-pointer",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n            \\n        }\\n \\n        int i = 0;\\n        int j = 1;\\n        int count = 0;\\n        while(i<=j&&j<nums.length)\\n        {\\n    \\n            if(nums[j]-nums[i]<diff)\\n            {\\n                 System.out.println(\"diff< \"+nums[i]+\"-\"+nums[j]);\\n               j++;\\n            }\\n            else if(nums[j]-nums[i]>diff)\\n            {\\n             \\n               i++;\\n            }\\n            else\\n            {\\n                \\n              if(set.contains(nums[j]+diff))\\n              {\\n                 count++;\\n                  \\n                  \\n              }\\n              \\n                    i++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```\\nWe havce used 2 pointer approach along woth hashset\\n1st we declare a hashset and add all the elements of nums array in it\\nlets take an example :\\nA= [0,1,4,6,7,10] and diff = 3\\n\\nintially i = 0; and j = 1\\n we will run loop while(i is less than or equal to j)\\n \\n 1. i = 0 j = 1\\n     a[j]-a[i] = 1-0 = 1 <diff \\n\\t so j++ since there is still a possibility of a[j]-a[i] being equal to diff since array is sorted in increasing order\\n2. i = 0 j = 2\\n     a[j]-a[i]= 4-0 = 4>3  so i++ since now there is no possibility of a triplet having 0 since difference will only               increase from here so \\n3. i = 1 j = 2\\n   a[j] - a[i] = 4-1 = 3 = diff so now check if a[j]+diff i.e 7 is present in set or not\\n   if yes  then we increase count++\\n   \\n  i++ and j++ count = 1\\n4. i = 2 j = 3 \\n   a[3]-a[2] = 6-4<diff so j++\\n 5. i = 2 j = 4 \\n    7-4 = diff and there is 7+diff i.e 10 present in set Hashset so count++\\n   so i++ j++ count = 2\\n 6. i = 3 j = 4\\n    7-6<diff so j++\\n7. i = 3 j = 5 \\n   10-6>diff so i++\\n8.i = 4 j = 5\\n   10-7 = diff but 10+diff i.e 13 not present in set so dont increase count\\n   i++ j++\\n9 j >=nums.length so exit loop\\n\\nhence final ans = 2",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            set.add(nums[i]);\\n            \\n        }\\n \\n        int i = 0;\\n        int j = 1;\\n        int count = 0;\\n        while(i<=j&&j<nums.length)\\n        {\\n    \\n            if(nums[j]-nums[i]<diff)\\n            {\\n                 System.out.println(\"diff< \"+nums[i]+\"-\"+nums[j]);\\n               j++;\\n            }\\n            else if(nums[j]-nums[i]>diff)\\n            {\\n             \\n               i++;\\n            }\\n            else\\n            {\\n                \\n              if(set.contains(nums[j]+diff))\\n              {\\n                 count++;\\n                  \\n                  \\n              }\\n              \\n                    i++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397271,
                "title": "java-solution-with-explain-equation",
                "content": "As follow to the requirement of the problem: \\nWe have: **nums[j] - nums[i] == diff** and **nums[k] - nums[j] == diff**\\nFrom that we have equation:\\n=> nums[j] == diff + nums[i]\\n<=> nums[k] - nums[j] == diff\\n<=> nums[k] - diff - nums[i] = diff;\\n<=> nums[i] = nums[k] - 2diff\\n\\nFrom that we will check if the set contains contains num-diff and the next is num-2*diff as follow to the equations above\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        int result = 0;\\n        for(int num : nums){\\n            if(set.contains(num-diff) && set.contains(num-2* diff)){\\n                result++;\\n            }\\n            set.add(num);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> set = new HashSet<>();\\n        int result = 0;\\n        for(int num : nums){\\n            if(set.contains(num-diff) && set.contains(num-2* diff)){\\n                result++;\\n            }\\n            set.add(num);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393978,
                "title": "easy-understanding-map-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            if(mp.find(nums[i]-diff)!=mp.end() && mp.find(nums[i]-2*diff)!=mp.end())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            if(mp.find(nums[i]-diff)!=mp.end() && mp.find(nums[i]-2*diff)!=mp.end())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392850,
                "title": "c-hash-map-p-diff-and-p-2-diff-brute-force",
                "content": "Hash Map approach\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> dp;\\n        int res=0;\\n        for(auto i:nums) \\n            if((dp[i]=dp[i-diff]+1)>=3) res++;\\n        return res;\\n    }\\n};\\n```\\n[p - diff] and [p - 2 * diff] \\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count[201] = {}, it = 0;\\n        for (auto p : nums) {\\n            if (p >= 2 * diff)\\n                it += count[p - diff] && count[p - 2 * diff];\\n            count[p] = true;\\n        }\\n        return it;\\n    }\\n};\\n```\\nBrute Force approach\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[j]-nums[i])==diff && (nums[k]-nums[j])==diff){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> dp;\\n        int res=0;\\n        for(auto i:nums) \\n            if((dp[i]=dp[i-diff]+1)>=3) res++;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count[201] = {}, it = 0;\\n        for (auto p : nums) {\\n            if (p >= 2 * diff)\\n                it += count[p - diff] && count[p - 2 * diff];\\n            count[p] = true;\\n        }\\n        return it;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[j]-nums[i])==diff && (nums[k]-nums[j])==diff){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390909,
                "title": "secret-python-answer-binary-search-right-and-left",
                "content": "````\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        t = len(nums)\\n\\n        def binary_search(arr, low, high, x):\\n \\n            if high >= low:\\n\\n                mid = (high + low) // 2\\n\\n                if arr[mid] == x:\\n                    return mid\\n\\n\\n                elif arr[mid] > x:\\n                    return binary_search(arr, low, mid - 1, x)\\n\\n                else:\\n                    return binary_search(arr, mid + 1, high, x)\\n\\n            else:\\n                return -1\\n \\n        count = 0\\n        for i,n in enumerate(nums):\\n            if binary_search(nums, 0, i-1, n-diff) != -1  and binary_search(nums, i+1, t-1,n + diff) != -1:\\n                count+=1\\n        \\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        t = len(nums)\\n\\n        def binary_search(arr, low, high, x):\\n \\n            if high >= low:\\n\\n                mid = (high + low) // 2\\n\\n                if arr[mid] == x:\\n                    return mid\\n\\n\\n                elif arr[mid] > x:\\n                    return binary_search(arr, low, mid - 1, x)\\n\\n                else:\\n                    return binary_search(arr, mid + 1, high, x)\\n\\n            else:\\n                return -1\\n \\n        count = 0\\n        for i,n in enumerate(nums):\\n            if binary_search(nums, 0, i-1, n-diff) != -1  and binary_search(nums, i+1, t-1,n + diff) != -1:\\n                count+=1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2390832,
                "title": "c-binary-search-for-nums-i-diff-and-nums-i-2-diff",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        for(int i = 0 ; i < size(nums) ; ++i ){\\n            int id1 = lower_bound(begin(nums),end(nums),nums[i] + diff) - begin(nums) ;\\n            int id2 = lower_bound(begin(nums),end(nums),nums[i] + diff + diff) - begin(nums) ;\\n            \\n            if(id1 < size(nums) and nums[id1] == nums[i] + diff){\\n                if(id2 < size(nums) and nums[id2] == nums[i] + diff + diff) ++ans ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        for(int i = 0 ; i < size(nums) ; ++i ){\\n            int id1 = lower_bound(begin(nums),end(nums),nums[i] + diff) - begin(nums) ;\\n            int id2 = lower_bound(begin(nums),end(nums),nums[i] + diff + diff) - begin(nums) ;\\n            \\n            if(id1 < size(nums) and nums[id1] == nums[i] + diff){\\n                if(id2 < size(nums) and nums[id2] == nums[i] + diff + diff) ++ans ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390694,
                "title": "easiest-most-efficient-binary-search-based-approach-c",
                "content": "The idea is to take the start and end of the binary search space as the indices of first and last element of the triplet and apply the binary search to find the middle element of the triplet.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int diff, vector<int>& arr) {\\n    int start=0, end=0;\\n    int count=0;\\n    while(start<=end && end<arr.size()){\\n        if(arr[end]-arr[start]==2*diff){\\n            if(binary_search(&arr[start], &arr[end], arr[start]+diff)){\\n                count++;\\n            }\\n            start++;\\n        }else if(arr[end]-arr[start]<2*diff){\\n            end++;\\n        }else{\\n            start++;\\n        }\\n    }\\n    return count;\\n}\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        return solve(diff, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int diff, vector<int>& arr) {\\n    int start=0, end=0;\\n    int count=0;\\n    while(start<=end && end<arr.size()){\\n        if(arr[end]-arr[start]==2*diff){\\n            if(binary_search(&arr[start], &arr[end], arr[start]+diff)){\\n                count++;\\n            }\\n            start++;\\n        }else if(arr[end]-arr[start]<2*diff){\\n            end++;\\n        }else{\\n            start++;\\n        }\\n    }\\n    return count;\\n}\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        return solve(diff, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390597,
                "title": "python-using-pointer",
                "content": "* Start with `i` index\\n* Find the `j` index : `nums[j] - nums[i] <= diff` until this condition satisfies increment `j`\\n* If the value is **greater than diff** skip the `i` index\\n* Else if the value is **equal to diff** find the` k` index \\n* By `k = j + 1` until there is a match `nums[k] - nums[j] == diff` increment *ans*\\n\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\tans = 0\\n\\n\\tfor i in range(len(nums)-2):\\n\\t\\tj = i+1\\n\\t\\twhile(nums[j] - nums[i] < diff and j < len(nums)-2):\\n\\t\\t\\tj+=1\\n\\n\\t\\tif((nums[j] - nums[i])== diff):\\n\\t\\t\\tk = j+1\\n\\t\\t\\twhile(k<len(nums) and nums[k] - nums[j] <= diff):\\n\\t\\t\\t\\tif(nums[k] - nums[j] == diff):\\n\\t\\t\\t\\t\\tans+=1;\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk+=1  \\n\\n\\treturn ans\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "* Start with `i` index\\n* Find the `j` index : `nums[j] - nums[i] <= diff` until this condition satisfies increment `j`\\n* If the value is **greater than diff** skip the `i` index\\n* Else if the value is **equal to diff** find the` k` index \\n* By `k = j + 1` until there is a match `nums[k] - nums[j] == diff` increment *ans*\\n\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\tans = 0\\n\\n\\tfor i in range(len(nums)-2):\\n\\t\\tj = i+1\\n\\t\\twhile(nums[j] - nums[i] < diff and j < len(nums)-2):\\n\\t\\t\\tj+=1\\n\\n\\t\\tif((nums[j] - nums[i])== diff):\\n\\t\\t\\tk = j+1\\n\\t\\t\\twhile(k<len(nums) and nums[k] - nums[j] <= diff):\\n\\t\\t\\t\\tif(nums[k] - nums[j] == diff):\\n\\t\\t\\t\\t\\tans+=1;\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk+=1  \\n\\n\\treturn ans\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2390510,
                "title": "easy-optimised-solution-with-intuition-o-n",
                "content": "**The Idea is based on that if we Know the first element of arithematic sequence and common difference then we can obtain the whole sequence.**\\n\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        unordered_map<int,int>idx;\\n        for(int i=n-1;i>=0;i--){\\n            if(!idx.count(nums[i])){\\n                idx[nums[i]]=i;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int first=nums[i];\\n            int second=first+diff;\\n            int third=second+diff;\\n            if(idx.count(second) && idx.count(third) && idx[third]>idx[second]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n };\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        unordered_map<int,int>idx;\\n        for(int i=n-1;i>=0;i--){\\n            if(!idx.count(nums[i])){\\n                idx[nums[i]]=i;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int first=nums[i];\\n            int second=first+diff;\\n            int third=second+diff;\\n            if(idx.count(second) && idx.count(third) && idx[third]>idx[second]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390486,
                "title": "c-o-n-solution",
                "content": "Using unordered_map.\\nThis requires the strictly increasing property of the array.\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> count;\\n        int ans = 0;\\n        for (int num : nums) {\\n            count[num]++;\\n            ans += count[num - diff] * count[num - diff*2];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nUsing 2 vectors\\nThis does not require strictly increasing property, but only works for 0<= num[i] <= 200\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        vector<int> single(201), pair(201);\\n        int ans = 0;\\n        for (int num : nums) {\\n            single[num]++;\\n            if (num >= diff) {\\n                pair[num] += single[num - diff];\\n                ans += pair[num - diff];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> count;\\n        int ans = 0;\\n        for (int num : nums) {\\n            count[num]++;\\n            ans += count[num - diff] * count[num - diff*2];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        vector<int> single(201), pair(201);\\n        int ans = 0;\\n        for (int num : nums) {\\n            single[num]++;\\n            if (num >= diff) {\\n                pair[num] += single[num - diff];\\n                ans += pair[num - diff];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078032,
                "title": "efficient-o-n-solution-for-counting-arithmetic-triplets-in-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n1. Create a Counter Hash:\\nInitialize a hash to keep track of the number of arithmetic triplets found so far.\\n\\n2. Iterate Through the Array:\\nIterate through the array nums. For each element nums[j], calculate the potential previous elements nums[i] and nums[k] in the arithmetic triplet.\\nIn an arithmetic triplet, nums[j] - nums[i] == diff and nums[k] - nums[j] == diff. Hence, for the current element nums[j], the potential previous elements are nums[j] - diff and nums[j] - 2 * diff.\\n\\n3. Update Counter:\\nUpdate the counter for arithmetic triplets by considering the count of potential previous elements for each nums[j].\\n\\n4. Return the Total Count:\\nReturn the total count of unique arithmetic triplets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\nconst n = nums.length \\nlet count = 0 // Total count of arithmetic triplets\\nconst hashMap = new Map()\\n\\nfor(let i=0; i<n; i++){\\n  const val1 = nums[i] - diff // First potential previous element\\n  const val2 = nums[i] - 2 * diff; // Second potential previous element\\n if(hashMap.has(val1) && hashMap.has(val2)){\\n   count++\\n }\\n hashMap.set(nums[i],nums[i])\\n}\\n\\nreturn count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\nconst n = nums.length \\nlet count = 0 // Total count of arithmetic triplets\\nconst hashMap = new Map()\\n\\nfor(let i=0; i<n; i++){\\n  const val1 = nums[i] - diff // First potential previous element\\n  const val2 = nums[i] - 2 * diff; // Second potential previous element\\n if(hashMap.has(val1) && hashMap.has(val2)){\\n   count++\\n }\\n hashMap.set(nums[i],nums[i])\\n}\\n\\nreturn count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078014,
                "title": "typescript-javascript-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\n  const hash = new Set<number>();\\n  let ans = 0;\\n\\n  // what we need to find are the triplets\\n  // let\\'s say if 1,4,7 are the triplets and\\n  // the diff is 3, so we need to find 3 numbers\\n  // who have difference of 3 between them\\n  // let\\'s assume we\\'re on number 7, so we would\\n  // neet to find 4(num-diff) and 1(num - diff - diff)\\n  // if we find both the numbers then increment the count\\n  // else we add the current number in the hash\\n  for (const num of nums) {\\n    if (hash.has(num - diff) && hash.has(num - diff * 2)) ans++;\\n    hash.add(num);\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arithmeticTriplets(nums: number[], diff: number): number {\\n  const hash = new Set<number>();\\n  let ans = 0;\\n\\n  // what we need to find are the triplets\\n  // let\\'s say if 1,4,7 are the triplets and\\n  // the diff is 3, so we need to find 3 numbers\\n  // who have difference of 3 between them\\n  // let\\'s assume we\\'re on number 7, so we would\\n  // neet to find 4(num-diff) and 1(num - diff - diff)\\n  // if we find both the numbers then increment the count\\n  // else we add the current number in the hash\\n  for (const num of nums) {\\n    if (hash.has(num - diff) && hash.has(num - diff * 2)) ans++;\\n    hash.add(num);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016060,
                "title": "c-check-out-this-simple-constant-space-solution",
                "content": "# Code - 1 (Using Binary Search)\\n- **Time Complexity :** $$O(n*logn)$$\\n- **Space Complexity :** $$O(1)$$\\n\\n```\\nclass Solution {\\npublic:\\n    int bs (vector<int> &nums, int &key, int start, int end) {\\n        int low = start, high = end;\\n        while (low <= high) {\\n            int mid = low+(high-low)/2;\\n            if (nums[mid] == key) return mid;\\n            else if (nums[mid] > key) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return -1;\\n    }\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for (int i=0; i<n-2; i++) {\\n            int key = diff + nums[i];\\n            int j = bs(nums, key, i+1, n-2);\\n            if (j==-1) continue;\\n            key += diff;\\n            int k = bs(nums, key, j+1, n-1);\\n            if (k!=-1) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n\\n# Code - 2 (Using HashMap)\\n\\n- **Time Complexity :** $$O(n)$$\\n- **Space Complexity :** $$O(n)$$\\n\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        unordered_map<int,bool> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs (vector<int> &nums, int &key, int start, int end) {\\n        int low = start, high = end;\\n        while (low <= high) {\\n            int mid = low+(high-low)/2;\\n            if (nums[mid] == key) return mid;\\n            else if (nums[mid] > key) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return -1;\\n    }\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for (int i=0; i<n-2; i++) {\\n            int key = diff + nums[i];\\n            int j = bs(nums, key, i+1, n-2);\\n            if (j==-1) continue;\\n            key += diff;\\n            int k = bs(nums, key, j+1, n-1);\\n            if (k!=-1) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        unordered_map<int,bool> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955954,
                "title": "c-solution-using-unordered-set-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nset c=0;\\nFirstly insert all elements into a unordered_set. After that iterate through each value (let, x) of vector and check if (x+diff) and (x+diff+diff) is present in the set or not. if it is present then increment c by 1, atlast return the value of c.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i]+diff;\\n            int y=x+diff;\\n            if(s.find(x)!=s.end() && s.find(y)!=s.end())\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=nums[i]+diff;\\n            int y=x+diff;\\n            if(s.find(x)!=s.end() && s.find(y)!=s.end())\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804690,
                "title": "binary-search-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution is all about arithmatic mean concept . We should check wheather nums[i]+diff & nums[i]+2*diff is present in the vector or not.If true then increase count then return count\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the test cases depicts that vector contains increasing elements . So we can apply binary search concept on this problem \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) ---  one loop\\nO(logn) ---  Binary search function\\n\\noverall ---- O(n).O(logn).O(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool BS (vector<int>& nums , int value)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        int mid = start+(end-start)/2;\\n\\n        while(start<=end)\\n        {\\n            if(nums[mid] == value)\\n            {\\n                return true;\\n            }\\n\\n            else if(nums[mid] > value)\\n            {\\n                end = mid-1;\\n            }\\n\\n            else\\n            {\\n                start = mid+1;\\n            }\\n\\n            mid = start+(end-start)/2;\\n        }\\n        return false;\\n    }\\n\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int count = 0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(BS(nums , nums[i]+diff) && BS(nums, nums[i]+2*diff))\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool BS (vector<int>& nums , int value)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        int mid = start+(end-start)/2;\\n\\n        while(start<=end)\\n        {\\n            if(nums[mid] == value)\\n            {\\n                return true;\\n            }\\n\\n            else if(nums[mid] > value)\\n            {\\n                end = mid-1;\\n            }\\n\\n            else\\n            {\\n                start = mid+1;\\n            }\\n\\n            mid = start+(end-start)/2;\\n        }\\n        return false;\\n    }\\n\\n    int arithmeticTriplets(vector<int>& nums, int diff) \\n    {\\n        int count = 0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(BS(nums , nums[i]+diff) && BS(nums, nums[i]+2*diff))\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707908,
                "title": "easy-simple-java-solution-in-o-n-2",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find a triplet of (i, j, k) such that \\ni<j<k , \\nnums[j] - nums[i] == diff, and \\nnums[k] - nums[j] == diff\\n\\nin other word we can also say nums[k]-nums[i]== 2*diff. To reduce the time complexity I use only 2 loop remove the loop for k and include it in j iterartion such that nums[j]-nums[i] == 2*diff. So in every iterartion of j we will get 2 condition nums[j]-nums[i] == diff and nums[j]-nums[i] == 2*diff when these 2 condition get satisfied in j iterartion, We get 1 count as answer. So for every iteration when count>=2 we add 1 to ans and at last return it.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int ans =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            int count =0;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count >= 2){\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int ans =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            int count =0;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count >= 2){\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707821,
                "title": "simple-easy-brute-force-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I use simple brute force approach. Use 3 for loop iterarte i, j, k one by one and search a combinantion of i, j, k which can satisfied these given conditions and count that combinations.\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            for(int j=i+1; j<nums.length-1; j++){\\n                for(int k=j+1; k<nums.length; k++){\\n                    if(nums[k]-nums[j] == diff && nums[j]-nums[i]== diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            for(int j=i+1; j<nums.length-1; j++){\\n                for(int k=j+1; k<nums.length; k++){\\n                    if(nums[k]-nums[j] == diff && nums[j]-nums[i]== diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700666,
                "title": "intuitive-but-not-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int i = 0, j = 1, k = 2;\\n        while(i<=nums.length-3) {\\n            if(nums[j]-nums[i] > diff) {\\n                // skip i\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else if(k < nums.length && (nums[k]-nums[j])!=diff)\\n                ++k;\\n            else if(nums[j]-nums[i]==diff && nums[k>=nums.length?nums.length-1:k]-nums[j]==diff) {\\n                ++count;\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else if(j==k-1) {\\n                // change i\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else {\\n                ++j;\\n                k = j+1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int i = 0, j = 1, k = 2;\\n        while(i<=nums.length-3) {\\n            if(nums[j]-nums[i] > diff) {\\n                // skip i\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else if(k < nums.length && (nums[k]-nums[j])!=diff)\\n                ++k;\\n            else if(nums[j]-nums[i]==diff && nums[k>=nums.length?nums.length-1:k]-nums[j]==diff) {\\n                ++count;\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else if(j==k-1) {\\n                // change i\\n                ++i;\\n                j = i+1;\\n                k = j+1;\\n            }\\n            else {\\n                ++j;\\n                k = j+1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684846,
                "title": "two-actually-three-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was looking for a two-pointers solution, but had to use a three-pointers instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are moving the right(leading) pointer and adjusting the left and middle pointers\\' position only when they fail to meet the requirement of not being too far (according to **diff** costraint).\\n\\nFor each set of left, middle and right pointers we then check if the numbers they are pointing at satisfy the condition announced in the task. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        left = 0\\n        middle = 1\\n        right = 2\\n        \\n        length = len(nums)\\n        result_count = 0\\n        \\n        \\n        while right < length:\\n\\n            while nums[right] - nums[middle] > diff and middle < right:\\n                middle += 1\\n            \\n            while nums[middle] - nums[left] > diff and left < middle:\\n                left += 1\\n                       \\n            if  nums[middle] - nums[left] == diff and nums[right] - nums[middle] == diff:\\n                result_count += 1\\n            \\n            right += 1\\n            \\n            \\n                \\n\\n            \\n        \\n        return result_count\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        left = 0\\n        middle = 1\\n        right = 2\\n        \\n        length = len(nums)\\n        result_count = 0\\n        \\n        \\n        while right < length:\\n\\n            while nums[right] - nums[middle] > diff and middle < right:\\n                middle += 1\\n            \\n            while nums[middle] - nums[left] > diff and left < middle:\\n                left += 1\\n                       \\n            if  nums[middle] - nums[left] == diff and nums[right] - nums[middle] == diff:\\n                result_count += 1\\n            \\n            right += 1\\n            \\n            \\n                \\n\\n            \\n        \\n        return result_count\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556695,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int count =0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1;j<n; j++){\\n                if(nums[j]-nums[i]==diff)\\n                for(int k=j+1; k<n; k++){\\n                    if(nums[j]-nums[i]== diff && nums[k]-nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n = nums.size();\\n        int count =0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1;j<n; j++){\\n                if(nums[j]-nums[i]==diff)\\n                for(int k=j+1; k<n; k++){\\n                    if(nums[j]-nums[i]== diff && nums[k]-nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527263,
                "title": "java-two-pointer-approach",
                "content": "# Intuition\\n  For solving this in bruteforce approach, it takes 3 loops, so reduce that, two pointer approach is helpful here.\\n# Approach\\n  Take two points, i starting from 0th index and j starting from 1st index. you have to gradually move this elements and check the difference.\\nWe have 3 cases here:\\nCase-1:\\nIf diff is less than given one that means, your lower number is somewhere upper value of ith index.\\nCase-2:\\nIf your diff is greater than the given diff, this means there would be number which is greater than current jth element.\\nCase-3\\nIf numbers diff is same as given, then increment count based on triplet count from hashset.\\nThen increase both i & j, for exploring other triplets.\\n\\nHope this helps.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N), as it uses hashset to store all the elements\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> hashset = new HashSet();\\n        for(int num: nums)\\n            hashset.add(num);\\n        System.out.println(\"set: \"+hashset);\\n\\n       int i=0,j=1;\\n       int cnt=0;\\n       while(i<=j && j<nums.length){\\n\\n            if(nums[j]-nums[i] < diff)\\n                j++;\\n            else if(nums[j]-nums[i]>diff)\\n                i++;\\n            else{\\n                if(hashset.contains(nums[j]+diff))\\n                      cnt++;\\n                i++;\\n                j++;   \\n            }        \\n       }\\n\\n    return cnt;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Set<Integer> hashset = new HashSet();\\n        for(int num: nums)\\n            hashset.add(num);\\n        System.out.println(\"set: \"+hashset);\\n\\n       int i=0,j=1;\\n       int cnt=0;\\n       while(i<=j && j<nums.length){\\n\\n            if(nums[j]-nums[i] < diff)\\n                j++;\\n            else if(nums[j]-nums[i]>diff)\\n                i++;\\n            else{\\n                if(hashset.contains(nums[j]+diff))\\n                      cnt++;\\n                i++;\\n                j++;   \\n            }        \\n       }\\n\\n    return cnt;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490448,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                for(int k = j + 1; k < nums.length; k++) {\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                for(int k = j + 1; k < nums.length; k++) {\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477461,
                "title": "fastest-at-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0; \\n        Set<Integer> list = new HashSet<>();\\n        for(int a : nums){\\n            if(list.contains(a-diff) && list.contains(a-diff*2)) count++;\\n            list.add(a);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0; \\n        Set<Integer> list = new HashSet<>();\\n        for(int a : nums){\\n            if(list.contains(a-diff) && list.contains(a-diff*2)) count++;\\n            list.add(a);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444797,
                "title": "simple-c-brute-force-o-n3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff)\\n    {\\n       \\n      int n=nums.size();\\n\\n      int cnt=0; \\n\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=i+1;j<n;j++)\\n          {\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[k]-nums[j]==diff&&nums[j]-nums[i]==diff)\\n                  {\\n                      cnt++;\\n                  }\\n              }\\n          }\\n      }\\n\\n         return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff)\\n    {\\n       \\n      int n=nums.size();\\n\\n      int cnt=0; \\n\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=i+1;j<n;j++)\\n          {\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[k]-nums[j]==diff&&nums[j]-nums[i]==diff)\\n                  {\\n                      cnt++;\\n                  }\\n              }\\n          }\\n      }\\n\\n         return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246041,
                "title": "number-of-arithmetic-triplets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int i, j, n, m, count=0, c=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            n = nums[i]+diff;\\n            m = n + diff;\\n            c=0;\\n            for(j=i ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]==n || nums[j]==m)\\n                {\\n                    c++;\\n                }\\n                if(c==2)\\n                {\\n                    count++;\\n                    break;\\n                }\\n                else if(nums[j]>m)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int i, j, n, m, count=0, c=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            n = nums[i]+diff;\\n            m = n + diff;\\n            c=0;\\n            for(j=i ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]==n || nums[j]==m)\\n                {\\n                    c++;\\n                }\\n                if(c==2)\\n                {\\n                    count++;\\n                    break;\\n                }\\n                else if(nums[j]>m)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214241,
                "title": "pointer-manipulation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nex:\\n[0,1,4,6,7,10]\\ntraversing nums in for loop from index1= 0~numsSize-3 (0,1,4,6).\\n\\nThere is a while loop in each for loop starting from index2= 1~numsSize-1 to check if nums[index2]-nums[index1]==diff.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0 ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n5.9 MB\\n# Code\\n```\\nint arithmeticTriplets(int* nums, int numsSize, int diff){\\n   \\n    int* numPtr=nums;\\n    int cnt=1, total=0;\\n    for(int i=0; i<numsSize-2; i++){\\n        numPtr=nums+i+1;\\n        cnt=1;\\n            while(numPtr!=nums+numsSize){                \\n                if(*numPtr-nums[i]==diff*cnt) cnt++;\\n                if(cnt==3){\\n                    total++;\\n                    break;\\n                }\\n                *numPtr++;\\n            }   \\n    }\\n    return total;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint arithmeticTriplets(int* nums, int numsSize, int diff){\\n   \\n    int* numPtr=nums;\\n    int cnt=1, total=0;\\n    for(int i=0; i<numsSize-2; i++){\\n        numPtr=nums+i+1;\\n        cnt=1;\\n            while(numPtr!=nums+numsSize){                \\n                if(*numPtr-nums[i]==diff*cnt) cnt++;\\n                if(cnt==3){\\n                    total++;\\n                    break;\\n                }\\n                *numPtr++;\\n            }   \\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3124346,
                "title": "solution-in-python-easy-to-understand",
                "content": "Input: nums = [0,1,4,6,7,10], diff = 3\\nOutput: 2\\nExplanation:\\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.\\n\\nCode explaination:\\n((nums[i] + diff) in arr) and ((nums[i] + 2 * diff) in arr)\\n   =  1    +  3   in arr  and     1     + 2 *  3    in arr\\n   =     4        in arr  and            7          in arr \\nthen count +1\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        arr=set(nums)\\n        for i in range(len(nums)):\\n            if ((nums[i]+diff) in arr) and ((nums[i]+2*diff) in arr):\\n                count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        arr=set(nums)\\n        for i in range(len(nums)):\\n            if ((nums[i]+diff) in arr) and ((nums[i]+2*diff) in arr):\\n                count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102643,
                "title": "c-using-map",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) //[0,1,5]  for 0 it store 1 and for 2 it store 0 its store freq for number \\n            mp[nums[i]]++;\\n        \\n    \\n        for(int i=0;i<nums.size();i++)\\n        {      //check if the freq of number or nums[i]+diff && nums[i] + diff + diff exist then cnt++ \\n            if(mp[nums[i] + diff]>0 && mp[nums[i] + diff + diff]>0)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) //[0,1,5]  for 0 it store 1 and for 2 it store 0 its store freq for number \\n            mp[nums[i]]++;\\n        \\n    \\n        for(int i=0;i<nums.size();i++)\\n        {      //check if the freq of number or nums[i]+diff && nums[i] + diff + diff exist then cnt++ \\n            if(mp[nums[i] + diff]>0 && mp[nums[i] + diff + diff]>0)\\n                cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3078041,
                "title": "java-0ms-easy-binary-search",
                "content": "# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] a, int diff) {\\n        int count=0;\\n        boolean a2=false,a3=false;\\n\\n        for(int i=0;i<a.length;i++){            \\n            a2=check(a,a[i]+diff);\\n            a3=check(a,a[i]+2*diff);\\n            if( a2 && a3){\\n                count++;\\n                a2=false;\\n                a3=false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean check(int []a,int x){\\n\\n        int low=0,high=a.length-1;\\n        int mid=0;\\n        while(low<=high){\\n            mid=(low+high)/2;\\n            if(a[mid]==x){\\n                return true;\\n            }\\n            else if(a[mid]>x){\\n                high=mid-1;\\n            }\\n            else if(a[mid]<x){\\n                low=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] a, int diff) {\\n        int count=0;\\n        boolean a2=false,a3=false;\\n\\n        for(int i=0;i<a.length;i++){            \\n            a2=check(a,a[i]+diff);\\n            a3=check(a,a[i]+2*diff);\\n            if( a2 && a3){\\n                count++;\\n                a2=false;\\n                a3=false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean check(int []a,int x){\\n\\n        int low=0,high=a.length-1;\\n        int mid=0;\\n        while(low<=high){\\n            mid=(low+high)/2;\\n            if(a[mid]==x){\\n                return true;\\n            }\\n            else if(a[mid]>x){\\n                high=mid-1;\\n            }\\n            else if(a[mid]<x){\\n                low=mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051327,
                "title": "swift-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        var uniqueNumber: Int = 0\\n\\n        nums.forEach{\\n            if nums.contains($0 + diff), nums.contains($0 + 2 * diff) {\\n                uniqueNumber += 1\\n            }\\n        }\\n        return uniqueNumber\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        var uniqueNumber: Int = 0\\n\\n        nums.forEach{\\n            if nums.contains($0 + diff), nums.contains($0 + 2 * diff) {\\n                uniqueNumber += 1\\n            }\\n        }\\n        return uniqueNumber\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933536,
                "title": "simple-c-solution",
                "content": "# Intuition\\nSimply find the element + diff and element +diff +diff if true then count ++; \\n\\n# Approach\\nuse fast access i.e order of 1 to find \\n\\n# Complexity\\n- Time complexity:\\norder of n \\n\\n- Space complexity:\\norder of n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        set<int>s(nums.begin(), nums.end());\\n        int count = 0 ; \\n        for (auto i :nums){\\n            if (s.find(i+diff)!=s.end() && s.find(i+diff+diff)!=s.end())\\n            count++;\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        set<int>s(nums.begin(), nums.end());\\n        int count = 0 ; \\n        for (auto i :nums){\\n            if (s.find(i+diff)!=s.end() && s.find(i+diff+diff)!=s.end())\\n            count++;\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912512,
                "title": "java-solution-bruteforce",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824626,
                "title": "swift-reduce-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        return nums.reduce(into: 0) { \\n            if nums.contains($1 + diff) && nums.contains($1 + diff * 2) {\\n                $0 += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arithmeticTriplets(_ nums: [Int], _ diff: Int) -> Int {\\n        return nums.reduce(into: 0) { \\n            if nums.contains($1 + diff) && nums.contains($1 + diff * 2) {\\n                $0 += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741214,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,bool> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        \\n\\t\\t\\n        return cnt;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int arithmeticTriplets(vector<int>& nums, int diff) {\\n        \\n        int cnt = 0;\\n        \\n        unordered_map<int,bool> mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]] = true;\\n        \\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp[nums[i]-diff] && mp[nums[i]+diff])\\n                cnt++;\\n        }\\n        \\n\\t\\t\\n        return cnt;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718954,
                "title": "binary-search-by-searching-without-any-space",
                "content": "##### INTUTION: \\n\\n1. search no+diff and no+2diff by the help of lower bound. \\n1. if both numbers present in array then just count++\\n2. same thing is done for each element of nums\\n\\n```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            int ind=lower_bound(nums.begin(),nums.end(),nums[i]+diff)-nums.begin();\\n            if(ind>=nums.size())continue;\\n            else if(nums[ind]!=nums[i]+diff)continue;\\n            else{\\n                int ind2=lower_bound(nums.begin(),nums.end(),nums[ind]+diff)-nums.begin();\\n                if(ind2>=nums.size())continue;\\n                else if(nums[ind2]!=nums[ind]+diff)continue;\\n                else{\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            int ind=lower_bound(nums.begin(),nums.end(),nums[i]+diff)-nums.begin();\\n            if(ind>=nums.size())continue;\\n            else if(nums[ind]!=nums[i]+diff)continue;\\n            else{\\n                int ind2=lower_bound(nums.begin(),nums.end(),nums[ind]+diff)-nums.begin();\\n                if(ind2>=nums.size())continue;\\n                else if(nums[ind2]!=nums[ind]+diff)continue;\\n                else{\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688015,
                "title": "python3-solution-one-line-solution",
                "content": "Ask if you have question - upvote if you like the solution.\\n\\n# Intuition\\nReally tricky.. Instead of going into a nested for loop.. just switch mind: go from the diff. Think of the pattern: count the numbers in the list which has both the number + diff and number - diff included in the list?\\n\\n# Code\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum([1 for i in nums if i-diff in nums and i+diff in nums])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum([1 for i in nums if i-diff in nums and i+diff in nums])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660523,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& v, int k) {\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(auto&i:v)m[i]++;\\n        for(auto&i:v){\\n            if((m.find(i+k)!=m.end())&&(m.find(i-k)!=m.end()))ans++;\\n        }\\n    return ans;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& v, int k) {\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(auto&i:v)m[i]++;\\n        for(auto&i:v){\\n            if((m.find(i+k)!=m.end())&&(m.find(i-k)!=m.end()))ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2648813,
                "title": "simple-c-solution",
                "content": "```\\nint arithmeticTriplets(int* nums, int numsSize, int diff){\\nint count=0;\\n    for(int i = 0 ; i < numsSize  ; i++) {\\n    for(int j = i + 1 ; j < numsSize  ; j++) {\\n        for(int k = j + 1 ; k < numsSize  ; k++) {\\n            if(( i < j < k ) && ((nums[j] - nums[i]) == diff) && ((nums[k] - nums[j]) == diff))\\n                count++;\\n        }\\n    }   \\n}\\n\\nreturn count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\nint arithmeticTriplets(int* nums, int numsSize, int diff){\\nint count=0;\\n    for(int i = 0 ; i < numsSize  ; i++) {\\n    for(int j = i + 1 ; j < numsSize  ; j++) {\\n        for(int k = j + 1 ; k < numsSize  ; k++) {\\n            if(( i < j < k ) && ((nums[j] - nums[i]) == diff) && ((nums[k] - nums[j]) == diff))\\n                count++;\\n        }\\n    }   \\n}\\n\\nreturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587110,
                "title": "python-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        dict_ = {}\\n        for num in nums:\\n            dict_[num] = dict_.get(num,0) + 1 ##To keep the count of each num\\'s occurence\\n        \\n        count = 0\\n        for num in nums:\\n            if dict_.get(num+diff) and dict_.get(num+diff*2): #Check if any number with 3 and 6 more than present in dictionary\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        dict_ = {}\\n        for num in nums:\\n            dict_[num] = dict_.get(num,0) + 1 ##To keep the count of each num\\'s occurence\\n        \\n        count = 0\\n        for num in nums:\\n            if dict_.get(num+diff) and dict_.get(num+diff*2): #Check if any number with 3 and 6 more than present in dictionary\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583136,
                "title": "java-both-solution-simmple-and-optimal",
                "content": "class Solution {\\n    \\n    //Brout fource apporch\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int n = nums.length;\\n        \\n        if(n <3) return 0;\\n        \\n        \\n        int countPair=0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            \\n            for(int j=i+1; j<n;j++){\\n                \\n                for(int k = j+1; k<n ; k++){\\n                    \\n                    if((nums[k] - nums[j] == diff )&& (nums[j] - nums[i] == diff)) {\\n                        countPair+=1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return countPair;\\n    }\\n    \\n    // optimal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n    \\n     public int arithmeticTriplets(int[] nums, int diff) {\\n         \\n         int n = nums.length;\\n         \\n         HashSet<Integer> hs = new HashSet<>();\\n         \\n         int countPair=0;\\n         for(int i=0; i<n;i++){\\n             \\n             int first = nums[i]-diff;\\n             int last =  nums[i] - 2* diff;\\n             \\n             if(hs.contains(first) && hs.contains(last)) countPair++;\\n             \\n             hs.add(nums[i]);\\n         }\\n         \\n         return countPair;\\n     }\\n}",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "class Solution {\\n    \\n    //Brout fource apporch\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int n = nums.length;\\n        \\n        if(n <3) return 0;\\n        \\n        \\n        int countPair=0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            \\n            for(int j=i+1; j<n;j++){\\n                \\n                for(int k = j+1; k<n ; k++){\\n                    \\n                    if((nums[k] - nums[j] == diff )&& (nums[j] - nums[i] == diff)) {\\n                        countPair+=1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2575200,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int triplets = 0;\\n        \\n        map.put(nums[0], nums[0]);\\n        map.put(nums[1], nums[1]);\\n        \\n        int t;\\n        \\n        for (int i = 2; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n\\n            if (map.get(nums[i] - diff) != null) {\\n                t = map.get(nums[i] - diff);\\n                if (map.get(t - diff) != null) triplets++;\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int triplets = 0;\\n        \\n        map.put(nums[0], nums[0]);\\n        map.put(nums[1], nums[1]);\\n        \\n        int t;\\n        \\n        for (int i = 2; i < nums.length; i++) {\\n            map.put(nums[i], nums[i]);\\n\\n            if (map.get(nums[i] - diff) != null) {\\n                t = map.get(nums[i] - diff);\\n                if (map.get(t - diff) != null) triplets++;\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573545,
                "title": "java-using-binary-search-1ms-and-o-n",
                "content": "Loop over the array and do binary search to find elements, after adding **diff** to the current number.\\n\\n```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n\\n        int count= 0;\\n        \\n        for(int i = 0; i < nums.length; ++i){\\n            int nextSum = nums[i] + diff;\\n            int firstIndex = Arrays.binarySearch(nums, i + 1, nums.length, nextSum);\\n            if(firstIndex > -1 && \\n               Arrays.binarySearch(nums, firstIndex + 1, nums.length, nextSum + diff) > -1) {\\n                ++count;\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n\\n        int count= 0;\\n        \\n        for(int i = 0; i < nums.length; ++i){\\n            int nextSum = nums[i] + diff;\\n            int firstIndex = Arrays.binarySearch(nums, i + 1, nums.length, nextSum);\\n            if(firstIndex > -1 && \\n               Arrays.binarySearch(nums, firstIndex + 1, nums.length, nextSum + diff) > -1) {\\n                ++count;\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572803,
                "title": "c-easy-set-solution-with-explanation",
                "content": "# Simple C++ Solution using Set\\n\\nA - B = diff\\nB - C = diff\\n\\nB is common in both so we store it in a set\\n\\nB = A - diff\\nB = C + diff\\n\\n\\n```\\nint arithmeticTriplets(vector<int>& nums, int diff) {        \\n        set<int> s;\\n        \\n        for(auto x: nums){\\n            s.insert(x);\\n        }\\n        int count = 0;\\n        for(auto x: nums){\\n            if(s.find(x - diff)!=s.end() and s.find(x + diff)!=s.end()){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint arithmeticTriplets(vector<int>& nums, int diff) {        \\n        set<int> s;\\n        \\n        for(auto x: nums){\\n            s.insert(x);\\n        }\\n        int count = 0;\\n        for(auto x: nums){\\n            if(s.find(x - diff)!=s.end() and s.find(x + diff)!=s.end()){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572029,
                "title": "cpp-brute-force-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size(),c=0,s1;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                s1=nums[j]-nums[i];\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[k]-nums[j]==s1 && s1==diff)\\n                        c++;\\n                }\\n        }\\n    }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size(),c=0,s1;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                s1=nums[j]-nums[i];\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[k]-nums[j]==s1 && s1==diff)\\n                        c++;\\n                }\\n        }\\n    }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570360,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& n, int diff) {\\n        int count = 0;\\n        \\n        unordered_set<int> s;\\n        \\n        for(int i=0;i<n.size();i++)\\n        {\\n            s.insert(n[i]);\\n        }\\n        \\n        for(int i=0;i<n.size();i++){\\n            if(s.find(n[i]-diff)!=s.end() && s.find(n[i]+diff)!=s.end())\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& n, int diff) {\\n        int count = 0;\\n        \\n        unordered_set<int> s;\\n        \\n        for(int i=0;i<n.size();i++)\\n        {\\n            s.insert(n[i]);\\n        }\\n        \\n        for(int i=0;i<n.size();i++){\\n            if(s.find(n[i]-diff)!=s.end() && s.find(n[i]+diff)!=s.end())\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570152,
                "title": "brute-force-3-loop-s-java",
                "content": "```\\npublic  int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                if(nums[j] - nums[i] == diff){\\n                    for(int k = j+1; k < n; k++){\\n                        if(nums[k] - nums[j] == diff){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic  int arithmeticTriplets(int[] nums, int diff) {\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                if(nums[j] - nums[i] == diff){\\n                    for(int k = j+1; k < n; k++){\\n                        if(nums[k] - nums[j] == diff){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561096,
                "title": "faster-than-98-java-solution-with-simple-three-pointer-solution-with-o-n-2-time-complexity",
                "content": "\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int n= nums.length;\\n        int ans=0;\\n\\n       int i=0;\\n       int j=1;\\n       int k=2;\\n        \\n        while(i<n-2 ){\\n            \\n            while( j<n-2 && nums[j]-nums[i]<diff){\\n                j++;\\n            }\\n            \\n            while(k<n-1 && nums[k]-nums[j]<diff ){\\n                k++;\\n            }\\n            \\n            if(nums[k]-nums[j]==diff &&  nums[j]-nums[i]==diff ){\\n                ans++;\\n            }\\n\\n            i++;\\n            \\n             \\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int n= nums.length;\\n        int ans=0;\\n\\n       int i=0;\\n       int j=1;\\n       int k=2;\\n        \\n        while(i<n-2 ){\\n            \\n            while( j<n-2 && nums[j]-nums[i]<diff){\\n                j++;\\n            }\\n            \\n            while(k<n-1 && nums[k]-nums[j]<diff ){\\n                k++;\\n            }\\n            \\n            if(nums[k]-nums[j]==diff &&  nums[j]-nums[i]==diff ){\\n                ans++;\\n            }\\n\\n            i++;\\n            \\n             \\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560958,
                "title": "simple-o-n-time-complexity",
                "content": "Runtime: 49 ms, faster than 84.84% of Python3 online submissions for Number of Arithmetic Triplets.\\nMemory Usage: 13.8 MB, less than 68.01% of Python3 online submissions for Number of Arithmetic Triplets.\\n\\n\\t\\tfrom collections import Counter\\n\\t\\tc = Counter(nums)\\n        count = 0\\n        for i in nums:\\n            if c[i + diff]:\\n                if c[i + diff * 2]:\\n                    count += 1\\n        return count\\nPlease upvote if you like, Thanks in advance!",
                "solutionTags": [
                    "Python"
                ],
                "code": "Runtime: 49 ms, faster than 84.84% of Python3 online submissions for Number of Arithmetic Triplets.\\nMemory Usage: 13.8 MB, less than 68.01% of Python3 online submissions for Number of Arithmetic Triplets.\\n\\n\\t\\tfrom collections import Counter\\n\\t\\tc = Counter(nums)\\n        count = 0\\n        for i in nums:\\n            if c[i + diff]:\\n                if c[i + diff * 2]:\\n                    count += 1\\n        return count\\nPlease upvote if you like, Thanks in advance!",
                "codeTag": "Python3"
            },
            {
                "id": 2557205,
                "title": "rust-0-ms-two-solutions-functional-style-loops-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/796181323/) employs a functional-style approach with two iterators and filters. It demonstrated **0 ms runtime (100%)** and used **2.1 MB memory (81.20%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn arithmetic_triplets(nums: Vec<i32>, diff: i32) -> i32 \\n    {\\n        // [1] scan elements of array\\n        (0..nums.len()-2)\\n        // [2] filter nums[i] which are starters for triples \\n        //     (i.e. those nums[i] for which nums[i]+diff and nums[i]+diff*2 was found)\\n            .filter(|&i| \\n                (i+1..nums.len())\\n                    // [3] filter elements which are either nums[i]+diff or nums[i]+diff*2\\n                    .filter(|&j| nums[j]-nums[i] == diff || nums[j]-nums[i] == diff*2)\\n                    // [4] count filtered elements  \\n                    .count() == 2)\\n            .count() as i32\\n    }\\n}\\n```\\n\\nFor clarity, I also proide an imperative-style [solution](https://leetcode.com/submissions/detail/796179411/) with expliit loops.\\n```\\nimpl Solution \\n{\\n    pub fn arithmetic_triplets(nums: Vec<i32>, diff: i32) -> i32 \\n    {\\n        let mut triplets: i32 = 0;\\n        let mut cnt: i32;\\n        \\n        // [1] scan elements of array\\n        for i in 0..nums.len()-2\\n        {\\n            cnt = 0;\\n            // [2] increase counter if diff or diff*2 is found\\n            for j in i+1..nums.len()\\n            {\\n                if nums[j] - nums[i] == diff || nums[j] - nums[i] == 2*diff\\n                {\\n                    cnt += 1;\\n            // [3] provided that array is strictly increasing, \\n            //     cnt = 2 implies that perfect triple was found\\n                    if cnt == 2 {triplets += 1; break}\\n                }\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn arithmetic_triplets(nums: Vec<i32>, diff: i32) -> i32 \\n    {\\n        // [1] scan elements of array\\n        (0..nums.len()-2)\\n        // [2] filter nums[i] which are starters for triples \\n        //     (i.e. those nums[i] for which nums[i]+diff and nums[i]+diff*2 was found)\\n            .filter(|&i| \\n                (i+1..nums.len())\\n                    // [3] filter elements which are either nums[i]+diff or nums[i]+diff*2\\n                    .filter(|&j| nums[j]-nums[i] == diff || nums[j]-nums[i] == diff*2)\\n                    // [4] count filtered elements  \\n                    .count() == 2)\\n            .count() as i32\\n    }\\n}\\n```\n```\\nimpl Solution \\n{\\n    pub fn arithmetic_triplets(nums: Vec<i32>, diff: i32) -> i32 \\n    {\\n        let mut triplets: i32 = 0;\\n        let mut cnt: i32;\\n        \\n        // [1] scan elements of array\\n        for i in 0..nums.len()-2\\n        {\\n            cnt = 0;\\n            // [2] increase counter if diff or diff*2 is found\\n            for j in i+1..nums.len()\\n            {\\n                if nums[j] - nums[i] == diff || nums[j] - nums[i] == 2*diff\\n                {\\n                    cnt += 1;\\n            // [3] provided that array is strictly increasing, \\n            //     cnt = 2 implies that perfect triple was found\\n                    if cnt == 2 {triplets += 1; break}\\n                }\\n            }\\n        }\\n        \\n        return triplets;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549110,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        n=len(nums)\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                if nums[j]-nums[i]==diff:\\n                    for k in range(j+1,n):\\n                        if nums[k]-nums[j]==diff:\\n                            count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        count=0\\n        n=len(nums)\\n        for i in range(n-2):\\n            for j in range(i+1,n-1):\\n                if nums[j]-nums[i]==diff:\\n                    for k in range(j+1,n):\\n                        if nums[k]-nums[j]==diff:\\n                            count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544460,
                "title": "easy-java-c-solution",
                "content": "```\\n// Java Solution\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int n=nums.length;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                for(int k=j+1;k<n;k++)\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        cnt++;\\n        return cnt;\\n    }\\n}\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                for(int k=j+1;k<n;k++)\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        cnt++;\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\n// Java Solution\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int n=nums.length;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                for(int k=j+1;k<n;k++)\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        cnt++;\\n        return cnt;\\n    }\\n}\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                for(int k=j+1;k<n;k++)\\n                    if(nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        cnt++;\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535870,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(binary_search(nums.begin(),nums.end(),diff + nums[i]))\\n            {\\n                if(binary_search(nums.begin(),nums.end(),2*diff + nums[i]))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(binary_search(nums.begin(),nums.end(),diff + nums[i]))\\n            {\\n                if(binary_search(nums.begin(),nums.end(),2*diff + nums[i]))\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520815,
                "title": "using-binary-search-c-98-64-fast",
                "content": "```\\nint bsearch(vector<int>& nums,int target,int start){\\n    int h=nums.size()-1;\\n    int l=start, m;\\n    while(l<=h){\\n        m = l + (h-l)/2;\\n        if(nums[m] == target) return 1;\\n        else if(nums[m] < target) l = m+1;\\n        else h = m-1;\\n        \\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0; i<=nums.size()-3; i++){\\n            if(bsearch(nums, nums[i]+diff, i+1) && bsearch(nums, nums[i]+(2*diff), i+1)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint bsearch(vector<int>& nums,int target,int start){\\n    int h=nums.size()-1;\\n    int l=start, m;\\n    while(l<=h){\\n        m = l + (h-l)/2;\\n        if(nums[m] == target) return 1;\\n        else if(nums[m] < target) l = m+1;\\n        else h = m-1;\\n        \\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        int ans=0;\\n        for(int i=0; i<=nums.size()-3; i++){\\n            if(bsearch(nums, nums[i]+diff, i+1) && bsearch(nums, nums[i]+(2*diff), i+1)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519169,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] arr, int k) {\\n        int count = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            boolean left = checkLeft(arr, i, k);\\n            boolean right = checkRight(arr, i, k);\\n            if (left && right) count++;\\n        }\\n        return count;\\n    }\\n\\n    private static boolean checkRight(int[] arr, int i, int k) {\\n        for (int a = i+1; a < arr.length; a++) {\\n            if (arr[a] - arr[i] == k) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static boolean checkLeft(int[] arr, int i, int k) {\\n        for (int a = 0; a < i; a++) {\\n            if (arr[i] - arr[a] == k) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] arr, int k) {\\n        int count = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            boolean left = checkLeft(arr, i, k);\\n            boolean right = checkRight(arr, i, k);\\n            if (left && right) count++;\\n        }\\n        return count;\\n    }\\n\\n    private static boolean checkRight(int[] arr, int i, int k) {\\n        for (int a = i+1; a < arr.length; a++) {\\n            if (arr[a] - arr[i] == k) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static boolean checkLeft(int[] arr, int i, int k) {\\n        for (int a = 0; a < i; a++) {\\n            if (arr[i] - arr[a] == k) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517926,
                "title": "super-simple-o-n-solution-with-explanation-and-code-in-python",
                "content": "## Reframing The Problem\\nThe problem wants us to find 3 numbers (i, j , k) such that i < j < k, nums[j] - nums[i] == diff, and nums[k] - nums[j] == diff. We can rearrange the last 2 constraints to define nums[j] and nums[k] in terms of nums[i] as follows:\\n\\n* *nums[j] - nums[i] == diff ---> **nums[j] = nums[i] + diff***\\n\\n* *nums[k] - nums[j] == diff ---> nums[k] = nums[j] + diff ---> nums[k] = (nums[i] + diff) + diff) ---> **nums[k] = nums[i] + (2 * diff)***\\n\\n## The Solution Explained\\nSo now we can just iterate over the array, considering one index (i) at a time, and look for indexes j and k such that i < j < k, index j\\'s value is  `nums[i] + diff` and index k\\'s value is `nums[i] + (2 * diff)`.  To speed up and simplify the looking up work, we can convert the nums array into a set (hashmap) data structure which has O(1) look up time complexity.  \\n\\nAdditionally, because the numbers in original array are sorted, if for any index i we find nums[i] + diff and nums[i] + (2 * diff)  in the set, we can be sure that they exist at indexes that satisfy the constraint of i < j < k since any value greater than current index number\\'s value would be at a higher index than current index *(nums[i] + diff and nums[i] + (2 * diff) will always be greater indexes than nums[i] since according to problem constraints 1 <= diff <= 50)*.\\n\\n## Code:\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        answer = 0  # to count number of arithemetic triplets\\n        lookup = set(nums)  # for faster searching\\n        \\n        for i, n in enumerate(nums):\\n            if ((n + diff) in lookup) and ((n + (2 * diff)) in lookup):\\n                answer += 1\\n        \\n        return answer\\n```\\n### Complexities\\n*(N = number of elements in array nums)*\\n**Time Complexity:** O(N). Converting nums to set is O(N), the for loop is O(N), and searching for elements in set (inside if condition) is O(1).\\n**Space Complexity:** O(N). Using one set which can contain maximum N elements\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        answer = 0  # to count number of arithemetic triplets\\n        lookup = set(nums)  # for faster searching\\n        \\n        for i, n in enumerate(nums):\\n            if ((n + diff) in lookup) and ((n + (2 * diff)) in lookup):\\n                answer += 1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516697,
                "title": "java-1ms-beats-98-3-load-nums-into-a-hashset-iterate-check-for-n-diff-and-n-2-diff",
                "content": "```\\n/*\\nRuntime: 1 ms, faster than 98.27% of Java online submissions for Number of Arithmetic Triplets.\\nMemory Usage: 40.4 MB, less than 92.92% of Java online submissions for Number of Arithmetic Triplets.\\nElapsed dev time: 6m\\n*/\\n\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n        \\n        int numTriplets = 0;  // what we\\'ll return\\n        \\n        for (int n : nums) {\\n            if ((set.contains(n + diff)) && set.contains(n + 2 * diff)) {\\n                ++numTriplets;\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 1 ms, faster than 98.27% of Java online submissions for Number of Arithmetic Triplets.\\nMemory Usage: 40.4 MB, less than 92.92% of Java online submissions for Number of Arithmetic Triplets.\\nElapsed dev time: 6m\\n*/\\n\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n        \\n        int numTriplets = 0;  // what we\\'ll return\\n        \\n        for (int n : nums) {\\n            if ((set.contains(n + diff)) && set.contains(n + 2 * diff)) {\\n                ++numTriplets;\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516434,
                "title": "java-hashmap-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int k = 0; k < nums.length; k++){\\n            int target = nums[k]-diff;  \\n            if(map.containsKey(target)) // looks for j\\n                if(map.containsKey(map.get(target))) // looks for i\\n                    count++;\\n            map.put(nums[k],nums[k] - diff);\\n        }\\n        return count;\\n        \\n    }\\n    \\n    \\n    //(0,-3),(1,-2),(4,1),(6,3),(7,4),(10,7)\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int k = 0; k < nums.length; k++){\\n            int target = nums[k]-diff;  \\n            if(map.containsKey(target)) // looks for j\\n                if(map.containsKey(map.get(target))) // looks for i\\n                    count++;\\n            map.put(nums[k],nums[k] - diff);\\n        }\\n        return count;\\n        \\n    }\\n    \\n    \\n    //(0,-3),(1,-2),(4,1),(6,3),(7,4),(10,7)\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505341,
                "title": "java-optimized-solution-brute-force-solution-explained",
                "content": "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n     \\n        //optimized solution\\n\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for( int num : nums){\\n            set.add(num);\\n        }\\n       \\n        int ans = 0;\\n            for( int num : nums){\\n                if(( set.contains(num + diff )  && set.contains(num + 2 * diff) ) ){\\n                    //first condition- j=d+i\\n                    //second condition - k=2d+i \\n                    ans++;\\n                    \\n                }\\n            }\\n        \\n        return ans;\\n        \\n        \\n        //Brute force\\n            \\n         \\n        /*\\n        int count=0;\\n       for(int i=0;i<nums.length-2;i++){\\n           for(int j=i+1;j<nums.length-1;j++){\\n               for(int k=j+1;k<nums.length;k++){\\n                   if(nums[j]-nums[i]==diff && nums[k]-nums[j]==diff){\\n                       count ++;\\n                   }\\n               }\\n           }\\n       }\\n        return count;*/\\n    \\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n     \\n        //optimized solution\\n\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for( int num : nums){\\n            set.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2505287,
                "title": "python-linear-solution",
                "content": "class Solution(object):\\n    def arithmeticTriplets(self, nums, diff):\\n\\t\\n        dic={}\\n        count=0\\n        for i in nums:\\n            dic[i]=1\\n        for i in nums:\\n            try:\\n                if dic[i+diff]==1 and dic[i+2*diff]==1:\\n                    count+=1\\n                    \\n            except KeyError:\\n                un=0\\n            dic[i]=0\\n        return count",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def arithmeticTriplets(self, nums, diff):\\n\\t\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 2504413,
                "title": "python-dictionary-solution-41-ms-time-o-n-space-o-n",
                "content": "For some reason using seen = set() uses slightly more space.\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = dict()\\n        count = 0\\n        for x in nums:\\n            if x - diff in seen and x - 2 * diff in seen:\\n                count += 1\\n            seen[x] = True\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        seen = dict()\\n        count = 0\\n        for x in nums:\\n            if x - diff in seen and x - 2 * diff in seen:\\n                count += 1\\n            seen[x] = True\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504375,
                "title": "java-easy-to-understand-o-n-soln-using-hashmap",
                "content": "```\\n public int arithmeticTriplets(int[] arr, int diff) {\\n        int n=arr.length;\\n        \\n        int ct=0;\\n        \\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i],1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(arr[i]+diff) && hm.containsKey(arr[i]+2*diff)){\\n                ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n public int arithmeticTriplets(int[] arr, int diff) {\\n        int n=arr.length;\\n        \\n        int ct=0;\\n        \\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++){\\n            hm.put(arr[i],1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(hm.containsKey(arr[i]+diff) && hm.containsKey(arr[i]+2*diff)){\\n                ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503102,
                "title": "2-solutions-arr-and-hashmap-1-ms-t-c-easy-short-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int[] arr = new int[201];\\n        for(int i: nums) arr[i]++;\\n\\n        int count = 0;\\n        for (int i: nums) {\\n            if (i + 2 * diff >= arr.length) break;\\n            if (arr[i + diff] > 0 && arr[i + 2 * diff] > 0) count++;\\n        }\\n        return count;\\n        \\n        \\n//         Map<Integer, Integer> map = new HashMap<>();\\n//         for(int i = 0; i < nums.length; i++) map.put(nums[i], i);\\n\\n//         int count = 0;\\n//         for (int i = 0; i < nums.length - 2; i++) {\\n//             if (map.get(nums[i] + diff) != null && map.get(nums[i] + 2 * diff) != null)\\n//                 count++;\\n//         }\\n//         return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489249,
                "title": "python-brute-force-and-optimised-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        # Brute force \\n        # Time: O(N3)\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:\\n                        count += 1\\n        return count\\n```\\n\\t\\t\\n```\\n        # Time: O(N),  Space: O(N)\\n        counter, res = {}, 0\\n        for num in nums:\\n            if counter.get(num - diff) and counter.get(num - 2 * diff):\\n                res += 1\\n            counter[num] = 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        # Brute force \\n        # Time: O(N3)\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:\\n                        count += 1\\n        return count\\n```\n```\\n        # Time: O(N),  Space: O(N)\\n        counter, res = {}, 0\\n        for num in nums:\\n            if counter.get(num - diff) and counter.get(num - 2 * diff):\\n                res += 1\\n            counter[num] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488509,
                "title": "simple-c-solution-map-approach-6ms-solution",
                "content": "Here the approach I used take 2 maps where 2nd map will be used to store the second number in triplet below is the approach given hope u understand.\\n```\\n//m1 holds the count of original array and m2 holds the second number of the pairs\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff)\\n    {\\n        unordered_map<int , int> m1 , m2;\\n        int count = 0;\\n        for(auto i : nums)\\n        {\\n            if(m1.find(i - diff) != m1.end())\\n            {\\n                if(m2.find(i - diff) != m2.end())\\n                    count += m2[i - diff];//If number is persent in both maps then triplet exist and this will handle the cases of duplicates also\\n                m2[i]++;// inserting the second number of the pair like 1 , 4 when diff = 3 it will store 4\\n            }\\n            m1[i]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//m1 holds the count of original array and m2 holds the second number of the pairs\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff)\\n    {\\n        unordered_map<int , int> m1 , m2;\\n        int count = 0;\\n        for(auto i : nums)\\n        {\\n            if(m1.find(i - diff) != m1.end())\\n            {\\n                if(m2.find(i - diff) != m2.end())\\n                    count += m2[i - diff];//If number is persent in both maps then triplet exist and this will handle the cases of duplicates also\\n                m2[i]++;// inserting the second number of the pair like 1 , 4 when diff = 3 it will store 4\\n            }\\n            m1[i]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457935,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int x : nums) set.add(x);\\n        \\n        int ans = 0;\\n        \\n        for (int x : nums) {\\n            if (set.contains(x - diff) && set.contains(x + diff)) ans++;\\n        }\\n\\t\\t\\n\\t\\t// OR\\n\\t\\t//   for (int i = nums.length - 1; i >= 0; i--) {\\n        //       if (set.contains(nums[i] - diff) && set.contains(nums[i] - 2 * diff)) ans++;\\n        //   }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int x : nums) set.add(x);\\n        \\n        int ans = 0;\\n        \\n        for (int x : nums) {\\n            if (set.contains(x - diff) && set.contains(x + diff)) ans++;\\n        }\\n\\t\\t\\n\\t\\t// OR\\n\\t\\t//   for (int i = nums.length - 1; i >= 0; i--) {\\n        //       if (set.contains(nums[i] - diff) && set.contains(nums[i] - 2 * diff)) ans++;\\n        //   }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457150,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        set<int>st;\\n        int count = 0;\\n        for(auto i:nums){\\n            st.insert(i);\\n            if(st.find(i-diff)!=st.end()){\\n                int k = i - 2*diff;\\n                if(st.find(k)!=st.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        set<int>st;\\n        int count = 0;\\n        for(auto i:nums){\\n            st.insert(i);\\n            if(st.find(i-diff)!=st.end()){\\n                int k = i - 2*diff;\\n                if(st.find(k)!=st.end()){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454001,
                "title": "python-one-line",
                "content": "```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return len([[x,x+diff,x+diff+diff] for x in nums if x+diff in nums if x+diff+diff in nums])\\n```",
                "solutionTags": [],
                "code": "```\\ndef arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return len([[x,x+diff,x+diff+diff] for x in nums if x+diff in nums if x+diff+diff in nums])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2447686,
                "title": "easy-and-best-solution-in-js",
                "content": "var arithmeticTriplets = function(nums, diff) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length - 2; i++) {\\n        let left = i + 1;\\n        let right = nums.length - 1;\\n        while(left < right) {\\n            let first = nums[left] - nums[i];\\n            let second = nums[right] - nums[left]\\n            if(first === diff &&  second === diff){\\n                count++;\\n                left++;\\n                right--;\\n            }\\n            else if(first < diff) left++;\\n            else right --;\\n        }\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "var arithmeticTriplets = function(nums, diff) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length - 2; i++) {\\n        let left = i + 1;\\n        let right = nums.length - 1;\\n        while(left < right) {\\n            let first = nums[left] - nums[i];\\n            let second = nums[right] - nums[left]\\n            if(first === diff &&  second === diff){\\n                count++;\\n                left++;\\n                right--;\\n            }\\n            else if(first < diff) left++;\\n            else right --;\\n        }\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2447562,
                "title": "8ms-c-easy-map-70-beats",
                "content": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }\\n        for(auto &i: mp){\\n            if(mp.count((i.first-diff)) && mp.count((i.first+diff)))\\n            ans += (mp[(i.first-diff)]*mp[(i.first+diff)]);\\n            // cout<<mp[(i.first-diff)]<<\" \"<<mp[(i.first+diff)]<<endl;;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arithmeticTriplets(vector<int>& nums, int diff) {\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2446530,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        hash_set = Counter(nums)\\n        count = 0\\n        for i in range(0 , len(nums)):\\n            if (nums[i] + diff)in hash_set and (nums[i] + 2*diff) in hash_set:\\n                count += 1\\n        return count      \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        hash_set = Counter(nums)\\n        count = 0\\n        for i in range(0 , len(nums)):\\n            if (nums[i] + diff)in hash_set and (nums[i] + 2*diff) in hash_set:\\n                count += 1\\n        return count      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428058,
                "title": "most-efficient-solution-and-easily-understandable-in-python-one-liner",
                "content": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum(1 for num in nums if num+diff in nums and num+(2*diff) in nums)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n        return sum(1 for num in nums if num+diff in nums and num+(2*diff) in nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427618,
                "title": "easily-understandable-and-simple-using-python-one-liner-optimized-solution",
                "content": "Just adding the Diff with elements present in the list and Checking whether the added number is in the list.\\n```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\tnums = set(nums)\\n        return sum(1 for num in nums if num+diff in nums and num+(2*diff) in nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\\n\\t\\tnums = set(nums)\\n        return sum(1 for num in nums if num+diff in nums and num+(2*diff) in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421294,
                "title": "c-runtime-faster-than-100-space-less-than-100",
                "content": "Hi All,\\nThe following code is ***as good as it gets***(screenshot attached). It\\'s easy to understand, so please ***upvote*** if you liked the solution.\\n```\\n\\t\\t    int count = 0;\\n            int n = nums.Length;\\n\\n            for (int i = 0; i < n-2; i++)\\n            {\\n                for (int j = i + 1; j < n-1; j++)\\n                {\\n                    for (int k = j + 1; k < n; k++)\\n                    {\\n                        if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        {\\n                            //Console.WriteLine(i + \" \"+ j + \" \" + k);\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2e5d911a-2aca-4503-bb42-f84eb0cad5ee_1660420016.30906.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\t    int count = 0;\\n            int n = nums.Length;\\n\\n            for (int i = 0; i < n-2; i++)\\n            {\\n                for (int j = i + 1; j < n-1; j++)\\n                {\\n                    for (int k = j + 1; k < n; k++)\\n                    {\\n                        if (nums[j] - nums[i] == diff && nums[k] - nums[j] == diff)\\n                        {\\n                            //Console.WriteLine(i + \" \"+ j + \" \" + k);\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1807992,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1798727,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1945513,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1757033,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1991867,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1991891,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1968162,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1836562,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1753837,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 2069288,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1807992,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1798727,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1945513,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1757033,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1991867,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1991891,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1968162,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1836562,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 1753837,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            },
            {
                "id": 2069288,
                "content": [
                    {
                        "username": "Code_Surgeon",
                        "content": "Numbers from nowhere, can someone please explain what\\'s happening here, am loosing my mind now"
                    },
                    {
                        "username": "monikkacha",
                        "content": "Would someone explain the question !"
                    },
                    {
                        "username": "ylee078",
                        "content": "basically, any if you pick any three numbers in the lists, the differences between the first and second, and the second and third must be equal to \"diff\".\nfor example in the first example,\n2-0 = 2\n4-2 = 2\ndiff = 2\nThat is one of the two occurences.\nThe funny thing is that regardless of what number you choose in the list. As long as it's not repetitive. it will always fulfills i<j<k (after all different indexes).\nSo you only need to care about if the smaller number \"i\" and the bigger number \"k\" is in the list."
                    },
                    {
                        "username": "Deep_down",
                        "content": "many of us \"after thinking about best approachs to the problem at end we just apply brute force approach\". \\nha ha ha.."
                    },
                    {
                        "username": "Karan_Hadiyal",
                        "content": "Use binary search to find nums[j] and nums[k]."
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "My approach simple, store all the elements in Hashmap and check of( map[nums[I]-diff] and map[nums[I]+diff]) and increase count if above condition is true... suggestions are welcome to make the approach efficient\\uD83D\\uDE07"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking to count the number of unique arithmetic triplets in the given list of numbers. A triplet is arithmetic if the difference between the second and first element is equal to the difference between the third and second element, and this difference equals a given value `diff`.\\n\\nHere\\'s an example: consider the list [1, 4, 7, 10] and diff = 3. The arithmetic triplets in this case would be (1, 4, 7) and (4, 7, 10), because in both cases the difference between each consecutive pair of elements is 3. So the output would be 2, because there are two such triplets.\\n\\nTo be considered a triplet, the three numbers have to be in the correct order in the array, not just any three numbers. For example, in the list [1, 7, 4, 10] with diff = 3, there are no arithmetic triplets, because even though 1, 4, and 7 could form a triplet, they are not in the right order in the array.\\n\\nAlso, the array `nums` is strictly increasing, which means that each number is larger than the previous number.\\n\\nThe goal is to find an efficient way to count all such triplets in the given array."
                    },
                    {
                        "username": "RomanGleizer",
                        "content": "I can give you a hint about getting all the triple pairs of an array using a triple loop:\n1) i = 0; i < nums.Length - 2; i++\n2) j = i + 1; j < nums.Length - 1; j++\n3) k = j + 1; k < nums.Length; k++"
                    },
                    {
                        "username": "datalinx",
                        "content": "Now that would be a brute force solution\\n"
                    },
                    {
                        "username": "RjTilton",
                        "content": "I, Uh, I was able to throw together a nested, nested, nested.... solution that works. \\nbut it is so slow it almost timed out. \\n\\nany one throw me a term to google that will help me learn something useful for things like this in the future?"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "This is on the \\'Two Pointers\\' problem list. You can practice this and others on the list."
                    },
                    {
                        "username": "Yuvjeet",
                        "content": "class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        int count = 0;\n        for(int i = 0; i < nums.size()-2; i++){\n            for(int j = i+1; j < nums.size()-1; j++){\n                if(nums[j]-nums[i] == diff){\n                    for(int k = j+1; k < nums.size(); k++){\n                        if(nums[k] - nums[j] == diff) count++;\n                        else\n                            if(nums[k] - nums[j] > diff) break;\n                    }\n                }\n                else{\n                    if(nums[j] - nums[i] > diff) break;\n                }\n            }\n        }\n        return count;\n    }\n};"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "Please don't post any solutions in this discussion.\n\nSeems like you can't read the rules. So stupid action!"
                    },
                    {
                        "username": "govindkumarsingh140",
                        "content": "I solved it in O(n^3). \\uD83E\\uDD7A\\uD83D\\uDE25"
                    }
                ]
            }
        ]
    }
]