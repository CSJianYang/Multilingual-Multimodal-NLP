[
    {
        "title": "Find Maximum Number of String Pairs",
        "question_content": "You are given a 0-indexed array words consisting of distinct strings.\nThe string words[i] can be paired with the string words[j] if:\n\n\tThe string words[i] is equal to the reversed string of words[j].\n\t0 <= i < j < words.length.\n\nReturn the maximum number of pairs that can be formed from the array words.\nNote that&nbsp;each string can belong in&nbsp;at most one pair.\n&nbsp;\nExample 1:\n\nInput: words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\nOutput: 2\nExplanation: In this example, we can form 2 pair of strings in the following way:\n- We pair the 0th string with the 2nd string, as the reversed string of word[0] is \"dc\" and is equal to words[2].\n- We pair the 1st string with the 3rd string, as the reversed string of word[1] is \"ca\" and is equal to words[3].\nIt can be proven that 2 is the maximum number of pairs that can be formed.\nExample 2:\n\nInput: words = [\"ab\",\"ba\",\"cc\"]\nOutput: 1\nExplanation: In this example, we can form 1 pair of strings in the following way:\n- We pair the 0th string with the 1st string, as the reversed string of words[1] is \"ab\" and is equal to words[0].\nIt can be proven that 1 is the maximum number of pairs that can be formed.\n\nExample 3:\n\nInput: words = [\"aa\",\"ab\"]\nOutput: 0\nExplanation: In this example, we are unable to form any pair of strings.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 50\n\twords[i].length == 2\n\twords&nbsp;consists of distinct strings.\n\twords[i]&nbsp;contains only lowercase English letters.",
        "solutions": [
            {
                "id": 3677578,
                "title": "explained-using-map-very-simple-easy-to-understand-solution",
                "content": "#### Upvote if you like the solution\\n# Approach\\n1. Take a map with seen string as the index and its count as its value.\\n2. Iterate the words vector and check if its reverse exist in the map or not. \\n3. If exist in the map then update the ans and decrement the map value as the we have considered this value for pairing.\\n\\n# Code\\n```\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string, int> mp;\\n        for(auto w: words){\\n            string r = w;\\n            reverse(r.begin(), r.end());\\n            if(mp[r] > 0){ ans++; mp[r]--; }\\n            else mp[w]++;\\n        }\\n        return ans;\\n    }\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string, int> mp;\\n        for(auto w: words){\\n            string r = w;\\n            reverse(r.begin(), r.end());\\n            if(mp[r] > 0){ ans++; mp[r]--; }\\n            else mp[w]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677686,
                "title": "676",
                "content": "There are 676 possible 2-character strings.\\n\\nSo, we can use a boolean array to track if we\\'ve seen a string before.\\n\\n**C++**\\n```cpp\\nint maximumNumberOfStringPairs(vector<string>& words) {\\n    int vis[676] = {}, res = 0;\\n    for (const auto &w : words) {\\n        res += vis[(w[1] - \\'a\\') * 26 + w[0] - \\'a\\'];\\n        vis[(w[0] - \\'a\\') * 26 + w[1] - \\'a\\'] = true;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumNumberOfStringPairs(vector<string>& words) {\\n    int vis[676] = {}, res = 0;\\n    for (const auto &w : words) {\\n        res += vis[(w[1] - \\'a\\') * 26 + w[0] - \\'a\\'];\\n        vis[(w[0] - \\'a\\') * 26 + w[1] - \\'a\\'] = true;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677662,
                "title": "c-java-python-o-1-space-easy-to-understand-with-explanation",
                "content": "- Time complexity : O(n^2)\\n- Space complexity : O(1)\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int ans = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n\\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    ans++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n\\n        return ans; // Return the total number of matching pairs\\n    }\\n};\\n\\n```\\n# Phython Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, word: List[str]) -> int:\\n        ans = 0\\n        n = len(word)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if word[i][0] == word[j][1] and word[i][1] == word[j][0]:\\n                    ans += 1\\n        return ans\\n```\\n# JAVA Code \\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int ans = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n\\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    ans++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n\\n        return ans; // Return the total number of matching pairs\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, word: List[str]) -> int:\\n        ans = 0\\n        n = len(word)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if word[i][0] == word[j][1] and word[i][1] == word[j][0]:\\n                    ans += 1\\n        return ans\\n```\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677591,
                "title": "easy-c-solution-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nreverse  and check the string is  present in the set\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string>mp;\\n        int res=0;\\n        for(auto it:words){\\n            string s=it;\\n            reverse(it.begin(),it.end());\\n            if(mp.find(it)==mp.end()){\\n                mp.insert(s);\\n            }\\n            else res++;\\n           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string>mp;\\n        int res=0;\\n        for(auto it:words){\\n            string s=it;\\n            reverse(it.begin(),it.end());\\n            if(mp.find(it)==mp.end()){\\n                mp.insert(s);\\n            }\\n            else res++;\\n           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721668,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n# Intuition\\nThe problem asks us to find the maximum number of pairs that can be formed from a given list of words, where two words can be paired if one is the reverse of the other. We can use a set to keep track of the reversed versions of the words we have seen so far, and increment our answer whenever we encounter a word that is already in the set.\\n\\n# Approach\\n1. Initialize an empty set `strings` to keep track of the reversed versions of the words we have seen so far.\\n2. Initialize a variable `ans` to 0 to keep track of the number of pairs we have found.\\n3. Iterate over each word `w` in `words`.\\n4. If `w` is in `strings`, increment `ans` by 1.\\n5. Otherwise, add the reversed version of `w` to `strings`.\\n6. Return `ans`.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where $$n$$ is the number of words and $$k$$ is the maximum length of a word.\\n- Space complexity: $$O(nk)$$, where $$n$$ is the number of words and $$k$$ is the maximum length of a word.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        strings = set()\\n        ans = 0\\n        for w in words:\\n            if w in strings:\\n                ans += 1\\n            else:\\n                strings.add(w[::-1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        strings = set()\\n        ans = 0\\n        for w in words:\\n            if w in strings:\\n                ans += 1\\n            else:\\n                strings.add(w[::-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678533,
                "title": "c-set-vs-hashing-string-to-int-vs-bitmask-hashing-4ms-20-5mb",
                "content": "Let\\'s start with the simplest approach, which means we will use a hashset (`seen`) to keep track of already encountered strings.\\n\\nMore specifically, we will start declaring:\\n* `res` as our usual counter variable, initially set to be `0`;\\n* `seen`, our set where we will store what we already saw (or its reverse, in the second version of this solution down below).\\n\\nFor each `word` in `words`, we will:\\n* store the original `word` in `orig`;\\n* swap its first and second character;\\n* check if we have ever seen the newly reversed `word` in `seen` and, if so, increase `res` by `1`;\\n* store `orig` in `seen`.\\n\\nFinally, we will `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            string orig = word;\\n            swap(word[0], word[1]);\\n            if (seen.find(word) != end(seen)) res++;\\n            seen.insert(orig);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWe can actually play a bit smarter here and look up for the word itself, then store just the reverse of it, having to use `tmp` all the time:\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            if (seen.find(word) != end(seen)) res++;\\n            swap(word[0], word[1]);\\n            seen.insert(word);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut we can do better if we just consider that we have an alphabet of only `26` characters, and each word will only be `2` characters - so we can hash each string counting in base `26`, for a grant total of `26 * 26 == 676` cells.\\n\\nWe can then hash each word into an `int` and do way quicker checks about what we have seen before or not (albeit with potentially higher initialisation costs for `seen` with smaller sets of words).\\n\\nNotice we might actually optimise a bit more, space-wise, if we consider that strings like `\"aa\"`, `\"bb\"`, `\"cc\"`, etc. have no place being considered and since they appear every `27` positions, proceeding lexicographically, we might adjust our hashing by subtracting its value `/ 27`, but not really worth all the cost to save a handful of bites.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxRange = 676;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = (word[0] - \\'a\\') * 26 + word[1] - \\'a\\';\\n            if (seen[tmp]) res++;\\n            seen[(word[1] - \\'a\\') * 26 + word[0] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSame core logic, but hashing getting the value of each character with a bitmask (`\\'a\\' & 31` is `1`, `\\'b\\' & 31` is `2`, and so on), using `5` bits for each digits (since they are enough to represent values up to `31`, so fully within our range), which makes `10` bits total or, in other words, `1024` slots in `seen`.\\n\\nAgain, not a major increment with the small values we are dealing with, but still maybe a tad faster and a lot of fun to handle.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxRange = 1024, bitmask = 31;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = ((word[0] & bitmask) << 5) + (word[1] & bitmask);\\n            if (seen[tmp]) res++;\\n            seen[((word[1] & bitmask) << 5) + (word[0] & bitmask)] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation",
                    "Hash Function",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            string orig = word;\\n            swap(word[0], word[1]);\\n            if (seen.find(word) != end(seen)) res++;\\n            seen.insert(orig);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0;\\n        unordered_set<string> seen;\\n        // parsing words\\n        for (string &word: words) {\\n            if (seen.find(word) != end(seen)) res++;\\n            swap(word[0], word[1]);\\n            seen.insert(word);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxRange = 676;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = (word[0] - \\'a\\') * 26 + word[1] - \\'a\\';\\n            if (seen[tmp]) res++;\\n            seen[(word[1] - \\'a\\') * 26 + word[0] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxRange = 1024, bitmask = 31;\\n\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string> &words) {\\n        // suppor variables\\n        int res = 0, tmp;\\n        bool seen[maxRange] = {};\\n        // parsing words\\n        for (string &word: words) {\\n            tmp = ((word[0] & bitmask) << 5) + (word[1] & bitmask);\\n            if (seen[tmp]) res++;\\n            seen[((word[1] & bitmask) << 5) + (word[0] & bitmask)] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834659,
                "title": "python-3-3-lines-w-explanation-t-m-99-77",
                "content": "Here\\'s how the code works:\\n\\nThe code initializes`d`to keep track of the count of each word or its reverse.\\n\\nWe iterate over each word in`words`, and we use the lexicographic minimum of the word and its reverse (`word[::-1]`)as the key for loading `words` into `d`, which ensures that the same pair is counted only once.\\n\\nWe return the sum of the counts of pairs in each value (using`x*(x-1)//2`) as the answer.\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n        d = defaultdict(int)\\n\\n        for word in words:\\n            d[min(word, word[::-1])]+= 1\\n        \\n        return  sum(map((lambda x: x*(x-1)), d.values()))//2\\n```\\n[https://leetcode.com/problems/find-maximum-number-of-string-pairs/submissions/978714868/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*NM*) and space complexity is *O*(*N*), in which *N* ~`len(nums)` and *M* ~ average`len(word)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n        d = defaultdict(int)\\n\\n        for word in words:\\n            d[min(word, word[::-1])]+= 1\\n        \\n        return  sum(map((lambda x: x*(x-1)), d.values()))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816585,
                "title": "video-maximum-number-of-string-pairs-reversed-string-pairing",
                "content": "# Intuition\\nUpon reading the problem, it\\'s apparent that we need to pair strings that are the reverse of each other. The first instinct is to use a data structure that allows quick lookups to check for the existence of a reversed word. A Python dictionary fits this need perfectly.\\n\\nhttps://www.youtube.com/watch?v=zL2d3G-nO0A\\n\\n# Approach\\nWe\\'ll start by initializing an empty dictionary and a counter variable to track the number of pairs. Next, we iterate through each word in the list. For each word, we generate its reversed counterpart and check if this reversed word is in the dictionary. If it is, we increment our counter and remove the reversed word from the dictionary, effectively forming a pair. If not, we add the original word to the dictionary. This process continues until we\\'ve iterated through all the words. Finally, we return the counter as the result, which is the maximum number of pairs we can form.\\n\\n# Complexity\\n- Time complexity: The time complexity is \\\\(O(n)\\\\) where \\\\(n\\\\) is the length of the input list. This is because we\\'re iterating through the list once.\\n\\n- Space complexity: The space complexity is also \\\\(O(n)\\\\) in the worst-case scenario where no words can be paired and all words end up in the dictionary.\\n\\nIn the code, we\\'ve used Python\\'s string slicing feature to reverse the string and dictionary\\'s quick lookup feature to find the reversed string. This solution thus efficiently solves the problem.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_dict = {} \\n        pairs = 0 \\n        for word in words: \\n            reversed_word = word[::-1] \\n            if reversed_word in word_dict: \\n                word_dict.pop(reversed_word) \\n                pairs += 1 \\n            else: \\n                word_dict[word] = 1 \\n        return pairs \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        std::unordered_map<std::string, int> word_dict;\\n        int pairs = 0;\\n        for (auto& word : words) {\\n            std::string reversed_word = word;\\n            std::reverse(reversed_word.begin(), reversed_word.end());\\n            if (word_dict[reversed_word]) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String, Integer> word_dict = new HashMap<>();\\n        int pairs = 0;\\n        for (String word : words) {\\n            String reversed_word = new StringBuilder(word).reverse().toString();\\n            if (word_dict.containsKey(reversed_word) && word_dict.get(reversed_word) > 0) {\\n                word_dict.put(reversed_word, word_dict.get(reversed_word) - 1);\\n                pairs++;\\n            }\\n            else {\\n                word_dict.put(word, word_dict.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let word_dict = {};\\n    let pairs = 0;\\n    for (let word of words) {\\n        let reversed_word = word.split(\\'\\').reverse().join(\\'\\');\\n        if (word_dict[reversed_word]) {\\n            word_dict[reversed_word]--;\\n            pairs++;\\n        }\\n        else {\\n            word_dict[word] = (word_dict[word] || 0) + 1;\\n        }\\n    }\\n    return pairs;    \\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string, int> word_dict = new Dictionary<string, int>();\\n        int pairs = 0;\\n        foreach (string word in words) {\\n            char[] arr = word.ToCharArray();\\n            Array.Reverse(arr);\\n            string reversed_word = new string(arr);\\n            if (word_dict.ContainsKey(reversed_word) && word_dict[reversed_word] > 0) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                if (!word_dict.ContainsKey(word)) word_dict[word] = 0;\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_dict = {} \\n        pairs = 0 \\n        for word in words: \\n            reversed_word = word[::-1] \\n            if reversed_word in word_dict: \\n                word_dict.pop(reversed_word) \\n                pairs += 1 \\n            else: \\n                word_dict[word] = 1 \\n        return pairs \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        std::unordered_map<std::string, int> word_dict;\\n        int pairs = 0;\\n        for (auto& word : words) {\\n            std::string reversed_word = word;\\n            std::reverse(reversed_word.begin(), reversed_word.end());\\n            if (word_dict[reversed_word]) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String, Integer> word_dict = new HashMap<>();\\n        int pairs = 0;\\n        for (String word : words) {\\n            String reversed_word = new StringBuilder(word).reverse().toString();\\n            if (word_dict.containsKey(reversed_word) && word_dict.get(reversed_word) > 0) {\\n                word_dict.put(reversed_word, word_dict.get(reversed_word) - 1);\\n                pairs++;\\n            }\\n            else {\\n                word_dict.put(word, word_dict.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let word_dict = {};\\n    let pairs = 0;\\n    for (let word of words) {\\n        let reversed_word = word.split(\\'\\').reverse().join(\\'\\');\\n        if (word_dict[reversed_word]) {\\n            word_dict[reversed_word]--;\\n            pairs++;\\n        }\\n        else {\\n            word_dict[word] = (word_dict[word] || 0) + 1;\\n        }\\n    }\\n    return pairs;    \\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string, int> word_dict = new Dictionary<string, int>();\\n        int pairs = 0;\\n        foreach (string word in words) {\\n            char[] arr = word.ToCharArray();\\n            Array.Reverse(arr);\\n            string reversed_word = new string(arr);\\n            if (word_dict.ContainsKey(reversed_word) && word_dict[reversed_word] > 0) {\\n                word_dict[reversed_word]--;\\n                pairs++;\\n            }\\n            else {\\n                if (!word_dict.ContainsKey(word)) word_dict[word] = 0;\\n                word_dict[word]++;\\n            }\\n        }\\n        return pairs;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738371,
                "title": "simple-java-with-iterator",
                "content": "# Approach\\nI used Iterator and StringBuffer.reverse() for easy and simple solution.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        List<String> wordsList = new ArrayList(Arrays.asList(words));\\n        int count = 0;\\n        for (Iterator<String> wordsIterator = wordsList.iterator(); wordsIterator.hasNext();) {\\n            String word = wordsIterator.next();\\n            wordsIterator.remove();\\n            if (wordsList.contains(reverse(word))) count++;\\n        }\\n        return count;\\n    }\\n\\n    private String reverse(String input) {\\n        return new StringBuffer(input).reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        List<String> wordsList = new ArrayList(Arrays.asList(words));\\n        int count = 0;\\n        for (Iterator<String> wordsIterator = wordsList.iterator(); wordsIterator.hasNext();) {\\n            String word = wordsIterator.next();\\n            wordsIterator.remove();\\n            if (wordsList.contains(reverse(word))) count++;\\n        }\\n        return count;\\n    }\\n\\n    private String reverse(String input) {\\n        return new StringBuffer(input).reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736904,
                "title": "java-solution-using-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find whether the reverse of a string at words[i] is present at index j such that 0<=i<j<words.length and return the count of such pairs found.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used two for loops one from i=0 to words.length and inside it from j=i+1 to words.length and stored the words[j] in a string builder and compared it to the words[i] by reversing the one at index j and after the comparison has taken place then emtpying the stringbuilder so that new string can be stored in it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                sb.append(words[j]);\\n                if(words[i].equals(sb.reverse().toString())){\\n                    count++;\\n                }\\n                sb.delete(0,sb.length());\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/789fb96d-4a96-464c-a4ee-ea8b1f844689_1688829277.9101799.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                sb.append(words[j]);\\n                if(words[i].equals(sb.reverse().toString())){\\n                    count++;\\n                }\\n                sb.delete(0,sb.length());\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690265,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681331,
                "title": "easy-peasy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677706,
                "title": "java-o-n-runtime-o-n-space-scalable-solution-using-stringbuilder-reverse",
                "content": "O(N) runtime due to iteration through `words`.\\nO(N) space due to HashSet `wordSet` that may go up to N, the input `words` length.\\n\\nPairs are unique so removing from HashSet is never needed.\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int maxPairs = 0;\\n        \\n        //Iterate through words and insert them into a HashSet\\n        //At each word, check if you have seen it\\'s reverse\\n        Set<String> wordSet = new HashSet<>();\\n        \\n        for(String word : words) {\\n            StringBuilder sb = new StringBuilder(word);\\n            String reversedWord = sb.reverse().toString();\\n            \\n            //We have seen the reverse here, so we increment a pair has been found\\n\\t\\t\\t//contains() check is O(1) runtime\\n            if(wordSet.contains(reversedWord)) {\\n                maxPairs++;\\n            }\\n            \\n            //Always add a word that we have run across\\n            wordSet.add(word);\\n        }\\n        \\n        return maxPairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int maxPairs = 0;\\n        \\n        //Iterate through words and insert them into a HashSet\\n        //At each word, check if you have seen it\\'s reverse\\n        Set<String> wordSet = new HashSet<>();\\n        \\n        for(String word : words) {\\n            StringBuilder sb = new StringBuilder(word);\\n            String reversedWord = sb.reverse().toString();\\n            \\n            //We have seen the reverse here, so we increment a pair has been found\\n\\t\\t\\t//contains() check is O(1) runtime\\n            if(wordSet.contains(reversedWord)) {\\n                maxPairs++;\\n            }\\n            \\n            //Always add a word that we have run across\\n            wordSet.add(word);\\n        }\\n        \\n        return maxPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677535,
                "title": "map-c-most-simple-easy-to-understand",
                "content": "# if this code helps you, please upvote\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        string s;\\n        for(auto &i: words){\\n            s = i;\\n            reverse(s.begin(),s.end());\\n            if(mp.count(s)){\\n                ans++;\\n                mp.erase(i);\\n            }else{\\n                mp[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        string s;\\n        for(auto &i: words){\\n            s = i;\\n            reverse(s.begin(),s.end());\\n            if(mp.count(s)){\\n                ans++;\\n                mp.erase(i);\\n            }else{\\n                mp[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678773,
                "title": "1-line-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        return len(words)-len({f\"{sorted(i)}\" for i in words})\\n        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        return len(words)-len({f\"{sorted(i)}\" for i in words})\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677874,
                "title": "c-brute-force-set-solution-2-solution",
                "content": "# Intuition\\nThink of reverse the each words of the given string and check if the reverse words available or not.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n1. *Brute Force:* **O(n^2)**\\n2. *Set:* **O(n)**\\n\\n- Space complexity:**O(n)**\\n\\n---\\n\\n\\n**Solution 1 - Brute Force**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> rev;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(),str.end());\\n            rev.push_back(str);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(words[i] == rev[j] && i!=j)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n**Solution 2 - Set**\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int r = 0;\\n        for (string &word : words) {\\n            sort(word.begin(), word.end());\\n            r += !s.insert(word).second;\\n        }\\n        return r;  \\n    }\\n};\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/970e1476-e7e6-4150-8f2c-33d33fac059f_1687626500.9282358.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> rev;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(),str.end());\\n            rev.push_back(str);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(words[i] == rev[j] && i!=j)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int r = 0;\\n        for (string &word : words) {\\n            sort(word.begin(), word.end());\\n            r += !s.insert(word).second;\\n        }\\n        return r;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677526,
                "title": "simple-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s : words) {\\n            String rev = new StringBuilder(s).reverse().toString();\\n            if(map.containsKey(rev))    map.put(rev, map.get(rev)+1);\\n            else    map.put(s,0);\\n        }\\n        int ans = 0;\\n        for(int value : map.values())   ans += value;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String s : words) {\\n            String rev = new StringBuilder(s).reverse().toString();\\n            if(map.containsKey(rev))    map.put(rev, map.get(rev)+1);\\n            else    map.put(s,0);\\n        }\\n        int ans = 0;\\n        for(int value : map.values())   ans += value;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917802,
                "title": "finding-maximum-number-of-string-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWHEN I SEE THIS PROBLEM: Find Maximum Number of (String Pairs)\\n![image.png](https://assets.leetcode.com/users/images/da4fa02d-8240-425d-9ee7-93b95966a1ed_1692186832.7186623.png)\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        ArrayList<String> obj=new  ArrayList<String>();\\n        Collections.addAll(obj,words);\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String str=words[i];\\n            int n=str.length();\\n            String ktr=\"\";\\n            //REVERSE\\n            for(int k=0;k<n;k++){\\n                ktr=str.charAt(k)+ktr;\\n            }\\n            //REMOVE ELEMENTS LIKE \"ZZ\",\"aa\"\\n            if(ktr.equals(str)){\\n                 obj.remove(ktr);\\n            }\\n             //REMOVE ELEMENTS IF PRESENT IN ARRAY LIST\\n            if(obj.contains(ktr)){\\n                obj.remove(str); \\n                count++;\\n            }\\n            \\n         \\n          \\n        }\\n        \\n        return count;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        ArrayList<String> obj=new  ArrayList<String>();\\n        Collections.addAll(obj,words);\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String str=words[i];\\n            int n=str.length();\\n            String ktr=\"\";\\n            //REVERSE\\n            for(int k=0;k<n;k++){\\n                ktr=str.charAt(k)+ktr;\\n            }\\n            //REMOVE ELEMENTS LIKE \"ZZ\",\"aa\"\\n            if(ktr.equals(str)){\\n                 obj.remove(ktr);\\n            }\\n             //REMOVE ELEMENTS IF PRESENT IN ARRAY LIST\\n            if(obj.contains(ktr)){\\n                obj.remove(str); \\n                count++;\\n            }\\n            \\n         \\n          \\n        }\\n        \\n        return count;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786951,
                "title": "2-c-solutions-using-hash-map-and-hash-set-approach-beats-100",
                "content": "# Code\\n```\\n// Soution 1 (HashMap)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(mp[rev] > 0)\\n                ans++, mp[rev]--;\\n            else\\n                mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 (Using HashSet, beats 100%)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(s.find(rev) == s.end())\\n                s.insert(i);\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n// Soution 1 (HashMap)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(mp[rev] > 0)\\n                ans++, mp[rev]--;\\n            else\\n                mp[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 (Using HashSet, beats 100%)\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> s;\\n        int ans = 0;\\n        for(auto i : words){\\n            string rev = i;\\n            reverse(rev.begin(), rev.end());\\n            if(s.find(rev) == s.end())\\n                s.insert(i);\\n            else\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688778,
                "title": "most-easy-c-ode",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string a=words[i];\\n                string b=words[j];\\n                reverse(b.begin(),b.end());\\n                if(a==b)\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                string a=words[i];\\n                string b=words[j];\\n                reverse(b.begin(),b.end());\\n                if(a==b)\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686613,
                "title": "string-pairs-javascript-beats-99-46-56-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/5387b061-43d8-4eb2-ad68-62c894a3d6f3_1687823172.9767308.png)\\n\\n1. Solution with two for loops\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n\\n    for (let i = 0; i < words.length; i++) \\n        for (let j = i + 1; j < words.length; j++) \\n            if (words[i][0] == words[j][1])\\n                if (words[i][1] == words[j][0])\\n                    count ++            \\n           \\n    return count\\n};\\n```\\n2. Solution with Hash Table\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n    obj = {}\\n    \\n    for (word of words) {\\n        reverse = word[1] + word[0]        \\n\\n        if (obj[reverse] == true) count ++\\n\\n        obj[word] = true        \\n    }    \\n    \\n    return count\\n};\\n```\\nPlease put likes, leave comments, share my solution, I try to find the best solutions)",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n\\n    for (let i = 0; i < words.length; i++) \\n        for (let j = i + 1; j < words.length; j++) \\n            if (words[i][0] == words[j][1])\\n                if (words[i][1] == words[j][0])\\n                    count ++            \\n           \\n    return count\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    count = 0 \\n    obj = {}\\n    \\n    for (word of words) {\\n        reverse = word[1] + word[0]        \\n\\n        if (obj[reverse] == true) count ++\\n\\n        obj[word] = true        \\n    }    \\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678859,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        ans = 0\\n        for i in range(len(words)):\\n            for j in range(i+1, len(words)):\\n                if words[i][0] == words[j][1] and words[i][1] == words[j][0]:\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        ans = 0\\n        for i in range(len(words)):\\n            for j in range(i+1, len(words)):\\n                if words[i][0] == words[j][1] and words[i][1] == words[j][0]:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677771,
                "title": "easy-bruteforce",
                "content": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(reverse(words[j]))){\\n                   // System.out.println(words[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static String  reverse(String str) {\\n        String ans=\"\";\\n        ans+=str.charAt(1);\\n        ans+=str.charAt(0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].equals(reverse(words[j]))){\\n                   // System.out.println(words[i]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static String  reverse(String str) {\\n        String ans=\"\";\\n        ans+=str.charAt(1);\\n        ans+=str.charAt(0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677520,
                "title": "javascript-simple-solution-with-explanation",
                "content": "# Approach\\n\\n1. Initialize `maxPairs` to keep track of the maximum number of pairs\\n2. Initialize `wordSet` to track words that can potentially form pairs\\n3. Iterate through the words:\\n    - sort the word lexicographically\\n    - checks if it is in `wordSet`\\n    - if found, a pair is formed, increment `maxPairs` and remove the word from the set\\n    - otherwise, add the word to the set\\n4. Return `maxPairs`\\n\\n# Complexity\\n\\n- Time Complexity: `O(n)` - It iterates through the array once.\\n- Space Complexity: `O(n)` - In the worst case, all words could be added to the set.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = function (words) {\\n  let maxPairs = 0;\\n  const wordSet = new Set();\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const w = words[i][0] > words[i][1] \\n      ? words[i][1] + words[i][0] \\n      : words[i];\\n\\n    if (wordSet.has(w)) {\\n      maxPairs++;\\n      wordSet.delete(w);\\n    } else {\\n      wordSet.add(w);\\n    }\\n  }\\n  return maxPairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = function (words) {\\n  let maxPairs = 0;\\n  const wordSet = new Set();\\n\\n  for (let i = 0; i < words.length; i++) {\\n    const w = words[i][0] > words[i][1] \\n      ? words[i][1] + words[i][0] \\n      : words[i];\\n\\n    if (wordSet.has(w)) {\\n      maxPairs++;\\n      wordSet.delete(w);\\n    } else {\\n      wordSet.add(w);\\n    }\\n  }\\n  return maxPairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048840,
                "title": "find-maximum-number-of-string-pairs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Unordered map\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, string> mp;\\n        int i, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            if(mp.find(str)!=mp.end())\\n            {\\n                mp[str] = words[i];\\n                count++;\\n            }\\n            else\\n            {\\n                mp[words[i]] = \"\";\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0933a2a5-9a92-4f43-a9a0-46eeda81e2b2_1694801285.4025972.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, string> mp;\\n        int i, count=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            string str = words[i];\\n            reverse(str.begin(), str.end());\\n            if(mp.find(str)!=mp.end())\\n            {\\n                mp[str] = words[i];\\n                count++;\\n            }\\n            else\\n            {\\n                mp[words[i]] = \"\";\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956301,
                "title": "easy-java-solution-beats-100",
                "content": "We can use a nested for-loop to iterate through our \\'words\\' array and compare any two words in our array without worrying about it being counted as a duplicate (because the second for loop starts at \\'i+1\\' to ensure it can not be compared again). \\n    We can make use of String\\'s charAt function to compare the characters. Since we are dealing with Strings of length 2, we can use charAt to compare the 1st character of one word with the 2nd character of the other word (We cannot use String.reverse or any similar functionality because Strings are not mutable in Java). If the comparison works, increment the pairs variable and return it at the end of the nested for loop.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = i + 1; j < words.length; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    pairs++;\\n                }\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = i + 1; j < words.length; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) {\\n                    pairs++;\\n                }\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949732,
                "title": "beats-95-59-64-74-the-most-simple-js-solution",
                "content": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const set = new Set()\\n    let cnt = 0\\n    \\n    for (let word of words) {\\n        if (set.has(word.split(\\'\\').reverse().join(\\'\\'))) cnt++\\n        \\n        set.add(word)\\n    }\\n    \\n    return cnt\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const set = new Set()\\n    let cnt = 0\\n    \\n    for (let word of words) {\\n        if (set.has(word.split(\\'\\').reverse().join(\\'\\'))) cnt++\\n        \\n        set.add(word)\\n    }\\n    \\n    return cnt\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874241,
                "title": "simple-solution-using-hash-map-easy-to-understand-for-beginners-beats-about-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![Screenshot from 2023-08-07 07-01-17.png](https://assets.leetcode.com/users/images/7258eb3a-f009-4df7-a514-c0ecc1501da6_1691373718.0283215.png)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for i,word in enumerate(words):\\n            dict_[word[::-1]] = i\\n        pairs = 0\\n        extra = []\\n        for i,element in enumerate(words):\\n            if element in dict_ and dict_[element] != i and element not in extra:\\n                pairs += 1\\n                extra.append(element[::-1])\\n            else:\\n                continue\\n        return pairs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        from collections import defaultdict\\n        dict_ = defaultdict(int)\\n        for i,word in enumerate(words):\\n            dict_[word[::-1]] = i\\n        pairs = 0\\n        extra = []\\n        for i,element in enumerate(words):\\n            if element in dict_ and dict_[element] != i and element not in extra:\\n                pairs += 1\\n                extra.append(element[::-1])\\n            else:\\n                continue\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851809,
                "title": "java-1ms-run-o-n-mem-o-1-boolean-flags-no-hashmap",
                "content": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] found = new boolean[26 * 26];\\n        int pairCount = 0;\\n        for (String s : words) {\\n            if (found[(s.charAt(1) - \\'a\\') * 26 + s.charAt(0) - \\'a\\'])  pairCount++;\\n            found[(s.charAt(0) - \\'a\\') * 26 + s.charAt(1) - \\'a\\'] = true;\\n        }\\n        return pairCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] found = new boolean[26 * 26];\\n        int pairCount = 0;\\n        for (String s : words) {\\n            if (found[(s.charAt(1) - \\'a\\') * 26 + s.charAt(0) - \\'a\\'])  pairCount++;\\n            found[(s.charAt(0) - \\'a\\') * 26 + s.charAt(1) - \\'a\\'] = true;\\n        }\\n        return pairCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811281,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=words.length;\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n          for(int j = i + 1; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n            if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n\\t\\t\\t\\t\\t\\t{\\n              count++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=words.length;\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n          for(int j = i + 1; j < n; j++)\\n\\t\\t\\t\\t\\t{\\n            if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n\\t\\t\\t\\t\\t\\t{\\n              count++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784379,
                "title": "java-easy-solution-without-stringbuilder-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the entire array words count the number of times a word and its reverse is present in the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor all the words check if the first letter of a word equals the second letter of another word in the array `words`  and vice versa\\n\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769081,
                "title": "easy-c-solution-using-linear-search",
                "content": "# Intuition\\n\\n# Approach\\nBrute Force Solution:\\nUsing two loops firstly reverse the string of words and compare string of entire words.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        string s;\\n        int count = 0;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                s = words[j];\\n                reverse(s.begin(),s.end());\\n                if(words[i]==s)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        string s;\\n        int count = 0;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                s = words[j];\\n                reverse(s.begin(),s.end());\\n                if(words[i]==s)    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763010,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        return words.count - Set(words.map(Set.init)).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        return words.count - Set(words.map(Set.init)).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762980,
                "title": "simple-php-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        //Here we\\'ll keep words as array keys\\n        $hash = [];\\n        $counter = 0;\\n        //for every item in $words\\n        foreach ($words as $value) {\\n            //if $hash has item with key == reverse $value then increment $counter\\n            if ($hash[strrev($value)]) {\\n                $counter++;\\n            } else {\\n                //if item has not pair then just save it in $hash\\n                $hash[$value] = \\'1\\';\\n            }\\n        }\\n        return $counter;\\n    }\\n}\\n```\\n# P.S.\\nUpvote if it helps you)\\n",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        //Here we\\'ll keep words as array keys\\n        $hash = [];\\n        $counter = 0;\\n        //for every item in $words\\n        foreach ($words as $value) {\\n            //if $hash has item with key == reverse $value then increment $counter\\n            if ($hash[strrev($value)]) {\\n                $counter++;\\n            } else {\\n                //if item has not pair then just save it in $hash\\n                $hash[$value] = \\'1\\';\\n            }\\n        }\\n        return $counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748429,
                "title": "java-simple-solution-rutime-100-memory-94-with-explanation",
                "content": "# Approach\\n\\n1. Initialize two variables: `n` to store the length of the `words` array and `cnt` to keep track of the count of valid pairs.\\n2. Use nested loops to iterate over all possible pairs of strings in the `words` array. The outer loop variable `i` represents the index of the first word, and the inner loop variable `j` represents the index of the second word.\\n3. Inside the nested loops, check if the first character of `words[i]` is equal to the second character of `words[j]`, and the second character of `words[i]` is equal to the first character of `words[j]`. This condition ensures that the two words can be paired according to the given conditions.\\n4. If the condition is satisfied, increment the `cnt` variable by 1.\\n5. After the loops finish executing, return the final value of `cnt` as the maximum number of pairs that can be formed.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n = words.length;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n                        cnt++;\\n                        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n = words.length;\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = i + 1; j < n; j++)\\n                if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n                        cnt++;\\n                        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740459,
                "title": "q2744-accepted-c-hashmap-o-n-easiest-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int count = 0;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(words[i][0] > words[i][1]){\\n                swap(words[i][0],words[i][1]);\\n            }\\n            mp[words[i]]++;\\n        }\\n            \\n        for(auto i : mp)\\n            count += i.second/2;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int count = 0;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(words[i][0] > words[i][1]){\\n                swap(words[i][0],words[i][1]);\\n            }\\n            mp[words[i]]++;\\n        }\\n            \\n        for(auto i : mp)\\n            count += i.second/2;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736558,
                "title": "easy-simple-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }\\n            else{\\n                arr.put(words[i],0);\\n            }\\n        }\\n\\n        for(int j : arr.values()){\\n            count += j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n        HashMap<String,Integer> arr = new HashMap<>();\\n\\n        for(int i=0 ;i<words.length;i++){\\n             String r = new StringBuilder(words[i]).reverse().toString();\\n            if(arr.containsKey(r)){\\n                arr.put(r, arr.get(r)+1);\\n            }\\n            else{\\n                arr.put(words[i],0);\\n            }\\n        }\\n\\n        for(int j : arr.values()){\\n            count += j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732675,
                "title": "java-2-different-approach-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:words){\\n            set.add(s);\\n        }\\n        System.out.println(set);\\n\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String rev=reverse(words[i]);\\n            set.remove(words[i]);\\n            if(set.contains(rev)){\\n                count++;\\n                set.remove(rev);\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String temp){\\n        char ch[]=temp.toCharArray();\\n        char cur=ch[0];\\n        ch[0]=ch[1];\\n        ch[1]=cur;\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            ans+=ch[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:words){\\n            set.add(s);\\n        }\\n        System.out.println(set);\\n\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String rev=reverse(words[i]);\\n            set.remove(words[i]);\\n            if(set.contains(rev)){\\n                count++;\\n                set.remove(rev);\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String temp){\\n        char ch[]=temp.toCharArray();\\n        char cur=ch[0];\\n        ch[0]=ch[1];\\n        ch[1]=cur;\\n        String ans=\"\";\\n        for(int i=0;i<ch.length;i++){\\n            ans+=ch[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696525,
                "title": "solution-with-shift-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Remove the first `item` from the array `words` and returns that removed `item`;\\n2. Reverce letters in removed `item`;\\n3. Determine whether the array `words` includes a reverce `item` among its entries;\\n4. Repeat until the array `words` has elements.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = (words) => {\\n  let num = 0;\\n  while (words.length) {\\n    let item = words.shift();\\n    item = item[1] + item[0];\\n    if (words.includes(item)) num++;\\n  }\\n  return num;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nconst maximumNumberOfStringPairs = (words) => {\\n  let num = 0;\\n  while (words.length) {\\n    let item = words.shift();\\n    item = item[1] + item[0];\\n    if (words.includes(item)) num++;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693160,
                "title": "java-hashset",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        int cnt = 0;\\n        for (String s : words) {\\n            StringBuilder sb = new StringBuilder(s).reverse();\\n            if (set.contains(sb.toString())) {\\n                cnt++;\\n            } else {\\n                set.add(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n### Time complexity: $$O(n^2)$$\\n> Worst case time complexity for lookup in hashset can be $$O(n)$$.\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        int cnt = 0;\\n        for (String s : words) {\\n            StringBuilder sb = new StringBuilder(s).reverse();\\n            if (set.contains(sb.toString())) {\\n                cnt++;\\n            } else {\\n                set.add(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692667,
                "title": "python-simple-python-solution-using-hashmap-95-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 52 ms, faster than 95.84% of Python3 online submissions for Find Maximum Number of String Pairs.\\n# Memory Usage: 16.3 MB, less than 77.61% of Python3 online submissions for Find Maximum Number of String Pairs.\\n\\n![image](https://assets.leetcode.com/users/images/a34a2061-717a-4bd4-968e-4184005e17bf_1687949173.33394.png)\\n\\n\\tclass Solution:\\n\\t\\tdef maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tfor word in words:\\n\\n\\t\\t\\t\\treverse_word = word[::-1]\\n\\n\\t\\t\\t\\tif reverse_word in hash_map:\\n\\t\\t\\t\\t\\thash_map[reverse_word] = hash_map[reverse_word] + 1\\n\\n\\t\\t\\t\\telif word not in hash_map:\\n\\t\\t\\t\\t\\thash_map[word] = 1\\n\\n\\t\\t\\tfor key in hash_map:\\n\\n\\t\\t\\t\\tif hash_map[key] > 1:\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "class Solution:\\n\\t\\tdef maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3686151,
                "title": "easy-and-understandable-code-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse can help\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate the loop\\n2. each and every word reverse\\n3. and check weather they are equal or not\\n4. print result \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j = i+ 1;j<n;j++){\\n                string s1 = words[i];\\n                string s2 = words[j];\\n                reverse(s2.begin(), s2.end());\\n                // cout<<s1<<\" \"<<s2<<endl;\\n                if(s1 == s2){\\n                    ans++;\\n                    // cout<<ans;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n = words.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j = i+ 1;j<n;j++){\\n                string s1 = words[i];\\n                string s2 = words[j];\\n                reverse(s2.begin(), s2.end());\\n                // cout<<s1<<\" \"<<s2<<endl;\\n                if(s1 == s2){\\n                    ans++;\\n                    // cout<<ans;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3685959,
                "title": "easy-one-xd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685958,
                "title": "easy-one-xd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n\\tst := make(map[string]bool)\\n\\tres := 0\\n\\tfor _, i := range words {\\n\\t\\ts := i\\n\\t\\ti = reverseString(i)\\n\\t\\tif !st[i] {\\n\\t\\t\\tst[s] = true\\n\\t\\t} else {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nfunc reverseString(s string) string {\\n\\trunes := []rune(s)\\n\\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\\n\\t\\trunes[i], runes[j] = runes[j], runes[i]\\n\\t}\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680958,
                "title": "python-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    cnt+=1\\n                    break\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        cnt=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    cnt+=1\\n                    break\\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680928,
                "title": "go-straightforward",
                "content": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    res := 0\\n    h := make(map[string]bool)\\n    for _, w := range words {\\n        if r := fmt.Sprintf(\"%c%c\", w[1], w[0]); h[r] {\\n            res++\\n        } else {\\n            h[w] = true\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    res := 0\\n    h := make(map[string]bool)\\n    for _, w := range words {\\n        if r := fmt.Sprintf(\"%c%c\", w[1], w[0]); h[r] {\\n            res++\\n        } else {\\n            h[w] = true\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680055,
                "title": "no-map-no-set-using-find-easy-c",
                "content": "# Intuition\\nSimply Pick each words Reverse it and check by using find().\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Dry run the 1st Test Case.\\n- pick the 1st string of the words and reverse it .\\n- Befor finding the reversed string first check either 1st and 2nd letter are same or not (since there is only 2 char) \\n- NOW using find().. we search for str(ie reversed string) in words[]\\n- if found then increase the count \\n- AND Here the important stepwe have to make words[i]=str ?? think u will get if not then....\\n\\n---> because if we futher check we will again reach to element whose reversed is present before ie increase the count 2 times .\\n\\n---> Eg ; 1St TC : [\"cd\",\"ac\",\"dc\",...]  for \"cd\" we get \"dc\" in words[] and again for \"dc\" we get \"cd\" means extra count so replace with reversed(ie str itself) simpply...\\n\\ndry run more .... :)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            reverse(str.begin(),str.end());\\n            if(str[0]==str[1]) continue; \\n\\n            auto it = find(words.begin(),words.end(),str);\\n            if(it!=words.end())\\n            {\\n                cnt++;\\n            }\\n            words[i]=str;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            reverse(str.begin(),str.end());\\n            if(str[0]==str[1]) continue; \\n\\n            auto it = find(words.begin(),words.end(),str);\\n            if(it!=words.end())\\n            {\\n                cnt++;\\n            }\\n            words[i]=str;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679988,
                "title": "swift-simple-set-self-made-hash-solutions",
                "content": "# Simple Set\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n$n$ is words count\\n\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: Set<String> = [], count = 0\\n        for word in words\\n        {\\n            if wordSet.contains(String(word.reversed())) { count += 1 }\\n            else { wordSet.insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```\\n\\n# Custom hash\\n\\nAs the words are constained to have just 2 letters, we can do without the Set with its costly hash calculation. Just use ascii values of two letters, which can produce 26 * 26 = 676 combinations and map these combinations to a bit array.\\nAlso when calculating hash we first bring the word\\'s letters to ascending order. This conveniently ensures that reversals, i.e. pair words that we need to count will have the same hash value.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(26^m)$\\n$n$ is words count, m is words letter count (currently 2)\\n\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: [UInt8] = Array(repeating: 0, count: 26*26/8 + 1)\\n        let a: UInt8 = 97 //asciiValue\\n\\n        func hash(_ word: String) -> Int\\n        {\\n            var chars = Array(word)\\n            if chars[0] > chars[1] { chars.swapAt(0, 1) }\\n            return Int(chars[0].asciiValue! - a) * 26 + Int(chars[1].asciiValue! - a)\\n        }\\n        func contains(_ word: String) -> Bool {\\n            let hashValue = hash(word)\\n            return wordSet[hashValue / 8] & (1 << (hashValue % 8)) != 0\\n        }\\n        func insert(_ word: String) {\\n            let hashValue = hash(word)\\n            wordSet[hashValue / 8] |= (1 << (hashValue % 8))\\n        }\\n        \\n        var count = 0\\n        for word in words\\n        {\\n            if contains(word) { count += 1 }\\n            else { insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Bit Manipulation",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: Set<String> = [], count = 0\\n        for word in words\\n        {\\n            if wordSet.contains(String(word.reversed())) { count += 1 }\\n            else { wordSet.insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int\\n    {\\n        var wordSet: [UInt8] = Array(repeating: 0, count: 26*26/8 + 1)\\n        let a: UInt8 = 97 //asciiValue\\n\\n        func hash(_ word: String) -> Int\\n        {\\n            var chars = Array(word)\\n            if chars[0] > chars[1] { chars.swapAt(0, 1) }\\n            return Int(chars[0].asciiValue! - a) * 26 + Int(chars[1].asciiValue! - a)\\n        }\\n        func contains(_ word: String) -> Bool {\\n            let hashValue = hash(word)\\n            return wordSet[hashValue / 8] & (1 << (hashValue % 8)) != 0\\n        }\\n        func insert(_ word: String) {\\n            let hashValue = hash(word)\\n            wordSet[hashValue / 8] |= (1 << (hashValue % 8))\\n        }\\n        \\n        var count = 0\\n        for word in words\\n        {\\n            if contains(word) { count += 1 }\\n            else { insert(word) }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678003,
                "title": "easy-c-solution-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int cnt = 0;\\n        for(int i=0;i<words.size();i++) {\\n            if(mp.find(words[i]) != mp.end()) {\\n                cnt++;\\n                mp.erase(words[i]);\\n            } else {\\n                swap(words[i][0], words[i][1]);\\n                mp[words[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int cnt = 0;\\n        for(int i=0;i<words.size();i++) {\\n            if(mp.find(words[i]) != mp.end()) {\\n                cnt++;\\n                mp.erase(words[i]);\\n            } else {\\n                swap(words[i][0], words[i][1]);\\n                mp[words[i]]++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677778,
                "title": "simple-c-soltion-without-map",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n=words.size();\\n        int cnt=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            string s=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string t=words[j];\\n                reverse(t.begin(), t.end());\\n                if(t==s && s[0]!=s[1]) cnt++;\\n                \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n\\'\\'\\'\\n\\n-----------------UPVOTE--------------------",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n=words.size();\\n        int cnt=0;\\n        \\n        for(int i=0; i<n-1; i++){\\n            string s=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string t=words[j];\\n                reverse(t.begin(), t.end());\\n                if(t==s && s[0]!=s[1]) cnt++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3677673,
                "title": "c-hash-table",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> us;\\n        int res = 0;\\n        for(auto w : words) {\\n            if(us.count(w)) res += 1;\\n            reverse(begin(w), end(w));\\n            us.insert(w);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_set<string> us;\\n        int res = 0;\\n        for(auto w : words) {\\n            if(us.count(w)) res += 1;\\n            reverse(begin(w), end(w));\\n            us.insert(w);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677587,
                "title": "using-hashing-easy-commented-code",
                "content": "# Guys consider upvoting! Thanks!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n  = words.size();\\n        unordered_map<string, int> mp;\\n        //add words to the map\\n        for(int i = 0; i < n; i++){\\n            mp[words[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            string temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            // if reverse is present and is not equal (eg \"zz\")\\n            if(words[i] != temp){\\n                if(mp.count(temp) > 0){\\n                    ans++;\\n                    // reducing the count to remove duplicates\\n                    mp[temp]--;\\n                    mp[words[i]]--;\\n                    // if count is zero we remove it\\n                    if(mp[temp] == 0)\\n                        mp.erase(temp);\\n                    if(mp[words[i]] == 0)\\n                        mp.erase(words[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int n  = words.size();\\n        unordered_map<string, int> mp;\\n        //add words to the map\\n        for(int i = 0; i < n; i++){\\n            mp[words[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            string temp = words[i];\\n            reverse(temp.begin(), temp.end());\\n            // if reverse is present and is not equal (eg \"zz\")\\n            if(words[i] != temp){\\n                if(mp.count(temp) > 0){\\n                    ans++;\\n                    // reducing the count to remove duplicates\\n                    mp[temp]--;\\n                    mp[words[i]]--;\\n                    // if count is zero we remove it\\n                    if(mp[temp] == 0)\\n                        mp.erase(temp);\\n                    if(mp[words[i]] == 0)\\n                        mp.erase(words[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677570,
                "title": "c-brute-force-approach",
                "content": "\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            string str = words[i];\\n            \\n            for(int j = i+1; j < words.size(); j++){\\n                string s = words[j];\\n                string st;\\n                reverse(s.begin(),s.end());\\n                \\n                if(str == s){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "\\t\\tint count = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            string str = words[i];\\n            \\n            for(int j = i+1; j < words.size(); j++){\\n                string s = words[j];\\n                string st;\\n                reverse(s.begin(),s.end());\\n                \\n                if(str == s){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3677561,
                "title": "easy-easy-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677558,
                "title": "easy-easy-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n           for(int j=i+1;j<words.size();j++)\\n           {\\n               string ans=words[j];\\n               reverse(ans.begin(),ans.end());\\n               if(words[i]==ans)\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677490,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string,bool> mp;\\n        int ans=0;\\n        for(auto ele:words){\\n            string st=ele;\\n            reverse(st.begin(),st.end());\\n            if(mp.find(st) != mp.end()){\\n                ans++;\\n            }\\n            mp[ele]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        unordered_map<string,bool> mp;\\n        int ans=0;\\n        for(auto ele:words){\\n            string st=ele;\\n            reverse(st.begin(),st.end());\\n            if(mp.find(st) != mp.end()){\\n                ans++;\\n            }\\n            mp[ele]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677486,
                "title": "python-easy-using-of-set",
                "content": "During this beweekly contest leetcode server is down again \\uD83D\\uDE2D\\n\\n```python\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        v = set()\\n        \\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j][::-1] and j not in v:\\n                    v.add(j)\\n                    break\\n                    \\n        return len(v)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        v = set()\\n        \\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j][::-1] and j not in v:\\n                    v.add(j)\\n                    break\\n                    \\n        return len(v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087350,
                "title": "c-solution-with-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string,string> d=new Dictionary<string,string>();\\n        int count=0;\\n        for(int i=0;i<words.Count();i++)\\n        {\\n            if(d.ContainsKey(String.Join(\"\",words[i].ToCharArray().Reverse())))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                d.Add(words[i],\"*\");\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumNumberOfStringPairs(string[] words) {\\n        Dictionary<string,string> d=new Dictionary<string,string>();\\n        int count=0;\\n        for(int i=0;i<words.Count();i++)\\n        {\\n            if(d.ContainsKey(String.Join(\"\",words[i].ToCharArray().Reverse())))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                d.Add(words[i],\"*\");\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086228,
                "title": "approach-using-hashmap-and-making-a-new-function-reverse-as-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2ms 70% faster\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:70% better\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String,Boolean> map=new HashMap<>(); \\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String key=words[i];\\n            String keyrev=reverse(key);\\n            if(map.containsKey(keyrev))\\n            count++;\\n            else map.put(key,true);\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String word)\\n    {\\n        StringBuilder rev=new StringBuilder();\\n        rev.append(word);\\n        rev.reverse();\\n        return rev.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashMap<String,Boolean> map=new HashMap<>(); \\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String key=words[i];\\n            String keyrev=reverse(key);\\n            if(map.containsKey(keyrev))\\n            count++;\\n            else map.put(key,true);\\n        }\\n        return count;\\n    }\\n\\n    public String reverse(String word)\\n    {\\n        StringBuilder rev=new StringBuilder();\\n        rev.append(word);\\n        rev.reverse();\\n        return rev.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084556,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int c=0;\\n        StringBuilder sb=new StringBuilder();\\n        String w=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n            \\n            if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0))\\n            {\\n                c++;\\n            }\\n                  \\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int c=0;\\n        StringBuilder sb=new StringBuilder();\\n        String w=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n            \\n            if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0))\\n            {\\n                c++;\\n            }\\n                  \\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082084,
                "title": "easy-java-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1;j<words.length; j++){\\n                String c = new StringBuffer(words[j]).reverse().toString();\\n                if(words[i].equals(c)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1;j<words.length; j++){\\n                String c = new StringBuffer(words[j]).reverse().toString();\\n                if(words[i].equals(c)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080187,
                "title": "bruteforce",
                "content": "# Intuition\\njust count numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n       int count = 0;\\n        for(int i=0; i<words.length;i++){\\n            for(int j=i+1; j<words.length;j++){\\n                if(Objects.equals(words[i],\"\"+words[j].charAt(1)+words[j].charAt(0))){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n       int count = 0;\\n        for(int i=0; i<words.length;i++){\\n            for(int j=i+1; j<words.length;j++){\\n                if(Objects.equals(words[i],\"\"+words[j].charAt(1)+words[j].charAt(0))){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080063,
                "title": "java-1ms-beats-100-easy-to-understand",
                "content": "# Intuition\\n\\nas the size of the each String in an Array is 2 so we can just use \\n\\nstr.charAt(0)==str.charAt(1) && str.charAt(1)==str.charAt(0)\\n\\nif it was not fixed we can just convert String into StringBuilder and the revese it with the .revese() function and then compare it \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n         int count=0;\\n        for (int i = 0; i < words.length-1; i++) {\\n\\n            for (int j = i+1; j <words.length ; j++) {\\n\\n\\n                   if (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0) )\\n                   {\\n                       count++;\\n                       break;\\n                   }\\n\\n\\n            }\\n\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n         int count=0;\\n        for (int i = 0; i < words.length-1; i++) {\\n\\n            for (int j = i+1; j <words.length ; j++) {\\n\\n\\n                   if (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0) )\\n                   {\\n                       count++;\\n                       break;\\n                   }\\n\\n\\n            }\\n\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079415,
                "title": "easy-solution-using-length",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        s = []\\n        for ch in words :\\n            s.append(\\'\\'.join(sorted(ch)))\\n        return len(words) - len(set(s))\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        s = []\\n        for ch in words :\\n            s.append(\\'\\'.join(sorted(ch)))\\n        return len(words) - len(set(s))\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078531,
                "title": "simple-approach-sort-and-next-compare-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        for(int i = 0; i < words.size(); i++){\\n          sort(words[i].begin(),words[i].end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < words.size()-1; i++){\\n          for(int j = i + 1; j < words.size(); j++){\\n            if(words[i] == words[j]){\\n              ans = ans + 1;\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        for(int i = 0; i < words.size(); i++){\\n          sort(words[i].begin(),words[i].end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < words.size()-1; i++){\\n          for(int j = i + 1; j < words.size(); j++){\\n            if(words[i] == words[j]){\\n              ans = ans + 1;\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074050,
                "title": "run-time-high-but-easy-to-understand-java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        String temp=new String();\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n             StringBuilder sb=new StringBuilder(words[i]);\\n             sb.reverse();\\n             temp=sb.toString();\\n             System.out.println(temp);\\n             for(int j=0;j<words.length;j++){\\n                 System.out.println(words[j]);\\n                 if((temp.equals(words[j]))&&(i!=j))\\n                 count++;\\n             }\\n             \\n\\n        }\\n\\n            return count/2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        String temp=new String();\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n             StringBuilder sb=new StringBuilder(words[i]);\\n             sb.reverse();\\n             temp=sb.toString();\\n             System.out.println(temp);\\n             for(int j=0;j<words.length;j++){\\n                 System.out.println(words[j]);\\n                 if((temp.equals(words[j]))&&(i!=j))\\n                 count++;\\n             }\\n             \\n\\n        }\\n\\n            return count/2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072901,
                "title": "100-fast-solution-of-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity\\n- O(N-Square)\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n        int count=0;\\n        int n=w.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=i+1;j<n;j++){\\n             if(w[i][0]==w[j][1] && w[i][1]==w[j][0]){\\n                 count++;\\n             }\\n             }\\n         } \\n     return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n        int count=0;\\n        int n=w.size();\\n     for(int i=0;i<n;i++){\\n         for(int j=i+1;j<n;j++){\\n             if(w[i][0]==w[j][1] && w[i][1]==w[j][0]){\\n                 count++;\\n             }\\n             }\\n         } \\n     return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072399,
                "title": "easiest-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean func(String a, String b){\\n        int n=a.length();\\n        int m=b.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(n-1-i))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        int n=words.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(func(words[i],words[j])==true){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean func(String a, String b){\\n        int n=a.length();\\n        int m=b.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(n-1-i))\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans=0;\\n        int n=words.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(func(words[i],words[j])==true){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072183,
                "title": "len-words-words-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)) :\\n                if words[i] == words[j][::-1] and 0 <= i < j < len(words):\\n                    count +=1\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)) :\\n                if words[i] == words[j][::-1] and 0 <= i < j < len(words):\\n                    count +=1\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071898,
                "title": "java-easy-solution-o-n",
                "content": "# Approach\\ngo to each string in words, make a reverse of the string check if that reverse is present in the set or not, if present increase the count by 1, if not then add the the original string into the set, when next time the iterator comes to the reverse of the stored string, it will reverse the string, check it\\'s presence in the set and increase the count by 1\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        Set<String> set = new HashSet<>();\\n\\n        for(String w: words){\\n            StringBuilder str = new StringBuilder(w);\\n            String reverseStr = str.reverse().toString();\\n\\n            if(set.contains(reverseStr))\\n                count++;\\n            \\n            set.add(w);\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        Set<String> set = new HashSet<>();\\n\\n        for(String w: words){\\n            StringBuilder str = new StringBuilder(w);\\n            String reverseStr = str.reverse().toString();\\n\\n            if(set.contains(reverseStr))\\n                count++;\\n            \\n            set.add(w);\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071641,
                "title": "solution-using-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var wordss = words\\n        var count = 0\\n        while wordss.count != 1{\\n            let check = wordss.remove(at: 0)\\n            if wordss.contains(String(check.reversed())) {\\n                print(wordss.first!)\\n                count += 1\\n            }\\n           \\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var wordss = words\\n        var count = 0\\n        while wordss.count != 1{\\n            let check = wordss.remove(at: 0)\\n            if wordss.contains(String(check.reversed())) {\\n                print(wordss.first!)\\n                count += 1\\n            }\\n           \\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071373,
                "title": "best-solution-in-java-beats-100-in-time-and-99-in-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDone using sliding window approach; eliminating the already checked cases.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        if(words.length == 1) return 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].equals(\"\"))continue;\\n            for(int j = i+1; j < words.length; j++) {\\n                if(words[j].equals(\"\")) continue;\\n                if((words[i].charAt(0) == words[j].charAt(1)) && (words[i].charAt(1) == words[j].charAt(0))) {\\n                    count++;\\n                    words[j] = \"\";\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        if(words.length == 1) return 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(words[i].equals(\"\"))continue;\\n            for(int j = i+1; j < words.length; j++) {\\n                if(words[j].equals(\"\")) continue;\\n                if((words[i].charAt(0) == words[j].charAt(1)) && (words[i].charAt(1) == words[j].charAt(0))) {\\n                    count++;\\n                    words[j] = \"\";\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071064,
                "title": "easy-code-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070714,
                "title": "python-rust-solutions",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        words_reversed = [word[::-1] for word in words]\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words_reversed[j]:\\n                    count += 1\\n        return count\\n```\\n```rust []\\nimpl Solution {\\n    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {\\n        let len = words.len();\\n        let mut count = 0;\\n        let words_reversed: Vec<String> = words\\n            .iter()\\n            .map(|word| word.chars().rev().collect::<String>())\\n            .collect();\\n        for (i, word) in words.iter().take(len - 1).enumerate() {\\n            for word_reversed in words_reversed.iter().skip(i + 1) {\\n                if word == word_reversed {\\n                    dbg!(word);\\n                    dbg!(word_reversed);\\n                    count += 1\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        words_reversed = [word[::-1] for word in words]\\n        for i in range(len(words) - 1):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words_reversed[j]:\\n                    count += 1\\n        return count\\n```\n```rust []\\nimpl Solution {\\n    pub fn maximum_number_of_string_pairs(words: Vec<String>) -> i32 {\\n        let len = words.len();\\n        let mut count = 0;\\n        let words_reversed: Vec<String> = words\\n            .iter()\\n            .map(|word| word.chars().rev().collect::<String>())\\n            .collect();\\n        for (i, word) in words.iter().take(len - 1).enumerate() {\\n            for word_reversed in words_reversed.iter().skip(i + 1) {\\n                if word == word_reversed {\\n                    dbg!(word);\\n                    dbg!(word_reversed);\\n                    count += 1\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069560,
                "title": "simple-c-solution",
                "content": "# Intuition\\nnested for loops with if condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068667,
                "title": "simple-code-that-beats-100",
                "content": "# Intuition\\nthey have given that if same elements exist, they are in pairs. So when you encounter a pair, just increment count and you have your number of pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len=words.length,count=0;\\n        for(int i=0;i<len-1;i++)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(words[i]==words[j] || (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0)))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len=words.length,count=0;\\n        for(int i=0;i<len-1;i++)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(words[i]==words[j] || (words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0)))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068107,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans =0, n = words.length;\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        // for(int i=0;i<n;i++){\\n        //     list.add(words[i]);\\n        // }\\n        for(int i=0;i<n;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            if(set.contains(sb.reverse().toString())) ans++;\\n            else set.add(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int ans =0, n = words.length;\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        // for(int i=0;i<n;i++){\\n        //     list.add(words[i]);\\n        // }\\n        for(int i=0;i<n;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            if(set.contains(sb.reverse().toString())) ans++;\\n            else set.add(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066435,
                "title": "easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1: ]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1: ]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065683,
                "title": "easy-solution-brooos",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n      pairs = 0\\n      seen = set()\\n      for word in words:\\n          if word[::-1] not in seen:\\n             seen.add(word)\\n          else:\\n              pairs += 1\\n              seen.remove(word[::-1])\\n\\n      return pairs\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n      pairs = 0\\n      seen = set()\\n      for word in words:\\n          if word[::-1] not in seen:\\n             seen.add(word)\\n          else:\\n              pairs += 1\\n              seen.remove(word[::-1])\\n\\n      return pairs\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064265,
                "title": "easy-and-understandable-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n    int count=0;\\n        for(int i=0;i<words.size();i++){\\n            string vp=words[i];\\n            reverse(words[i].begin(),words[i].end());\\n            for(int j=i+1;j<words.size();j++){\\n                if(words[i]==words[j]){\\n                    count++;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n   return  count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n    int count=0;\\n        for(int i=0;i<words.size();i++){\\n            string vp=words[i];\\n            reverse(words[i].begin(),words[i].end());\\n            for(int j=i+1;j<words.size();j++){\\n                if(words[i]==words[j]){\\n                    count++;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n   return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063849,
                "title": "java-easy-solution-map-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        Set<String> wordSet= Arrays.stream(words).collect(Collectors.toSet());\\n        for (int i = 0; i < words.length; i++) {\\n            String currentWord = words[i];\\n            wordSet.remove(currentWord);\\n            // StringBuilder reversedWord = new StringBuilder(currentWord).reverse();\\n            String reversedWordStr = new StringBuilder(currentWord).reverse().toString();\\n            \\n            if (wordSet.contains(reversedWordStr)) {\\n                pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n       public int maximumNumberOfStringPairs(String[] words) {\\n        int pairs = 0;\\n        Set<String> wordSet= Arrays.stream(words).collect(Collectors.toSet());\\n        for (int i = 0; i < words.length; i++) {\\n            String currentWord = words[i];\\n            wordSet.remove(currentWord);\\n            // StringBuilder reversedWord = new StringBuilder(currentWord).reverse();\\n            String reversedWordStr = new StringBuilder(currentWord).reverse().toString();\\n            \\n            if (wordSet.contains(reversedWordStr)) {\\n                pairs++;\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061162,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) \\n    {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                StringBuilder st=new StringBuilder();\\n                st.append(words[j]);\\n                st.reverse();\\n                if(st.toString().equals(words[i]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) \\n    {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=i+1;j<words.length;j++)\\n            {\\n                StringBuilder st=new StringBuilder();\\n                st.append(words[j]);\\n                st.reverse();\\n                if(st.toString().equals(words[i]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056801,
                "title": "java-beats-100-user",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        int n = words.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056779,
                "title": "simple-java-1ms-beats-100-runtime-easy-to-understand",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the number of pairs present in the array of strings.\\nWhen two strings are reverse of each other then they are pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollow the steps below to understand the solution:\\n    \\n    1. Find the length of the array.\\n    2. Iterate the outer for-loop from 0 to n-1.\\n    3. Iterate the inner for-loop from i+1 to n-1.\\n    4. Check the conditions.\\n    5. Increment the counter if condition is satisfied.\\n**Follow the code below to understand the solution.**\\n\\n      **If this solution helped you, give it an up-vote to help others** \\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\n        //it will count the number of pairs\\n        int count=0;\\n\\n        //find the length of the array.\\n        int n = words.length;\\n\\n        //outer for loop will check ith string.\\n        for(int i=0;i<n;i++)\\n        {\\n            //inner for loop will check jth string.\\n            for(int j=i+1;j<n;j++)\\n            {\\n                //since string are of length 2\\n                //we can apply the following condition.\\n                if(words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0))\\n                {\\n                    //if they are pairs then increment the count.\\n                    count+=1;                   \\n                }\\n            }\\n        }\\n        //finally, return the count variable.\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\n        //it will count the number of pairs\\n        int count=0;\\n\\n        //find the length of the array.\\n        int n = words.length;\\n\\n        //outer for loop will check ith string.\\n        for(int i=0;i<n;i++)\\n        {\\n            //inner for loop will check jth string.\\n            for(int j=i+1;j<n;j++)\\n            {\\n                //since string are of length 2\\n                //we can apply the following condition.\\n                if(words[i].charAt(0)==words[j].charAt(1) && words[i].charAt(1)==words[j].charAt(0))\\n                {\\n                    //if they are pairs then increment the count.\\n                    count+=1;                   \\n                }\\n            }\\n        }\\n        //finally, return the count variable.\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056668,
                "title": "java-easy-explanation-time-and-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReverse the word and compare it with the contents in the set\\nIf found increase count.\\nRemove the reverseword from set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each word, we need to reverse it and compare it with contents of set, if found increase the count and remove the reversed word.\\nElse, add the word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String reverseWord = new StringBuilder(word).reverse().toString();\\n            if(set.contains(reverseWord)){\\n                count++;\\n                set.remove(reverseWord);\\n            }\\n            else{\\n                set.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n        for(String word : words){\\n            String reverseWord = new StringBuilder(word).reverse().toString();\\n            if(set.contains(reverseWord)){\\n                count++;\\n                set.remove(reverseWord);\\n            }\\n            else{\\n                set.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055805,
                "title": "one-line-of-javascript-code-with-high-ordered-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    return  words.length - new Set(words.map(e=>e.split(\"\").sort().join(\"\"))).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    return  words.length - new Set(words.map(e=>e.split(\"\").sort().join(\"\"))).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055411,
                "title": "0ms-beats-100-by-memory",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    ln := len(words)\\n    c:=0\\n    for i :=0;i<ln-1;i++{\\n        for j :=i+1;j<ln;j++{\\n            if words[i][0]==words[j][1] && words[i][1] == words[j][0]{\\n                c++\\n            }\\n        }\\n    }\\n    return c\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumNumberOfStringPairs(words []string) int {\\n    ln := len(words)\\n    c:=0\\n    for i :=0;i<ln-1;i++{\\n        for j :=i+1;j<ln;j++{\\n            if words[i][0]==words[j][1] && words[i][1] == words[j][0]{\\n                c++\\n            }\\n        }\\n    }\\n    return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055365,
                "title": "easy-approach-to-find-the-pair-of-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i =0;i < words.length;i++){\\n            String st = new StringBuilder(words[i]).reverse().toString();\\n            for(int j = i+1;j<words.length;j++){\\n               if(st.equals(words[j]))\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i =0;i < words.length;i++){\\n            String st = new StringBuilder(words[i]).reverse().toString();\\n            for(int j = i+1;j<words.length;j++){\\n               if(st.equals(words[j]))\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054193,
                "title": "brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChecking each word against every other word in words \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        res = 0 \\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j] or words[i] == words[j][::-1]:\\n                    res += 1\\n        return res \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        res = 0 \\n\\n        for i in range(len(words)):\\n            for j in range(i + 1, len(words)):\\n                if words[i] == words[j] or words[i] == words[j][::-1]:\\n                    res += 1\\n        return res \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053385,
                "title": "simple-solution-java-1ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int count = 0;\\n      int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n        for (int j = i + 1; j < len; j++) {\\n          if (isEqual(words[i], words[j]))\\n            count++;\\n          }\\n      }\\n\\n      return count;\\n    }\\n\\n    public boolean isEqual(String a, String b) {\\n      int j = a.length() - 1;\\n      int x = a.length();\\n\\n      for (int i = 0; i < x; i++) {\\n        if (a.charAt(i) != b.charAt(j))\\n          return false;\\n        j--;\\n      }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n      int count = 0;\\n      int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n        for (int j = i + 1; j < len; j++) {\\n          if (isEqual(words[i], words[j]))\\n            count++;\\n          }\\n      }\\n\\n      return count;\\n    }\\n\\n    public boolean isEqual(String a, String b) {\\n      int j = a.length() - 1;\\n      int x = a.length();\\n\\n      for (int i = 0; i < x; i++) {\\n        if (a.charAt(i) != b.charAt(j))\\n          return false;\\n        j--;\\n      }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052918,
                "title": "java-beats-100-1ms-and-beats-83-memory",
                "content": "# Here\\'s a breakdown of how the code works:\\n\\n```int count = 0``` Initialize a variable count to keep track of the number of valid pairs of strings.\\n\\n1. The code uses two nested loops to iterate through all pairs of strings in the words array:\\n    - The outer loop iterates from ```i = 0``` to ```i < words.length```.\\n    - The inner loop iterates from ```j = i + 1``` to ```j < words.length```.\\n2. Inside the nested loops, it checks if the first character of the ```i-th string``` \\n\\n- If both conditions are true, it means that the two strings can form a valid pair.\\n\\n3. If the conditions in step 3 are met, increment the count variable by 1, indicating that a valid pair has been found.\\n\\n4. After both loops have finished, the method returns the final value of count, which represents the maximum number of valid pairs of strings in the array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$$O(n^2)$$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$$O(1)$$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```int count = 0```\n```i = 0```\n```i < words.length```\n```j = i + 1```\n```j < words.length```\n```i-th string```\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1)&&words[i].charAt(1)==words[j].charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050583,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder word1;\\n        StringBuilder word2;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n            word1 = new StringBuilder(words[i]);\\n            for(int j = i+1; j < words.length; j++){\\n                word2 = new StringBuilder(words[j]);\\n                if(word1.toString().equals(word2.reverse().toString())){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count = 0;\\n        StringBuilder word1;\\n        StringBuilder word2;\\n\\n        for(int i = 0; i < words.length-1; i++){\\n            word1 = new StringBuilder(words[i]);\\n            for(int j = i+1; j < words.length; j++){\\n                word2 = new StringBuilder(words[j]);\\n                if(word1.toString().equals(word2.reverse().toString())){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048615,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int count = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    count++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n        return count; // Return the total number of matching pairs\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n        int count = 0; // Initialize the variable to store the answer\\n        int n = v.size(); \\n        // Iterate over all pairs of strings\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Check if i-th string is eaqual to reverse of j-th string\\n                if (v[i][0] == v[j][1] && v[i][1] == v[j][0]) {\\n                    count++; // Increment the count of matching pairs\\n                }\\n            }\\n        }\\n        return count; // Return the total number of matching pairs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048553,
                "title": "simple-o-n-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        cnt = 0\\n        d = {}\\n        for i in range(n):\\n            if words[i][::-1] in d:\\n                cnt += 1\\n            else:\\n                d[words[i]] = i\\n\\n        return (cnt)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        cnt = 0\\n        d = {}\\n        for i in range(n):\\n            if words[i][::-1] in d:\\n                cnt += 1\\n            else:\\n                d[words[i]] = i\\n\\n        return (cnt)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048357,
                "title": "80-18-beats",
                "content": "> # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(String word : words){\\n            if(set.contains(word)){\\n                count++;\\n                set.remove(word);\\n            }\\n            else{\\n                StringBuilder s=new StringBuilder(word);\\n                String s1=s.reverse().toString();\\n                set.add(s1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(String word : words){\\n            if(set.contains(word)){\\n                count++;\\n                set.remove(word);\\n            }\\n            else{\\n                StringBuilder s=new StringBuilder(word);\\n                String s1=s.reverse().toString();\\n                set.add(s1);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047436,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing string builder\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                String str = new StringBuilder(words[j]).reverse().toString();\\n                if(words[i].equals(str)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length;++i){\\n            for(int j=i+1; j<words.length; ++j){\\n                String str = new StringBuilder(words[j]).reverse().toString();\\n                if(words[i].equals(str)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046076,
                "title": "o-n-python-beats-98-u-1f60e",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        # 2744. Find Maximum Number of String Pairs\\n        d = {}\\n        out = 0\\n        for i, word in enumerate(words):\\n            r_word = word[::-1]\\n            if r_word in d:\\n                if d[r_word] == 0:\\n                    out += 1\\n                    d[r_word] = 1\\n                    d[word] = 1\\n            else:\\n                d[word] = 0\\n        return out\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        # 2744. Find Maximum Number of String Pairs\\n        d = {}\\n        out = 0\\n        for i, word in enumerate(words):\\n            r_word = word[::-1]\\n            if r_word in d:\\n                if d[r_word] == 0:\\n                    out += 1\\n                    d[r_word] = 1\\n                    d[word] = 1\\n            else:\\n                d[word] = 0\\n        return out\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045673,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nint maximumNumberOfStringPairs(char ** words, int wordsSize)\\n{\\n\\n    int pairsCntr   = 0 ;\\n    int i           = 0 ;\\n    int j           = 0 ;\\n    char temp       = 0 ;\\n\\n    for( i = 0; i < wordsSize; i++ )\\n    {\\n\\n        /* Reverse the string */\\n        temp        = words[i][0] ;\\n        words[i][0] = words[i][1] ;\\n        words[i][1] = temp ;\\n\\n        for( j = i+1; j < wordsSize; j++ )\\n        {\\n            if(strcmp(words[i], words[j]) == 0)\\n            {\\n                pairsCntr++ ;\\n            }\\n            else\\n            {\\n                /* Do nothing */\\n            } \\n        }\\n\\n    }\\n\\n    return pairsCntr ;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumNumberOfStringPairs(char ** words, int wordsSize)\\n{\\n\\n    int pairsCntr   = 0 ;\\n    int i           = 0 ;\\n    int j           = 0 ;\\n    char temp       = 0 ;\\n\\n    for( i = 0; i < wordsSize; i++ )\\n    {\\n\\n        /* Reverse the string */\\n        temp        = words[i][0] ;\\n        words[i][0] = words[i][1] ;\\n        words[i][1] = temp ;\\n\\n        for( j = i+1; j < wordsSize; j++ )\\n        {\\n            if(strcmp(words[i], words[j]) == 0)\\n            {\\n                pairsCntr++ ;\\n            }\\n            else\\n            {\\n                /* Do nothing */\\n            } \\n        }\\n\\n    }\\n\\n    return pairsCntr ;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045132,
                "title": "2744-find-maximum-number-of-string-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    \\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    \\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int ans = 0;\\n      for (int i = 0; i < words.length; i ++) {\\n          for(int j = i + 1; j < words.length; j ++) \\n              if(words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0))\\n              ans ++;\\n      }  \\n      return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044448,
                "title": "easy-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n       for(auto &i: v){\\n           sort(i.begin(),i.end());\\n       }\\n       // sorted the strings in the vector\\n        sort(v.begin(),v.end());\\n        // sorted the vector itself\\n        int ans = 0;\\n        // count the number of equal pairs\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i] == v[i+1]) ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& v) {\\n       for(auto &i: v){\\n           sort(i.begin(),i.end());\\n       }\\n       // sorted the strings in the vector\\n        sort(v.begin(),v.end());\\n        // sorted the vector itself\\n        int ans = 0;\\n        // count the number of equal pairs\\n        for(int i=0;i<v.size()-1;i++){\\n            if(v[i] == v[i+1]) ans++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044216,
                "title": "javascript-beats-90-comments",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n// Initialize a variable to keep track of the count of reversed word pairs.\\nlet ans = 0;\\n\\n// Continue the loop as long as there are more than one word in the \\'words\\' array.\\nwhile (words.length > 1) {\\n    // Remove and store the first word from the \\'words\\' array.\\n    let shiftedArr = words.shift();\\n    // Split the word into an array of characters.\\n    let splitString = shiftedArr.split(\\'\\');\\n    // Reverse the characters.\\n    let reversed = splitString.reverse();\\n    // Join the reversed characters back into a string.\\n    reversed = reversed.join(\\'\\');\\n    // Check if the reversed word exists in the remaining words in the \\'words\\' array.\\n    if (words.includes(reversed)) {\\n        // If a reversed word is found, increment the count.\\n        ans++;\\n    }\\n}\\n// Return the count of reversed word pairs.\\nreturn ans;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n// Initialize a variable to keep track of the count of reversed word pairs.\\nlet ans = 0;\\n\\n// Continue the loop as long as there are more than one word in the \\'words\\' array.\\nwhile (words.length > 1) {\\n    // Remove and store the first word from the \\'words\\' array.\\n    let shiftedArr = words.shift();\\n    // Split the word into an array of characters.\\n    let splitString = shiftedArr.split(\\'\\');\\n    // Reverse the characters.\\n    let reversed = splitString.reverse();\\n    // Join the reversed characters back into a string.\\n    reversed = reversed.join(\\'\\');\\n    // Check if the reversed word exists in the remaining words in the \\'words\\' array.\\n    if (words.includes(reversed)) {\\n        // If a reversed word is found, increment the count.\\n        ans++;\\n    }\\n}\\n// Return the count of reversed word pairs.\\nreturn ans;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043267,
                "title": "2ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        \\n      int c=0;\\n        for(int i=0;i<words.length;i++){\\n             StringBuilder s=new StringBuilder(words[i]);\\n             String ans=(s.reverse()).toString();\\n           for(int j=i+1;j<words.length;j++){\\n             if(ans.equals(words[j])){\\n                 c++;\\n             }             \\n           }\\n           \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        \\n      int c=0;\\n        for(int i=0;i<words.length;i++){\\n             StringBuilder s=new StringBuilder(words[i]);\\n             String ans=(s.reverse()).toString();\\n           for(int j=i+1;j<words.length;j++){\\n             if(ans.equals(words[j])){\\n                 c++;\\n             }             \\n           }\\n           \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039720,
                "title": "easy-python-solution-stepwise-explained-python",
                "content": "# EASY PYTHON SOLUTION || STEPWISE EXPLAINED || PYTHON \\u270C\\u270C\\n\\n# Runtime\\n- 51ms\\n- Beats 82.16%of users with Python3\\n# Memory\\n- 16.09MB\\n- Beats 99.58%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        revSet = set()\\n        count = 0\\n\\n        for word in words:\\n            #print(word,word[::-1])\\n            revWord = word[::-1]\\n    \\n            if revWord in revSet:\\n                #print(\\'if run\\')\\n                revSet.remove(revWord)\\n                count+=1\\n                #print(count)\\n            else:\\n                #print(\\'else run\\')\\n                revSet.add(word)\\n\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        revSet = set()\\n        count = 0\\n\\n        for word in words:\\n            #print(word,word[::-1])\\n            revWord = word[::-1]\\n    \\n            if revWord in revSet:\\n                #print(\\'if run\\')\\n                revSet.remove(revWord)\\n                count+=1\\n                #print(count)\\n            else:\\n                #print(\\'else run\\')\\n                revSet.add(word)\\n\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037954,
                "title": "easy-java-solution-without-stringbuilder-and-hash-map",
                "content": "# Intuition\\nThe size of words[i]==2 i.e constant so we can operate statically on it, so the problem lies on array of string.\\n\\n# Approach\\nwe will iterate through array and compare the i+1 index then statically work with the words[i] value.\\n\\n# Complexity\\n- Time complexity:\\nTC: O(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1) &&words[j].charAt(0)==words[i].charAt(1) )\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0;i<words.length-1;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                if(words[i].charAt(0)==words[j].charAt(1) &&words[j].charAt(0)==words[i].charAt(1) )\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036201,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1:]:\\n                count += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i+1:]:\\n                count += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035945,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len = words.length;\\n        int temp[] = new int[5530];\\n        int count = 0;\\n        for(int i = 0; i < len; i++){\\n            int temp1 = words[i].charAt(0) - \\'a\\';\\n            int temp2 = words[i].charAt(1) - \\'a\\'; \\n            int ind = (temp1 + temp2) * 100 + Math.abs(temp1 - temp2);\\n            if(temp[ind] != 0){\\n                count++;\\n            }\\n            temp[ind]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int len = words.length;\\n        int temp[] = new int[5530];\\n        int count = 0;\\n        for(int i = 0; i < len; i++){\\n            int temp1 = words[i].charAt(0) - \\'a\\';\\n            int temp2 = words[i].charAt(1) - \\'a\\'; \\n            int ind = (temp1 + temp2) * 100 + Math.abs(temp1 - temp2);\\n            if(temp[ind] != 0){\\n                count++;\\n            }\\n            temp[ind]++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035872,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n    guard words.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        for j in i + 1..<words.count {\\n            if words[i] == String(words[j].reversed()){\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n    guard words.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...words.count - 2 {\\n        for j in i + 1..<words.count {\\n            if words[i] == String(words[j].reversed()){\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035434,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let count=0;\\n    for(let i=0;i<words.length;i++){\\n        for(let j=i+1;j<words.length;j++){\\n            let temp=words[j].split(\"\").reverse().join(\"\");\\n            if(words[i]===temp)\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let count=0;\\n    for(let i=0;i<words.length;i++){\\n        for(let j=i+1;j<words.length;j++){\\n            let temp=words[j].split(\"\").reverse().join(\"\");\\n            if(words[i]===temp)\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034793,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\tfor (String st : words) {\\n\\t\\t\\tif(!set.contains(st)) {\\n\\t\\t\\t\\tString str = new StringBuilder(st).reverse().toString();\\n\\t\\t\\t\\tset.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tint count = 0;\\n\\t\\tfor (String st : words) {\\n\\t\\t\\tif(!set.contains(st)) {\\n\\t\\t\\t\\tString str = new StringBuilder(st).reverse().toString();\\n\\t\\t\\t\\tset.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032343,
                "title": "easy-o-n-using-hashset",
                "content": "# Intuition\\nUSING HashSet for checking target pairs.\\n\\n# Approach\\nPutting sorted string in the hashset will result in getting false when same string is tried being added again. After every false return from set function we increment the count.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n\\n        for(String s : words){\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            String sh = new String(arr);\\n            if(!set.add(sh)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int count = 0;\\n\\n        for(String s : words){\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            String sh = new String(arr);\\n            if(!set.add(sh)){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031155,
                "title": "php-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        $result = 0;\\n        $map = [];\\n\\n        foreach($words as $word) {\\n            if (isset($map[strrev($word)])) {\\n                $result++;\\n            } else {\\n                $map[$word] = true;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @return Integer\\n     */\\n    function maximumNumberOfStringPairs($words) {\\n        $result = 0;\\n        $map = [];\\n\\n        foreach($words as $word) {\\n            if (isset($map[strrev($word)])) {\\n                $result++;\\n            } else {\\n                $map[$word] = true;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030226,
                "title": "using-dictionary-to-optimize-time-complexity-to-o-n",
                "content": "# Intuition\\n\\n\\n# Approach\\nusing dictionary to optimize the solution \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_count = {}\\n        count = 0\\n\\n        for word in words:\\n            if word in word_count:\\n                count += word_count[word]\\n            reversed_word = word[::-1]\\n            if reversed_word in word_count:\\n                count += word_count[reversed_word]\\n            \\n            if word in word_count:\\n                word_count[word] += 1\\n            else:\\n                word_count[word] = 1\\n        \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        word_count = {}\\n        count = 0\\n\\n        for word in words:\\n            if word in word_count:\\n                count += word_count[word]\\n            reversed_word = word[::-1]\\n            if reversed_word in word_count:\\n                count += word_count[reversed_word]\\n            \\n            if word in word_count:\\n                word_count[word] += 1\\n            else:\\n                word_count[word] = 1\\n        \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028936,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> bag = new HashSet<>();\\n        int count = 0;\\n        for(String word: words){\\n            StringBuilder rev = new StringBuilder(word);\\n            rev.reverse();\\n            if(bag.contains(rev.toString())){\\n                ++count;\\n            }else{\\n                bag.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Set<String> bag = new HashSet<>();\\n        int count = 0;\\n        for(String word: words){\\n            StringBuilder rev = new StringBuilder(word);\\n            rev.reverse();\\n            if(bag.contains(rev.toString())){\\n                ++count;\\n            }else{\\n                bag.add(word);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027996,
                "title": "c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n\\n        int count=0; \\n\\n        for (int i=0;i<words.size();i++){\\n            string str1 = words[i];\\n\\n            for(int j=i+1;j<words.size();j++){\\n                string str2 = words[j];\\n\\n                if(str1[0]==str2[1] && str1[1]==str2[0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n\\n        int count=0; \\n\\n        for (int i=0;i<words.size();i++){\\n            string str1 = words[i];\\n\\n            for(int j=i+1;j<words.size();j++){\\n                string str2 = words[j];\\n\\n                if(str1[0]==str2[1] && str1[1]==str2[0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026884,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public static String Reverse(String str)\\n        {\\n            char[] strChar = str.ToCharArray();\\n            Array.Reverse(strChar);\\n            String rev = new string(strChar);\\n            return rev;\\n        }\\n    public int MaximumNumberOfStringPairs(string[] s) {\\n         int count = 0;\\n            for(int i=0;i< s.Length; i++)\\n            {\\n               for(int j=0;j<s.Length;j++)\\n                {\\n                    if (s[i].Contains(Reverse(s[j])) && i>j)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public static String Reverse(String str)\\n        {\\n            char[] strChar = str.ToCharArray();\\n            Array.Reverse(strChar);\\n            String rev = new string(strChar);\\n            return rev;\\n        }\\n    public int MaximumNumberOfStringPairs(string[] s) {\\n         int count = 0;\\n            for(int i=0;i< s.Length; i++)\\n            {\\n               for(int j=0;j<s.Length;j++)\\n                {\\n                    if (s[i].Contains(Reverse(s[j])) && i>j)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026048,
                "title": "python-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i + 1:]:\\n                count += 1\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count = 0\\n\\n        for i in range(len(words)):\\n            if words[i][::-1] in words[i + 1:]:\\n                count += 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020378,
                "title": "easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int count = 0;\\n\\t        for(String word: words) {\\n\\t        \\tStringBuilder resultword = new StringBuilder(word);\\n\\t        \\tString reversedWord = resultword.reverse().toString();\\n\\t        \\tif(Arrays.asList(words).indexOf(reversedWord) !=-1 && !word.equals(reversedWord)){\\n\\t        \\t\\tcount++;\\n\\t        \\t\\t}\\n\\t        }\\n\\t        return count/2;\\n\\t    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n          int count = 0;\\n\\t        for(String word: words) {\\n\\t        \\tStringBuilder resultword = new StringBuilder(word);\\n\\t        \\tString reversedWord = resultword.reverse().toString();\\n\\t        \\tif(Arrays.asList(words).indexOf(reversedWord) !=-1 && !word.equals(reversedWord)){\\n\\t        \\t\\tcount++;\\n\\t        \\t\\t}\\n\\t        }\\n\\t        return count/2;\\n\\t    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019759,
                "title": "swift-0-n-solution-ez-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N\\n# Code\\n```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var unique: Set<String> = []\\n        var count = 0\\n        for i in words {\\n            if unique.contains(i) || unique.contains(String(i.reversed())) {\\n                count += 1\\n            }\\n            unique.insert(i)\\n        }\\n        return count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumNumberOfStringPairs(_ words: [String]) -> Int {\\n        var unique: Set<String> = []\\n        var count = 0\\n        for i in words {\\n            if unique.contains(i) || unique.contains(String(i.reversed())) {\\n                count += 1\\n            }\\n            unique.insert(i)\\n        }\\n        return count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014775,
                "title": "javascript-map",
                "content": "# Code\\n```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const map = {}\\n    const rev = (w) => w.split(\\'\\').reverse().join(\\'\\');\\n    for (let i = 0; i < words.length; i++) {\\n        map[words[i]] = i;\\n    }\\n    let res = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let r = rev(words[i]);\\n        if (map[r] >= 0 && map[r] !== i) res++\\n        delete map[words[i]]\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumNumberOfStringPairs = function(words) {\\n    const map = {}\\n    const rev = (w) => w.split(\\'\\').reverse().join(\\'\\');\\n    for (let i = 0; i < words.length; i++) {\\n        map[words[i]] = i;\\n    }\\n    let res = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let r = rev(words[i]);\\n        if (map[r] >= 0 && map[r] !== i) res++\\n        delete map[words[i]]\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013349,
                "title": "simply-python-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(1+i,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    count=count+1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        count=0\\n        for i in range(len(words)):\\n            for j in range(1+i,len(words)):\\n                if words[i]==words[j][::-1]:\\n                    count=count+1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012003,
                "title": "best-solution-using-set-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        unordered_set <string> s1;\\n        for(auto w : words) {\\n            string org = w;\\n            swap(w[0], w[1]);\\n            if(s1.find(w) != s1.end()) {\\n                count++;\\n            }\\n            s1.insert(org);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        unordered_set <string> s1;\\n        for(auto w : words) {\\n            string org = w;\\n            swap(w[0], w[1]);\\n            if(s1.find(w) != s1.end()) {\\n                count++;\\n            }\\n            s1.insert(org);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011066,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n\\n        d = {}\\n        for i in words:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        count = 0\\n        for value in d.values():\\n            if value>1:\\n                count += 1\\n\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n\\n        d = {}\\n        for i in words:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n\\n        count = 0\\n        for value in d.values():\\n            if value>1:\\n                count += 1\\n\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009660,
                "title": "java-solution-100-faster-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] flag = new boolean[words.length];\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n\\n            for(int j = i + 1; j < words.length; j++){\\n                if(flag[j])\\n                continue;\\n\\n                String word2 = words[j];\\n\\n                if(word1.charAt(0) == word2.charAt(1) && word1.charAt(1) == word2.charAt(0)){\\n                    flag[i] = true;\\n                    flag[j] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        boolean[] flag = new boolean[words.length];\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < words.length - 1; i++) {\\n            String word1 = words[i];\\n\\n            for(int j = i + 1; j < words.length; j++){\\n                if(flag[j])\\n                continue;\\n\\n                String word2 = words[j];\\n\\n                if(word1.charAt(0) == word2.charAt(1) && word1.charAt(1) == word2.charAt(0)){\\n                    flag[i] = true;\\n                    flag[j] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008778,
                "title": "java-easy-to-understand",
                "content": "The intuition here is to check if the reversed string is present in the map or not.\\nFor ex:- [\"ab\", \"ba\"]\\n\\nWhen the loops runs on \"ab\", then there is no entry present in the hashmap and the key-value pair is created with key being the string i.e. \"ab\" and the value being the reversed string \"ba\", now when the second iteration of the loop runs for the string \"ba\" then we check if the reverse of the string is present in the map, if present then we increase the count and return it after the loop has completed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tint count = 0;\\n\\t\\tMap<String, String> map = new HashMap<>();\\n\\t\\tfor(String word : words) {\\n\\t\\t\\tif(map.get(new StringBuilder(word).reverse().toString()) != null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(word, new StringBuilder(word).reverse().toString());\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n\\t\\tint count = 0;\\n\\t\\tMap<String, String> map = new HashMap<>();\\n\\t\\tfor(String word : words) {\\n\\t\\t\\tif(map.get(new StringBuilder(word).reverse().toString()) != null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(word, new StringBuilder(word).reverse().toString());\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006563,
                "title": "c-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        map<string,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            reverse(temp.begin(),temp.end());\\n            if(mp[temp]&&i+1>mp[temp]) cnt++;\\n            mp[words[i]]=i+1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        map<string,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            reverse(temp.begin(),temp.end());\\n            if(mp[temp]&&i+1>mp[temp]) cnt++;\\n            mp[words[i]]=i+1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005185,
                "title": "easy-cpp-optimized-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        int n = words.size();\\n        unordered_set<string> seen;\\n\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n\\n            if (seen.count(reversedWord)) {\\n                count++;\\n                seen.erase(reversedWord);\\n            } else {\\n                seen.insert(word);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count = 0;\\n        int n = words.size();\\n        unordered_set<string> seen;\\n\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            string reversedWord = word;\\n            reverse(reversedWord.begin(), reversedWord.end());\\n\\n            if (seen.count(reversedWord)) {\\n                count++;\\n                seen.erase(reversedWord);\\n            } else {\\n                seen.insert(word);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005163,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001579,
                "title": "c-two-loops-using-sort-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort all the string in the vector and enter two for loop if the element are present in the vector two times or more then increment the result.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and two for loops\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case : O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001553,
                "title": "c-two-loops-using-sort-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort all the string in the vector and enter two for loop if the element are present in the vector two times or more then increment the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and two for loops\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case : O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int res = 0;\\n        int n = words.size();\\n        for(auto &it: words){\\n            sort(it.begin(),it.end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(words[i] == words[j]){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998073,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        StringBuilder str;\\n        int l=words.length;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            for(int j=i+1;j<l;j++){\\n                str=new StringBuilder();\\n                str.append(words[j]);\\n                String s=str.reverse().toString();\\n                if(words[i].equals(s))\\n                    p++;\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        StringBuilder str;\\n        int l=words.length;\\n        int p=0;\\n        for(int i=0;i<l;i++){\\n            for(int j=i+1;j<l;j++){\\n                str=new StringBuilder();\\n                str.append(words[j]);\\n                String s=str.reverse().toString();\\n                if(words[i].equals(s))\\n                    p++;\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996248,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int count=0;\\n        int n=words.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            string s1=words[i];\\n\\n            for(int j=i+1; j<n; j++){\\n                string s2=words[j];\\n\\n                if(s1[0]==s2[1] and s1[1]==s2[0]) count++;   \\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995941,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\nUse palindrome properties with a hashmap\\n# Approach\\nHashMap + sorting\\n# Complexity\\n- Time complexity:\\nO(N*KlogK), where N - length of an array and K - length of words\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - HashMap\\n# Code\\n```\\nclass Solution {\\n    private String sortedWord(String w) {\\n        char[] arr = w.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            //System.out.println(sortedWord(words[i]));\\n            String word = sortedWord(words[i]);\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        int result = 0;\\n        for (Map.Entry<String, Integer> entry: map.entrySet()) {\\n            if (entry.getValue() > 1) result += (entry.getValue() - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private String sortedWord(String w) {\\n        char[] arr = w.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            //System.out.println(sortedWord(words[i]));\\n            String word = sortedWord(words[i]);\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        int result = 0;\\n        for (Map.Entry<String, Integer> entry: map.entrySet()) {\\n            if (entry.getValue() > 1) result += (entry.getValue() - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995901,
                "title": "using-stringbuilder-method-and-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {int a=0;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                str.append(words[j]);\\n\\n            \\n            if(words[i].equals(str.reverse().toString()))a++;\\n            str.delete(0,str.length());//to input new string\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {int a=0;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=i+1;j<words.length;j++){\\n                str.append(words[j]);\\n\\n            \\n            if(words[i].equals(str.reverse().toString()))a++;\\n            str.delete(0,str.length());//to input new string\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990881,
                "title": "optiminal-solution-with-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String reverse(String s1){\\n        StringBuilder s = new StringBuilder();\\n        for(int i=s1.length()-1; i>=0; i--){\\n            s.append(Character.toString(s1.charAt(i)));\\n        }\\n        return s.toString();\\n    }\\n\\n    boolean checksimilar(String s1, String s2){\\n        String rev = reverse(s1);\\n        if(s1.equals(s2) || s2.equals(rev)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                if(checksimilar(words[i],words[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    String reverse(String s1){\\n        StringBuilder s = new StringBuilder();\\n        for(int i=s1.length()-1; i>=0; i--){\\n            s.append(Character.toString(s1.charAt(i)));\\n        }\\n        return s.toString();\\n    }\\n\\n    boolean checksimilar(String s1, String s2){\\n        String rev = reverse(s1);\\n        if(s1.equals(s2) || s2.equals(rev)){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count=0;\\n        for(int i=0; i<words.length; i++){\\n            for(int j=i+1; j<words.length; j++){\\n                if(checksimilar(words[i],words[j])){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989111,
                "title": "99-better-in-time-o-n-time-solution-an-easy-unique-techinque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## Map solution\\n        n=len(words)\\n        mymap={}\\n        count=0\\n        for word in words:\\n           sorted_word = tuple(sorted(word))\\n           if sorted_word not in mymap:\\n             mymap[sorted_word] = 1\\n           else:\\n             mymap[sorted_word] += 1\\n        for key,value in mymap.items():\\n            if value==1 :\\n                continue\\n            while value!=1:\\n                count+=value-1\\n                value-=1\\n        return count\\n\\n            \\n\\n                 \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumNumberOfStringPairs(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        ## Map solution\\n        n=len(words)\\n        mymap={}\\n        count=0\\n        for word in words:\\n           sorted_word = tuple(sorted(word))\\n           if sorted_word not in mymap:\\n             mymap[sorted_word] = 1\\n           else:\\n             mymap[sorted_word] += 1\\n        for key,value in mymap.items():\\n            if value==1 :\\n                continue\\n            while value!=1:\\n                count+=value-1\\n                value-=1\\n        return count\\n\\n            \\n\\n                 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986004,
                "title": "set-o-1-easy-friendly-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int z=0;\\n        set<string>s;\\n        for(int h=0; h<words.size(); h++){\\n            string f=words[h];\\n            reverse(f.begin(),f.end());\\n            if(f==words[h]) z++;\\n            s.insert(f);\\n            s.insert(words[h]);\\n        }\\n        int g=words.size();\\n        int w=0;\\n        if(z>1){\\n            return (2*g-s.size()-z)/2;\\n    }\\n    \\n    return (2*g-s.size())/2;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int z=0;\\n        set<string>s;\\n        for(int h=0; h<words.size(); h++){\\n            string f=words[h];\\n            reverse(f.begin(),f.end());\\n            if(f==words[h]) z++;\\n            s.insert(f);\\n            s.insert(words[h]);\\n        }\\n        int g=words.size();\\n        int w=0;\\n        if(z>1){\\n            return (2*g-s.size()-z)/2;\\n    }\\n    \\n    return (2*g-s.size())/2;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985668,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            string t=w[i];\\n            reverse(t.begin(),t.end());\\n            for(int j=i+1;j<w.size();j++){\\n                if(w[j]==t){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& w) {\\n\\n        int ans=0;\\n        for(int i=0;i<w.size();i++){\\n            string t=w[i];\\n            reverse(t.begin(),t.end());\\n            for(int j=i+1;j<w.size();j++){\\n                if(w[j]==t){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984420,
                "title": "easy-to-understand-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy First view of code you might feel like iits O(n^2), but its O(N). Try it once!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a visited array on each iteration, so that u wont traverse second loop to search reversed data.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        visited = [False] * n\\n        count = 0\\n        for i in range(n):\\n            if visited[i] == False and i == n-1:\\n                break\\n            if visited[i] == True:\\n                continue\\n\\n            reversed_word = words[i][::-1]\\n            visited[i] = True\\n            for j in range(i+1, n):\\n                if words[j] == reversed_word:\\n                    visited[j] = True\\n                    count += 1\\n                    break\\n        return count\\n\\n\\n\"\"\"\\ncount = 2\\n\\nvisited =       T       T       T       T       F\\n                0       1       2       3       4\\n\\nwords           cd      ac      dc      ca      zz\\n\\n                        i\\n                                j(dc)\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        n = len(words)\\n        visited = [False] * n\\n        count = 0\\n        for i in range(n):\\n            if visited[i] == False and i == n-1:\\n                break\\n            if visited[i] == True:\\n                continue\\n\\n            reversed_word = words[i][::-1]\\n            visited[i] = True\\n            for j in range(i+1, n):\\n                if words[j] == reversed_word:\\n                    visited[j] = True\\n                    count += 1\\n                    break\\n        return count\\n\\n\\n\"\"\"\\ncount = 2\\n\\nvisited =       T       T       T       T       F\\n                0       1       2       3       4\\n\\nwords           cd      ac      dc      ca      zz\\n\\n                        i\\n                                j(dc)\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983231,
                "title": "world-easiest-solution-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let number =0;\\n    for(let i =0; i<words.length; i++){\\n        for(let j =i+1; j<words.length; j++){\\n            let count = checkstring(words[i], words[j]);\\n            if(count){\\n                number++;\\n            }\\n        }\\n    }\\n    return number;\\n};\\nfunction checkstring(firstString, secString){\\n    console.log(firstString,secString);\\n    for(let i=0, j=secString.length-1; i<firstString.length, j>=0; i++,j--){\\n        // console.log(firstString[i],secString[j]);\\n        if(firstString[i]!=secString[j])\\n        {\\n            // console.log(firstString[i],secString[j]);\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar maximumNumberOfStringPairs = function(words) {\\n    let number =0;\\n    for(let i =0; i<words.length; i++){\\n        for(let j =i+1; j<words.length; j++){\\n            let count = checkstring(words[i], words[j]);\\n            if(count){\\n                number++;\\n            }\\n        }\\n    }\\n    return number;\\n};\\nfunction checkstring(firstString, secString){\\n    console.log(firstString,secString);\\n    for(let i=0, j=secString.length-1; i<firstString.length, j>=0; i++,j--){\\n        // console.log(firstString[i],secString[j]);\\n        if(firstString[i]!=secString[j])\\n        {\\n            // console.log(firstString[i],secString[j]);\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982843,
                "title": "c-fast-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) \\n    {\\n        int count = 0;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            for (int j = i + 1; j < words.size(); j++)\\n            {\\n                if (isPair(words[i], words[j]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\nprivate:\\n    bool isPair(const std::string& s, const std::string& t)\\n    {\\n        if (s.length() != t.length())\\n            return false;\\n        \\n        int left = 0, right = s.length() - 1;\\n        while (left < s.length())\\n        {\\n            if (s[left] != t[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) \\n    {\\n        int count = 0;\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            for (int j = i + 1; j < words.size(); j++)\\n            {\\n                if (isPair(words[i], words[j]))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\nprivate:\\n    bool isPair(const std::string& s, const std::string& t)\\n    {\\n        if (s.length() != t.length())\\n            return false;\\n        \\n        int left = 0, right = s.length() - 1;\\n        while (left < s.length())\\n        {\\n            if (s[left] != t[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982571,
                "title": "c-super-easy-approach",
                "content": "# Intuition\\nClassic nested loop problem \\n\\n# Approach\\nWith a simple nested loop, you can access the characters of the string array that is shown below. My approach was not that fast though, I have no idea why. If you have an idea, please comment on why my approach is slower than others. Thanks!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982570,
                "title": "c-super-easy-approach",
                "content": "# Intuition\\nClassic nested loop problem \\n\\n# Approach\\nWith a simple nested loop, you can access the characters of the string array that is shown below. My approach was not that fast though, I have no idea why. If you have an idea, please comment on why my approach is slower than others. Thanks!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MaximumNumberOfStringPairs(string[] words) {\\n    int result = 0, len = words.Length;\\n    \\n    for(int i = 0; i < len; i++){\\n      for(int j = i+1; j < len; j++){\\n        if((words[i][0] == words[j][1]) && (words[i][1] == words[j][0])){\\n          result++;\\n        }\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979568,
                "title": "just-3-lines-of-code-python",
                "content": "\\n# Complexity\\n- Time complexity: 84.12%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  93.49%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=[]\\n        for i in words:\\n            c+=[\"\".join(sorted(i))]\\n        return len(words)-len(set(c))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        c=[]\\n        for i in words:\\n            c+=[\"\".join(sorted(i))]\\n        return len(words)-len(set(c))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971750,
                "title": "2-easy-ways-to-solve-using-set-sort",
                "content": "# Method 1 : Using Sort Only\\n\\nInitialize an integer variable c to keep track of the count of pairs.\\n\\nLoop through each string in the words vector:\\n\\nFor each string, sort its characters in ascending order. This step essentially standardizes the character order within each string, making it easier to compare strings later.\\nAfter sorting the characters within each string, sort the entire words vector in lexicographically ascending order. This step is done to group together strings that are anagrams (i.e., they can be rearranged to form the same word).\\n\\nLoop through the sorted words vector (up to the second-to-last element):\\n\\nCompare each string with the next one in the vector.\\nIf two consecutive strings are equal, increment the c counter. This means they are anagrams and can form a pair.\\nReturn the final count c of anagram pairs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        sort(words.begin(),words.end());\\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(words[i]==words[i+1]){\\n                c+=1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n# Method 2 : Using Set\\nCreate an empty set called ans. The set data structure is being used to store unique strings. This will help identify unique anagram patterns among the words.\\n\\nLoop through each string in the words vector:\\n\\nFor each string, create a copy called s.\\nSort the characters of s in ascending order. This standardizes the character order within each string, making it easier to identify anagrams.\\nInsert the sorted string s into the ans set. The set will automatically take care of removing duplicates, so only unique anagram patterns are stored.\\n\\nAfter processing all the strings, the size of the ans set will represent the number of unique anagram patterns.\\n\\nCalculate the difference between the total number of input words (words.size()) and the number of unique anagram patterns (ans.size()). This difference represents the count of strings that are not part of any anagram pair.\\n\\nReturn this difference as the result.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        set<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            ans.insert(s);\\n        }\\n        return words.size()-ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        sort(words.begin(),words.end());\\n\\n        for(int i=0;i<words.size()-1;i++){\\n            if(words[i]==words[i+1]){\\n                c+=1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        set<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            ans.insert(s);\\n        }\\n        return words.size()-ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967258,
                "title": "solution-in-java-with-85-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHasheSet Approach \\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n    \\n        Set<String> set = new HashSet<>();\\n\\n\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            if(!set.contains(sb.toString())) set.add(words[i]);\\n        }\\n\\n\\n        return words.length-set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n    \\n        Set<String> set = new HashSet<>();\\n\\n\\n        for(int i=0;i<words.length;i++){\\n            StringBuilder sb = new StringBuilder(words[i]);\\n            sb.reverse();\\n            if(!set.contains(sb.toString())) set.add(words[i]);\\n        }\\n\\n\\n        return words.length-set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964730,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        auto result = 0;\\n        unordered_map<string, int> map;\\n        for (auto word : words) {\\n            if (!map.count(word)) reverse(begin(word), end(word));\\n            ++map[word];\\n        }\\n        for (const auto& pair : map)\\n            result += pair.second / 2;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumNumberOfStringPairs(vector<string>& words) {\\n        auto result = 0;\\n        unordered_map<string, int> map;\\n        for (auto word : words) {\\n            if (!map.count(word)) reverse(begin(word), end(word));\\n            ++map[word];\\n        }\\n        for (const auto& pair : map)\\n            result += pair.second / 2;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963462,
                "title": "100-optimezed-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n=words.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            String s1=words[i];\\n            for(int j=i+1;j<n;j++){\\n               String s2=words[j];\\n               if(s1.charAt(0)==s2.charAt(1) && s1.charAt(1)==s2.charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int n=words.length;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            String s1=words[i];\\n            for(int j=i+1;j<n;j++){\\n               String s2=words[j];\\n               if(s1.charAt(0)==s2.charAt(1) && s1.charAt(1)==s2.charAt(0)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957107,
                "title": "find-maximum-number-of-string-in-pairs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n     int count = 0;\\n     int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len ; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)){\\n                   count++;\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n     int count = 0;\\n     int len = words.length;\\n\\n      for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len ; j++) {\\n                if (words[i].charAt(0) == words[j].charAt(1) && words[i].charAt(1) == words[j].charAt(0)){\\n                   count++;\\n                }\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955227,
                "title": "java-easy-solution-string-reversing-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n\\t\\tfor(int i=0; i<words.length; i++) \\n\\t\\t\\tfor(int j=i+1; j<words.length; j++) \\n\\t\\t\\t\\tif(reverse(words[i]).equals(words[j])) count++;\\n\\t\\treturn count;\\n    }\\n\\n    public static String reverse(String str) {\\n\\t\\t  return str.isEmpty() ? \"\" : reverse(str.substring(1))+Character.toString(str.charAt(0));\\n\\t  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumNumberOfStringPairs(String[] words) {\\n        int count =0;\\n\\t\\tfor(int i=0; i<words.length; i++) \\n\\t\\t\\tfor(int j=i+1; j<words.length; j++) \\n\\t\\t\\t\\tif(reverse(words[i]).equals(words[j])) count++;\\n\\t\\treturn count;\\n    }\\n\\n    public static String reverse(String str) {\\n\\t\\t  return str.isEmpty() ? \"\" : reverse(str.substring(1))+Character.toString(str.charAt(0));\\n\\t  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952333,
                "title": "python-dict-beats-98-32",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        d = {}\\n        count = 0\\n        for word in words:\\n            if word[::-1] in d:\\n                count += 1\\n            else:\\n                d[word] = True\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\\n        d = {}\\n        count = 0\\n        for word in words:\\n            if word[::-1] in d:\\n                count += 1\\n            else:\\n                d[word] = True\\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1942758,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 1984362,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 2000277,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            },
            {
                "id": 2005502,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ Optimal solution.\\n\\n# Approach\\n\\n1. Create an empty set called `st` to store unique strings.\\n2. Get the size of the input vector `words` and store it in the variable `n`.\\n3. Initialize a counter variable `count` to keep track of the number of string pairs.\\n4. Iterate over each element in the `words` vector using a loop variable `i`.\\n5. Inside the loop, check if the current index `i` is 0 (first string in the vector).\\n6. If `i` is 0, insert the first string `words[i]` into the set `st`.\\n7. If `i` is not 0, perform the following steps:\\n   a. Create a temporary string `temp` by rotating the current string `words[i]` by one character to the left. This is done by taking a substring of `words[i]` starting from the second character (index 1) and appending the first character (index 0) at the end.\\n   b. Check if the rotated string `temp` exists in the set `st` by using the `find` function. If it does exist, it means a pair can be formed.\\n   c. If `temp` is found in `st`, increment the `count` variable by 1 to keep track of the number of pairs found, and remove `temp` from the set `st` using the `erase` function.\\n   d. If `temp` is not found in `st`, it means a pair cannot be formed at this point. Insert the current string `words[i]` into the set `st`.\\n8. After the loop ends, return the value of `count`, which represents the maximum number of string pairs that can be formed.\\n\\n--------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n- Space complexity:\\nS.C=O(n) set space.\\n------------------------------------\\nPlease Upvote. If Understand the concept.\\nSolution link:\\n https://leetcode.com/problems/find-maximum-number-of-string-pairs/solutions/3678104/c-optimal-solution/"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "brute force method is easy here\\n"
                    },
                    {
                        "username": "negarrrr",
                        "content": "I think test cases are not enough, as I could submit a solution that does not pass such a case: \\nInput: words =[\\'abc\\', \\'bca\\']\\noutput = 0"
                    },
                    {
                        "username": "vinnisnx",
                        "content": "words[i].length == 2"
                    },
                    {
                        "username": "Gabbar_007",
                        "content": "Test cases are not enough. "
                    }
                ]
            }
        ]
    }
]