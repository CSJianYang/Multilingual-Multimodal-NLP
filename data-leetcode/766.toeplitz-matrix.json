[
    {
        "title": "House Robber III",
        "question_content": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.\nBesides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.\nGiven the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n&nbsp;\nExample 1:\n\nInput: root = [3,2,3,null,3,null,1]\nOutput: 7\nExplanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\nExample 2:\n\nInput: root = [3,4,5,1,3,null,1]\nOutput: 9\nExplanation: Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t0 <= Node.val <= 104",
        "solutions": [
            {
                "id": 79330,
                "title": "step-by-step-tackling-of-the-problem",
                "content": "**Step I -- Think naively**\\n\\nAt first glance, the problem exhibits the feature of \"optimal substructure\": if we want to rob maximum amount of money from current binary tree (rooted at `root`), we surely hope that we can do the same to its left and right subtrees. \\n\\nSo going along this line, let\\'s define the function `rob(root)` which will return the maximum amount of money that we can rob for the binary tree rooted at `root`; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get `rob(root)` from `rob(root.left), rob(root.right), ...` etc.\\n\\nApparently the analyses above suggest a recursive solution. And for recursion, it\\'s always worthwhile figuring out the following two properties:\\n\\n 1. Termination condition: when do we know the answer to `rob(root)` without any calculation? Of course when the tree is empty ---- we\\'ve got nothing to rob so the amount of money is zero.\\n\\n 2. Recurrence relation: i.e., how to get `rob(root)` from `rob(root.left), rob(root.right), ...` etc. From the point of view of the tree root, there are only two scenarios at the end: `root` is robbed or is not. If it is, due to the constraint that \"we cannot rob any two directly-linked houses\", the next level of subtrees that are available would be the four \"**grandchild-subtrees**\" (`root.left.left, root.left.right, root.right.left, root.right.right`).  However if `root` is not robbed, the next level of available subtrees would just be the two \"**child-subtrees**\" (`root.left, root.right`). We only need to choose the scenario which yields the larger amount of money.\\n\\nHere is the program for the ideas above:\\n\\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int val = 0;\\n        \\n        if (root.left != null) {\\n            val += rob(root.left.left) + rob(root.left.right);\\n        }\\n        \\n        if (root.right != null) {\\n            val += rob(root.right.left) + rob(root.right.right);\\n        }\\n        \\n        return Math.max(val + root.val, rob(root.left) + rob(root.right));\\n    }\\n\\nHowever the solution runs very slowly (`1186 ms`) and barely got accepted (the time complexity turns out to be exponential, see my [comments](https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem/26?page=2) below).\\n\\n---\\n\\n**Step II -- Think one step further**\\n\\nIn step `I`, we only considered the aspect of \"optimal substructure\", but think little about the possibilities of overlapping of the subproblems. For example, to obtain `rob(root)`, we need `rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right)`; but to get `rob(root.left)`, we also need `rob(root.left.left), rob(root.left.right)`, similarly for `rob(root.right)`. The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming (DP): \"**optimal substructure**\" + \"**overlapping of subproblems**\", we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees. \\n\\nAnd here is the improved solution:\\n\\n    public int rob(TreeNode root) {\\n        return robSub(root, new HashMap<>());\\n    }\\n    \\n    private int robSub(TreeNode root, Map<TreeNode, Integer> map) {\\n        if (root == null) return 0;\\n        if (map.containsKey(root)) return map.get(root);\\n        \\n        int val = 0;\\n        \\n        if (root.left != null) {\\n            val += robSub(root.left.left, map) + robSub(root.left.right, map);\\n        }\\n        \\n        if (root.right != null) {\\n            val += robSub(root.right.left, map) + robSub(root.right.right, map);\\n        }\\n        \\n        val = Math.max(val + root.val, robSub(root.left, map) + robSub(root.right, map));\\n        map.put(root, val);\\n        \\n        return val;\\n    }\\n\\nThe runtime is sharply reduced to `9 ms`, at the expense of `O(n)` space cost (`n` is the total number of nodes; stack cost for recursion is not counted).\\n\\n---\\n\\n**Step III -- Think one step back**\\n\\nIn step `I`, we defined our problem as `rob(root)`, which will yield the maximum amount of money that can be robbed of the binary tree rooted at `root`. This leads to the DP problem summarized in step `II`. \\n\\nNow let\\'s take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you\\'ll find the answer lies in the way how we have defined `rob(root)`. As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. `rob(root)` does not distinguish between these two cases, so \"information is lost as the recursion goes deeper and deeper\", which results in repeated subproblems.\\n\\nIf we were able to maintain the information about the two scenarios for each tree root, let\\'s see how it plays out. Redefine `rob(root)` as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if `root` is **not robbed**, while the second element signifies the maximum amount of money robbed if it is **robbed**. \\n\\nLet\\'s relate `rob(root)` to `rob(root.left)` and `rob(root.right)...`, etc. For the 1st element of `rob(root)`, we only need to sum up the larger elements of `rob(root.left)` and `rob(root.right)`, respectively, since `root` is not robbed and we are free to rob its left and right subtrees. For the 2nd element of `rob(root)`, however, we only need to add up the 1st elements of `rob(root.left)` and `rob(root.right)`, respectively, plus the value robbed from `root` itself, since in this case it\\'s guaranteed that we cannot rob the nodes of `root.left` and `root.right`. \\n\\nAs you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:\\n\\n    public int rob(TreeNode root) {\\n        int[] res = robSub(root);\\n        return Math.max(res[0], res[1]);\\n    }\\n    \\n    private int[] robSub(TreeNode root) {\\n        if (root == null) return new int[2];\\n        \\n        int[] left = robSub(root.left);\\n        int[] right = robSub(root.right);\\n        int[] res = new int[2];\\n\\n        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        res[1] = root.val + left[0] + right[0];\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Step I -- Think naively**\\n\\nAt first glance, the problem exhibits the feature of \"optimal substructure\": if we want to rob maximum amount of money from current binary tree (rooted at `root`), we surely hope that we can do the same to its left and right subtrees. \\n\\nSo going along this line, let\\'s define the function `rob(root)` which will return the maximum amount of money that we can rob for the binary tree rooted at `root`; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get `rob(root)` from `rob(root.left), rob(root.right), ...` etc.\\n\\nApparently the analyses above suggest a recursive solution. And for recursion, it\\'s always worthwhile figuring out the following two properties:\\n\\n 1. Termination condition: when do we know the answer to `rob(root)` without any calculation? Of course when the tree is empty ---- we\\'ve got nothing to rob so the amount of money is zero.\\n\\n 2. Recurrence relation: i.e., how to get `rob(root)` from `rob(root.left), rob(root.right), ...` etc. From the point of view of the tree root, there are only two scenarios at the end: `root` is robbed or is not. If it is, due to the constraint that \"we cannot rob any two directly-linked houses\", the next level of subtrees that are available would be the four \"**grandchild-subtrees**\" (`root.left.left, root.left.right, root.right.left, root.right.right`).  However if `root` is not robbed, the next level of available subtrees would just be the two \"**child-subtrees**\" (`root.left, root.right`). We only need to choose the scenario which yields the larger amount of money.\\n\\nHere is the program for the ideas above:\\n\\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int val = 0;\\n        \\n        if (root.left != null) {\\n            val += rob(root.left.left) + rob(root.left.right);\\n        }\\n        \\n        if (root.right != null) {\\n            val += rob(root.right.left) + rob(root.right.right);\\n        }\\n        \\n        return Math.max(val + root.val, rob(root.left) + rob(root.right));\\n    }\\n\\nHowever the solution runs very slowly (`1186 ms`) and barely got accepted (the time complexity turns out to be exponential, see my [comments](https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem/26?page=2) below).\\n\\n---\\n\\n**Step II -- Think one step further**\\n\\nIn step `I`, we only considered the aspect of \"optimal substructure\", but think little about the possibilities of overlapping of the subproblems. For example, to obtain `rob(root)`, we need `rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right)`; but to get `rob(root.left)`, we also need `rob(root.left.left), rob(root.left.right)`, similarly for `rob(root.right)`. The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming (DP): \"**optimal substructure**\" + \"**overlapping of subproblems**\", we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees. \\n\\nAnd here is the improved solution:\\n\\n    public int rob(TreeNode root) {\\n        return robSub(root, new HashMap<>());\\n    }\\n    \\n    private int robSub(TreeNode root, Map<TreeNode, Integer> map) {\\n        if (root == null) return 0;\\n        if (map.containsKey(root)) return map.get(root);\\n        \\n        int val = 0;\\n        \\n        if (root.left != null) {\\n            val += robSub(root.left.left, map) + robSub(root.left.right, map);\\n        }\\n        \\n        if (root.right != null) {\\n            val += robSub(root.right.left, map) + robSub(root.right.right, map);\\n        }\\n        \\n        val = Math.max(val + root.val, robSub(root.left, map) + robSub(root.right, map));\\n        map.put(root, val);\\n        \\n        return val;\\n    }\\n\\nThe runtime is sharply reduced to `9 ms`, at the expense of `O(n)` space cost (`n` is the total number of nodes; stack cost for recursion is not counted).\\n\\n---\\n\\n**Step III -- Think one step back**\\n\\nIn step `I`, we defined our problem as `rob(root)`, which will yield the maximum amount of money that can be robbed of the binary tree rooted at `root`. This leads to the DP problem summarized in step `II`. \\n\\nNow let\\'s take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you\\'ll find the answer lies in the way how we have defined `rob(root)`. As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. `rob(root)` does not distinguish between these two cases, so \"information is lost as the recursion goes deeper and deeper\", which results in repeated subproblems.\\n\\nIf we were able to maintain the information about the two scenarios for each tree root, let\\'s see how it plays out. Redefine `rob(root)` as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if `root` is **not robbed**, while the second element signifies the maximum amount of money robbed if it is **robbed**. \\n\\nLet\\'s relate `rob(root)` to `rob(root.left)` and `rob(root.right)...`, etc. For the 1st element of `rob(root)`, we only need to sum up the larger elements of `rob(root.left)` and `rob(root.right)`, respectively, since `root` is not robbed and we are free to rob its left and right subtrees. For the 2nd element of `rob(root)`, however, we only need to add up the 1st elements of `rob(root.left)` and `rob(root.right)`, respectively, plus the value robbed from `root` itself, since in this case it\\'s guaranteed that we cannot rob the nodes of `root.left` and `root.right`. \\n\\nAs you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:\\n\\n    public int rob(TreeNode root) {\\n        int[] res = robSub(root);\\n        return Math.max(res[0], res[1]);\\n    }\\n    \\n    private int[] robSub(TreeNode root) {\\n        if (root == null) return new int[2];\\n        \\n        int[] left = robSub(root.left);\\n        int[] right = robSub(root.right);\\n        int[] res = new int[2];\\n\\n        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        res[1] = root.val + left[0] + right[0];\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 79333,
                "title": "simple-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int tryRob(TreeNode* root, int& l, int& r) {\\n            if (!root)\\n                return 0;\\n                \\n            int ll = 0, lr = 0, rl = 0, rr = 0;\\n            l = tryRob(root->left, ll, lr);\\n            r = tryRob(root->right, rl, rr);\\n            \\n            return max(root->val + ll + lr + rl + rr, l + r);\\n        }\\n    \\n        int rob(TreeNode* root) {\\n            int l, r;\\n            return tryRob(root, l, r);\\n        }\\n    };\\n\\nBasically you want to compare which one is bigger between 1) you + sum of your grandchildren and 2) sum of your children. Personally I like my solution better than the most voted solution because I don't need complex data structures like map.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int tryRob(TreeNode* root, int& l, int& r) {\\n            if (!root)\\n                return 0;\\n                \\n            int ll = 0, lr = 0, rl = 0, rr = 0;\\n            l = tryRob(root->left, ll, lr);\\n            r = tryRob(root->right, rl, rr);\\n            \\n            return max(root->val + ll + lr + rl + rr, l + r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79363,
                "title": "easy-understanding-solution-with-dfs",
                "content": "dfs all the nodes of the tree, each node return two number, int[] num, num[0] is the max value while rob this node, num[1] is max value while not rob this value. Current node return value only depend on its children's value. Transform function should be very easy to understand.\\n\\n    public class Solution {\\n        public int rob(TreeNode root) {\\n            int[] num = dfs(root);\\n            return Math.max(num[0], num[1]);\\n        }\\n        private int[] dfs(TreeNode x) {\\n            if (x == null) return new int[2];\\n            int[] left = dfs(x.left);\\n            int[] right = dfs(x.right);\\n            int[] res = new int[2];\\n            res[0] = left[1] + right[1] + x.val;\\n            res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rob(TreeNode root) {\\n            int[] num = dfs(root);\\n            return Math.max(num[0], num[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79394,
                "title": "python-o-n-code-optimized-for-readability",
                "content": "Implementing the decoupled recursive approach detailed [here](https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem)\\n\\n```\\nclass Solution(object):\\n    def rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def superrob(node):\\n            # returns tuple of size two (now, later)\\n            # now: max money earned if input node is robbed\\n            # later: max money earned if input node is not robbed\\n            \\n            # base case\\n            if not node: return (0, 0)\\n            \\n            # get values\\n            left, right = superrob(node.left), superrob(node.right)\\n            \\n            # rob now\\n            now = node.val + left[1] + right[1]\\n            \\n            # rob later\\n            later = max(left) + max(right)\\n            \\n            return (now, later)\\n            \\n        return max(superrob(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def superrob(node):\\n            # returns tuple of size two (now, later)\\n            # now: max money earned if input node is robbed\\n            # later: max money earned if input node is not robbed\\n            \\n            # base case\\n            if not node: return (0, 0)\\n            \\n            # get values\\n            left, right = superrob(node.left), superrob(node.right)\\n            \\n            # rob now\\n            now = node.val + left[1] + right[1]\\n            \\n            # rob later\\n            later = max(left) + max(right)\\n            \\n            return (now, later)\\n            \\n        return max(superrob(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612349,
                "title": "c-python-simple-solutions-w-explanation-optimization-from-brute-force-to-dp-to-optimized-dp",
                "content": "We are given a binary tree consisting of houses. We need to find maximum loot that we can get without robbing two directly linked houses\\n\\n---\\n\\n \\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s try to solve this starting with brute-force.\\n\\n* At each house/node of the tree, we have the choice to either rob it or not to rob it\\n* If we rob the current node, we cannot rob the left or right child of the current node\\n* If we dont rob the current node, we can move to the left and right nodes and rob them\\n* We choose the option which yields us the maximum loot\\n\\nWe can implement this in two ways- \\n1. In 1st implementation below, I have used a boolean `canRob` variable denoting whether we can rob the current node or not. Each time we move to child nodes with `canRob` parameter set to true or false depending on whether the current node was robbed or not.\\n2. In the 2nd implementation, we never move to directly linked nodes when we rob the current node. So we can either not rob the current node, or we can rob it and move to both child nodes of `root -> left` and `root -> right` if they exists.\\n\\nI found 1st version a bit simpler but the 2nd version will be better for optimization into `dp`.\\n\\n### **C++**\\n> *1st Implementation*\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root, bool canRob = true) {\\n        if(!root) return 0;\\n        int dontRob = rob(root -> left, true) + rob(root -> right, true);\\n        int robRoot = canRob ? root -> val + rob(root -> left, false) + rob(root -> right, false) : -1;\\n        return max(dontRob, robRoot);\\n    }\\n};\\n```\\n\\n> *2nd Implementation*\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        int dontRob = rob(root -> left) + rob(root -> right), robRoot = root -> val;\\n        if(root -> left) robRoot += rob(root -> left -> left) + rob(root -> left -> right);\\n        if(root -> right) robRoot += rob(root -> right -> left) + rob(root -> right -> right);\\n        return max(dontRob, robRoot);\\n    }\\n};\\n```\\n\\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> <hr> \\n\\n### **Python**\\n> *1st Implmentation*\\n```python\\nclass Solution:\\n    def rob(self, root, canRob = True):\\n        if not root: return 0\\n        dont_rob = self.rob(root.left, True) + self.rob(root.right, True)\\n        rob_root = root.val + self.rob(root.left, False) + self.rob(root.right, False) if canRob else -1\\n        return max(dont_rob, rob_root)\\n```\\n\\n> *2nd Implemtation*\\n```python\\nclass Solution:\\n    def rob(self, root):\\n        if not root: return 0\\n        dont_rob, rob_root = self.rob(root.left) + self.rob(root.right), root.val\\n        if root.left:   rob_root += self.rob(root.left.left)  + self.rob(root.left.right)\\n        if root.right:  rob_root += self.rob(root.right.left) + self.rob(root.right.right)\\n        return max(dont_rob, rob_root)\\n```\\n\\n***Time Complexity :*** <code>O(2<sup>N</sup>)</code>, where `N` is the number of nodes in the tree. \\n***Space Complexity :*** `O(H)`, where `H` is the height of the tree. `H` is the max recursion depth & thus `O(H)` space is required by recursive stack. It is `O(N)` in case of skewed tree and `O(logN)` in case of balanced binary tree.\\n\\n\\n---\\n\\n \\u2714\\uFE0F ***Solution - II (Dynamic Programming)***\\n\\nDrawing out the recursion tree, we can see that there are multiple repeated computations taking place. But call to `rob()` with same parameters should always give us the same result which is maximum possible loot that we can get starting from that node. So, instead of doing repeated computations over and over again, we can simply save the result for a given state of function and directly return the same result when repeated call is made. \\n\\nHere, for the 1st case, we use a `dp` hashmap where `dp[node][canRob]` denotes the maximum possible loot that we can get starting from `node` in the tree & `canRob` denotes whether it can be robbed or not. Note that in this case we needed to save the complete state of function into `dp` which includes `canRob` parameter as well.\\nSimilarly, for 2nd case, we use `dp` hashmap where `dp[node]` denotes the maximum possible loot that we can get starting from `node` in the tree.\\n\\n### **C++**\\n> *1st Implementation*\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, vector<int>> dp;\\n    int rob(TreeNode* root, bool canRob = true) {\\n        if(!root) return 0;\\n        if(dp.count(root) && dp[root][canRob] != -1) return dp[root][canRob];\\n        dp[root] = {-1,-1};\\n        int dontRob = rob(root -> left, true) + rob(root -> right, true);\\n        int robRoot = canRob ? root -> val + rob(root -> left, false) + rob(root -> right, false) : -1;\\n        return dp[root][canRob] = max(dontRob, robRoot);\\n    }\\n};\\n```\\n\\n> *2nd Implementation*\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        if(dp.count(root)) return dp[root];\\n        int dontRob = rob(root -> left) + rob(root -> right), robRoot = root -> val;\\n        if(root -> left) robRoot += rob(root -> left -> left) + rob(root -> left -> right);\\n        if(root -> right) robRoot += rob(root -> right -> left) + rob(root -> right -> right);\\n        return dp[root] = max(dontRob, robRoot);\\n    }\\n};\\n```\\n\\n### **Python**\\n> *1st Implementation*\\n```python\\nclass Solution:\\n    @cache\\n    def rob(self, root, canRob = True):\\n        if not root: return 0\\n        dont_rob = self.rob(root.left, True) + self.rob(root.right, True)\\n        rob_root = root.val + self.rob(root.left, False) + self.rob(root.right, False) if canRob else -1\\n        return max(dont_rob, rob_root)\\n```\\n\\n> *2nd Implemtation*\\n```python\\nclass Solution:\\n    @cache\\n    def rob(self, root):\\n        if not root: return 0\\n        dont_rob, rob_root = self.rob(root.left) + self.rob(root.right), root.val\\n        if root.left:   rob_root += self.rob(root.left.left)  + self.rob(root.left.right)\\n        if root.right:  rob_root += self.rob(root.right.left) + self.rob(root.right.right)\\n        return max(dont_rob, rob_root)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we calculate `dp[node]` for each of `N` nodes in the tree only once.\\n***Space Complexity :*** `O(N)`, required for maintaining `dp`\\n\\n---\\n\\n \\u2714\\uFE0F ***Solution - III (Space-Optimized Dynamic Programming)***\\n\\nIn the above solutions, we recursed for both cases when current node was robbed and current node wasn\\'t robbed and depending on the result from both cases, we decided which one to choose. This led to separate dfs calls with multiple states, one with current node\\'s state as being robbed and other one with the state being not robbed. This required us memoize the results to avoid repeated calls to a node\\'s state which was already calculated in one of earlier dfs call.\\n\\nGoing a slightly different route, instead of doing separate calls, we just make a single dfs call to left and right child nodes (without differentiating the state of current node) and return the results for both the cases of the child nodes being robbed and not robbed. We can then calculate the result for current node for -\\n * state when **current node is robbed** which will be equal to current node\\'s value + sum of result of child nodes not being robbed.\\n * state when **current node is NOT robbed** which will be equal to sum of result of child nodes in their maximum loot state (i.e, for each child node, choose its state of either being robbed or not robbed, whichever gave maximum loot).\\n\\nTo summarize, this approach issues a single dfs call down till the leaf node and from there it propagates upwards the value of **1.** maximum loot when child node is not robbed and, **2.** maximum loot when child node is robbed. This allows us to calculate result for both states of current node being robbed and not being robbed without the need of memoizing the results for child nodes.\\n\\n### **C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n    pair<int, int> dfs(TreeNode* root) {\\n        if(!root) return {0, 0};\\n        auto [leftDontRob, leftRob]   = dfs(root -> left);\\n        auto [rightDontRob, rightRob] = dfs(root -> right);\\n        return {\\n            max(leftDontRob, leftRob) + max(rightDontRob, rightRob),\\n            root -> val + leftDontRob + rightDontRob\\n        };\\n    }\\n};\\n```\\n\\n### **Python**\\n```python\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(root):\\n            if not root: return (0, 0)\\n            L, R = dfs(root.left), dfs(root.right)\\n            return (max(L) + max(R), root.val + L[0] + R[0])\\n        return max(dfs(root))\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** `O(H)`, required for recursive stack\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root, bool canRob = true) {\\n        if(!root) return 0;\\n        int dontRob = rob(root -> left, true) + rob(root -> right, true);\\n        int robRoot = canRob ? root -> val + rob(root -> left, false) + rob(root -> right, false) : -1;\\n        return max(dontRob, robRoot);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        int dontRob = rob(root -> left) + rob(root -> right), robRoot = root -> val;\\n        if(root -> left) robRoot += rob(root -> left -> left) + rob(root -> left -> right);\\n        if(root -> right) robRoot += rob(root -> right -> left) + rob(root -> right -> right);\\n        return max(dontRob, robRoot);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, root, canRob = True):\\n        if not root: return 0\\n        dont_rob = self.rob(root.left, True) + self.rob(root.right, True)\\n        rob_root = root.val + self.rob(root.left, False) + self.rob(root.right, False) if canRob else -1\\n        return max(dont_rob, rob_root)\\n```\n```python\\nclass Solution:\\n    def rob(self, root):\\n        if not root: return 0\\n        dont_rob, rob_root = self.rob(root.left) + self.rob(root.right), root.val\\n        if root.left:   rob_root += self.rob(root.left.left)  + self.rob(root.left.right)\\n        if root.right:  rob_root += self.rob(root.right.left) + self.rob(root.right.right)\\n        return max(dont_rob, rob_root)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, vector<int>> dp;\\n    int rob(TreeNode* root, bool canRob = true) {\\n        if(!root) return 0;\\n        if(dp.count(root) && dp[root][canRob] != -1) return dp[root][canRob];\\n        dp[root] = {-1,-1};\\n        int dontRob = rob(root -> left, true) + rob(root -> right, true);\\n        int robRoot = canRob ? root -> val + rob(root -> left, false) + rob(root -> right, false) : -1;\\n        return dp[root][canRob] = max(dontRob, robRoot);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        if(dp.count(root)) return dp[root];\\n        int dontRob = rob(root -> left) + rob(root -> right), robRoot = root -> val;\\n        if(root -> left) robRoot += rob(root -> left -> left) + rob(root -> left -> right);\\n        if(root -> right) robRoot += rob(root -> right -> left) + rob(root -> right -> right);\\n        return dp[root] = max(dontRob, robRoot);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    @cache\\n    def rob(self, root, canRob = True):\\n        if not root: return 0\\n        dont_rob = self.rob(root.left, True) + self.rob(root.right, True)\\n        rob_root = root.val + self.rob(root.left, False) + self.rob(root.right, False) if canRob else -1\\n        return max(dont_rob, rob_root)\\n```\n```python\\nclass Solution:\\n    @cache\\n    def rob(self, root):\\n        if not root: return 0\\n        dont_rob, rob_root = self.rob(root.left) + self.rob(root.right), root.val\\n        if root.left:   rob_root += self.rob(root.left.left)  + self.rob(root.left.right)\\n        if root.right:  rob_root += self.rob(root.right.left) + self.rob(root.right.right)\\n        return max(dont_rob, rob_root)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n    pair<int, int> dfs(TreeNode* root) {\\n        if(!root) return {0, 0};\\n        auto [leftDontRob, leftRob]   = dfs(root -> left);\\n        auto [rightDontRob, rightRob] = dfs(root -> right);\\n        return {\\n            max(leftDontRob, leftRob) + max(rightDontRob, rightRob),\\n            root -> val + leftDontRob + rightDontRob\\n        };\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(root):\\n            if not root: return (0, 0)\\n            L, R = dfs(root.left), dfs(root.right)\\n            return (max(L) + max(R), root.val + L[0] + R[0])\\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376297,
                "title": "python3-dynamic-programming-depth-first-search",
                "content": "* we construct a dp tree, each node in dp tree represents [rob the current node how much you gain, skip the current node how much you gain]\\n dp_node[0] =[rob the current node how much you gain]\\n dp_node[1] =[skip the current node how much you gain]\\n* we start the stolen from the leaf: Depth First Search\\n* for each node you have 2 opitions:\\n\\toption 1: rob the node, then you can\\'t rob the child of the node.\\n\\t\\t\\t\\t\\tdp_node[0] = node.val + dp_node.left[1] +dp_node.right[1]\\n\\toption 2: skip the node, then you can rob or skip the child of the node. \\n\\t\\t\\t\\t\\tdp_node[1] = dp_node.left[0] + dp_node.right[0]\\n* \\tthe maximum of gain of the node depents on max(dp_node[0],dp_node[1])\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \"\"\"\\n    Input: [3,4,5,1,3,null,1]\\n input tree            dp tree:\\n     3                  [3+3+1,4+5]\\n    / \\\\                /        \\\\\\n   4   5            [4,3]      [5,1]\\n  / \\\\   \\\\          /     \\\\          \\\\\\n 1   2   1      [1,0]    [2,0]     [1,0]\\n                / \\\\       /  \\\\        /  \\\\\\n           [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n    \\n    \"\"\"\\n    def rob(self, root: TreeNode) -> int:\\n        return max(self.dfs(root))\\n    \\n    def dfs(self, root: TreeNode):\\n        if not root:\\n            return (0, 0)\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        return (root.val + left[1] + right[1], max(left[0], left[1]) + max(right[0], right[1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    \"\"\"\\n    Input: [3,4,5,1,3,null,1]\\n input tree            dp tree:\\n     3                  [3+3+1,4+5]\\n    / \\\\                /        \\\\\\n   4   5            [4,3]      [5,1]\\n  / \\\\   \\\\          /     \\\\          \\\\\\n 1   2   1      [1,0]    [2,0]     [1,0]\\n                / \\\\       /  \\\\        /  \\\\\\n           [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n    \\n    \"\"\"\\n    def rob(self, root: TreeNode) -> int:\\n        return max(self.dfs(root))\\n    \\n    def dfs(self, root: TreeNode):\\n        if not root:\\n            return (0, 0)\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        return (root.val + left[1] + right[1], max(left[0], left[1]) + max(right[0], right[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79344,
                "title": "easy-to-understand-java",
                "content": "public class Solution {\\n    \\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(robInclude(root), robExclude(root));\\n    }\\n    \\n    public int robInclude(TreeNode node) {\\n        if(node == null) return 0;\\n        return robExclude(node.left) + robExclude(node.right) + node.val;\\n    }\\n    \\n    public int robExclude(TreeNode node) {\\n        if(node == null) return 0;\\n        return rob(node.left) + rob(node.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(robInclude(root), robExclude(root));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1611899,
                "title": "c-with-and-without-memo-detailed-explaination",
                "content": "So, robber is active again , let\\'s see how we can calculate an efficient robbery !!\\n\\nThis again is a classic **DFS** problem where we have to look out for the recurrence relation and think dynamically ... The houses are present in the form of binary tree and if we are at the root_house then we have two choices :: \\n**/a. to the rob the root house and skip it\\'s children and move on to root\\'s grandchildren.../**     OR     **/b. to skip this house and move on to left and right_subtree, with the hope that it will yeild better result./**\\n   * In case robber is robbing the *root_house*,    maximum money he is gonna rob == **root->val + answer(root->left->left + root->left->right + root->right->left + root->right->right)**{as then these nodes are gonna be the grandchildren of curr_root (in case they exist)}..\\n   * In case he is not robbing the *root_house*, maximum money he gonna rob == **answer(root->left + root->right)**.\\n   * And Final answer == **max(root_included, root_excluded)**\\n   * We are ready with the approach , just need to write base case and do recursion calls and then some calculations ... But before blindly making recursion calls , we should check out if we are calling on the same node multiple times or not !! If multiple calls on same is done, then Time Complexity would get screwed and we will have to memoize the solution !!\\n   * ![image](https://assets.leetcode.com/users/images/2f063a24-f0b5-4f9f-b95c-24f38ed5fdec_1638668481.2415957.jpeg)\\n   * Here , in this example we can see that::\\n   *   When we include(root) , then it calls on (nodes with value 1,3 and 1) .... And when node with the value 4 will be the root and we will be excluding it , then it will call on those same nodes with value(1 and 3).... So memoization would be perfect way to go for this problem.....\\n   *   **Now we know, what calls to make , what calculation to do and we also know that we need to memoize**.... So here is the code for that !!!\\n   \\n\\n### Solution 1 ... with MEMO \\n```\\nclass Solution {\\n\\nprivate:\\n    unordered_map<TreeNode*,int>memo;\\n    int helper(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        \\n        if (memo.count(root)){\\n            return memo[root];\\n        } \\n    \\n        int ans_including_root = root->val;\\n    \\n        if (root->left != NULL) {\\n              ans_including_root += helper(root->left->left) + helper(root->left->right);\\n        }\\n    \\n        if (root->right != NULL) {\\n              ans_including_root += helper(root->right->left) + helper(root->right->right);\\n        }\\n        \\n        int ans_excluding_root = helper(root->left) + helper(root->right);\\n    \\n        int ans = max(ans_including_root , ans_excluding_root);\\n        \\n        memo[root]=ans;\\n    \\n        return ans;\\n   }\\n    \\npublic:\\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }    \\n};\\n```\\n\\nIt\\'s a good solution to come up with ... But why to use memo when we can have a better solution without it ? \\n* Why was the memoization needed  ? Because we were going Top Down and we weren\\'t sure whether to include the root_house at that instance or not .... So , we were making recursion calls for both cases , which led to the complication of situation and we had to cover it up with the map !!\\n* So , instead of going that Top-down way , let\\'s try going the deepest and then while returning back, we will decide whether to choose that house or not !\\n* **We will return the Pair here, {case_when_curr_root_is_chosen, case_when_not_chosen}** ... \\n  * Let\\'s assume any particular node (H), gets the answer from it\\'s left child as {a,b} and right child as{x,y} ....\\n  * So , b is the case when H->left was not included and y is the case when H->right was not included... So, if we are gonna rob the House (H) , then total money we can get, p == **H->val +y+b**\\n  * And when House will be not robbed then maximum money robbed, q == **max(a,b) + max(x,y)**..... and what this node H will return is {p,q}\\n \\n \\n###  Solution 2 -- without memo\\n```\\nclass Solution {\\nprivate:\\n    pair<int,int> max_money_robbed(TreeNode* root){\\n        \\n        if(root==NULL)return {0,0};\\n        \\n        pair<int,int>left = max_money_robbed(root->left);\\n        pair<int,int>right = max_money_robbed(root->right);\\n        \\n        int root_house_robbed = left.second + right.second + root->val;\\n        int root_house_not_robbed = max(left.first,left.second)+ max(right.first,right.second);\\n        \\n        pair<int,int>ans;\\n        \\n        ans.first = root_house_robbed, ans.second = root_house_not_robbed;\\n        \\n        return ans;\\n        \\n    }\\npublic:\\n    int rob(TreeNode* root) {\\n        pair<int,int>result = max_money_robbed(root);\\n        return max(result.first,result.second);\\n    }\\n};\\n\\n**If you reached here, Thanks for giving it a read !!**\\n      \\n\\n\\n   \\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    unordered_map<TreeNode*,int>memo;\\n    int helper(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        \\n        if (memo.count(root)){\\n            return memo[root];\\n        } \\n    \\n        int ans_including_root = root->val;\\n    \\n        if (root->left != NULL) {\\n              ans_including_root += helper(root->left->left) + helper(root->left->right);\\n        }\\n    \\n        if (root->right != NULL) {\\n              ans_including_root += helper(root->right->left) + helper(root->right->right);\\n        }\\n        \\n        int ans_excluding_root = helper(root->left) + helper(root->right);\\n    \\n        int ans = max(ans_including_root , ans_excluding_root);\\n        \\n        memo[root]=ans;\\n    \\n        return ans;\\n   }\\n    \\npublic:\\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611881,
                "title": "java-3-approaches-recursion-dp-greedy-detailed-explanation",
                "content": "**Intution:** Since we have to start with root and we can\\'t rob two directly-linked houses. We have two cases:\\n* **Case1:** If we rob the root node - Then we can\\'t rob the child nodes of root but we can rob the 4 grandchildren of the root (i.e., root.left.left, root.left.right, root.right.left, root.right.right).\\n* **Case2:** If we don\\'t rob the root node - Then we can rob the 2 children of root (i.e., root.left, root.right).\\nAnd our answer will be maximum of the two cases.\\nFor Example:\\n ```\\n1.)     3                                            2.)           3\\n        / \\\\                                                        /  \\\\\\n       2   3                                                      4    5\\n        \\\\   \\\\                                                    / \\\\   /  \\n         3   1                                                  1   3 1\\n\\tHere rob the root node and its grandchildren       Here better will be to rob the child nodes of \\n\\ti.e., (3+3+1) = 7                                  root i.e., (4+5)=9.  \\n\\tHere Case1 will give 5(2+3) < 7                    Here Case2 will give 8(3+1+3+1) < 9\\n```\\nNow after all the discussion lets start with approach starting from recursion and will optimize as much possible.\\n\\n**Approach1: Recursive (TLE)**\\nT.C : O(2^n)\\nS.C : O(1) (ignoring stack memory used for recursion)\\n```\\nclass Solution{\\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// max value from left grandchildren\\n        if (root.left != null) {\\n            ans += rob(root.left.left) + rob(root.left.right);\\n        }\\n\\t\\t\\n\\t\\t// max value from right grandchildren\\n        if (root.right != null) {\\n            ans += rob(root.right.left) + rob(root.right.right);\\n        }\\n\\n        return Math.max(ans + root.val, rob(root.left) + rob(root.right));  //(Case1,Case2)\\n    }\\n}\\n```\\n\\n**Approach2: Rucrsion Using HashMap**\\nT.C : O(n)\\nS.C. : O(n)\\n**Explanation:** If you observe the recursive approach we have overlapping subproblems like for root node we are calling on its grandchildren (root.left.left, root.left.right, root.right.left, root.right.right) and when we are on child node of root (root.left, root.right) then again we will need the data of those four nodes so again calling on it. So here you have **Recusrion+Overlapping SubProblems** which can make you think of DP Approach.\\nSo what we are doing is just store the calculated answer for each node int the HashMap and if we need the value for that node again at any point we will just do the map.get(node) and get the value. Rest Recursive logic is absolutely same.\\n```\\nclass Solution{\\n    public int rob(TreeNode root) {\\n        return rob(root, new HashMap<>());\\n    }\\n\\n    public int rob(TreeNode root, Map<TreeNode, Integer> map) {\\n        \\n        if (root == null) return 0;\\n\\n        if (map.containsKey(root)) return map.get(root);\\n\\n        int ans = 0;\\n\\n        if (root.left != null) {\\n            ans += rob(root.left.left, map) + rob(root.left.right, map);\\n        }\\n\\n        if (root.right != null) {\\n            ans += rob(root.right.left, map) + rob(root.right.right, map);\\n        }\\n\\n        ans = Math.max(ans + root.val, rob(root.left, map) + rob(root.right, map));\\n        map.put(root, ans);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n**Approach3: Greedy Approach** \\nT.C. : O(n)\\nS.C. : O(1)\\n**Explanation:** Since we can now say that for each node we need only two data is required that is what will be the max value if that node is robbed and whats the max value if the node is not robbed.\\nSo why not just keep the array of two elements of which first element have the data if that node is not robbed and second element has the data if that node is robbed.\\nSo at last we have to return max of first and second element data stored for root. And this makes it a greedy approach.\\n\\n**More Explanation:** So in the below code how we are filling ans[0]  and ans[1]:\\n1.) Since ans[0] will have the value if root is not robbed, so we are concerned just about the root.left and root.right data which is in left and right array. Now we want max value so we need to check both Cases for both left and right that which Case will give max value \\n* left[0],right[0] -> indicates that while calculating, left and right node were not robbed and it has value from its child nodes \\n* left[1],right[1] -> indicates that left and right were robbed so they have data from their grandchildren also.\\nAnd we need max of the two cases for both left and right.\\n\\n2.) Now ans[1] will have the value if root is robbed then we can\\'t rob root\\'s children but we can can rob its grandchildren and left[0] and right[0] have data in which left and right were not robbed that is root\\'s children were not robbed. So our value will be root.val + left[0] + right[0].\\nAnd at last max of ans[0] and ans[1] will be answer.\\n```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        int ans[] = robHouse(root);\\n        return Math.max(ans[0],ans[1]);\\n    }\\n    \\n    public int[] robHouse(TreeNode root){\\n        if(root==null){\\n            return new int[2];\\n        }\\n        \\n        int left[] = robHouse(root.left);\\n        int right[] = robHouse(root.right);\\n        \\n        int ans[] = new int[2];\\n        \\n        ans[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);\\n        ans[1] = root.val+left[0]+right[0];\\n        \\n        return ans;\\n    }\\n}\\n```\\n \\n* I hope the explanation helped you...Thanks!!",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n1.)     3                                            2.)           3\\n        / \\\\                                                        /  \\\\\\n       2   3                                                      4    5\\n        \\\\   \\\\                                                    / \\\\   /  \\n         3   1                                                  1   3 1\\n\\tHere rob the root node and its grandchildren       Here better will be to rob the child nodes of \\n\\ti.e., (3+3+1) = 7                                  root i.e., (4+5)=9.  \\n\\tHere Case1 will give 5(2+3) < 7                    Here Case2 will give 8(3+1+3+1) < 9\\n```\n```\\nclass Solution{\\n    public int rob(TreeNode root) {\\n        if (root == null) return 0;\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// max value from left grandchildren\\n        if (root.left != null) {\\n            ans += rob(root.left.left) + rob(root.left.right);\\n        }\\n\\t\\t\\n\\t\\t// max value from right grandchildren\\n        if (root.right != null) {\\n            ans += rob(root.right.left) + rob(root.right.right);\\n        }\\n\\n        return Math.max(ans + root.val, rob(root.left) + rob(root.right));  //(Case1,Case2)\\n    }\\n}\\n```\n```\\nclass Solution{\\n    public int rob(TreeNode root) {\\n        return rob(root, new HashMap<>());\\n    }\\n\\n    public int rob(TreeNode root, Map<TreeNode, Integer> map) {\\n        \\n        if (root == null) return 0;\\n\\n        if (map.containsKey(root)) return map.get(root);\\n\\n        int ans = 0;\\n\\n        if (root.left != null) {\\n            ans += rob(root.left.left, map) + rob(root.left.right, map);\\n        }\\n\\n        if (root.right != null) {\\n            ans += rob(root.right.left, map) + rob(root.right.right, map);\\n        }\\n\\n        ans = Math.max(ans + root.val, rob(root.left, map) + rob(root.right, map));\\n        map.put(root, ans);\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        int ans[] = robHouse(root);\\n        return Math.max(ans[0],ans[1]);\\n    }\\n    \\n    public int[] robHouse(TreeNode root){\\n        if(root==null){\\n            return new int[2];\\n        }\\n        \\n        int left[] = robHouse(root.left);\\n        int right[] = robHouse(root.right);\\n        \\n        int ans[] = new int[2];\\n        \\n        ans[0] = Math.max(left[0],left[1])+Math.max(right[0],right[1]);\\n        ans[1] = root.val+left[0]+right[0];\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79437,
                "title": "c-java-python-explanation",
                "content": "Let \\n\\n`f1(node)` be the value of maximum money we can rob from the subtree with `node` as root ( we can rob `node` if necessary).\\n\\n`f2(node)` be the value of maximum money we can rob from the subtree with `node` as root but without robbing `node`. \\n\\nThen we have \\n\\n`f2(node) = f1(node.left) + f1(node.right)` and \\n\\n`f1(node) = max(  f2(node.left)+f2(node.right)+node.value,  f2(node) )`.\\n\\n# C++\\n\\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            return robDFS(root).second;\\n        }\\n        pair<int, int> robDFS(TreeNode* node){\\n            if( !node) return make_pair(0,0);\\n            auto l = robDFS(node->left);\\n            auto r = robDFS(node->right);\\n            int f2 = l.second + r.second;\\n            int f1 = max(f2, l.first + r.first + node->val);\\n            return make_pair(f2, f1);\\n        }\\n    };\\n\\n\\n# JAVA\\n\\n    public class Solution {\\n        public int rob(TreeNode root) {\\n            return robDFS(root)[1];\\n        }\\n        int[] robDFS(TreeNode node){\\n            int [] res = new int[2];\\n            if(node==null) return res;\\n            int [] l = robDFS(node.left);\\n            int [] r = robDFS(node.right);\\n            res[0] = l[1] + r[1];\\n            res[1] = Math.max(res[0], l[0] + r[0] + node.val);\\n            return res;\\n        }\\n    }\\n\\n# PYTHON\\n\\n    class Solution(object):\\n        def rob(self, root):\\n            return self.robDFS(root)[1];\\n        def robDFS(self,node):\\n            if node is None:\\n                return (0,0)\\n            l = self.robDFS(node.left)\\n            r = self.robDFS(node.right)\\n            return (l[1] + r[1], max(l[1] + r[1], l[0] + r[0] + node.val))",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            return robDFS(root).second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 485579,
                "title": "simple-c-dfs-solution",
                "content": "The general idea here is that at each node you have two choices. \\nYou can either decide to rob that node, or skip it.\\nFrom this central idea, we can derive the following logic.\\n\\nAt each node, we return the possibilities if we had decided to rob that node, or if we had decided to skip it (this is represented in the structure RobbedRoot).\\n\\nTo find out the maximum stolen money if the robber had decided to steal from the current node, we must skip the left and right nodes.\\n`int robThisNode = root->val + robLeft.skippedRoot + robRight.skippedRoot;`\\nThis is so that we do not trip the alarms of two adjacent house nodes.\\n\\nHowever, if we decide to skip the current node, we have two options for the left and right sides.\\nWe can now rob the left and/or right node, as our skipping of the current node means that we won\\'t trip the alarm.\\nBut we can also decide to skip the left and/or right node.\\n\\nThis is because greedily robbing the node just because you have the option to does not guarantee that you will make the maximum profit, as by robbing a node, you could block off an adjacent higher value node which could lead to a higher profit.\\n\\nFor example in:\\n\\n```cpp\\n/*\\n4\\n    \\\\\\n\\t  1\\n\\t\\t \\\\\\n\\t\\t   2\\n\\t\\t\\t  \\\\\\n\\t\\t\\t\\t3\\n*/\\n```\\n\\t\\t\\t\\t\\nDeciding to rob 2, after skipping 1, blocks off the more profitable 3.\\nSo, we also need to take into account the cases for skipping the left and right nodes as well.\\n\\nHence:\\n`int skipThisNode = max(robLeft.robbedRoot, robLeft.skippedRoot) + max(robRight.robbedRoot, robRight.skippedRoot);`\\n\\nHence, the final code:\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nstruct RobbedRoot {\\n    int robbedRoot;\\n    int skippedRoot;\\n};\\n\\nclass Solution {\\nprivate:\\n    RobbedRoot robDFS(TreeNode* root) {\\n        if (root == nullptr) {\\n            return RobbedRoot{0, 0};\\n        }\\n        \\n        RobbedRoot robLeft = robDFS(root->left);\\n        RobbedRoot robRight = robDFS(root->right);\\n        \\n        int robThisNode = root->val + robLeft.skippedRoot + robRight.skippedRoot;\\n        int skipThisNode = max(robLeft.robbedRoot, robLeft.skippedRoot) + max(robRight.robbedRoot, robRight.skippedRoot);\\n        \\n        return RobbedRoot{robThisNode, skipThisNode};\\n    }\\npublic:\\n    int rob(TreeNode* root) {\\n        RobbedRoot finalState = robDFS(root);\\n        \\n        return max(finalState.robbedRoot, finalState.skippedRoot);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n/*\\n4\\n    \\\\\\n\\t  1\\n\\t\\t \\\\\\n\\t\\t   2\\n\\t\\t\\t  \\\\\\n\\t\\t\\t\\t3\\n*/\\n```\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nstruct RobbedRoot {\\n    int robbedRoot;\\n    int skippedRoot;\\n};\\n\\nclass Solution {\\nprivate:\\n    RobbedRoot robDFS(TreeNode* root) {\\n        if (root == nullptr) {\\n            return RobbedRoot{0, 0};\\n        }\\n        \\n        RobbedRoot robLeft = robDFS(root->left);\\n        RobbedRoot robRight = robDFS(root->right);\\n        \\n        int robThisNode = root->val + robLeft.skippedRoot + robRight.skippedRoot;\\n        int skipThisNode = max(robLeft.robbedRoot, robLeft.skippedRoot) + max(robRight.robbedRoot, robRight.skippedRoot);\\n        \\n        return RobbedRoot{robThisNode, skipThisNode};\\n    }\\npublic:\\n    int rob(TreeNode* root) {\\n        RobbedRoot finalState = robDFS(root);\\n        \\n        return max(finalState.robbedRoot, finalState.skippedRoot);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946176,
                "title": "python-very-short-dfs-explained",
                "content": "If you already solved House Robber I or II, you probably aware, that this problem is about dp. However, let us look at it from a bit different point of view, it will be much easier to digest: let us use dfs and for each node we will keep two values:\\n1. Maximum gain we can get if we already visited all subtree given node, if we rob given node.\\n2. Maximum gain, we can get if we already visited all subtree given node, if we do not rob given node.\\n\\nHow we can find it, using recursion now?\\nImagine, that we have `node` and `L` and `R` are left and right children. Then:\\n1. If we rob given node, than we can not rob children, so answer will be `node.val + L[1] + R[1]`\\n2. If we do not rob house, we have two options for `L` and two options for `R`, and we choose the best ones, so we have `max(L) + max(R)`.\\n\\n**Complexity**: time complexity is `O(n)`, because we visit all our tree. Space complexity is `O(h)`, because we use recursion.\\n\\n```\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(node):\\n            if not node: return [0, 0]\\n            L = dfs(node.left)\\n            R = dfs(node.right)\\n            return [node.val + L[1] + R[1], max(L) + max(R)]\\n        \\n        return max(dfs(root))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(node):\\n            if not node: return [0, 0]\\n            L = dfs(node.left)\\n            R = dfs(node.right)\\n            return [node.val + L[1] + R[1], max(L) + max(R)]\\n        \\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79360,
                "title": "1ms-java-solution",
                "content": "    public int rob(TreeNode root) {\\n        int[] maxVal = dpRob(root);\\n        return Math.max(maxVal[0], maxVal[1]);\\n    }\\n    \\n    public int[] dpRob(TreeNode root) {\\n        if (root == null) {\\n            return new int[]{0, 0};\\n        } else {\\n            int[] maxVal = new int[2];//maxVal[0] store the max value without robing current node, maxVal[1] store the max value with robing current node,\\n            int[] leftMax = dpRob(root.left);\\n            int[] rightMax = dpRob(root.right);\\n            maxVal[0] = Math.max(leftMax[0], leftMax[1]) + Math.max(rightMax[0], rightMax[1]);\\n            maxVal[1] = leftMax[0] + rightMax[0] + root.val;\\n            return maxVal;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public int rob(TreeNode root) {\\n        int[] maxVal = dpRob(root);\\n        return Math.max(maxVal[0], maxVal[1]);\\n    }\\n    \\n    public int[] dpRob(TreeNode root) {\\n        if (root == null) {\\n            return new int[]{0, 0};\\n        } else {\\n            int[] maxVal = new int[2];//maxVal[0] store the max value without robing current node, maxVal[1] store the max value with robing current node,\\n            int[] leftMax = dpRob(root.left);\\n            int[] rightMax = dpRob(root.right);\\n            maxVal[0] = Math.max(leftMax[0], leftMax[1]) + Math.max(rightMax[0], rightMax[1]);\\n            maxVal[1] = leftMax[0] + rightMax[0] + root.val;\\n            return maxVal;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 487437,
                "title": "python-human-readable-code-6-lines",
                "content": "This return statement should help ypu understand - \\n`return (root.val + without_l + without_r, max(with_l, without_l) + max(with_r, without_r))`\\n\\n```\\n    def rob(self, root):\\n        def with_without_rob(root):\\n\\n            if root :\\n                with_l, without_l = with_without_rob(root.left)\\n                with_r, without_r = with_without_rob(root.right)        \\n                return (root.val + without_l + without_r, max(with_l, without_l) + max(with_r, without_r))\\n            return (0, 0)\\n            \\n        return max(with_without_rob(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def rob(self, root):\\n        def with_without_rob(root):\\n\\n            if root :\\n                with_l, without_l = with_without_rob(root.left)\\n                with_r, without_r = with_without_rob(root.right)        \\n                return (root.val + without_l + without_r, max(with_l, without_l) + max(with_r, without_r))\\n            return (0, 0)\\n            \\n        return max(with_without_rob(root))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612838,
                "title": "intuitive-detailed-explanation-c-o-n-recursion-memo",
                "content": "**Explanation**:\\n\\nWe know that we cant choose consecutive nodes in a tree thus this leaves us with 2 options when we reach a node-\\n1)**Include that node** and then include its **grandchildren** ( that are root->left->left, root->left->right and root->right->left,root->right->right) in this way we dont select any connected nodes.\\n2)**Dont**  include the node and return the sum of maximum values of its **children** that are the left and right subtrees i.e. call our function on root->left and root->right\\n\\nNow if we write a purely recursive function for this it **will result in a TLE** as we will call the function on a node many times ( granchildren of our current node will also be the future children of the left and right subtrees) thus we use memoization.\\nWe simply use an unordered map with key as TreeNode* and value as int to maintain the memo.\\n\\n``` \\nclass Solution {\\n    int max_num=INT_MIN;\\npublic:\\n    \\n    unordered_map<TreeNode*,int>umap;\\n    int helper(TreeNode*root){\\n        \\n        if(root==NULL)return 0;\\n        if(umap[root])return umap[root];\\n        int left_max=0;\\n        int right_max=0;\\n        if(root->left){\\n            left_max=helper(root->left->left)+helper(root->left->right);\\n        }\\n       if(root->right){\\n            right_max=helper(root->right->left)+helper(root->right->right);\\n       }\\n        \\n        return umap[root]=max(root->val+left_max+right_max,helper(root->left)+helper(root->right));\\n        \\n        \\n    }\\n\\n    \\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` \\nclass Solution {\\n    int max_num=INT_MIN;\\npublic:\\n    \\n    unordered_map<TreeNode*,int>umap;\\n    int helper(TreeNode*root){\\n        \\n        if(root==NULL)return 0;\\n        if(umap[root])return umap[root];\\n        int left_max=0;\\n        int right_max=0;\\n        if(root->left){\\n            left_max=helper(root->left->left)+helper(root->left->right);\\n        }\\n       if(root->right){\\n            right_max=helper(root->right->left)+helper(root->right->right);\\n       }\\n        \\n        return umap[root]=max(root->val+left_max+right_max,helper(root->left)+helper(root->right));\\n        \\n        \\n    }\\n\\n    \\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948790,
                "title": "smallest-integer-divisible-by-k",
                "content": "Given a positive integer `K`, we must find the *length* of the smallest positive integer `N` such that `N` is divisible by `K`, and `N` only contains the digit `1`. If there is no such `N`, return `-1`. Therefore the following constraints must be met.\\n\\n* `N % K == 0`\\n* length of `N` is minimized\\n* `N` only contains the digit `1`\\n\\nThe first important item to note is that `N` may not fit into a 64-bit signed integer. This means that we can not simply iterate though the possible values of `N` and mod `K`. \\n\\nTo find a way to reduce the problem, lets take the example of `K=3`. The value `3` has the following possible remainders when dividing.\\n\\n| 0 | 1 | 2 |\\n|:-:|:-:|:-:|\\n\\nNow, lets find the value of `N` by brute-force. In the table below, we can see that the condition `N % K == 0` is first met with the value of `111`. More interestingly, we can see that the pattern `1 -> 2 -> 0` repeats. \\n\\n|  N  | 1 | 11 | 111 | 1111 | 11111 | 111111\\n|:---:|:-:|:--:|:---:|:----:|:-----:|:-----:|\\n| N%K | 1 |  2 |  0  |   1  |   2   |   0   |\\n\\nNow, lets take a look at the example `K=6`. We can see that there are a finite number of possible remainders for any value mod `K` and that we only need to iterate thought the sequence of remainders *once* to find that `N` is not divisible by `K`.\\n\\n| 0 | 1 | 2 | 3 | 4 | 5 |\\n|:-:|:-:|:-:|:-:|:-:|:-:|\\n\\n|  N  | 1 | 11 | 111 | 1111 | 11111 | 111111 | 1111111 |\\n|:---:|:-:|:--:|:---:|:----:|:-----:|:------:|:-------:|\\n| N%K | 1 |  5 |  3  |   1  |   5   |    3   |    1    |\\n\\nThe final piece that we must solve is how to calculate the `N%K` sequence: how to find the next remainder. We can\\'t go though the values of `N` because it might not fit in a 64-bit integer. Let take a look at how we would calculate the next value of `N` and go from there. \\n\\n\\n`N next = (N * 10) + 1` : the next value of `N` `1 -> 11 -> 111 ...`\\n`remainder = N%K` : the remainder\\n\\n`(N next)%K  = ((N * 10) + 1)%K` : we can mod both sides of our next remainder equation \\n`(N next)%K  = ((N * 10)%K + 1%K)%K` : the equation can then be rearranged. \"It is useful to know that modulos can be taken anywhere in the calculation if it involves only addition and multiplication.\" *[- duke-cps102](http://db.cs.duke.edu/courses/cps102/spring10/Lectures/L-04.pdf)*\\n`(N next)%K  = ((N * 10)%K + 1)%K` : `1` mod anything is `1`\\n`(N next)%K  = ((N * 10)%K + 1)%K` : `1` mod anything is `1`\\n**`remainder next = (remainder*10 + 1) %K`** : knowing that `N%K` is our remainder, we have now have a general equation that can find our next remainder value without knowing the value of `N`.\\n\\n```\\ndef smallestRepunitDivByK(self, K: int) -> int:\\n    r = 0\\n    for c in range(1, K+1):\\n        r = (r*10 + 1)%K\\n        if r == 0: return c\\n    return -1\\n```\\n\\nThe runtime of this solution is **`O(K)`**. \\nThe space complexity is **`O(1)`**.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef smallestRepunitDivByK(self, K: int) -> int:\\n    r = 0\\n    for c in range(1, K+1):\\n        r = (r*10 + 1)%K\\n        if r == 0: return c\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 79471,
                "title": "my-12ms-c-solution",
                "content": " \\n\\n     int rob(TreeNode* node, int& lm, int& rm) {\\n        if (!node)  return 0;\\n        int lm1 = 0, lm2 = 0, rm1 = 0, rm2 = 0;\\n        \\n        lm = rob(node->left, lm1, rm1);\\n        rm = rob(node->right, lm2, rm2);\\n        \\n        return max(node->val + lm1 + rm1 + lm2 + rm2, lm + rm);\\n      }\\n\\n     int rob(TreeNode* root) {\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        res = rob(root, lm, rm);\\n        return res;\\n     }\\n\\n - **lm** is the max rob value of node->left\\n - **rm** is the max rob value of node->right\\n - **lm1** is the max rob value of node->left->left (Same as **lm2**)\\n - **rm1** is the max rob value of node->left->right (Same as **rm2**)\\n - So the max rob value of node is the max value between **(lm + rm)** and **(node->val + lm1 + lm2 + rm1 + rm2)**",
                "solutionTags": [
                    "C++"
                ],
                "code": " \\n\\n     int rob(TreeNode* node, int& lm, int& rm) {\\n        if (!node)  return 0;\\n        int lm1 = 0, lm2 = 0, rm1 = 0, rm2 = 0;\\n        \\n        lm = rob(node->left, lm1, rm1);\\n        rm = rob(node->right, lm2, rm2);\\n        \\n        return max(node->val + lm1 + rm1 + lm2 + rm2, lm + rm);\\n      }\\n\\n     int rob(TreeNode* root) {\\n        int res = 0;\\n        int lm = 0, rm = 0;\\n        res = rob(root, lm, rm);\\n        return res;\\n     }\\n\\n - **lm** is the max rob value of node->left\\n - **rm** is the max rob value of node->right\\n - **lm1** is the max rob value of node->left->left (Same as **lm2**)\\n - **rm1** is the max rob value of node->left->right (Same as **rm2**)\\n - So the max rob value of node is the max value between **(lm + rm)** and **(node->val + lm1 + lm2 + rm1 + rm2)**",
                "codeTag": "Unknown"
            },
            {
                "id": 155497,
                "title": "python-solution-beats-100-inspired-by-the-top-post",
                "content": "```\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(node):\\n            if not node: return 0, 0\\n            l, r = dfs(node.left), dfs(node.right)\\n            return max(l) + max(r), node.val + l[0] + r[0]\\n        return max(dfs(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, root):\\n        def dfs(node):\\n            if not node: return 0, 0\\n            l, r = dfs(node.left), dfs(node.right)\\n            return max(l) + max(r), node.val + l[0] + r[0]\\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711850,
                "title": "c-o-n-simple-recursion-choosing-vs-not-choosing",
                "content": "**Approach: DFS on Tree**\\n* On each node, Recursively store what value it would have if you choose vs not choosing it. Store both values :)\\n* If you choose current node, then you will have to add child node\\'s not_choose values.\\n* If you don\\'t choose current node, then you can add maximum of child node\\'s choose, not_choose values.\\n\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> findMaxMoney (TreeNode* root) {\\n        if (!root) return {0, 0};\\n        int choose, not_choose;\\n        pair<int,int> left = findMaxMoney(root->left);\\n        pair<int,int> right = findMaxMoney(root->right);\\n        choose = root->val + left.second+right.second;\\n        not_choose = max(left.first, left.second) + \\n            max(right.first, right.second);\\n        return {choose, not_choose};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> maxValue = findMaxMoney(root);\\n        return max(maxValue.first, maxValue.second); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> findMaxMoney (TreeNode* root) {\\n        if (!root) return {0, 0};\\n        int choose, not_choose;\\n        pair<int,int> left = findMaxMoney(root->left);\\n        pair<int,int> right = findMaxMoney(root->right);\\n        choose = root->val + left.second+right.second;\\n        not_choose = max(left.first, left.second) + \\n            max(right.first, right.second);\\n        return {choose, not_choose};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> maxValue = findMaxMoney(root);\\n        return max(maxValue.first, maxValue.second); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385320,
                "title": "javascript-with-explaination",
                "content": "As most of the tree problems, recurssion is the easiest way to start.\\nThen, we need to figure out what we want to get from each of the node.\\nWe want to know the max value we can get if we rob it or not, `[rob, not]`.\\nIf the node is a leaf, it\\'s `[0,0]`,\\nif it\\'s not a leaf:\\n1. if we rob it, then we can\\'t rob its leaves.\\n2. if we do not rob it, then we need to find the max from the combinations of the leaves. \\n\\n```\\nvar rob = function(root) {\\n    function helper(node){\\n        if(!node) return [0,0];\\n        const [lr,ln] = helper(node.left);\\n        const [rr, rn] = helper(node.right);\\n        return [node.val + ln + rn, Math.max(lr+rr, ln+rn, lr+rn, ln+rr)];\\n    }\\n    \\n    return Math.max(...helper(root));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar rob = function(root) {\\n    function helper(node){\\n        if(!node) return [0,0];\\n        const [lr,ln] = helper(node.left);\\n        const [rr, rn] = helper(node.right);\\n        return [node.val + ln + rn, Math.max(lr+rr, ln+rn, lr+rn, ln+rr)];\\n    }\\n    \\n    return Math.max(...helper(root));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79473,
                "title": "12ms-c-dfs-solution",
                "content": "    //max_include_root = root->val + max_donot_include_root_left + max_donnot_include_root_right\\n    //max_donot_include_root = max(max_include_root_left, max_donnot_include_root_left) + max(max_include_root_right, max_donnot_include_root_right)\\n    \\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            int max_include_root = 0;\\n            int max_donnot_include_root = 0;\\n            return dfs(root, max_include_root, max_donnot_include_root);\\n        }\\n        \\n        int dfs(TreeNode* root, int& max_include_root, int& max_donnot_include_root) {\\n            if (root == NULL) {\\n                max_include_root = 0;\\n                max_donnot_include_root = 0;\\n                return 0;\\n            }\\n            int max_donnot_include_root_left = 0;\\n            int max_donnot_include_root_right = 0;\\n\\n            int max_include_root_left = 0;\\n            int max_include_root_right = 0;\\n\\n            int max_left = dfs(root->left, max_include_root_left, max_donnot_include_root_left);\\n            int max_right = dfs(root->right, max_include_root_right, max_donnot_include_root_right);\\n\\n            max_include_root = root->val + max_donnot_include_root_left + max_donnot_include_root_right;\\n            max_donnot_include_root = max_left + max_right;\\n\\n            return max(max_include_root, max_donnot_include_root);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            int max_include_root = 0;\\n            int max_donnot_include_root = 0;\\n            return dfs(root, max_include_root, max_donnot_include_root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1990000,
                "title": "don-t-think-about-level-order-traversal",
                "content": "Don\\'t be fooled by the example testcases.\\n\\nlook at this--> [2,1,3,null,4]  ans =7;\\n```\\t\\t\\n\\t\\t2\\n\\t1      3\\n4\\t\\n\\nans = 4+3\\n\\n//LOL",
                "solutionTags": [],
                "code": "Don\\'t be fooled by the example testcases.\\n\\nlook at this--> [2,1,3,null,4]  ans =7;\\n```\\t\\t\\n\\t\\t2\\n\\t1      3\\n4\\t\\n\\nans = 4+3\\n\\n//LOL",
                "codeTag": "Unknown"
            },
            {
                "id": 1513281,
                "title": "c-recursive-memoization",
                "content": "**C++**\\nWhen I started out doing Programming I used to find this question the most difficult. But Today I did It Without any Difficuty. Practice + Consistency  + Hard Work Can Change Everything. Good Luck.\\n\\n**Recursive Solution** ---->> This Gives TLE;\\n```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        int self = root->val;\\n        if(root->left) self += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) self += (rob(root->right->left) + rob(root->right->right));\\n        int nself = (rob(root->left) + rob(root->right));\\n        return max(self ,nself);    \\n    }\\n};\\n````\\n**After Memoization** \\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> m;\\n    int rob(TreeNode* root) {\\n        if(m.count(root)) return m[root];\\n        if(!root) return 0;\\n        int self = root->val;\\n        if(root->left) self += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) self += (rob(root->right->left) + rob(root->right->right));\\n        int nself = (rob(root->left) + rob(root->right));\\n        m[root] = max(self ,nself);\\n        return m[root];\\n    }\\n};\\n```\\n**IF YOU FIND THIS HELPFUL DO UPVOTE!!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        int self = root->val;\\n        if(root->left) self += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) self += (rob(root->right->left) + rob(root->right->right));\\n        int nself = (rob(root->left) + rob(root->right));\\n        return max(self ,nself);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> m;\\n    int rob(TreeNode* root) {\\n        if(m.count(root)) return m[root];\\n        if(!root) return 0;\\n        int self = root->val;\\n        if(root->left) self += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) self += (rob(root->right->left) + rob(root->right->right));\\n        int nself = (rob(root->left) + rob(root->right));\\n        m[root] = max(self ,nself);\\n        return m[root];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946369,
                "title": "c-dfs-dp-recursive-memoised-solution-explained-85-time-40-space",
                "content": "Neat one that had me think for a moment and try a wrong approach first (see last bit of the code); then I opted to go for a simpler solution and I solved it in one line.\\n\\nAt each iteration, we will first of all check if we have `root` and:\\n* if not, we of course return `0`;\\n* if yes, then we compute the max between:\\n\\t* the current value (`root->val`) + the recursive calls to `rob` passing each of its grandchildren (if any, `0` otherwise);\\n\\t* the sum of the recursive calls to `rob` passing it its direct children `root->left` and `root->right` (again if any, `0` otherwise).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        return root ? max(root->val + (root->left ? rob(root->left->left) + rob(root->left->right) : 0) + (root->right ? rob(root->right->left) + rob(root->right->right) : 0), rob(root->left) + rob(root->right)) : 0;\\n    }\\n};\\n```\\n\\nSame code, expanded on more lines for better readability:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        return root ? max(\\n            // current value plus values of the grandchildren (if any, 0 otherwise)\\n            root->val\\n            + (root->left ? rob(root->left->left) + rob(root->left->right) : 0)\\n            + (root->right ? rob(root->right->left) + rob(root->right->right) : 0),\\n            // values of the direct children (if any, 0 otherwise)\\n            rob(root->left) + rob(root->right)\\n        ) : 0;\\n    }\\n};\\n```\\n\\nWhich times out, so memoisation time it is - same logic, but wrapped through a helper function that checks if we already had a result computed in the hashmap `memo` for that specific node - if so we return it, if not we compute and store it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> memo;\\n    int memoisedRob(TreeNode* root) {\\n        return memo.find(root) != end(memo) ? memo[root] : memo[root] = rob(root);\\n    }\\n    int rob(TreeNode* root) {\\n        return root ? max(root->val + (root->left ? memoisedRob(root->left->left) + memoisedRob(root->left->right) : 0) + (root->right ? memoisedRob(root->right->left) + memoisedRob(root->right->right) : 0), memoisedRob(root->left) + memoisedRob(root->right)) : 0;\\n    }\\n};\\n```\\n\\nAnd just for the chronicles, my first BFS-based attempt, making the wrong assumption that proceeding by layers and applying the formula from the other problems was what was needed to solve this problem - regrettably it works only with very short trees:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        // aufwiedersehen, edge case\\n        if (!root) return 0;\\n        // support variables\\n        vector<int> houseRows;\\n        int len = 1, dp[3];\\n        TreeNode *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        // BFSing our way into getting the cumulative values of each row\\n        while (len) {\\n            houseRows.push_back(0);\\n            while (len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // increasing the matching row in houseRows\\n                houseRows.back() += curr->val;\\n                // adding possible children to q\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);\\n            }\\n            len = q.size();\\n        }\\n        // recycling len - bad practice in production and interviews, but we are stingy here\\n        len = houseRows.size();\\n        dp[0] = houseRows[0];\\n        dp[1] = max(houseRows[0], houseRows[1]);\\n        dp[2] = max(houseRows[2] + dp[0], dp[1]);\\n        for (int n: dp) cout << n << \\' \\';\\n        for (int i = 3; i < len; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], max(dp[(i - 3) % 3], dp[(i - 2) % 3]) + houseRows[i]);\\n        }\\n        return dp[--len % 3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        return root ? max(root->val + (root->left ? rob(root->left->left) + rob(root->left->right) : 0) + (root->right ? rob(root->right->left) + rob(root->right->right) : 0), rob(root->left) + rob(root->right)) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        return root ? max(\\n            // current value plus values of the grandchildren (if any, 0 otherwise)\\n            root->val\\n            + (root->left ? rob(root->left->left) + rob(root->left->right) : 0)\\n            + (root->right ? rob(root->right->left) + rob(root->right->right) : 0),\\n            // values of the direct children (if any, 0 otherwise)\\n            rob(root->left) + rob(root->right)\\n        ) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> memo;\\n    int memoisedRob(TreeNode* root) {\\n        return memo.find(root) != end(memo) ? memo[root] : memo[root] = rob(root);\\n    }\\n    int rob(TreeNode* root) {\\n        return root ? max(root->val + (root->left ? memoisedRob(root->left->left) + memoisedRob(root->left->right) : 0) + (root->right ? memoisedRob(root->right->left) + memoisedRob(root->right->right) : 0), memoisedRob(root->left) + memoisedRob(root->right)) : 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        // aufwiedersehen, edge case\\n        if (!root) return 0;\\n        // support variables\\n        vector<int> houseRows;\\n        int len = 1, dp[3];\\n        TreeNode *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        // BFSing our way into getting the cumulative values of each row\\n        while (len) {\\n            houseRows.push_back(0);\\n            while (len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // increasing the matching row in houseRows\\n                houseRows.back() += curr->val;\\n                // adding possible children to q\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);\\n            }\\n            len = q.size();\\n        }\\n        // recycling len - bad practice in production and interviews, but we are stingy here\\n        len = houseRows.size();\\n        dp[0] = houseRows[0];\\n        dp[1] = max(houseRows[0], houseRows[1]);\\n        dp[2] = max(houseRows[2] + dp[0], dp[1]);\\n        for (int n: dp) cout << n << \\' \\';\\n        for (int i = 3; i < len; i++) {\\n            dp[i % 3] = max(dp[(i - 1) % 3], max(dp[(i - 3) % 3], dp[(i - 2) % 3]) + houseRows[i]);\\n        }\\n        return dp[--len % 3];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 79359,
                "title": "my-simple-java-recursive-solution",
                "content": "    public class Solution {\\n        public int rob(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null&&root.right==null) return root.val;\\n            \\n            int left=0, right=0;\\n            int subleft=0, subright=0;\\n        \\n        if(root.left!=null){\\n            left=rob(root.left);\\n            subleft=rob(root.left.left)+rob(root.left.right);\\n        }\\n        \\n        if(root.right!=null){\\n            right=rob(root.right);\\n            subright=rob(root.right.left)+rob(root.right.right);\\n        }\\n        \\n        int sum1=left+right;\\n        int sum2=subleft+subright+root.val;\\n        \\n        return (sum1>sum2)?sum1:sum2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rob(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null&&root.right==null) return root.val;\\n            \\n            int left=0, right=0;\\n            int subleft=0, subright=0;\\n        \\n        if(root.left!=null){\\n            left=rob(root.left);\\n            subleft=rob(root.left.left)+rob(root.left.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79458,
                "title": "6-line-simple-python-solution-using-dfs",
                "content": "  The dfs function returns an array, the first element means the maximum if we include the value of the current node, and the second element means the maximum if we exclude the value of the current node.\\n\\n  So in the return statement, as the first element, we include the value of the current node, and we should exclude the left and right children, so we add the second element from the result of left and right children. The second element has 4 conditions, we can include the left child and include the right child, include the left child and exclude the right child..., so we return the maximum of them.\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rob(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: int\\n            \"\"\"\\n            def dfs(node):\\n                if not node:\\n                    return [0, 0]\\n                left, right = dfs(node.left), dfs(node.right)\\n                return [node.val+left[1]+right[1], max([left[0]+right[0], left[0]+right[1], left[1]+right[0], left[1]+right[1]])]\\n            \\n            return max(dfs(root))",
                "solutionTags": [
                    "Python"
                ],
                "code": "  The dfs function returns an array, the first element means the maximum if we include the value of the current node, and the second element means the maximum if we exclude the value of the current node.\\n\\n  So in the return statement, as the first element, we include the value of the current node, and we should exclude the left and right children, so we add the second element from the result of left and right children. The second element has 4 conditions, we can include the left child and include the right child, include the left child and exclude the right child..., so we return the maximum of them.\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        def rob(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: int\\n            \"\"\"\\n            def dfs(node):\\n                if not node:\\n                    return [0, 0]\\n                left, right = dfs(node.left), dfs(node.right)\\n                return [node.val+left[1]+right[1], max([left[0]+right[0], left[0]+right[1], left[1]+right[0], left[1]+right[1]])]\\n            \\n            return max(dfs(root))",
                "codeTag": "Java"
            },
            {
                "id": 1612260,
                "title": "c-step-by-step-recusion-memoization-easy-to-undestand",
                "content": "There are two case possible :\\n1. * **You can pick the current root**\\n\\t\\t*if you pick the current root you cannot pick its immediate children.\\n\\t\\t* so you will find if we can pick grand children if exists i.e. \\n\\t\\t\\t* root->left->left, \\n\\t\\t\\t* root->left->right, \\n\\t\\t\\t* root->right->left,\\n\\t\\t\\t* root->right-.right\\n2. * **if you dont pick the current root**\\n\\t\\t* you can pick its children i.e \\n\\t\\t\\t* root->left,\\n\\t\\t\\t* root->right\\n3. **determine from which path you are getting maximum**\\n\\n***Recusive Approach : -***\\n```\\n    int rob(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int include = root->val;\\n        if(root->left) include += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) include += rob(root->right->left) + rob(root->right->right);\\n        \\n        int exclude = rob(root->left) + rob(root->right);\\n        \\n        return max(include, exclude);\\n        \\n        \\n    }\\n```\\n\\n***Memoization : -***\\n```\\nunordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        if(dp[root]) return dp[root];\\n        \\n        int include = root->val;\\n        if(root->left) include += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) include += rob(root->right->left) + rob(root->right->right);\\n        \\n        int exclude = rob(root->left) + rob(root->right);\\n        \\n        return dp[root] = max(include, exclude);\\n    \\n    }\\n```\\n\\n**Make sure to give it a upvote if you find it helpful\\n<Happy Coding/>**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    int rob(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int include = root->val;\\n        if(root->left) include += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) include += rob(root->right->left) + rob(root->right->right);\\n        \\n        int exclude = rob(root->left) + rob(root->right);\\n        \\n        return max(include, exclude);\\n        \\n        \\n    }\\n```\n```\\nunordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        if(dp[root]) return dp[root];\\n        \\n        int include = root->val;\\n        if(root->left) include += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) include += rob(root->right->left) + rob(root->right->right);\\n        \\n        int exclude = rob(root->left) + rob(root->right);\\n        \\n        return dp[root] = max(include, exclude);\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634003,
                "title": "c-depth-first-search-dp-with-explaination",
                "content": "We construct a dp tree.\\nEach node (dp_node) in this dp tree is an array of two elements:\\ndp_node = [your gain when you ROB the current node, your gain when you SKIP the current node]\\ndp_node[0] =[your gain when you ROB the current node]\\ndp_node[1] =[your gain when you SKIP the current node]\\n\\nwe start by scanning from the leaf: Depth First Search\\n**For each node you have 2 options:\\noption 1: ROB the node, then you can\\'t rob the child/children of the node.\\ndp_node[0] = node.val + dp_node.left[1] + dp_node.right[1]\\noption 2: SKIP the node, then you can ROB or SKIP the child/children of the node.\\ndp_node[1] = max(dp_node.left[0], dp_node.left[1]) + max(dp_node.right[0], dp_node.right[1])**\\n\\nthe maximum of gain of the node\\n\\n```\\n    Input: [3,4,5,1,3,null,1]\\n input tree            dp tree:\\n     3                  [3+3+1,4+5]\\n    / \\\\                /        \\\\\\n   4   5            [4,3]      [5,1]\\n  / \\\\   \\\\          /     \\\\          \\\\\\n 1   2   1      [1,0]    [2,0]     [1,0]\\n                / \\\\       /  \\\\        /  \\\\\\n           [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n   \\n``` \\n\\n```\\npair<int,int> helper( TreeNode *node ) {\\n\\tif( !node ) return {0, 0};\\n\\n\\tauto l = helper( node->left );\\n\\tauto r = helper( node->right );\\n\\tint withNode = node->val + l.second + r.second;\\n\\tint withoutNode = max( r.first, r.second ) + max( l.first, l.second ); \\n\\treturn { withNode, withoutNode };\\n}\\n\\nint rob( TreeNode* root ) {\\n\\tauto res = helper( root );\\n\\treturn max( res.first, res.second );\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    Input: [3,4,5,1,3,null,1]\\n input tree            dp tree:\\n     3                  [3+3+1,4+5]\\n    / \\\\                /        \\\\\\n   4   5            [4,3]      [5,1]\\n  / \\\\   \\\\          /     \\\\          \\\\\\n 1   2   1      [1,0]    [2,0]     [1,0]\\n                / \\\\       /  \\\\        /  \\\\\\n           [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n   \\n```\n```\\npair<int,int> helper( TreeNode *node ) {\\n\\tif( !node ) return {0, 0};\\n\\n\\tauto l = helper( node->left );\\n\\tauto r = helper( node->right );\\n\\tint withNode = node->val + l.second + r.second;\\n\\tint withoutNode = max( r.first, r.second ) + max( l.first, l.second ); \\n\\treturn { withNode, withoutNode };\\n}\\n\\nint rob( TreeNode* root ) {\\n\\tauto res = helper( root );\\n\\treturn max( res.first, res.second );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398945,
                "title": "c-brute-force-optimized-dp-solutions-explained",
                "content": "**Approach:**\\n\\n* if we rob the ith level then we can\\'t rob the i+1 th level and hence we move to the (i+2)th level\\n\\t* ```ans = root->val + rob(root->left->left) + rob(root->left->right) + rob(root->right->left) + rob(root->right->right)```\\n* if we don\\'t rob the ith level then we move to the (i+1)th level\\n\\t* ```ans = rob(root->left) + rob(root->right)```\\n* final ans will be the maximum of above two cases\\n\\n\\n**Brute force:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        int val = 0;\\n        if (root->left != NULL)\\n            val += rob(root->left->left) + rob(root->left->right);\\n        if (root->right != NULL)\\n            val += rob(root->right->left) + rob(root->right->right);\\n        int notrob = rob(root->left) + rob(root->right);\\n        int rob = val + root->val;\\n        return max(notrob, rob);\\n    }\\n};\\n```\\n\\n* we can observe that there are some repetitive calls in the above code and that\\'s why it gives TLE\\n* so we can just store the optimal answer we get for each node in a map\\n* return the value if it has been already computed\\n* otherwise follow the same approach\\n* in the below code,\\n\\t* x = notrob case\\n\\t* y = rob the root case\\n\\n\\n\\n**DP**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<TreeNode *, int> mp;\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        if (mp.find(root) != mp.end())\\n            return mp[root];\\n        mp[root] = -1;\\n        int x = rob(root->left) + rob(root->right);\\n        int y = root->val;\\n        if (root->left != NULL)\\n            y += rob(root->left->left) + rob(root->left->right);\\n        if (root->right != NULL)\\n            y += rob(root->right->left) + rob(root->right->right);\\n        mp[root] = max(x, y);\\n        return mp[root];\\n    }\\n};\\n```\\n\\n* we can see that we only have two options at each node either rob the node or not\\n* if we rob the root\\n\\t* then we don\\'t want to rob the left and right child\\n\\t* ```ans = root->val + leftnotrob+ rightnotrob```\\n* if we don\\'t rob the root\\n\\t* we will check what\\'s the best case for the left and right child, whether to rob them or not\\n\\t* ```ans = max(leftnotrob, leftrob) + max(rightnotrob, rightrob```\\n* store these values in a pair to handle repetitive calls\\n* ```pair = {notrob,rob}```\\n\\n\\n**DP-space optimized:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<TreeNode *, int> mp;\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n    pair<int, int> dfs(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return {0, 0};\\n        auto [leftnotrob, leftrob] = dfs(root->left);\\n        auto [rightnotrob, rightrob] = dfs(root->right);\\n        int notrob = max(leftnotrob, leftrob) + max(rightnotrob, rightrob);\\n        int rob = root->val + leftnotrob + rightnotrob;\\n        return {notrob, rob};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```ans = root->val + rob(root->left->left) + rob(root->left->right) + rob(root->right->left) + rob(root->right->right)```\n```ans = rob(root->left) + rob(root->right)```\n```\\nclass Solution\\n{\\npublic:\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        int val = 0;\\n        if (root->left != NULL)\\n            val += rob(root->left->left) + rob(root->left->right);\\n        if (root->right != NULL)\\n            val += rob(root->right->left) + rob(root->right->right);\\n        int notrob = rob(root->left) + rob(root->right);\\n        int rob = val + root->val;\\n        return max(notrob, rob);\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<TreeNode *, int> mp;\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        if (mp.find(root) != mp.end())\\n            return mp[root];\\n        mp[root] = -1;\\n        int x = rob(root->left) + rob(root->right);\\n        int y = root->val;\\n        if (root->left != NULL)\\n            y += rob(root->left->left) + rob(root->left->right);\\n        if (root->right != NULL)\\n            y += rob(root->right->left) + rob(root->right->right);\\n        mp[root] = max(x, y);\\n        return mp[root];\\n    }\\n};\\n```\n```ans = root->val + leftnotrob+ rightnotrob```\n```ans = max(leftnotrob, leftrob) + max(rightnotrob, rightrob```\n```pair = {notrob,rob}```\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<TreeNode *, int> mp;\\n    int rob(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return 0;\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n    pair<int, int> dfs(TreeNode *root)\\n    {\\n        if (root == NULL)\\n            return {0, 0};\\n        auto [leftnotrob, leftrob] = dfs(root->left);\\n        auto [rightnotrob, rightrob] = dfs(root->right);\\n        int notrob = max(leftnotrob, leftrob) + max(rightnotrob, rightrob);\\n        int rob = root->val + leftnotrob + rightnotrob;\\n        return {notrob, rob};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510119,
                "title": "java-from-recursive-tle-to-dp-memoization-ac-in-4-lines",
                "content": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if (root == null)\\n            return 0;   \\n        \\n        int robCurrent = root.val;\\n        if (root.left != null)\\n            robCurrent += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null)\\n            robCurrent += rob(root.right.left) + rob(root.right.right);\\n        \\n        int doNotRobCurrent = 0;\\n        doNotRobCurrent += rob(root.left) + rob(root.right);\\n        \\n        int res = Math.max(robCurrent, doNotRobCurrent);\\n        return res; \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    private HashMap<TreeNode, Integer> dp = new HashMap<>();  // Line 1\\n    \\n    public int rob(TreeNode root) {\\n        if (root == null)\\n            return 0;   \\n        \\n        if (dp.containsKey(root))    // Line 2\\n            return dp.get(root);    // Line 3\\n                \\n        int robCurrent = root.val;\\n        if (root.left != null)\\n            robCurrent += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null)\\n            robCurrent += rob(root.right.left) + rob(root.right.right);\\n        \\n        int doNotRobCurrent = 0;\\n        doNotRobCurrent += rob(root.left) + rob(root.right);\\n        \\n        int res = Math.max(robCurrent, doNotRobCurrent);\\n        dp.put(root, res);   // Line 4\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if (root == null)\\n            return 0;   \\n        \\n        int robCurrent = root.val;\\n        if (root.left != null)\\n            robCurrent += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null)\\n            robCurrent += rob(root.right.left) + rob(root.right.right);\\n        \\n        int doNotRobCurrent = 0;\\n        doNotRobCurrent += rob(root.left) + rob(root.right);\\n        \\n        int res = Math.max(robCurrent, doNotRobCurrent);\\n        return res; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    private HashMap<TreeNode, Integer> dp = new HashMap<>();  // Line 1\\n    \\n    public int rob(TreeNode root) {\\n        if (root == null)\\n            return 0;   \\n        \\n        if (dp.containsKey(root))    // Line 2\\n            return dp.get(root);    // Line 3\\n                \\n        int robCurrent = root.val;\\n        if (root.left != null)\\n            robCurrent += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null)\\n            robCurrent += rob(root.right.left) + rob(root.right.right);\\n        \\n        int doNotRobCurrent = 0;\\n        doNotRobCurrent += rob(root.left) + rob(root.right);\\n        \\n        int res = Math.max(robCurrent, doNotRobCurrent);\\n        dp.put(root, res);   // Line 4\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811063,
                "title": "5-line-c-solution-using-memoization",
                "content": "```\\nunordered_map<TreeNode *,int> map;\\n    int rob(TreeNode* root) \\n    {\\n        if(!root)\\n            return 0;\\n        if(map.count(root))\\n            return map[root];\\n        int total=0;\\n        if(root->left)\\n            total+= rob(root->left->left)+rob(root->left->right);\\n        if(root->right)\\n            total+=rob(root->right->left)+rob(root->right->right);\\n        \\n        return map[root]=max(root->val+total,rob(root->left)+rob(root->right));\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nunordered_map<TreeNode *,int> map;\\n    int rob(TreeNode* root) \\n    {\\n        if(!root)\\n            return 0;\\n        if(map.count(root))\\n            return map[root];\\n        int total=0;\\n        if(root->left)\\n            total+= rob(root->left->left)+rob(root->left->right);\\n        if(root->right)\\n            total+=rob(root->right->left)+rob(root->right->right);\\n        \\n        return map[root]=max(root->val+total,rob(root->left)+rob(root->right));\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2544512,
                "title": "c-easy-dp-recursion-memoization",
                "content": "```\\n// T.C. -> O(N)\\n// S.C. -> O(N) [Recursion auxillary stack space] + O(N) [Unordered Map]\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> mp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL)return 0;\\n        if(mp.count(root)) return mp[root];\\n        int sum1 = root->val;\\n        \\n        if(root->left != NULL){\\n          sum1 +=  rob(root->left->left);\\n          sum1 += rob(root->left->right);\\n        }\\n        \\n        if(root->right != NULL){\\n            sum1 += rob(root->right->left);\\n            sum1 += rob(root->right->right);\\n        }\\n        int sum2 = rob(root->left) + rob(root->right);\\n        return mp[root] = max(sum1,sum2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// T.C. -> O(N)\\n// S.C. -> O(N) [Recursion auxillary stack space] + O(N) [Unordered Map]\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> mp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL)return 0;\\n        if(mp.count(root)) return mp[root];\\n        int sum1 = root->val;\\n        \\n        if(root->left != NULL){\\n          sum1 +=  rob(root->left->left);\\n          sum1 += rob(root->left->right);\\n        }\\n        \\n        if(root->right != NULL){\\n            sum1 += rob(root->right->left);\\n            sum1 += rob(root->right->right);\\n        }\\n        int sum2 = rob(root->left) + rob(root->right);\\n        return mp[root] = max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612319,
                "title": "dp-on-binary-trees-learn-how-to-tackle-such-problems-95-faster",
                "content": "**Approach:-**\\n* The Thief *cannot choose the two adjacent nodes* right?\\n* Also, If we know the maximum amount the thief can stole for the child and grand child nodes of current node, we can answer the maximum amount for current node also...Guess Why? [Think for above condition].\\n* Since, *If we choose current node into our answer*, we cannot take the child nodes of the current node right? Hence, **we\\'d be looking for maximum answer we can get with grand child nodes**.\\n* When *we don\\'t choose current node into our answer*, **we would look for maximum answer for left as well as right child nodes**.\\n* **dp[node v] = max(root->val + dp[left grand child of v] + dp[right grand child of v] , dp[left child of v] + dp[right child of v] )** is the dp relation.\\n* Wait, How we would maintain an array in binary tree?, If you\\'d notice we want only values for child nodes and grand child nodes right?\\n* So, we would maintain a **pair<int,int>** for every node **{max ans child nodes, max ans for grand child nodes}** and recursively calculate answer for every node.\\n\\n```\\nclass Solution {\\npublic:\\n    // TIME COMPLEXITY:- O(N)\\n    // SPACE COMPLEXITY:- O(1) [neglecting the extra space due to recursion stack]\\n    pair<int,int> findMax(TreeNode* root){\\n        if(!root)\\n            return {0,0};\\n        pair<int,int> l = findMax(root->left); // {max ans for left child, max ans for left grand child}\\n        pair<int,int> r = findMax(root->right); // {max ans for right child, max ans for right grand child}\\n        return {max(root->val+l.second+r.second,l.first+r.first),l.first+r.first}; // either choose the current node or go with the grand child nodes\\n    }\\n    int rob(TreeNode* root) {\\n        return findMax(root).first; // answer will be the max ans for current node\\n    }\\n};\\n```\\n\\n**Don\\'t forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // TIME COMPLEXITY:- O(N)\\n    // SPACE COMPLEXITY:- O(1) [neglecting the extra space due to recursion stack]\\n    pair<int,int> findMax(TreeNode* root){\\n        if(!root)\\n            return {0,0};\\n        pair<int,int> l = findMax(root->left); // {max ans for left child, max ans for left grand child}\\n        pair<int,int> r = findMax(root->right); // {max ans for right child, max ans for right grand child}\\n        return {max(root->val+l.second+r.second,l.first+r.first),l.first+r.first}; // either choose the current node or go with the grand child nodes\\n    }\\n    int rob(TreeNode* root) {\\n        return findMax(root).first; // answer will be the max ans for current node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323279,
                "title": "best-python-solution-clean-explained",
                "content": "# Explaination\\nI learn the answer from @realisking, I couldn\\'t come up with such elegant solution myself.\\n\\nOn every node we got two option, to rob or not to rob\\n* To rob this node, then we cannot rob our left and right child, so the max value would be the total of\\n    * value of this node\\n    * the max value from left child, when we not rob the left child\\n    * the max value from right child, when we not rob the right child\\n* Not to rob this node, means that we can either rob or not rob our left and right child, so the max value would be the total of\\n    * 0, because we choose not to rob this node\\n    * the max of `rob the left child` and `not rob the left child`\\n    * the max of `rob the right child` and `not rob the right child`\\n\\n`get_max_value(node)` returns the `max value when we rob this node` and `max value when we not rob this node` on each node.\\nSo we get the max from the two returns from `get_max_value(root)`\\n\\nThe time complexity is `O(LogN)`, because we keep calling `get_max_value()` until the very bottom of the tree.\\nThe space complexity is `O(LogN)`, too. Even we only use `O(1)` of space on every `get_max_value()`\\nBut we used `LogN` level of recursion. `N` is the number of houses.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rob(self, root):\\n        def get_max_value(node):\\n            if node is None: return 0, 0\\n            left_rob, left_not_rob = get_max_value(node.left)\\n            right_rob, right_not_rob = get_max_value(node.right)\\n\\n            rob = node.val+left_not_rob+right_not_rob\\n            not_rob = max(left_rob, left_not_rob)+max(right_rob, right_not_rob)\\n\\n            return rob, not_rob\\n\\n        return max(get_max_value(root))\\n```\\n\\n# More Resource\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rob(self, root):\\n        def get_max_value(node):\\n            if node is None: return 0, 0\\n            left_rob, left_not_rob = get_max_value(node.left)\\n            right_rob, right_not_rob = get_max_value(node.right)\\n\\n            rob = node.val+left_not_rob+right_not_rob\\n            not_rob = max(left_rob, left_not_rob)+max(right_rob, right_not_rob)\\n\\n            return rob, not_rob\\n\\n        return max(get_max_value(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79341,
                "title": "easy-4-lines-c-dfs",
                "content": "4 lines brute force, 1656ms.\\n```\\n    int rob(TreeNode* root) {\\n        return DFS(root, true);\\n    }\\n    \\n    int DFS(TreeNode* root, bool canRob){\\n        if(!root) return 0;\\n        int noRob = DFS(root->left, true) + DFS(root->right, true);\\n        return canRob ? max(root->val + DFS(root->left, false) + DFS(root->right, false), noRob) : noRob;\\n    }\\n```\\nHere is a greedy one, 22ms.\\n**idea:**\\nEach node only has 2 status, be robbed or not.\\nStore amount of money under 2 status into a vector<int>v(2).\\nv[0]: it's not robbed.\\nv[1]: it's robbed.\\n```\\n    int rob(TreeNode* root) {\\n        auto res = DFS(root);\\n        return max(res[0], res[1]);\\n    }\\n    \\n    vector<int> DFS(TreeNode* root){\\n        if(!root) return {0,0};\\n        auto left = DFS(root->left);\\n        auto right = DFS(root->right);\\n        vector<int>res(2);\\n        res[0] = max(left[0], left[1]) + max(right[0], right[1]);\\n        res[1] = root->val + left[0] + right[0];\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n    int rob(TreeNode* root) {\\n        return DFS(root, true);\\n    }\\n    \\n    int DFS(TreeNode* root, bool canRob){\\n        if(!root) return 0;\\n        int noRob = DFS(root->left, true) + DFS(root->right, true);\\n        return canRob ? max(root->val + DFS(root->left, false) + DFS(root->right, false), noRob) : noRob;\\n    }\\n```\n```\\n    int rob(TreeNode* root) {\\n        auto res = DFS(root);\\n        return max(res[0], res[1]);\\n    }\\n    \\n    vector<int> DFS(TreeNode* root){\\n        if(!root) return {0,0};\\n        auto left = DFS(root->left);\\n        auto right = DFS(root->right);\\n        vector<int>res(2);\\n        res[0] = max(left[0], left[1]) + max(right[0], right[1]);\\n        res[1] = root->val + left[0] + right[0];\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79507,
                "title": "complex-numbers",
                "content": "**Solution:**\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0\\n            z = root.val * 1j + rob(root.left) + rob(root.right)\\n            return max(z.real, z.imag) + z.real * 1j\\n        return int(rob(root).real)\\n\\nThe helper function returns a complex number. The real part tells, well, the real answer (maximum amount with or without robbing the (sub)tree's root). The imaginary part tells the maximum amount without robbing the root. (But in the temporary variable `z`, the real part is the amount without the root and the imaginary part is the amount with the root.)\\n\\n---\\n\\n**Shorter version:**\\n\\n    def rob(self, root):\\n        def rob(root):\\n            z = root.val * 1j + rob(root.left) + rob(root.right) if root else 0\\n            return max(z.real, z.imag) + z.real * 1j\\n        return int(rob(root).real)\\n\\n---\\n\\n**Tuple version:**\\n\\nHere the helper returns a tuple, first element being the real answer and second element being the without-root answer. Variables \"y/n\" mean yes/no, telling whether the subtree's root might be robbed.\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0, 0\\n            y, n = rob(root.left)\\n            Y, N = rob(root.right)\\n            return max(root.val + n + N, y + Y), y + Y\\n        return rob(root)[0]\\n\\nA variation:\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0, 0\\n            y, n = map(sum, zip(rob(root.left), rob(root.right)))\\n            return max(root.val + n, y), y\\n        return rob(root)[0]\\n\\nAnother:\\n\\n    def rob(self, root):\\n        def rob(root):\\n            y, n = map(sum, zip(rob(root.left), rob(root.right), (0, root.val))) if root else (0, 0)\\n            return max(y, n), y\\n        return rob(root)[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution:**\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0\\n            z = root.val * 1j + rob(root.left) + rob(root.right)\\n            return max(z.real, z.imag) + z.real * 1j\\n        return int(rob(root).real)\\n\\nThe helper function returns a complex number. The real part tells, well, the real answer (maximum amount with or without robbing the (sub)tree's root). The imaginary part tells the maximum amount without robbing the root. (But in the temporary variable `z`, the real part is the amount without the root and the imaginary part is the amount with the root.)\\n\\n---\\n\\n**Shorter version:**\\n\\n    def rob(self, root):\\n        def rob(root):\\n            z = root.val * 1j + rob(root.left) + rob(root.right) if root else 0\\n            return max(z.real, z.imag) + z.real * 1j\\n        return int(rob(root).real)\\n\\n---\\n\\n**Tuple version:**\\n\\nHere the helper returns a tuple, first element being the real answer and second element being the without-root answer. Variables \"y/n\" mean yes/no, telling whether the subtree's root might be robbed.\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0, 0\\n            y, n = rob(root.left)\\n            Y, N = rob(root.right)\\n            return max(root.val + n + N, y + Y), y + Y\\n        return rob(root)[0]\\n\\nA variation:\\n\\n    def rob(self, root):\\n        def rob(root):\\n            if not root:\\n                return 0, 0\\n            y, n = map(sum, zip(rob(root.left), rob(root.right)))\\n            return max(root.val + n, y), y\\n        return rob(root)[0]\\n\\nAnother:\\n\\n    def rob(self, root):\\n        def rob(root):\\n            y, n = map(sum, zip(rob(root.left), rob(root.right), (0, root.val))) if root else (0, 0)\\n            return max(y, n), y\\n        return rob(root)[0]",
                "codeTag": "Python3"
            },
            {
                "id": 3302413,
                "title": "recursive-logic-python3-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root):\\n            if not root: return [0,0]\\n            leftpair,rightpair=dfs(root.left),dfs(root.right)\\n            withroot,without=root.val+leftpair[1]+rightpair[1],max(leftpair)+max(rightpair)\\n            return [withroot,without]\\n        return max(dfs(root))\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def dfs(root):\\n            if not root: return [0,0]\\n            leftpair,rightpair=dfs(root.left),dfs(root.right)\\n            withroot,without=root.val+leftpair[1]+rightpair[1],max(leftpair)+max(rightpair)\\n            return [withroot,without]\\n        return max(dfs(root))\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690772,
                "title": "very-simple-and-intuitive-c-dp-solution",
                "content": "We basically have two cases:\\n**1. Take the root\\n2. Don\\'t take the root**\\n\\nFor **CASE I**, we take the root and all the left and right children of root->left and root->right i.e.,\\nresult = root+(root->left->left)+(root->left->right)+(root->right->left)+(root->right->right)\\n**Note**: We can\\'t take (root->left) and (root->right) if we take the root node\\n\\nFor **CASE II**, we can break it into two sub cases:\\ni) Take root->left\\nii) Take root->right\\n\\nFor CASE i) we take (root->left) + max ((root->right), (root->right->left)+(root->right->right))\\nFor CASE ii) we take (root->right) + max ((root->left), (root->left->left)+(root->left->right))\\n\\nAt the end, we take max of all these results and return it\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int>mp;\\n    int solve(TreeNode* root){\\n        //base case\\n        if(!root)return 0;\\n        if(mp.count(root))return mp[root];\\n        int l=solve(root->left);\\n        int r=solve(root->right);\\n        int ll=0,lr=0,rl=0,rr=0;\\n        if(root->left){\\n            ll=solve(root->left->left);\\n            lr=solve(root->left->right);\\n        }\\n        if(root->right){\\n            rl=solve(root->right->left);\\n            rr=solve(root->right->right);\\n        }\\n        int val=root->val;\\n        int lmx=ll+lr;\\n        int rmx=rl+rr;\\n        //if we take the root node\\n        int t1=val+lmx+rmx;\\n        //if we take the left child of root\\n        int t2=l+max(r,rmx);\\n        //if we take the right child of root\\n        int t3=r+max(l,lmx);\\n        //take maximum of all the cases and memoize\\n        mp[root]=max(t1,max(t2,t3));\\n        return mp[root];\\n    }\\n    int rob(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int>mp;\\n    int solve(TreeNode* root){\\n        //base case\\n        if(!root)return 0;\\n        if(mp.count(root))return mp[root];\\n        int l=solve(root->left);\\n        int r=solve(root->right);\\n        int ll=0,lr=0,rl=0,rr=0;\\n        if(root->left){\\n            ll=solve(root->left->left);\\n            lr=solve(root->left->right);\\n        }\\n        if(root->right){\\n            rl=solve(root->right->left);\\n            rr=solve(root->right->right);\\n        }\\n        int val=root->val;\\n        int lmx=ll+lr;\\n        int rmx=rl+rr;\\n        //if we take the root node\\n        int t1=val+lmx+rmx;\\n        //if we take the left child of root\\n        int t2=l+max(r,rmx);\\n        //if we take the right child of root\\n        int t3=r+max(l,lmx);\\n        //take maximum of all the cases and memoize\\n        mp[root]=max(t1,max(t2,t3));\\n        return mp[root];\\n    }\\n    int rob(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835597,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(TreeNode* root){\\n        if(!root) return {0, 0, 0};\\n        \\n        vector<int> temp = {0, 0, 0};\\n        \\n        vector<int> l = helper(root->left);\\n        vector<int> r = helper(root->right);\\n        \\n        temp[1] = max(l[1]+r[1], root->val+l[0]+l[2]+r[0]+r[2]);\\n        temp[0] = l[1];\\n        temp[2] = r[1];\\n        \\n        return temp;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        vector<int> temp = helper(root);\\n        return temp[1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> helper(TreeNode* root){\\n        if(!root) return {0, 0, 0};\\n        \\n        vector<int> temp = {0, 0, 0};\\n        \\n        vector<int> l = helper(root->left);\\n        vector<int> r = helper(root->right);\\n        \\n        temp[1] = max(l[1]+r[1], root->val+l[0]+l[2]+r[0]+r[2]);\\n        temp[0] = l[1];\\n        temp[2] = r[1];\\n        \\n        return temp;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        vector<int> temp = helper(root);\\n        return temp[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830267,
                "title": "recursive-approach-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(flg,root,memo):\\n    if(root==None):\\n        return 0\\n    if((root,flg) in memo):\\n        return memo[(root,flg)]\\n    if(flg==1):\\n        a=fun(0,root.left,memo)+fun(0,root.right,memo)\\n        memo[(root,flg)]=a\\n        return a\\n    a=fun(0,root.left,memo)+fun(0,root.right,memo)\\n    b=fun(1,root.left,memo)+fun(1,root.right,memo)+root.val\\n    x=max(a,b)\\n    memo[(root,flg)]=x\\n    return x\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        memo={}\\n        return(fun(0,root,memo))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(flg,root,memo):\\n    if(root==None):\\n        return 0\\n    if((root,flg) in memo):\\n        return memo[(root,flg)]\\n    if(flg==1):\\n        a=fun(0,root.left,memo)+fun(0,root.right,memo)\\n        memo[(root,flg)]=a\\n        return a\\n    a=fun(0,root.left,memo)+fun(0,root.right,memo)\\n    b=fun(1,root.left,memo)+fun(1,root.right,memo)+root.val\\n    x=max(a,b)\\n    memo[(root,flg)]=x\\n    return x\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        memo={}\\n        return(fun(0,root,memo))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116157,
                "title": "some-intuition-with-pictures-may-be-this-could-help",
                "content": "Some intution\\n\\n![image](https://assets.leetcode.com/users/images/f5010d75-8b50-4134-a817-5202a2509e29_1616104945.9881916.png)\\n\\n**Question That we have**\\n* What if we select this node? What Options Do we have? \\n* If we dont select this node then what could be the answer at this Point\\n* If we select this node then how do we get the answers for child nodes ? \\n\\n\\nLets find answers to these two questions. Lets us ask Child nodes the best possible solutions if we want to include the Immediate child\\'s value.\\nOr if we skip then what is the best possible answers that we can get. Let\\'s ask them.\\n\\n* Now Assume Child Node responds with his best answers for \\n{ if  we his (child\\'s) value  , If we dont Include ie we skip }\\n\\n\\n```\\npair<int,int> sub(TreeNode *root)\\n    {\\n        if(!root)\\n            return {0,0};\\n        \\n        pair<int,int> leftChildAnswer = sub(root->left);\\n        pair<int,int> rightChildAnswer= sub(root->right);\\n        \\n        int best_If_ParentValueIncluded    =  root->val + leftChildAnswer.second + rightChildAnswer.second;\\n\\n        int best_If_ParentValueNotIncluded =  max(rightChildAnswer.first , rightChildAnswer.second)\\n                                              + max(leftChildAnswer.first , leftChildAnswer.second);\\n        \\n        return {best_If_ParentValueIncluded , best_If_ParentValueNotIncluded};\\n    }\\n    \\n    int rob(TreeNode* root) \\n    {\\n        pair<int,int> ans = sub(root);\\n        return max(ans.first , ans.second);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npair<int,int> sub(TreeNode *root)\\n    {\\n        if(!root)\\n            return {0,0};\\n        \\n        pair<int,int> leftChildAnswer = sub(root->left);\\n        pair<int,int> rightChildAnswer= sub(root->right);\\n        \\n        int best_If_ParentValueIncluded    =  root->val + leftChildAnswer.second + rightChildAnswer.second;\\n\\n        int best_If_ParentValueNotIncluded =  max(rightChildAnswer.first , rightChildAnswer.second)\\n                                              + max(leftChildAnswer.first , leftChildAnswer.second);\\n        \\n        return {best_If_ParentValueIncluded , best_If_ParentValueNotIncluded};\\n    }\\n    \\n    int rob(TreeNode* root) \\n    {\\n        pair<int,int> ans = sub(root);\\n        return max(ans.first , ans.second);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946811,
                "title": "java-simple-recursive-solution-with-explanation",
                "content": "We can think in terms of the choices the robber has to make at every node.\\n\\n```\\n    public int rob(TreeNode root) {\\n        return rob(root, false);\\n    }\\n\\n    public int rob(TreeNode root, boolean isParentRobbed) {\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        // if the parent house is robbed, the current house CANNOT be robbed\\n        if (isParentRobbed) {\\n            return rob(root.left, false) + rob(root.right, false);\\n        }\\n\\n        // the robber has two options\\n        // 1. DO NOT rob the current house\\n        // 2. rob the current house\\n        // we need the maximum profit of the two choices\\n        return Math.max(rob(root.left, false) + rob(root.right, false), // DON\\'T rob\\n                root.val + rob(root.left, true) + rob(root.right, true)); // rob\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public int rob(TreeNode root) {\\n        return rob(root, false);\\n    }\\n\\n    public int rob(TreeNode root, boolean isParentRobbed) {\\n\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        // if the parent house is robbed, the current house CANNOT be robbed\\n        if (isParentRobbed) {\\n            return rob(root.left, false) + rob(root.right, false);\\n        }\\n\\n        // the robber has two options\\n        // 1. DO NOT rob the current house\\n        // 2. rob the current house\\n        // we need the maximum profit of the two choices\\n        return Math.max(rob(root.left, false) + rob(root.right, false), // DON\\'T rob\\n                root.val + rob(root.left, true) + rob(root.right, true)); // rob\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 577233,
                "title": "beats-100-java-easy-solution-dp",
                "content": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int[] result = helper(root);\\n        return Math.max(result[0], result[1]);\\n    }\\n    public int[] helper(TreeNode root){\\n        if(root == null){\\n            int[] result = {0, 0};\\n            return result;\\n        }\\n        int[] result = new int[2];\\n        int[] left = helper(root.left);\\n        int[] right = helper (root.right);\\n        result[0] = root.val + left[1] + right[1];\\n        result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        int[] result = helper(root);\\n        return Math.max(result[0], result[1]);\\n    }\\n    public int[] helper(TreeNode root){\\n        if(root == null){\\n            int[] result = {0, 0};\\n            return result;\\n        }\\n        int[] result = new int[2];\\n        int[] left = helper(root.left);\\n        int[] right = helper (root.right);\\n        result[0] = root.val + left[1] + right[1];\\n        result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405070,
                "title": "cpp-easy-1-line-100-beats-recursion",
                "content": "```\\n// In pair, returning take this value and not taking connected values or not taking this value and taking connected values.\\nint rob(TreeNode* root) {\\n\\treturn robMax(root).first;\\n}\\n\\npair<int, int> robMax(TreeNode* root){\\n\\tif(!root) return {0, 0};\\n\\n\\tpair<int, int> right = robMax(root->right);\\n\\tpair<int, int> left = robMax(root->left);\\n\\n\\treturn {max(root->val + right.second + left.second, right.first + left.first), right.first + left.first};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n// In pair, returning take this value and not taking connected values or not taking this value and taking connected values.\\nint rob(TreeNode* root) {\\n\\treturn robMax(root).first;\\n}\\n\\npair<int, int> robMax(TreeNode* root){\\n\\tif(!root) return {0, 0};\\n\\n\\tpair<int, int> right = robMax(root->right);\\n\\tpair<int, int> left = robMax(root->left);\\n\\n\\treturn {max(root->val + right.second + left.second, right.first + left.first), right.first + left.first};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371540,
                "title": "complexity-of-naive-recursion",
                "content": "In [this](https://leetcode.com/problems/house-robber-iii/discuss/79330/Step-by-step-tackling-of-the-problem) popular forum thread the author claims that the complexity of the naive recursion is exponential:\\n\\n\"The time complexity for the naive recursion in step I is indeed exponential. For each tree node tn at depth d, let T(d) be the number of times the rob function will be called on it. Then we have T(d) = T(d - 1) + T(d - 2). This is because rob will be called on tn either from its parent (at depth d - 1) or its grandparent (at depth d - 2), according to its definition. Note T(0) = T(1) = 1, i.e., rob will be called only once for the tree root and its two child nodes. Therefore T(d) will essentially be the (d+1)-th Fibonacci number (starting from 1), which grows exponentially (more info can be found here).\"\\n\\nThere is discussion in the comments about it actually being O(N^2) because the d (tree depth) in the T(d) above, scales logarithmically with the number of nodes. The author is right that in the worst case it scales exponentially. But for a balanced tree the scaling is indeed polynomial but not O(N^2) as I thought. I figured there was a 4 way branching so 4^log(N)->N^2. Empirically I find ~O(N^1.68157) for a perfectly balanced tree.\\n\\nI imagine the ~1.68157 corresponds to 1+log2(\\u03C6) (\\u03C6=(1+sqrt(5))/2) because the scaling of T(d) is \\u03C6^d=\\u03C6^log2(N)=2^(log2(N)log2(\\u03C6))=N^log2(\\u03C6). As the definition of T(d) was the number of calls per node at depth d we still have to multiply by N (half the nodes are at the leaves) to obtain N^(1+log2(\\u03C6))=N^(1.694...) which my empirical result would hopefully converge to if I let it run longer.\\n\\n![image](https://assets.leetcode.com/users/agade/image_1567281975.png)\\n\\nLocal code\\n```\\n#include <iostream>\\n#include <fstream>\\n#include <chrono>\\n#include <random>\\nusing namespace std;\\nusing namespace std::chrono;\\n\\ndefault_random_engine generator(system_clock::now().time_since_epoch().count());\\nuniform_int_distribution<int> Val_Generator(0,25);\\n\\nstruct TreeNode{\\n\\tint val;\\n\\tTreeNode *left,*right;\\n\\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n};\\n\\nint rob(const TreeNode *root,const bool can_take){\\n\\tif(root==nullptr){\\n\\t\\treturn 0;\\n\\t}\\n\\tif(can_take){\\n\\t\\treturn max(root->val+rob(root->left,false)+rob(root->right,false),rob(root->left,true)+rob(root->right,true));\\n\\t}\\n\\telse{\\n\\t\\treturn rob(root->left,true)+rob(root->right,true);\\n\\t}\\n}\\nint rob(const TreeNode* root){\\n    if(root==nullptr){\\n\\t\\treturn 0;\\n\\t}\\n\\treturn rob(root,true);\\n}\\n\\nvoid Add_Leaves(TreeNode *root){\\n\\tif(root->left!=nullptr){ //root->right is automatically not null because we only use balanced trees\\n\\t\\tAdd_Leaves(root->left);\\n\\t\\tAdd_Leaves(root->right);\\n\\t}\\n\\telse{\\n\\t\\troot->left=new TreeNode(Val_Generator(generator));\\n\\t\\troot->right=new TreeNode(Val_Generator(generator));\\n\\t}\\n}\\n\\nint main(){\\n\\tTreeNode *root=new TreeNode(Val_Generator(generator));\\n\\tofstream Timing_File(\"Time_Logs.txt\",ios::trunc);\\n\\tfor(int depth{1};depth<25;++depth){\\n\\t\\ttime_point<high_resolution_clock> start{high_resolution_clock::now()};\\n\\t\\trob(root);\\n\\t\\tTiming_File << pow(2.0,depth-1) << \" \" << depth << \" \" << (high_resolution_clock::now()-start).count() << endl;\\n\\t\\tAdd_Leaves(root);\\n\\t}\\n}\\n```\\nMakefile\\n```\\nall:\\n\\tg++ Local.cpp -o Local -std=c++17 -O3 -march=native -g\\n```\\nGnuplot script\\n```\\nset terminal pngcairo\\nset output \\'Timing_vs_N.png\\'\\nset title \\'Runtime vs N\\'\\n\\na=1\\nc=2\\nf(x)= a*x**c\\nfit f(x) \"Time_Logs.txt\" using 1:3 via a,c\\n\\nplot \"Time_Logs.txt\" using 1:3,\\\\\\n\\tf(x)\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\n#include <fstream>\\n#include <chrono>\\n#include <random>\\nusing namespace std;\\nusing namespace std::chrono;\\n\\ndefault_random_engine generator(system_clock::now().time_since_epoch().count());\\nuniform_int_distribution<int> Val_Generator(0,25);\\n\\nstruct TreeNode{\\n\\tint val;\\n\\tTreeNode *left,*right;\\n\\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n};\\n\\nint rob(const TreeNode *root,const bool can_take){\\n\\tif(root==nullptr){\\n\\t\\treturn 0;\\n\\t}\\n\\tif(can_take){\\n\\t\\treturn max(root->val+rob(root->left,false)+rob(root->right,false),rob(root->left,true)+rob(root->right,true));\\n\\t}\\n\\telse{\\n\\t\\treturn rob(root->left,true)+rob(root->right,true);\\n\\t}\\n}\\nint rob(const TreeNode* root){\\n    if(root==nullptr){\\n\\t\\treturn 0;\\n\\t}\\n\\treturn rob(root,true);\\n}\\n\\nvoid Add_Leaves(TreeNode *root){\\n\\tif(root->left!=nullptr){ //root->right is automatically not null because we only use balanced trees\\n\\t\\tAdd_Leaves(root->left);\\n\\t\\tAdd_Leaves(root->right);\\n\\t}\\n\\telse{\\n\\t\\troot->left=new TreeNode(Val_Generator(generator));\\n\\t\\troot->right=new TreeNode(Val_Generator(generator));\\n\\t}\\n}\\n\\nint main(){\\n\\tTreeNode *root=new TreeNode(Val_Generator(generator));\\n\\tofstream Timing_File(\"Time_Logs.txt\",ios::trunc);\\n\\tfor(int depth{1};depth<25;++depth){\\n\\t\\ttime_point<high_resolution_clock> start{high_resolution_clock::now()};\\n\\t\\trob(root);\\n\\t\\tTiming_File << pow(2.0,depth-1) << \" \" << depth << \" \" << (high_resolution_clock::now()-start).count() << endl;\\n\\t\\tAdd_Leaves(root);\\n\\t}\\n}\\n```\n```\\nall:\\n\\tg++ Local.cpp -o Local -std=c++17 -O3 -march=native -g\\n```\n```\\nset terminal pngcairo\\nset output \\'Timing_vs_N.png\\'\\nset title \\'Runtime vs N\\'\\n\\na=1\\nc=2\\nf(x)= a*x**c\\nfit f(x) \"Time_Logs.txt\" using 1:3 via a,c\\n\\nplot \"Time_Logs.txt\" using 1:3,\\\\\\n\\tf(x)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3718398,
                "title": "most-simple-solution-pure-greedy-no-map-no-dp",
                "content": "# Intuition\\nThought a lot about this problem then came up with the idea that greedy will work as instead of handling 2 recursive calls which will multiply, we can use a tricky approach.\\n# Approach\\nFirst value of the pair is of taking the current node and second its counterpart!\\nGreedly computing the values of take and notTake in a single pair and giving choices of taking and notTaking at the same time to its parent to save complexity. Observe the second pair here we take maximum greedly!\\n# Complexity\\n- Time complexity:\\n O(N)\\n- Space complexity:\\n O(height of the tree)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root ){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> a = solve(root->left);\\n        pair<int,int> b = solve(root->right);\\n        return {root->val+a.second+b.second,max(a.first,a.second)+max(b.first,b.second)};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans  = solve(root);\\n        return max(ans.first,ans.second);\\n    }\\n};\\n```\\nAlso Like if you find it helpful.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root ){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        pair<int,int> a = solve(root->left);\\n        pair<int,int> b = solve(root->right);\\n        return {root->val+a.second+b.second,max(a.first,a.second)+max(b.first,b.second)};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans  = solve(root);\\n        return max(ans.first,ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559011,
                "title": "beats-90-o-n-time",
                "content": "# Approach\\nApproach is written in the code in the form of comments just go through them and dry run once , i gaurentee you will understand the logic... I can also explain the logic in brief \\nSo here goes the logic , when we add the root data then we can\\'t add the adjacent values so we will skip them and when we will not add the root data then we have choice whether we want to add adjacent values or not...\\n\\n# Complexity\\n\\n- Time complexity: O(N) as we are traversing all the nodes only once\\n\\n- Space complexity: O(height of tree)\\n\\n# **If you liked the solution then pls upvote the solution \\uD83E\\uDD79**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    pair<int,int> solve(TreeNode *root){\\n        // base case\\n        if(root == NULL){\\n            return {0,0};\\n        }\\n\\n        // left part ki call\\n        pair<int,int> leftAns = solve(root->left);\\n\\n        // right part ki call\\n        pair<int,int> rightAns = solve(root->right);\\n\\n        // creating final ans \\n        pair<int,int>ans;\\n\\n        // jab humne root ke data koh include kara, toh adjacent koh pick nhi kr skte\\n        ans.first = root->val + leftAns.second + rightAns.second;\\n\\n        // jab humne root ke data koh include nhi kara \\n        ans.second = max(leftAns.first, leftAns.second) + max(rightAns.first, rightAns.second);\\n\\n        return ans;\\n    }\\n\\n\\n    int rob(TreeNode* root) {\\n        // we can think of this problem ans we want to add the root value or not\\n        pair<int,int>ans = solve(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    pair<int,int> solve(TreeNode *root){\\n        // base case\\n        if(root == NULL){\\n            return {0,0};\\n        }\\n\\n        // left part ki call\\n        pair<int,int> leftAns = solve(root->left);\\n\\n        // right part ki call\\n        pair<int,int> rightAns = solve(root->right);\\n\\n        // creating final ans \\n        pair<int,int>ans;\\n\\n        // jab humne root ke data koh include kara, toh adjacent koh pick nhi kr skte\\n        ans.first = root->val + leftAns.second + rightAns.second;\\n\\n        // jab humne root ke data koh include nhi kara \\n        ans.second = max(leftAns.first, leftAns.second) + max(rightAns.first, rightAns.second);\\n\\n        return ans;\\n    }\\n\\n\\n    int rob(TreeNode* root) {\\n        // we can think of this problem ans we want to add the root value or not\\n        pair<int,int>ans = solve(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065947,
                "title": "dp-soln-step-by-step-easy-video-explanation-o-n",
                "content": "***Challenge Company 4 : Flipkart\\n#ReviseWithArsh #6Companies30Days Challenge 2023\\nQ15. House Robber - Very Imp.***\\n\\nhttps://youtu.be/vOJXQ_mKFoQ\\n***If you found this video helpful, please consider supporting the hard work behind it. Your support would be greatly appreciated^_^***\\n\\n# Intuition\\nDynamic Programming.\\n\\n# Approach\\nThe key idea is to use recursion to break the problem down into subproblems and to use memoization to avoid redundant computation.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> lookup; // create a lookup table to store the results of subproblems\\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }\\n    int helper(TreeNode* node) {\\n        if (!node) // if the input node is null, return 0\\n            return 0;\\n        if (lookup.count(node)) // if the result is already in the lookup table, return the value stored in the lookup table\\n            return lookup[node];\\n        int left = helper(node->left); // calculate the maximum amount of money that can be robbed from the left subtree\\n        int right = helper(node->right); // calculate the maximum amount of money that can be robbed from the right subtree\\n        int left_grandchild = helper(node->left ? node->left->left : nullptr) + helper(node->left ? node->left->right : nullptr);\\n        // calculate the maximum amount of money that can be robbed from the left subtree\\'s grandchild\\n        int right_grandchild = helper(node->right ? node->right->left : nullptr) + helper(node->right ? node->right->right : nullptr);\\n        // calculate the maximum amount of money that can be robbed from the right subtree\\'s grandchild\\n        int result = max(node->val + left_grandchild + right_grandchild, left + right);\\n        // To avoid alerting the police, the thief cannot rob both the current node and its immediate children.\\n        // Therefore, the maximum amount of money that can be robbed from the current node is the maximum of the following two options:\\n        // 1. The maximum amount of money that can be robbed from the left subtree + the maximum amount of money that can be robbed from the right subtree.\\n        // 2. The value of the current node + the maximum amount of money that can be robbed from the left subtree\\'s grandchild + the maximum amount of money that can be robbed from the right subtree\\'s grandchild.\\n        lookup[node] = result; // store the result in the lookup table\\n        return result;\\n    }\\n};\\n\\n```\\n![upvotee.jpg](https://assets.leetcode.com/users/images/312c3619-6ac4-47fc-a29f-7baa9d4fc683_1674019461.7007656.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> lookup; // create a lookup table to store the results of subproblems\\n    int rob(TreeNode* root) {\\n        return helper(root);\\n    }\\n    int helper(TreeNode* node) {\\n        if (!node) // if the input node is null, return 0\\n            return 0;\\n        if (lookup.count(node)) // if the result is already in the lookup table, return the value stored in the lookup table\\n            return lookup[node];\\n        int left = helper(node->left); // calculate the maximum amount of money that can be robbed from the left subtree\\n        int right = helper(node->right); // calculate the maximum amount of money that can be robbed from the right subtree\\n        int left_grandchild = helper(node->left ? node->left->left : nullptr) + helper(node->left ? node->left->right : nullptr);\\n        // calculate the maximum amount of money that can be robbed from the left subtree\\'s grandchild\\n        int right_grandchild = helper(node->right ? node->right->left : nullptr) + helper(node->right ? node->right->right : nullptr);\\n        // calculate the maximum amount of money that can be robbed from the right subtree\\'s grandchild\\n        int result = max(node->val + left_grandchild + right_grandchild, left + right);\\n        // To avoid alerting the police, the thief cannot rob both the current node and its immediate children.\\n        // Therefore, the maximum amount of money that can be robbed from the current node is the maximum of the following two options:\\n        // 1. The maximum amount of money that can be robbed from the left subtree + the maximum amount of money that can be robbed from the right subtree.\\n        // 2. The value of the current node + the maximum amount of money that can be robbed from the left subtree\\'s grandchild + the maximum amount of money that can be robbed from the right subtree\\'s grandchild.\\n        lookup[node] = result; // store the result in the lookup table\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062152,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int, int> solve(TreeNode* t)\\n    {\\n        if(t==NULL)\\n        return {0,0};\\n        auto p1=solve(t->left);\\n        auto p2=solve(t->right);\\n        pair<int, int> p;\\n        p.first=t->val+p1.second+p2.second;\\n        p.second=max(p1.first, p1.second)+max(p2.first, p2.second);\\n        return p;\\n    }\\n    int rob(TreeNode* root) {\\n       auto p= solve(root);\\n       return max(p.first, p.second);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int, int> solve(TreeNode* t)\\n    {\\n        if(t==NULL)\\n        return {0,0};\\n        auto p1=solve(t->left);\\n        auto p2=solve(t->right);\\n        pair<int, int> p;\\n        p.first=t->val+p1.second+p2.second;\\n        p.second=max(p1.first, p1.second)+max(p2.first, p2.second);\\n        return p;\\n    }\\n    int rob(TreeNode* root) {\\n       auto p= solve(root);\\n       return max(p.first, p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555777,
                "title": "c-faster-100-space-100",
                "content": "we define function rob return the maximum amount of money.\\n**And It will automatically contact the police if two directly-linked houses were broken into on the same night.**\\n\\nit means that if we choose the value of current node we cannot choose the value of beside node.\\nso the ans = max(current->val + (**the largest amount of money without choosing the beside node**), **the largest amount of money without choosing the current node**);\\n\\nhow can we find the **the largest amount of money without choosing the beside node**?\\nfor example, if the current node is the root,\\n**the largest amount of money without choosing the beside node** = rob(current->left->left) + rob(current->left->right) + rob(current->right->left) + rob(current->right->right)\\n= 3 + 1 = 4.\\n\\n**how can we simplify it?**\\nwhen backtracking, we can use variable sum to store the sum of rob(current->left) and rob(current->right).\\nand when it backtrack to the parent node, current = parent node. \\nAnd sum = (rob(current->left->left) + rob(current->left->right)) \\nor (rob(current->left->left) + rob(current->left->right)).\\n\\nso when it backtrack to the parent node, we use preSum to store **the largest amount of money without choosing the beside node**.\\nAnd the end we return max(root->val + preSum, sum).\\n![image](https://assets.leetcode.com/users/images/47b68fc3-a39d-49b2-8ca5-6908125a36ce_1653318138.3652587.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int rob(TreeNode* root) {\\n        if(!root){\\n            sum = 0;\\n            return 0;\\n        }\\n        int l = rob(root->left);\\n        int preSum = sum;\\n        int r = rob(root->right);\\n        preSum += sum;\\n        sum = l + r;\\n        return max(root->val + preSum, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int rob(TreeNode* root) {\\n        if(!root){\\n            sum = 0;\\n            return 0;\\n        }\\n        int l = rob(root->left);\\n        int preSum = sum;\\n        int r = rob(root->right);\\n        preSum += sum;\\n        sum = l + r;\\n        return max(root->val + preSum, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872676,
                "title": "python-3-dfs-backtracking-explanation",
                "content": "### Explanation\\n- It\\'s a tree, there is an implied recursion relation between each layer\\n- Two options:\\n\\t- Take value in current node, then the direct children node can\\'t be taken, but we can take the maximum below its direct children\\n\\t- Don\\'t take value in current node, then we take the maximum below current node\\n- Return the maximum of root can get\\n### Implementation\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def dfs(node):\\n            if not node: return 0, 0\\n            left, right = dfs(node.left), dfs(node.right)\\n            v_take = node.val + left[1] + right[1]\\n            v_not_take = max(left) + max(right)\\n            return v_take, v_not_take\\n        return max(dfs(root))\\n```\\nHere is a 1-liner in Python 3.8\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def dfs(node):\\n            return (node.val + (left:=dfs(node.left))[1] + (right:=dfs(node.right))[1], max(left) + max(right)) if node else (0, 0)\\n        return max(dfs(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def dfs(node):\\n            if not node: return 0, 0\\n            left, right = dfs(node.left), dfs(node.right)\\n            v_take = node.val + left[1] + right[1]\\n            v_not_take = max(left) + max(right)\\n            return v_take, v_not_take\\n        return max(dfs(root))\\n```\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def dfs(node):\\n            return (node.val + (left:=dfs(node.left))[1] + (right:=dfs(node.right))[1], max(left) + max(right)) if node else (0, 0)\\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547984,
                "title": "java-postorder-0-ms-100-faster",
                "content": "So the idea here is to keep track of the sum **with** including the current node and **without** including the current node. \\n\\n\\tpublic int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        int[] res = postOrder(root);\\n        return Math.max(res[0], res[1]);\\n    }\\n    \\n    private int[] postOrder(TreeNode node) {\\n\\t\\tif (node == null) return new int[2];\\n        int[] l = postOrder(node.left);\\n        int[] r = postOrder(node.right);\\n\\n        int with = node.val + l[1] + r[1];\\n        int without = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);\\n\\n        return new int[]{with, without};\\n    }",
                "solutionTags": [],
                "code": "So the idea here is to keep track of the sum **with** including the current node and **without** including the current node. \\n\\n\\tpublic int rob(TreeNode root) {\\n        if (root == null) return 0;\\n        int[] res = postOrder(root);\\n        return Math.max(res[0], res[1]);\\n    }\\n    \\n    private int[] postOrder(TreeNode node) {\\n\\t\\tif (node == null) return new int[2];\\n        int[] l = postOrder(node.left);\\n        int[] r = postOrder(node.right);\\n\\n        int with = node.val + l[1] + r[1];\\n        int without = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);\\n\\n        return new int[]{with, without};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 480679,
                "title": "java-dp-with-explanation",
                "content": "```\\nclass Solution {\\n    // using DFS and backtracking; bottom to top\\n    // at certain point/node, this is how we determine the max\\n    // There are a couple of cases at this node \\n    // 1. if we consider to rob this node: max is current root.val + the value get from \\n    // robbing both its grandchildren \\n    // 2. if we consider not to rob: max is the sum of both its left child sum and its right \\n    // sum if exists \\n    // finally, we take the max and return and of course store the result into hashmap for \\n    // future use\\n    \\n    public int DFS(TreeNode root, HashMap<TreeNode, Integer>map){\\n        if(root == null) return 0;\\n        \\n        // if this root has been visited and the max has been calculated, return immediately\\n        if(map.containsKey(root)) return map.get(root);\\n        \\n        int result = 0;\\n        // say we rob the current root, we will also rob its both grandchildren\\n        // below is to rob its left child\\'s both children\\n        if(root.left != null)\\n            result += DFS(root.left.left, map) + DFS(root.left.right, map); \\n        // below is to rob its right child\\'s both children\\n        if(root.right != null)\\n            result += DFS(root.right.left, map) + DFS(root.right.right, map);\\n        \\n        // the sum we get from result will be compared to just robbing its left and right child \\n        result = Math.max(result + root.val, DFS(root.left, map)+DFS(root.right, map));\\n        map.put(root, result);\\n        return result;\\n    \\n    }\\n    public int rob(TreeNode root) {\\n        return DFS(root, new HashMap<TreeNode, Integer>());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // using DFS and backtracking; bottom to top\\n    // at certain point/node, this is how we determine the max\\n    // There are a couple of cases at this node \\n    // 1. if we consider to rob this node: max is current root.val + the value get from \\n    // robbing both its grandchildren \\n    // 2. if we consider not to rob: max is the sum of both its left child sum and its right \\n    // sum if exists \\n    // finally, we take the max and return and of course store the result into hashmap for \\n    // future use\\n    \\n    public int DFS(TreeNode root, HashMap<TreeNode, Integer>map){\\n        if(root == null) return 0;\\n        \\n        // if this root has been visited and the max has been calculated, return immediately\\n        if(map.containsKey(root)) return map.get(root);\\n        \\n        int result = 0;\\n        // say we rob the current root, we will also rob its both grandchildren\\n        // below is to rob its left child\\'s both children\\n        if(root.left != null)\\n            result += DFS(root.left.left, map) + DFS(root.left.right, map); \\n        // below is to rob its right child\\'s both children\\n        if(root.right != null)\\n            result += DFS(root.right.left, map) + DFS(root.right.right, map);\\n        \\n        // the sum we get from result will be compared to just robbing its left and right child \\n        result = Math.max(result + root.val, DFS(root.left, map)+DFS(root.right, map));\\n        map.put(root, result);\\n        return result;\\n    \\n    }\\n    public int rob(TreeNode root) {\\n        return DFS(root, new HashMap<TreeNode, Integer>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307490,
                "title": "java-clean-solution-with-recursion-and-map-as-cache",
                "content": "```\\n    private Map<TreeNode, Integer> map = new HashMap<>();\\n    \\n    public int rob(TreeNode root) {\\n        if (map.containsKey(root)) {\\n            return map.get(root);\\n        }\\n        \\n        int result = Math.max(robFrom(root), robNext(root));\\n        map.put(root, result);\\n        return result;\\n    }\\n    \\n    private int robFrom(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        return node.val + robNext(node.left) + robNext(node.right);\\n    }\\n    \\n    private int robNext(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        return rob(node.left) + rob(node.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n    private Map<TreeNode, Integer> map = new HashMap<>();\\n    \\n    public int rob(TreeNode root) {\\n        if (map.containsKey(root)) {\\n            return map.get(root);\\n        }\\n        \\n        int result = Math.max(robFrom(root), robNext(root));\\n        map.put(root, result);\\n        return result;\\n    }\\n    \\n    private int robFrom(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        return node.val + robNext(node.left) + robNext(node.right);\\n    }\\n    \\n    private int robNext(TreeNode node) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        \\n        return rob(node.left) + rob(node.right);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 302909,
                "title": "c-dfs-using-unordered-map-clean-solution",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_map<TreeNode*, int>m;\\n    \\n    int func(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int child=0, grandchild=0;\\n        \\n        child = func(root->left);\\n        child += func(root->right);\\n        \\n        if(root->left)\\n        {\\n            grandchild = m[root->left->left];\\n            grandchild += m[root->left->right];\\n        }\\n        if(root->right)\\n        {\\n            grandchild += m[root->right->left];\\n            grandchild += m[root->right->right];\\n        }    \\n        \\n        m[root] = max(root->val + grandchild , child);    \\n        return m[root];        \\n    }\\n    \\n    int rob(TreeNode* root) {\\n        \\n        m.clear();\\n        if(!root)\\n            return 0;\\n        \\n        return func(root);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<TreeNode*, int>m;\\n    \\n    int func(TreeNode* root) {\\n        \\n        if(!root) return 0;\\n        \\n        int child=0, grandchild=0;\\n        \\n        child = func(root->left);\\n        child += func(root->right);\\n        \\n        if(root->left)\\n        {\\n            grandchild = m[root->left->left];\\n            grandchild += m[root->left->right];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79436,
                "title": "java-dp-solution-with-explanation",
                "content": "    /**\\n     * Let S(k, r) represent the state of robbed money, where k is current node and r is whether to rob k (=1) or not (=0),\\n     * therefore, S(k, r) can be read as \"the amount of money can be robbed at node k, either to rob k (r=1) or not to rob k (r=0)\"\\n     *\\n     * Then, the state can be calculated via:\\n     *   S(k,0) = max{S(k.left, 0), S(k.left, 1)} + max{S(k.right, 0), S(k.right, 1)}\\n     *   S(k,1) = k.val + S(k.left, 0) + S(k.right, 0)\\n     * \\n     * Finally, the max amount of money can be robbed at root node is max{S(root,0), S(root,1)}\\n     */\\n    public class Solution {\\n    \\n        private Map<TreeNode, Integer> rob = new HashMap<>();\\n        private Map<TreeNode, Integer> norob = new HashMap<>();\\n    \\n        public int rob(TreeNode root) {\\n            return Math.max(robHelper(root, true), robHelper(root, false));\\n        }\\n        \\n        private int robHelper(TreeNode root, boolean robRoot) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            \\n            if (robRoot) {\\n                if (rob.containsKey(root)) {\\n                    // Solved case\\n                    return rob.get(root);\\n                } else {\\n                    int money = root.val + robHelper(root.left, false) + robHelper(root.right, false);\\n                    rob.put(root, money);\\n                    return money;\\n                }\\n            } else {\\n                if (norob.containsKey(root)) {\\n                    // Solved case\\n                    return norob.get(root);\\n                } else {\\n                    int leftMax = Math.max(robHelper(root.left, false), robHelper(root.left, true));\\n                    int rightMax = Math.max(robHelper(root.right, false), robHelper(root.right, true));\\n                    int money = leftMax + rightMax;\\n                    norob.put(root, money);\\n                    return money;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n        private Map<TreeNode, Integer> rob = new HashMap<>();\\n        private Map<TreeNode, Integer> norob = new HashMap<>();\\n    \\n        public int rob(TreeNode root) {\\n            return Math.max(robHelper(root, true), robHelper(root, false));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79476,
                "title": "2ms-java-ac-o-n-solution",
                "content": "The idea is for each node, we have a associated Point. Point's x represents the MAX value for taking this node. Point's y is the MAX value for not taking this node. The program will go from bottom to top and keep updating until root. \\n\\n\\n    public class Solution {\\n        public int rob(TreeNode root) {\\n            return robHelp(root).x;\\n        }\\n        public Point robHelp(TreeNode root) {\\n            if (root == null) {\\n                return new Point(0, 0);\\n            }\\n            Point leftPoint = robHelp(root.left);\\n            Point rightPoint = robHelp(root.right);\\n            \\n            return new Point(Math.max(root.val + leftPoint.y + rightPoint.y, leftPoint.x + rightPoint.x), leftPoint.x + rightPoint.x);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rob(TreeNode root) {\\n            return robHelp(root).x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3955575,
                "title": "easy-recursive-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find the max sum possible of all the non adjacent values in the tree\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto do this we will use recursion and store two piece of values one will be the sum if that node is used and one if that node is not used.\\nif that node is used then we cant take the values of its child so we will add the values when its chil node is not used. when that node is not considered then we can either take its child node or not so we will store the max of the both case. answer will be max of both the values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root){\\n        if(root == NULL){\\n            return {0,0};\\n        }\\n\\n        pair<int,int> left = solve(root->left);\\n        pair<int,int> right = solve(root->right);\\n\\n        pair<int,int> temp;\\n        temp.first = root->val + left.second + right.second;\\n        temp.second = max(left.first,left.second) + max(right.first,right.second);\\n\\n        return temp;\\n    }\\n\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans = solve(root);\\n        return max(ans.first,ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root){\\n        if(root == NULL){\\n            return {0,0};\\n        }\\n\\n        pair<int,int> left = solve(root->left);\\n        pair<int,int> right = solve(root->right);\\n\\n        pair<int,int> temp;\\n        temp.first = root->val + left.second + right.second;\\n        temp.second = max(left.first,left.second) + max(right.first,right.second);\\n\\n        return temp;\\n    }\\n\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans = solve(root);\\n        return max(ans.first,ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244915,
                "title": "337-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem can be solved using a recursive approach. We can traverse the binary tree in a post-order traversal. At each node, we need to decide whether to rob the node or not.\\n\\nLet\\'s define a helper function dfs which returns two values - robThis and notRobThis. robThis represents the maximum amount that can be robbed if we choose to rob the current node, and notRobThis represents the maximum amount that can be robbed if we choose not to rob the current node.\\n\\nTo calculate robThis, we need to add the value of the current node and the value of the grandchildren nodes (the nodes which are two levels below the current node) to notRobGrandChildren. To calculate notRobThis, we need to add the maximum of robGrandChildren and notRobGrandChildren.\\n\\nThe base case for the recursion is when the node is None, in which case we return (0, 0).\\n\\nAt the root node, we need to return the maximum of robThis and notRobThis.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        # Define the helper function\\n        def dfs(node):\\n            # Base case: if the node is None, return (0, 0)\\n            if not node:\\n                return (0, 0)\\n            \\n            # Recursive case: calculate the values for the left and right subtrees\\n            left_rob, left_not_rob = dfs(node.left)\\n            right_rob, right_not_rob = dfs(node.right)\\n            \\n            # Calculate the values for the current node\\n            rob_this = node.val + left_not_rob + right_not_rob\\n            not_rob_this = max(left_rob, left_not_rob) + max(right_rob, right_not_rob)\\n            \\n            # Return the values for the current node\\n            return (rob_this, not_rob_this)\\n        \\n        # Call the helper function on the root node and return the maximum value\\n        return max(dfs(root))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        # Define the helper function\\n        def dfs(node):\\n            # Base case: if the node is None, return (0, 0)\\n            if not node:\\n                return (0, 0)\\n            \\n            # Recursive case: calculate the values for the left and right subtrees\\n            left_rob, left_not_rob = dfs(node.left)\\n            right_rob, right_not_rob = dfs(node.right)\\n            \\n            # Calculate the values for the current node\\n            rob_this = node.val + left_not_rob + right_not_rob\\n            not_rob_this = max(left_rob, left_not_rob) + max(right_rob, right_not_rob)\\n            \\n            # Return the values for the current node\\n            return (rob_this, not_rob_this)\\n        \\n        # Call the helper function on the root node and return the maximum value\\n        return max(dfs(root))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510416,
                "title": "concise-c-dp-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* root) {\\n        if(!root) return {0, 0};\\n        auto [leftDontRob, leftRob]   = dfs(root -> left);\\n        auto [rightDontRob, rightRob] = dfs(root -> right);\\n        return {\\n            max(leftDontRob, leftRob) + max(rightDontRob, rightRob),\\n            root -> val + leftDontRob + rightDontRob\\n        };\\n    }\\n      int rob(TreeNode* root) {\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```\\n**Please Upvote\\nthank you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> dfs(TreeNode* root) {\\n        if(!root) return {0, 0};\\n        auto [leftDontRob, leftRob]   = dfs(root -> left);\\n        auto [rightDontRob, rightRob] = dfs(root -> right);\\n        return {\\n            max(leftDontRob, leftRob) + max(rightDontRob, rightRob),\\n            root -> val + leftDontRob + rightDontRob\\n        };\\n    }\\n      int rob(TreeNode* root) {\\n        auto ans = dfs(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277108,
                "title": "simplest-solution-ever-on-dynamic-programming",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic: \\n    unordered_map<TreeNode*, int> map;\\n   \\n    int rob(TreeNode* root) {\\n        \\n        if(root==NULL) return 0;\\n        \\n        if(map.count(root)) return map[root];\\n        \\n        int sum=0;\\n        \\n        if(root->left)\\n            sum+=rob(root->left->left)+rob(root->left->right);\\n        if(root->right)\\n            sum+=rob(root->right->left)+rob(root->right->right);\\n        \\n        return map[root]=max(root->val+sum,rob(root->left)+rob(root->right));       \\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic: \\n    unordered_map<TreeNode*, int> map;\\n   \\n    int rob(TreeNode* root) {\\n        \\n        if(root==NULL) return 0;\\n        \\n        if(map.count(root)) return map[root];\\n        \\n        int sum=0;\\n        \\n        if(root->left)\\n            sum+=rob(root->left->left)+rob(root->left->right);\\n        if(root->right)\\n            sum+=rob(root->right->left)+rob(root->right->right);\\n        \\n        return map[root]=max(root->val+sum,rob(root->left)+rob(root->right));       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1613441,
                "title": "simple-approach-fast-and-explained-with-pictures",
                "content": "***Simple Approach:-***\\nAs theif cannot enter two directly connected house, so he cannot enter root and its children. So, he has only two options :\\n1. Either he enter the **root and its grandchildren**.\\n2. Or he enter the **children only**.\\n\\nLets write the recursive solution.\\n\\nWe will use pair (**pair<int,int> t**) to store answer :\\n1. **root value**+**sum of grandchildren** in **t.first** and\\n2. **sum of children** in **t.second**\\n![image](https://assets.leetcode.com/users/images/a50cae51-7559-4181-8256-e48012c14957_1638731240.4278634.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> solve(TreeNode* root){\\n        if(root == NULL)\\n            return {0,0};\\n   \\n        pair<int,int> l = solve(root->left);\\n        pair<int,int> r = solve(root->right);\\n        \\n        pair<int,int> t;\\n        \\n        //here l.second + r.second = Sum of grandchildren and l.first + r.first = Sum of children\\n        //t.first contains maxmium money theif can rob till this house(node)\\n        t.first = max(root->val + l.second + r.second, l.first + r.first);\\n        \\n        //t.second contains the sum of children\\n        t.second = l.first + r.first;\\n        \\n        return t;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```\\n Thanks for reading : )",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> solve(TreeNode* root){\\n        if(root == NULL)\\n            return {0,0};\\n   \\n        pair<int,int> l = solve(root->left);\\n        pair<int,int> r = solve(root->right);\\n        \\n        pair<int,int> t;\\n        \\n        //here l.second + r.second = Sum of grandchildren and l.first + r.first = Sum of children\\n        //t.first contains maxmium money theif can rob till this house(node)\\n        t.first = max(root->val + l.second + r.second, l.first + r.first);\\n        \\n        //t.second contains the sum of children\\n        t.second = l.first + r.first;\\n        \\n        return t;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612666,
                "title": "easy-intuitive-recursion-python",
                "content": "Each Node in the tree has **two** options:\\n\\n1. \\t**Not Contribute** to the max sum (money) in which case we just call the recursive function for left and right child and add them.\\n\\n```\\n\"\"\"\\ncond1 = self.rob(root.left)+self.rob(root.right)\\n\"\"\"\\n```\\n\\n2. \\t**Contribute** to the max sum in which case we cannot select the immediate two childs of the node (as per the question constraints direct links cannot be added). In this case we add **the contribution of the current node** and **call the function on the four grandchildren of that node** and add all the four grandchildren sum. \\n```\\n\"\"\"\\ncond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right)\\n\"\"\"\\n```\\n\\nGet the max of above conditions will be the answer.\\n```\\n\"\"\"\\nreturn max(cond1,cond2)\\n\"\"\"\\n```\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n#         \"\"\"\\n#         Base Condtions\\n#         \"\"\"\\n        if(not root):\\n            return 0\\n        elif(not root.left and not root.right):\\n            return root.val\\n        # \"\"\"\\n        # if only left child is present. cond2 will not contain grandchildren of right ones\\n        # cond1 will be as simple as just calling on left node;; no adding with right node required.\\n        # \"\"\"\\n        elif(not root.right):\\n            cond1 = self.rob(root.left)\\n            cond2 = root.val+self.rob(root.left.left)+self.rob(root.left.right)\\n            max_money = max(cond1,cond2)\\n        # \"\"\"\\n        # If only right child is present ; similar as above explaination\\n        # \"\"\"\\n        elif(not root.left):\\n            cond1 = self.rob(root.right)\\n            cond2 = root.val+self.rob(root.right.left)+self.rob(root.right.right)\\n            max_money = max(cond1,cond2)\\n            \\n        else:\\n            \\n            cond1 = self.rob(root.left)+self.rob(root.right)\\n            cond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right))\\n            max_money = max(cond1,cond2)\\n        \\n        return max_money\\n```\\n\\n**Inorder to optimise** the above Solution simply **use a dictionary** to store the sum value of a node so that it is not calculated again in recursive calls:\\n\\nOptimised code : (Same as Above; just added a dictionary)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    d = {}\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n#         \"\"\"\\n#         Base Condtions\\n#         \"\"\"\\n        if(not root):\\n            return 0\\n        \\n        elif(Solution.d.get(root) != None):\\n            return Solution.d[root]\\n        \\n        elif(not root.left and not root.right):\\n            return root.val\\n        # \"\"\"\\n        # if only left child is present. cond2 will not contain grandchildren of right ones\\n        # cond1 will be as simple as just calling on left node;; no adding with right node required.\\n        # \"\"\"\\n        elif(not root.right):\\n            cond1 = self.rob(root.left)\\n            cond2 = root.val+self.rob(root.left.left)+self.rob(root.left.right)\\n            max_money = max(cond1,cond2)\\n        # \"\"\"\\n        # If only right child is present ; similar as above explaination\\n        # \"\"\"\\n        elif(not root.left):\\n            cond1 = self.rob(root.right)\\n            cond2 = root.val+self.rob(root.right.left)+self.rob(root.right.right)\\n            max_money = max(cond1,cond2)\\n            \\n        else:\\n            \\n            cond1 = self.rob(root.left)+self.rob(root.right)\\n            cond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right))\\n            max_money = max(cond1,cond2)\\n            \\n        Solution.d[root] = max_money\\n        \\n        return max_money\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\"\"\"\\ncond1 = self.rob(root.left)+self.rob(root.right)\\n\"\"\"\\n```\n```\\n\"\"\"\\ncond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right)\\n\"\"\"\\n```\n```\\n\"\"\"\\nreturn max(cond1,cond2)\\n\"\"\"\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n#         \"\"\"\\n#         Base Condtions\\n#         \"\"\"\\n        if(not root):\\n            return 0\\n        elif(not root.left and not root.right):\\n            return root.val\\n        # \"\"\"\\n        # if only left child is present. cond2 will not contain grandchildren of right ones\\n        # cond1 will be as simple as just calling on left node;; no adding with right node required.\\n        # \"\"\"\\n        elif(not root.right):\\n            cond1 = self.rob(root.left)\\n            cond2 = root.val+self.rob(root.left.left)+self.rob(root.left.right)\\n            max_money = max(cond1,cond2)\\n        # \"\"\"\\n        # If only right child is present ; similar as above explaination\\n        # \"\"\"\\n        elif(not root.left):\\n            cond1 = self.rob(root.right)\\n            cond2 = root.val+self.rob(root.right.left)+self.rob(root.right.right)\\n            max_money = max(cond1,cond2)\\n            \\n        else:\\n            \\n            cond1 = self.rob(root.left)+self.rob(root.right)\\n            cond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right))\\n            max_money = max(cond1,cond2)\\n        \\n        return max_money\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    d = {}\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n#         \"\"\"\\n#         Base Condtions\\n#         \"\"\"\\n        if(not root):\\n            return 0\\n        \\n        elif(Solution.d.get(root) != None):\\n            return Solution.d[root]\\n        \\n        elif(not root.left and not root.right):\\n            return root.val\\n        # \"\"\"\\n        # if only left child is present. cond2 will not contain grandchildren of right ones\\n        # cond1 will be as simple as just calling on left node;; no adding with right node required.\\n        # \"\"\"\\n        elif(not root.right):\\n            cond1 = self.rob(root.left)\\n            cond2 = root.val+self.rob(root.left.left)+self.rob(root.left.right)\\n            max_money = max(cond1,cond2)\\n        # \"\"\"\\n        # If only right child is present ; similar as above explaination\\n        # \"\"\"\\n        elif(not root.left):\\n            cond1 = self.rob(root.right)\\n            cond2 = root.val+self.rob(root.right.left)+self.rob(root.right.right)\\n            max_money = max(cond1,cond2)\\n            \\n        else:\\n            \\n            cond1 = self.rob(root.left)+self.rob(root.right)\\n            cond2 = root.val + (self.rob(root.left.left)+self.rob(root.left.right)+self.rob(root.right.left)+self.rob(root.right.right))\\n            max_money = max(cond1,cond2)\\n            \\n        Solution.d[root] = max_money\\n        \\n        return max_money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611884,
                "title": "dp-solution-python",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def rec(node, depth):\\n            if not node:\\n                return\\n            layer_dict[depth].append(node)\\n            rec(node.left, depth + 1)\\n            rec(node.right, depth + 1)\\n            \\n        #get layer dict\\n        layer_dict = defaultdict(list)\\n        rec(root, 0)\\n        \\n        #dp\\n        dp_use, dp_no_use = {None : 0}, {None : 0}\\n        \\n        for layer in range(max(layer_dict.keys()), -1, -1):\\n            for u in layer_dict[layer]:\\n                dp_use[u] = dp_no_use[u.left] + dp_no_use[u.right] + u.val\\n                dp_no_use[u] = max(dp_use[u.left], dp_no_use[u.left]) + max(dp_use[u.right], dp_no_use[u.right])\\n        \\n        return max(dp_use[root], dp_no_use[root])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def rec(node, depth):\\n            if not node:\\n                return\\n            layer_dict[depth].append(node)\\n            rec(node.left, depth + 1)\\n            rec(node.right, depth + 1)\\n            \\n        #get layer dict\\n        layer_dict = defaultdict(list)\\n        rec(root, 0)\\n        \\n        #dp\\n        dp_use, dp_no_use = {None : 0}, {None : 0}\\n        \\n        for layer in range(max(layer_dict.keys()), -1, -1):\\n            for u in layer_dict[layer]:\\n                dp_use[u] = dp_no_use[u.left] + dp_no_use[u.right] + u.val\\n                dp_no_use[u] = max(dp_use[u.left], dp_no_use[u.left]) + max(dp_use[u.right], dp_no_use[u.right])\\n        \\n        return max(dp_use[root], dp_no_use[root])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429939,
                "title": "c-dp",
                "content": "This is a straightforwad DP problem. \\nThe `helper` function returns a pair of `{the best result of the subtree if root is robbed, the best result of the subtree if root is not robbed}`.\\n\\nTime complexity `O(n)`\\nSpace complexity `O(n)` (considering the call stack)\\n\\n```\\n    pair<int, int> helper(TreeNode* root)\\n    {\\n        if (!root)\\n            return {0, 0};\\n        auto l = helper(root->left);\\n        auto r = helper(root->right);\\n        int cur_not_rob = max(l.first, l.second) + max(r.first, r.second);\\n        int cur_rob = l.second + r.second + root->val;\\n        return {cur_rob, cur_not_rob};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto res = helper(root);\\n        return max(res.first, res.second);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\n    pair<int, int> helper(TreeNode* root)\\n    {\\n        if (!root)\\n            return {0, 0};\\n        auto l = helper(root->left);\\n        auto r = helper(root->right);\\n        int cur_not_rob = max(l.first, l.second) + max(r.first, r.second);\\n        int cur_rob = l.second + r.second + root->val;\\n        return {cur_rob, cur_not_rob};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto res = helper(root);\\n        return max(res.first, res.second);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246548,
                "title": "java-simple-and-easy-solution-using-pair-class",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    \\n    class Pair{\\n        int withRob;\\n        int withoutRob;\\n        \\n        public Pair(int withRob, int withoutRob){\\n            this.withRob = withRob;\\n            this.withoutRob = withoutRob;\\n        }\\n    }\\n    \\n    public int rob(TreeNode root) {\\n         Pair obj = robHelper(root);\\n         return Math.max(obj.withRob, obj.withoutRob);\\n    }\\n    \\n    public Pair robHelper(TreeNode root){\\n        if(root == null)\\n            return new Pair(0, 0);\\n        \\n        Pair leftObj = robHelper(root.left);\\n        Pair rightObj = robHelper(root.right);\\n        \\n        int withRob = leftObj.withoutRob + rightObj.withoutRob + root.val;\\n        int withoutRob = Math.max(leftObj.withRob, leftObj.withoutRob) + Math.max(rightObj.withRob, rightObj.withoutRob);\\n        \\n        return new Pair(withRob, withoutRob);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        int withRob;\\n        int withoutRob;\\n        \\n        public Pair(int withRob, int withoutRob){\\n            this.withRob = withRob;\\n            this.withoutRob = withoutRob;\\n        }\\n    }\\n    \\n    public int rob(TreeNode root) {\\n         Pair obj = robHelper(root);\\n         return Math.max(obj.withRob, obj.withoutRob);\\n    }\\n    \\n    public Pair robHelper(TreeNode root){\\n        if(root == null)\\n            return new Pair(0, 0);\\n        \\n        Pair leftObj = robHelper(root.left);\\n        Pair rightObj = robHelper(root.right);\\n        \\n        int withRob = leftObj.withoutRob + rightObj.withoutRob + root.val;\\n        int withoutRob = Math.max(leftObj.withRob, leftObj.withoutRob) + Math.max(rightObj.withRob, rightObj.withoutRob);\\n        \\n        return new Pair(withRob, withoutRob);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177392,
                "title": "c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int>mp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(mp.find(root) != mp.end()) return mp[root];\\n        \\n        int total = 0;\\n        if(root->left) total += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) total += (rob(root->right->left) + rob(root->right->right));\\n        return mp[root] = max((root->val+total), (rob(root->left)+rob(root->right)));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int>mp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        if(mp.find(root) != mp.end()) return mp[root];\\n        \\n        int total = 0;\\n        if(root->left) total += (rob(root->left->left) + rob(root->left->right));\\n        if(root->right) total += (rob(root->right->left) + rob(root->right->right));\\n        return mp[root] = max((root->val+total), (rob(root->left)+rob(root->right)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952469,
                "title": "simple-java-recursion-memoization-solution",
                "content": "*  Time O(n) | Space O(n)\\n*   DP on trees\\n* \\twe can choose b/w grandchildren+parent or children\\n```\\n\\n HashMap<TreeNode, Integer> map=new HashMap<>();\\n    public int rob(TreeNode root) {\\n        //we can choose b/w grandchildren+parent or children\\n        if(root==null)return 0;\\n        \\n        if(map.containsKey(root)) return map.get(root);\\n        \\n        int total=0;\\n        \\n        if(root.left!=null)\\n        total+=rob(root.left.left)+rob(root.left.right);\\n        \\n         if(root.right!=null)\\n        total+=rob(root.right.left)+rob(root.right.right);\\n        \\n        int profit= Math.max((root.val +total), rob(root.left) + rob(root.right));\\n        \\n        map.put(root, profit);\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\n HashMap<TreeNode, Integer> map=new HashMap<>();\\n    public int rob(TreeNode root) {\\n        //we can choose b/w grandchildren+parent or children\\n        if(root==null)return 0;\\n        \\n        if(map.containsKey(root)) return map.get(root);\\n        \\n        int total=0;\\n        \\n        if(root.left!=null)\\n        total+=rob(root.left.left)+rob(root.left.right);\\n        \\n         if(root.right!=null)\\n        total+=rob(root.right.left)+rob(root.right.right);\\n        \\n        int profit= Math.max((root.val +total), rob(root.left) + rob(root.right));\\n        \\n        map.put(root, profit);\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946573,
                "title": "python-3-explained-solution-video-code",
                "content": "[](https://www.youtube.com/watch?v=mSzz_bZUVCQ)\\nhttps://www.youtube.com/watch?v=mSzz_bZUVCQ\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        @lru_cache(None)\\n        \\n        def helper(node, parent_stolen):\\n            if not node:\\n                return 0\\n            \\n            if parent_stolen:\\n                # we did steal from parent\\n                # the only option is to not steal since we stole from the parent\\n                return helper(node.left, False) + helper(node.right, False)\\n\\n            else:\\n                # we did NOT steal parent\\n                # Given a choice to choose b/w stealing or not stealing\\n                # stealing at the current node\\n                steal = node.val + helper(node.left, True) + helper(node.right, True)\\n                \\n                # NOT stealing current node\\n                not_stealing = helper(node.left, False) + helper(node.right, False)\\n                \\n                return max(steal, not_stealing)\\n        \\n        return helper(root, False)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        @lru_cache(None)\\n        \\n        def helper(node, parent_stolen):\\n            if not node:\\n                return 0\\n            \\n            if parent_stolen:\\n                # we did steal from parent\\n                # the only option is to not steal since we stole from the parent\\n                return helper(node.left, False) + helper(node.right, False)\\n\\n            else:\\n                # we did NOT steal parent\\n                # Given a choice to choose b/w stealing or not stealing\\n                # stealing at the current node\\n                steal = node.val + helper(node.left, True) + helper(node.right, True)\\n                \\n                # NOT stealing current node\\n                not_stealing = helper(node.left, False) + helper(node.right, False)\\n                \\n                return max(steal, not_stealing)\\n        \\n        return helper(root, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946391,
                "title": "rust-dfs-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let ret = Solution::dfs(&root);\\n        std::cmp::max(ret.0, ret.1)\\n    }\\n    fn dfs(node: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n        if let Some(n) = node {\\n            let l = Solution::dfs(&n.borrow().left);\\n            let r = Solution::dfs(&n.borrow().right);\\n            (\\n                n.borrow().val + l.1 + r.1,\\n                std::cmp::max(l.0, l.1) + std::cmp::max(r.0, r.1),\\n            )\\n        } else {\\n            (0, 0)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let ret = Solution::dfs(&root);\\n        std::cmp::max(ret.0, ret.1)\\n    }\\n    fn dfs(node: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n        if let Some(n) = node {\\n            let l = Solution::dfs(&n.borrow().left);\\n            let r = Solution::dfs(&n.borrow().right);\\n            (\\n                n.borrow().val + l.1 + r.1,\\n                std::cmp::max(l.0, l.1) + std::cmp::max(r.0, r.1),\\n            )\\n        } else {\\n            (0, 0)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900695,
                "title": "javascript-recursion-solution",
                "content": "Max at root is either the sum of max left subtree and max right subtree, or the sum of the root with max of left subtree children and max of right subtree children. The key here is that you want to return both the max at the root and the max of its children in the helper method.\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    return helper(root)[0];\\n};\\n\\nfunction helper(root){\\n    if(root == null) return [0, 0];\\n    const left = helper(root.left);\\n    const right = helper(root.right);\\n    const currMax = Math.max(left[0] + right[0], root.val + left[1] + right[1]);\\n    const childrenMax = left[0] + right[0];                 \\n    return [currMax, childrenMax];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    return helper(root)[0];\\n};\\n\\nfunction helper(root){\\n    if(root == null) return [0, 0];\\n    const left = helper(root.left);\\n    const right = helper(root.right);\\n    const currMax = Math.max(left[0] + right[0], root.val + left[1] + right[1]);\\n    const childrenMax = left[0] + right[0];                 \\n    return [currMax, childrenMax];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 803361,
                "title": "python-dp-soln",
                "content": "```\\nclass Solution:\\n    def dp(self, root, dp):\\n        if not root: return 0\\n        if root in dp:\\n            return dp[root]\\n        \\n        val = 0\\n        if root.left:\\n            val += self.dp(root.left.left, dp) + self.dp(root.left.right, dp)\\n        \\n        if root.right:\\n            val += self.dp(root.right.left, dp) + self.dp(root.right.right, dp)\\n    \\n        val = max(val + root.val, self.dp(root.left, dp) + self.dp(root.right, dp))\\n        dp[root] = val\\n        return val\\n    \\n    def rob(self, root: TreeNode) -> int:\\n        dp = {}\\n        return self.dp(root, dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, root, dp):\\n        if not root: return 0\\n        if root in dp:\\n            return dp[root]\\n        \\n        val = 0\\n        if root.left:\\n            val += self.dp(root.left.left, dp) + self.dp(root.left.right, dp)\\n        \\n        if root.right:\\n            val += self.dp(root.right.left, dp) + self.dp(root.right.right, dp)\\n    \\n        val = max(val + root.val, self.dp(root.left, dp) + self.dp(root.right, dp))\\n        dp[root] = val\\n        return val\\n    \\n    def rob(self, root: TreeNode) -> int:\\n        dp = {}\\n        return self.dp(root, dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776116,
                "title": "google-interview-question-dp-intuitive-explanation",
                "content": "It is same as the question https://leetcode.com/problems/house-robber/  but now we have to steal in a Binary Tree. At that question We have used our DP as maximum profit at ith index if we pick value at ith index or we do not pick the value at ith index.\\n\\nHere We have to use the same Dp state but we have to use it to Every Node in the tree. At Every Node we can store the maximum profit till that node if we rob the node or if we donot rob it.\\n\\nSo you have to store a pair at every Node  pair is like ** <max profit if we robNode ,  max profit if we doNotRob> \\n**\\n**Crux: If you are robbing the currNode you cant rob the childrens.\\nif you choose to rob the currNode\\nmaxProfit if we ROB currNode=currNodeVal+maxSumOfleftChild when we dont rob it +maxSumOfrightChild when we dont rob it.\\nbecause you cant rob the childrens if you rob the currNode**\\n\\n**If you choose to not rob the currNode then \\nmaxProfit if we  doNotROB currNode=maxFromLeftPair+maxFromRightPair\\nbecause if you are not robbing the current node then you can make any choice from the childrens you can rob the childrens or you dont its your wish so you have to return max from left child pair and from right child pair and add them.**\\n\\n```\\nclass Solution\\n{\\n    \\npublic:\\n    pair<int,int> topDownDp(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        pair<int,int> fromLeft=topDownDp(root->left);\\n        pair<int,int> fromRight=topDownDp(root->right);\\n \\n        \\n        int robNode=root->val+fromLeft.second+fromRight.second;\\n        int doNotRob=max(fromLeft.first,fromLeft.second)+max(fromRight.first,fromRight.second);\\n        \\n        return {robNode,doNotRob};\\n    }\\n\\n    int rob(TreeNode* root) \\n    {\\n    pair<int,int> choices=topDownDp(root);\\n    return max(choices.first,choices.second);    \\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    \\npublic:\\n    pair<int,int> topDownDp(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 775125,
                "title": "python-intuitive-o-n-solution",
                "content": "For each node, compute the maximum money whether choosing the node or not.\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        \\n        def check(root): \\n\\t\\t# return a tuple (choosing the root, not choosing the root)\\n            if not root:\\n                return (0,0)\\n            left = check(root.left)\\n            right = check(root.right)\\n            return (root.val + left[1] + right[1], max(left) + max(right))\\n        \\n        return max(check(root))\\n\\t\\t",
                "solutionTags": [],
                "code": "For each node, compute the maximum money whether choosing the node or not.\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        \\n        def check(root): \\n\\t\\t# return a tuple (choosing the root, not choosing the root)\\n            if not root:\\n                return (0,0)\\n            left = check(root.left)\\n            right = check(root.right)\\n            return (root.val + left[1] + right[1], max(left) + max(right))\\n        \\n        return max(check(root))\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 617173,
                "title": "python-dfs-solution-with-explanations",
                "content": "**Explanations**:\\nFor each node, the robber can either rob this node and leave out the consecutive left and right nodes, or he/she can not rob this node and try out different combinations to find the max value that he/she can rob. The combinations include rob 1. both left and right nodes, 2. rob only left node and not rob the right one, 3. rob only right node and not rob the left one, 4. rob neither of the left or right nodes. \\n`_rob` function will return the two scenario for each node.\\nIn the end, return the mac value.\\n\\n**Complexcity**: Time O(N), N is the number of nodes. Space O(1).\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def _rob(node):\\n            if not node: return 0, 0\\n            left, left_no = _rob(node.left)\\n            right, right_no = _rob(node.right)\\n            cur = node.val + left_no + right_no\\n            no = max(left + right, left + right_no, left_no + right, left_no + right_no)\\n            return cur, no\\n        return max(_rob(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def _rob(node):\\n            if not node: return 0, 0\\n            left, left_no = _rob(node.left)\\n            right, right_no = _rob(node.right)\\n            cur = node.val + left_no + right_no\\n            no = max(left + right, left + right_no, left_no + right, left_no + right_no)\\n            return cur, no\\n        return max(_rob(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567770,
                "title": "go-4ms-very-simple",
                "content": "```go\\nfunc rob(root *TreeNode) int {\\n\\treturn max(robber(root))\\n}\\n\\nfunc robber(node *TreeNode) (int, int) {\\n\\tif node == nil {\\n\\t\\treturn 0, 0\\n\\t}\\n\\tgold := node.Val\\n\\tl1, l2 := robber(node.Left)\\n\\tr1, r2 := robber(node.Right)\\n\\tc1 := gold + l2 + r2\\n\\tc2 := max(l1, l2) + max(r1, r2)\\n\\treturn c1, c2\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt32\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rob(root *TreeNode) int {\\n\\treturn max(robber(root))\\n}\\n\\nfunc robber(node *TreeNode) (int, int) {\\n\\tif node == nil {\\n\\t\\treturn 0, 0\\n\\t}\\n\\tgold := node.Val\\n\\tl1, l2 := robber(node.Left)\\n\\tr1, r2 := robber(node.Right)\\n\\tc1 := gold + l2 + r2\\n\\tc2 := max(l1, l2) + max(r1, r2)\\n\\treturn c1, c2\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt32\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440363,
                "title": "linear-time-python",
                "content": "Same logic as [House Robber](https://leetcode.com/problems/house-robber/discuss/440346/python-constant-space-O(N))\\n```\\ndef rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(root):\\n            if not root:\\n                return 0, 0 \\n            \\n            l_prev, l_rob = helper(root.left)\\n            r_prev, r_rob = helper(root.right)\\n            \\n            prev = max([l_prev+r_prev, l_rob+r_rob, l_prev+r_rob, l_rob+r_prev])\\n            rob = l_prev+r_prev+root.val\\n            return prev, rob\\n        return max(helper(root))\\n```",
                "solutionTags": [],
                "code": "```\\ndef rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(root):\\n            if not root:\\n                return 0, 0 \\n            \\n            l_prev, l_rob = helper(root.left)\\n            r_prev, r_rob = helper(root.right)\\n            \\n            prev = max([l_prev+r_prev, l_rob+r_rob, l_prev+r_rob, l_rob+r_prev])\\n            rob = l_prev+r_prev+root.val\\n            return prev, rob\\n        return max(helper(root))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242419,
                "title": "java-solution",
                "content": "\\u9898\\u76EE\\u4E3A\\uFF1A\\u6709\\u5F88\\u591A\\u4E92\\u76F8\\u8FDE\\u63A5\\u7684\\u623F\\u95F4\\uFF0C\\u8FD9\\u4E9B\\u623F\\u95F4\\u6B63\\u597D\\u8FDE\\u6210\\u4E00\\u68F5\\u4E8C\\u53C9\\u6811\\u7684\\u6837\\u5B50\\uFF0C\\u5C0F\\u5077\\u9700\\u8981\\u4ECE\\u8FD9\\u68F5\\u6811\\u7684\\u6839\\u7ED3\\u70B9\\u623F\\u95F4\\u51FA\\u53D1\\u5F00\\u59CB\\u5077\\u4E1C\\u897F\\u3002\\u4E3A\\u4E86\\u4E0D\\u88AB\\u6293\\u4F4F\\uFF0C\\u5C0F\\u5077\\u4E0D\\u80FD\\u5077\\u76F8\\u8FDE\\u7684\\u4E24\\u4E2A\\u623F\\u95F4\\u3002\\n\\n\\u4E8E\\u662F\\uFF0C\\u6709\\u8FD9\\u4E48\\u4E24\\u4E2A\\u8981\\u6C42\\uFF1A\\n\\n1.  \\u5982\\u679C\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u7236\\u7ED3\\u70B9\\u6CA1\\u6709\\u88AB\\u5077\\uFF0C\\u90A3\\u4E48\\u5F53\\u524D\\u7ED3\\u70B9\\u53EF\\u5077\\u53EF\\u4E0D\\u5077\\n2.  \\u5982\\u679C\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u7236\\u7ED3\\u70B9\\u88AB\\u5077\\u4E86\\uFF0C\\u90A3\\u4E48\\u5F53\\u524D\\u7ED3\\u70B9\\u4E0D\\u53EF\\u5077\\n\\n\\u6240\\u4EE5\\uFF0C\\u5F53\\u4ECE\\u6839\\u7ED3\\u70B9\\u5224\\u65AD\\u5F00\\u59CB\\u7684\\u65F6\\u5019\\uFF0C\\u6709\\uFF1A\\n\\n1.  \\u5982\\u679C\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u4E0B\\u9762\\u80FD\\u5077\\u7684\\u53EA\\u80FD\\u662F\\u81EA\\u5DF1\\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\n2.  \\u5982\\u679C\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u4E0B\\u9762\\u53EF\\u4EE5\\u5077\\u81EA\\u5DF1\\u7684\\u5B69\\u5B50\\u7ED3\\u70B9\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    public static int rob(TreeNode node) {\\n        if (node == null) return 0;\\n        int max = rob(node.left) + rob(node.right);\\n        int m = node.val;\\n        if (node.left != null) {\\n            m += rob(node.left.left) + rob(node.left.right);\\n        }\\n        if (node.right != null) {\\n            m += rob(node.right.left) + rob(node.right.right);\\n        }\\n        max = Math.max(max, m);\\n        return max;\\n    }\\n\\n\\u5728\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4E2D\\u53EF\\u4EE5\\u770B\\u5230\\uFF0C\\u4ECE\\u7ED3\\u70B9 node \\u6709\\u4E24\\u6761\\u7EBF\\uFF0C\\u5206\\u522B\\u662F\\u8D70\\u5411 node \\u7684\\u5B50\\u7ED3\\u70B9\\u548C\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u8FD9\\u5C31\\u5BFC\\u81F4\\u4E00\\u4E2A\\u95EE\\u9898\\uFF1A\\u4F1A\\u4EA7\\u751F\\u91CD\\u590D\\u8BA1\\u7B97\\u3002\\u6BD4\\u5982\\uFF0C\\u5BF9\\u4E8E\\u4ECE node \\u7ED3\\u70B9\\u5230\\u5B83\\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u53EF\\u4EE5\\u6709\\u4E24\\u79CD\\u65B9\\u5F0F\\uFF1Anode -> \\u5B59\\u5B50\\u548Cnode -> \\u5B69\\u5B50 -> \\u5B69\\u5B50\\u3002\\u4ECE\\u4E24\\u6761\\u8DEF\\u5927\\u5230\\u8FBE\\u540C\\u4E00\\u7ED3\\u70B9\\uFF0C\\u5C31\\u662F\\u8BF4\\u4F1A\\u4ECE\\u4E24\\u4E2A\\u9012\\u5F52\\u51FD\\u6570\\u5206\\u522B\\u8FDB\\u5165 node \\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u52BF\\u5FC5\\u4F1A\\u8BA1\\u7B97\\u4E24\\u6B21\\u8FD9\\u4E2A\\u7ED3\\u70B9\\u7684\\u89E3\\u3002\\n\\n\\u6240\\u4EE5\\u9700\\u8981\\u91C7\\u53D6\\u4E00\\u5B9A\\u7684\\u63AA\\u65BD\\uFF0C\\u4F7F\\u5F97\\u91CD\\u590D\\u8FDB\\u5165\\u540C\\u4E00\\u7ED3\\u70B9\\u7684\\u65F6\\u5019\\u907F\\u514D\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u5373\\u4F7F\\u7528\\u7F13\\u5B58\\uFF1A\\n\\n    public static int rob(TreeNode root) {\\n        return rob(root, new HashMap<>());\\n    }\\n    private static int rob(TreeNode node, Map<TreeNode, Integer> saved) {\\n        if (node == null) return 0;\\n        if (saved.containsKey(node)) return saved.get(node);\\n        int max = rob(node.left, saved) + rob(node.right, saved);\\n        int m = node.val;\\n        if (node.left != null) {\\n            m += rob(node.left.left, saved) + rob(node.left.right, saved);\\n        }\\n        if (node.right != null) {\\n            m += rob(node.right.left, saved) + rob(node.right.right, saved);\\n        }\\n        max = Math.max(max, m);\\n        saved.put(node, max);\\n        return max;\\n    }\\n\\n\\u4F7F\\u7528\\u4E00\\u4E2A HashMap \\u4FDD\\u5B58\\u5DF2\\u7ECF\\u6C42\\u89E3\\u8FC7\\u7684\\u7ED3\\u70B9\\uFF0C\\u5C31\\u662F\\u4E00\\u79CD\\u7F13\\u5B58\\u7684\\u601D\\u60F3\\u3002\\n\\n\\u518D\\u770B\\u672C\\u65B9\\u6CD5\\u7684\\u7F3A\\u9677\\uFF0C\\u8FD9\\u662F\\u4E00\\u79CD\\u201C\\u8DF3\\u8DC3\\u5F0F\\u201D\\u7684\\u89E3\\u6CD5\\uFF0C\\u4ECE\\u4E00\\u4E2A\\u7ED3\\u70B9\\u51FA\\u53D1\\u5230\\u53E6\\u4E00\\u4E2A\\u7ED3\\u70B9\\uFF0C\\u4F1A\\u6709\\u591A\\u6761\\u8DEF\\u5F84\\uFF0C\\u800C\\u591A\\u6761\\u8DEF\\u5F84\\u4F1A\\u5BFC\\u81F4\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u90A3\\u4E48\\u5982\\u679C\\u80FD\\u4F7F\\u5B83\\u4E0D\\u518D\\u8DF3\\u8DC3\\uFF0C\\u53EA\\u80FD\\u4E00\\u6B65\\u4E00\\u6B65\\u5F80\\u4E0B\\u8D70\\u7684\\u8BDD\\uFF0C\\u8FD9\\u4E2A\\u91CD\\u590D\\u8BA1\\u7B97\\u4E5F\\u5C31\\u4E0D\\u590D\\u5B58\\u5728\\u4E86\\u3002\\n\\n\\u5982\\u4F55\\u6539\\u8FDB\\uFF1F\\u5C0F\\u5077\\u5BF9\\u4E8E\\u6BCF\\u4E2A\\u7ED3\\u70B9\\u6709\\u4E24\\u79CD\\u5904\\u7406\\uFF1A\\u5077\\u6216\\u4E0D\\u5077\\u3002\\n\\n1.  \\u5982\\u679C\\u5C0F\\u5077\\u5077\\u4E86\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u5B83\\u7684\\u5B50\\u7ED3\\u70B9\\u4E0D\\u80FD\\u5077\\n2.  \\u5982\\u679C\\u5C0F\\u5077\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u5B50\\u7ED3\\u70B9\\u53EF\\u4EE5\\u5077\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u4E0D\\u5077\\uFF08\\u53D6\\u5176\\u4E2D\\u8F83\\u5927\\u7684\\u5373\\u53EF\\uFF09\\n\\n\\u8FD9\\u6B21\\u7684\\u6761\\u4EF6\\u597D\\u50CF\\u4E0E\\u4E0A\\u9762\\u7684\\u6761\\u4EF6\\u4E00\\u6837\\uFF0C\\u4F46\\u662F\\u8FD8\\u662F\\u6709\\u533A\\u522B\\u7684\\uFF0C\\u90A3\\u4E2A\\u6D89\\u53CA\\u5230\\u4E86\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u800C\\u8FD9\\u4E2A\\uFF0C\\u53EA\\u6D89\\u53CA\\u5230\\u5B69\\u5B50\\uFF0C\\u5982\\u679C\\u4E0A\\u9762\\u90A3\\u4E2A\\u662F\\u201C\\u8DF3\\u8DC3\\u5F0F\\u201D\\u7684\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u5C31\\u662F\\u201C\\u6B65\\u8FDB\\u5F0F\\u201D\\u7684\\u3002\\u5F53\\u4E00\\u4E2A\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u53EA\\u4E0E\\u5B83\\u7684\\u5B69\\u5B50\\u7ED3\\u70B9\\u6709\\u5173\\u65F6\\uFF0C\\u8FD9\\u4E2A\\u95EE\\u9898\\u5C31\\u53D8\\u5F97\\u7B80\\u5355\\u4E86\\u3002\\u5982\\u4E0B\\uFF1A\\n\\n    public static int rob(TreeNode root) {\\n        int[] rob = max(root);\\n        return Math.max(rob[0], rob[1]);\\n    }\\n    private static int[] max(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{0, 0};\\n        }\\n        int[] rob = new int[2];\\n        int[] left = max(node.left);\\n        int[] right = max(node.right);\\n        rob[0] = left[1] + right[1] + node.val;\\n        rob[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        return rob;\\n    }\\n\\n\\u51FD\\u6570rob\\u8FD4\\u56DE\\u4E86\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u6570\\u7EC4\\u7684\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F\\u5077\\u4E86\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u7B2C\\u4E8C\\u4E2A\\u6570\\u662F\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u7ED3\\u70B9 node \\u6765\\u8BF4\\uFF0C\\u5B83\\u53EA\\u8981\\u77E5\\u9053\\u4E86\\u5B83\\u7684\\u5DE6\\u53F3\\u5B69\\u5B50\\u7ED3\\u70B9\\u7684\\u8FD9\\u6837\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u5C31\\u53EF\\u4EE5\\u6839\\u636E\\u4E0A\\u9762\\u90A3\\u4E2A\\u6761\\u4EF6\\u6C42\\u51FA\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u6700\\u4F18\\u89E3\\uFF0C\\u56E0\\u4E3A\\u6CA1\\u6709\\u4E86\\u8DF3\\u8DC3\\u8BBF\\u95EE\\uFF0C\\u6240\\u6709\\u7684\\u7ED3\\u70B9\\u53EA\\u4F1A\\u8BBF\\u95EE\\u5230\\u4E00\\u904D\\u3002\\n",
                "solutionTags": [],
                "code": "\\u9898\\u76EE\\u4E3A\\uFF1A\\u6709\\u5F88\\u591A\\u4E92\\u76F8\\u8FDE\\u63A5\\u7684\\u623F\\u95F4\\uFF0C\\u8FD9\\u4E9B\\u623F\\u95F4\\u6B63\\u597D\\u8FDE\\u6210\\u4E00\\u68F5\\u4E8C\\u53C9\\u6811\\u7684\\u6837\\u5B50\\uFF0C\\u5C0F\\u5077\\u9700\\u8981\\u4ECE\\u8FD9\\u68F5\\u6811\\u7684\\u6839\\u7ED3\\u70B9\\u623F\\u95F4\\u51FA\\u53D1\\u5F00\\u59CB\\u5077\\u4E1C\\u897F\\u3002\\u4E3A\\u4E86\\u4E0D\\u88AB\\u6293\\u4F4F\\uFF0C\\u5C0F\\u5077\\u4E0D\\u80FD\\u5077\\u76F8\\u8FDE\\u7684\\u4E24\\u4E2A\\u623F\\u95F4\\u3002\\n\\n\\u4E8E\\u662F\\uFF0C\\u6709\\u8FD9\\u4E48\\u4E24\\u4E2A\\u8981\\u6C42\\uFF1A\\n\\n1.  \\u5982\\u679C\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u7236\\u7ED3\\u70B9\\u6CA1\\u6709\\u88AB\\u5077\\uFF0C\\u90A3\\u4E48\\u5F53\\u524D\\u7ED3\\u70B9\\u53EF\\u5077\\u53EF\\u4E0D\\u5077\\n2.  \\u5982\\u679C\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u7236\\u7ED3\\u70B9\\u88AB\\u5077\\u4E86\\uFF0C\\u90A3\\u4E48\\u5F53\\u524D\\u7ED3\\u70B9\\u4E0D\\u53EF\\u5077\\n\\n\\u6240\\u4EE5\\uFF0C\\u5F53\\u4ECE\\u6839\\u7ED3\\u70B9\\u5224\\u65AD\\u5F00\\u59CB\\u7684\\u65F6\\u5019\\uFF0C\\u6709\\uFF1A\\n\\n1.  \\u5982\\u679C\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u4E0B\\u9762\\u80FD\\u5077\\u7684\\u53EA\\u80FD\\u662F\\u81EA\\u5DF1\\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\n2.  \\u5982\\u679C\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u4E0B\\u9762\\u53EF\\u4EE5\\u5077\\u81EA\\u5DF1\\u7684\\u5B69\\u5B50\\u7ED3\\u70B9\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n    public static int rob(TreeNode node) {\\n        if (node == null) return 0;\\n        int max = rob(node.left) + rob(node.right);\\n        int m = node.val;\\n        if (node.left != null) {\\n            m += rob(node.left.left) + rob(node.left.right);\\n        }\\n        if (node.right != null) {\\n            m += rob(node.right.left) + rob(node.right.right);\\n        }\\n        max = Math.max(max, m);\\n        return max;\\n    }\\n\\n\\u5728\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4E2D\\u53EF\\u4EE5\\u770B\\u5230\\uFF0C\\u4ECE\\u7ED3\\u70B9 node \\u6709\\u4E24\\u6761\\u7EBF\\uFF0C\\u5206\\u522B\\u662F\\u8D70\\u5411 node \\u7684\\u5B50\\u7ED3\\u70B9\\u548C\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u8FD9\\u5C31\\u5BFC\\u81F4\\u4E00\\u4E2A\\u95EE\\u9898\\uFF1A\\u4F1A\\u4EA7\\u751F\\u91CD\\u590D\\u8BA1\\u7B97\\u3002\\u6BD4\\u5982\\uFF0C\\u5BF9\\u4E8E\\u4ECE node \\u7ED3\\u70B9\\u5230\\u5B83\\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u53EF\\u4EE5\\u6709\\u4E24\\u79CD\\u65B9\\u5F0F\\uFF1Anode -> \\u5B59\\u5B50\\u548Cnode -> \\u5B69\\u5B50 -> \\u5B69\\u5B50\\u3002\\u4ECE\\u4E24\\u6761\\u8DEF\\u5927\\u5230\\u8FBE\\u540C\\u4E00\\u7ED3\\u70B9\\uFF0C\\u5C31\\u662F\\u8BF4\\u4F1A\\u4ECE\\u4E24\\u4E2A\\u9012\\u5F52\\u51FD\\u6570\\u5206\\u522B\\u8FDB\\u5165 node \\u7684\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u52BF\\u5FC5\\u4F1A\\u8BA1\\u7B97\\u4E24\\u6B21\\u8FD9\\u4E2A\\u7ED3\\u70B9\\u7684\\u89E3\\u3002\\n\\n\\u6240\\u4EE5\\u9700\\u8981\\u91C7\\u53D6\\u4E00\\u5B9A\\u7684\\u63AA\\u65BD\\uFF0C\\u4F7F\\u5F97\\u91CD\\u590D\\u8FDB\\u5165\\u540C\\u4E00\\u7ED3\\u70B9\\u7684\\u65F6\\u5019\\u907F\\u514D\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u5373\\u4F7F\\u7528\\u7F13\\u5B58\\uFF1A\\n\\n    public static int rob(TreeNode root) {\\n        return rob(root, new HashMap<>());\\n    }\\n    private static int rob(TreeNode node, Map<TreeNode, Integer> saved) {\\n        if (node == null) return 0;\\n        if (saved.containsKey(node)) return saved.get(node);\\n        int max = rob(node.left, saved) + rob(node.right, saved);\\n        int m = node.val;\\n        if (node.left != null) {\\n            m += rob(node.left.left, saved) + rob(node.left.right, saved);\\n        }\\n        if (node.right != null) {\\n            m += rob(node.right.left, saved) + rob(node.right.right, saved);\\n        }\\n        max = Math.max(max, m);\\n        saved.put(node, max);\\n        return max;\\n    }\\n\\n\\u4F7F\\u7528\\u4E00\\u4E2A HashMap \\u4FDD\\u5B58\\u5DF2\\u7ECF\\u6C42\\u89E3\\u8FC7\\u7684\\u7ED3\\u70B9\\uFF0C\\u5C31\\u662F\\u4E00\\u79CD\\u7F13\\u5B58\\u7684\\u601D\\u60F3\\u3002\\n\\n\\u518D\\u770B\\u672C\\u65B9\\u6CD5\\u7684\\u7F3A\\u9677\\uFF0C\\u8FD9\\u662F\\u4E00\\u79CD\\u201C\\u8DF3\\u8DC3\\u5F0F\\u201D\\u7684\\u89E3\\u6CD5\\uFF0C\\u4ECE\\u4E00\\u4E2A\\u7ED3\\u70B9\\u51FA\\u53D1\\u5230\\u53E6\\u4E00\\u4E2A\\u7ED3\\u70B9\\uFF0C\\u4F1A\\u6709\\u591A\\u6761\\u8DEF\\u5F84\\uFF0C\\u800C\\u591A\\u6761\\u8DEF\\u5F84\\u4F1A\\u5BFC\\u81F4\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u90A3\\u4E48\\u5982\\u679C\\u80FD\\u4F7F\\u5B83\\u4E0D\\u518D\\u8DF3\\u8DC3\\uFF0C\\u53EA\\u80FD\\u4E00\\u6B65\\u4E00\\u6B65\\u5F80\\u4E0B\\u8D70\\u7684\\u8BDD\\uFF0C\\u8FD9\\u4E2A\\u91CD\\u590D\\u8BA1\\u7B97\\u4E5F\\u5C31\\u4E0D\\u590D\\u5B58\\u5728\\u4E86\\u3002\\n\\n\\u5982\\u4F55\\u6539\\u8FDB\\uFF1F\\u5C0F\\u5077\\u5BF9\\u4E8E\\u6BCF\\u4E2A\\u7ED3\\u70B9\\u6709\\u4E24\\u79CD\\u5904\\u7406\\uFF1A\\u5077\\u6216\\u4E0D\\u5077\\u3002\\n\\n1.  \\u5982\\u679C\\u5C0F\\u5077\\u5077\\u4E86\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u5B83\\u7684\\u5B50\\u7ED3\\u70B9\\u4E0D\\u80FD\\u5077\\n2.  \\u5982\\u679C\\u5C0F\\u5077\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\uFF0C\\u90A3\\u4E48\\u5B50\\u7ED3\\u70B9\\u53EF\\u4EE5\\u5077\\uFF0C\\u4E5F\\u53EF\\u4EE5\\u4E0D\\u5077\\uFF08\\u53D6\\u5176\\u4E2D\\u8F83\\u5927\\u7684\\u5373\\u53EF\\uFF09\\n\\n\\u8FD9\\u6B21\\u7684\\u6761\\u4EF6\\u597D\\u50CF\\u4E0E\\u4E0A\\u9762\\u7684\\u6761\\u4EF6\\u4E00\\u6837\\uFF0C\\u4F46\\u662F\\u8FD8\\u662F\\u6709\\u533A\\u522B\\u7684\\uFF0C\\u90A3\\u4E2A\\u6D89\\u53CA\\u5230\\u4E86\\u5B59\\u5B50\\u7ED3\\u70B9\\uFF0C\\u800C\\u8FD9\\u4E2A\\uFF0C\\u53EA\\u6D89\\u53CA\\u5230\\u5B69\\u5B50\\uFF0C\\u5982\\u679C\\u4E0A\\u9762\\u90A3\\u4E2A\\u662F\\u201C\\u8DF3\\u8DC3\\u5F0F\\u201D\\u7684\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u5C31\\u662F\\u201C\\u6B65\\u8FDB\\u5F0F\\u201D\\u7684\\u3002\\u5F53\\u4E00\\u4E2A\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u53EA\\u4E0E\\u5B83\\u7684\\u5B69\\u5B50\\u7ED3\\u70B9\\u6709\\u5173\\u65F6\\uFF0C\\u8FD9\\u4E2A\\u95EE\\u9898\\u5C31\\u53D8\\u5F97\\u7B80\\u5355\\u4E86\\u3002\\u5982\\u4E0B\\uFF1A\\n\\n    public static int rob(TreeNode root) {\\n        int[] rob = max(root);\\n        return Math.max(rob[0], rob[1]);\\n    }\\n    private static int[] max(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{0, 0};\\n        }\\n        int[] rob = new int[2];\\n        int[] left = max(node.left);\\n        int[] right = max(node.right);\\n        rob[0] = left[1] + right[1] + node.val;\\n        rob[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        return rob;\\n    }\\n\\n\\u51FD\\u6570rob\\u8FD4\\u56DE\\u4E86\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u6570\\u7EC4\\u7684\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F\\u5077\\u4E86\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u7B2C\\u4E8C\\u4E2A\\u6570\\u662F\\u4E0D\\u5077\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u89E3\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E\\u4E00\\u4E2A\\u7ED3\\u70B9 node \\u6765\\u8BF4\\uFF0C\\u5B83\\u53EA\\u8981\\u77E5\\u9053\\u4E86\\u5B83\\u7684\\u5DE6\\u53F3\\u5B69\\u5B50\\u7ED3\\u70B9\\u7684\\u8FD9\\u6837\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u5C31\\u53EF\\u4EE5\\u6839\\u636E\\u4E0A\\u9762\\u90A3\\u4E2A\\u6761\\u4EF6\\u6C42\\u51FA\\u5F53\\u524D\\u7ED3\\u70B9\\u7684\\u6700\\u4F18\\u89E3\\uFF0C\\u56E0\\u4E3A\\u6CA1\\u6709\\u4E86\\u8DF3\\u8DC3\\u8BBF\\u95EE\\uFF0C\\u6240\\u6709\\u7684\\u7ED3\\u70B9\\u53EA\\u4F1A\\u8BBF\\u95EE\\u5230\\u4E00\\u904D\\u3002\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 131263,
                "title": "python-3-iterative-and-recursive-solution",
                "content": "```\\n# the value in the couple is (yesrob, norob)\\n# yesrob is the max amount with robbing the current node\\n# norob is the max amount without robbing the current node\\nclass Solution_iterative_postorder:\\n    def rob(self, root):\\n        stack = [(0, root)]\\n        d = {None: (0, 0)}\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n            else:\\n                yesrob = d[node.left][1] + d[node.right][1] + node.val\\n                norob = max(d[node.left]) + max(d[node.right])\\n                d[node] = (yesrob, norob)\\n        return max(d[root])\\n\\n\\nclass Solution_recursive:\\n    def rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def couple(root):\\n            if root is None:\\n                return (0, 0)\\n            left = couple(root.left)\\n            right = couple(root.right)\\n            return (left[1] + right[1] + root.val, max(left) + max(right))\\n\\n        return max(couple(root))\\n```",
                "solutionTags": [],
                "code": "```\\n# the value in the couple is (yesrob, norob)\\n# yesrob is the max amount with robbing the current node\\n# norob is the max amount without robbing the current node\\nclass Solution_iterative_postorder:\\n    def rob(self, root):\\n        stack = [(0, root)]\\n        d = {None: (0, 0)}\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n            else:\\n                yesrob = d[node.left][1] + d[node.right][1] + node.val\\n                norob = max(d[node.left]) + max(d[node.right])\\n                d[node] = (yesrob, norob)\\n        return max(d[root])\\n\\n\\nclass Solution_recursive:\\n    def rob(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def couple(root):\\n            if root is None:\\n                return (0, 0)\\n            left = couple(root.left)\\n            right = couple(root.right)\\n            return (left[1] + right[1] + root.val, max(left) + max(right))\\n\\n        return max(couple(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79395,
                "title": "short-python-solution",
                "content": "    class Solution(object):\\n        def rob(self, root):\\n            def solve(root):\\n                if not root:\\n                    return 0, 0\\n                left, right = solve(root.left), solve(root.right)\\n                return (root.val + left[1] + right[1]), (max(left) + max(right))\\n            return max(solve(root))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def rob(self, root):\\n            def solve(root):\\n                if not root:\\n                    return 0, 0\\n                left, right = solve(root.left), solve(root.right)\\n                return (root.val + left[1] + right[1]), (max(left) + max(right))\\n            return max(solve(root))",
                "codeTag": "Java"
            },
            {
                "id": 79472,
                "title": "6-line-python-solution-return-subtree-max-money-if-not-rob-this-node-subtree-max-money",
                "content": "    def rob(self, root):\\n        def dfs(node):\\n            # return (subtree max money if not rob this node, subtree max money)\\n            if not node: return 0, 0\\n            max_l_ignore, max_l = dfs(node.left)\\n            max_r_ignore, max_r = dfs(node.right)\\n            return max_l + max_r, max(max_l + max_r, node.val + max_l_ignore + max_r_ignore)\\n\\n        return dfs(root)[1]",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def rob(self, root):\\n        def dfs(node):\\n            # return (subtree max money if not rob this node, subtree max money)\\n            if not node: return 0, 0\\n            max_l_ignore, max_l = dfs(node.left)\\n            max_r_ignore, max_r = dfs(node.right)\\n            return max_l + max_r, max(max_l + max_r, node.val + max_l_ignore + max_r_ignore)\\n\\n        return dfs(root)[1]",
                "codeTag": "Python3"
            },
            {
                "id": 79406,
                "title": "c-implementation-refer-to-fun4leetcode",
                "content": "First naive Solution \\n\\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            if(root == NULL)  return 0;\\n            int val = 0;\\n            if(root->left) {\\n                val += rob(root->left->left) + rob(root->left->right);\\n            }\\n            if(root->right) {\\n                val += rob(root->right->left) + rob(root->right->right);\\n            }\\n            return max(val + root->val, rob(root->left) + rob(root->right));\\n        }\\n    };\\n\\nSecond, use the dict to record the sub-problem information method\\n\\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            unordered_map<TreeNode*, int> dict;\\n            return help(root, dict);\\n        }\\n        \\n        int help(TreeNode* root, unordered_map<TreeNode*, int>& dict) {\\n            if(root == NULL)  return 0;\\n            if(dict.find(root)!=dict.end())  return dict[root];\\n            int val = 0;\\n            if(root->left != NULL) {\\n                val += help(root->left->left, dict) + help(root->left->right, dict);\\n            }\\n            if(root->right != NULL) {\\n                val += help(root->right->left, dict) + help(root->right->right, dict);\\n            }\\n            val = max(val + root->val, help(root->left, dict) + help(root->right, dict));\\n            dict[root] = val;\\n            return val;\\n        }\\n    };\\n\\nThird Solution  is optimized a bit :\\n\\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            vector<int> result = help(root);\\n            return max(result[0], result[1]);\\n        }\\n        /**\\n         * result[0] : record the max sum exclude the root value\\n         * result[1] : record the max sum include the root value\\n         **/\\n        vector<int> help(TreeNode* root) {\\n            vector<int> result(2, 0);\\n            if(!root) {\\n                return result;\\n            }\\n            vector<int> left = help(root->left);\\n            vector<int> right = help(root->right);\\n            /** root excluded : so we can include the child or not **/\\n            result[0] = max(left[0], left[1]) + max(right[0], right[1]);\\n            /** root included : so must exclude the child **/\\n            result[1] = root->val + left[0] + right[0];\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            if(root == NULL)  return 0;\\n            int val = 0;\\n            if(root->left) {\\n                val += rob(root->left->left) + rob(root->left->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79519,
                "title": "12-ms-c-solution",
                "content": "    class Solution {\\n    public:\\n    \\tint rob(TreeNode* root) \\n    \\t{\\n    \\t\\tint mt, ms;\\n    \\t\\trob(root, mt, ms);\\n    \\t\\treturn max(mt, ms);\\n    \\t}\\n    \\n    \\tvoid rob(TreeNode* node, int& mt, int& ms)\\n    \\t{\\n    \\t\\tmt = ms = 0;\\n    \\t\\tif (!node) return;\\n    \\n    \\t\\tint mtl, mtr, msl, msr;\\n    \\t\\trob(node->left, mtl, msl);\\n    \\t\\trob(node->right, mtr, msr);\\n    \\n    \\t\\tmt = msl + msr + node->val;\\n    \\t\\tms = max(mtl, msl) + max(mtr, msr);\\n    \\t\\treturn;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint rob(TreeNode* root) \\n    \\t{\\n    \\t\\tint mt, ms;\\n    \\t\\trob(root, mt, ms);\\n    \\t\\treturn max(mt, ms);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 79504,
                "title": "java-bottom-up-and-top-down-solutions-using-dp",
                "content": "The naive solution is straightforward, just traverse the tree and in each node, we either take it or not.  If we take it, we cannot take its children, if not take, we can take either or both of the children.  This will cause TLE due to extra calculation.  Since this is a house robber problem, DP is the first come to mind for optimization.  There are two ways to work with this problem.  The top-down is the most intuitive one for me, as follows.  Used two map, hasRoot and noRoot, since we need to keep track of the result for either rob the house or not. \\n\\nThe second approach is bottom-up.  It is not very intuitive for a tree.  But one can think about post-order traversal.  We traverse the left and the right child and return some necessary result, and then process the root.  First, what do we need the child to return?  So from the first solution, we can see that we either rob a house or not, so the child needs to return two values, *rob* or *no rob* for the root.  Here we can just use an int array to keep the two values.   `// traverse the tree   int[] left = helper(curr.left); int[] right = helper(curr.right);`  Here left[0] represents robbing root node, left[1] not robbing.  \\n\\nThen we do stuff for the root node.   We need an int array again to save its result.  We either rob root, and take the `left[1]` and `right[1]` and add root value to it, or we don't rob root, and take the largest one for left and right.  In the end, we just return res.  \\n\\nHere are two solutions, hope it helps!\\n\\n\\nTop-down approach:\\n\\n        Map<TreeNode, Integer> hasRoot = new HashMap<>();\\n        Map<TreeNode, Integer> noRoot = new HashMap<>();\\n        public int rob(TreeNode root) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            int max = Math.max(helper(root, true), helper(root, false));\\n            return max;\\n        }\\n    \\n        private int helper(TreeNode root, boolean canrob) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            int res = 0;\\n            if (canrob) {\\n                // check the hasRoot map for previous calculated\\n                if(hasRoot.containsKey(root)) {\\n                    return hasRoot.get(root);\\n                }\\n                res = Math.max(helper(root.left, false) + helper(root.right, false) + root.val, helper(root.left, true) + helper(root.right, true));\\n                hasRoot.put(root, res);\\n            } else {\\n                // check the noRoot map\\n                if(noRoot.containsKey(root)) {\\n                    return noRoot.get(root);\\n                }\\n                res = helper(root.left, true) + helper(root.right, true);\\n                noRoot.put(root, res);\\n            }\\n            return res;\\n        }\\n\\n\\nBottom-up:\\n\\n        // bottom-up solution\\n        public int rob(TreeNode root) {\\n            int[] num = helper(root);\\n            // nums[0] includes root, nums[1] excludes root\\n            return Math.max(num[0], num[1]);\\n        }\\n        private int[] helper(TreeNode curr) {\\n            if (curr == null) {\\n                return new int[2];\\n            }\\n            // traverse the tree\\n            int[] left = helper(curr.left);\\n            int[] right = helper(curr.right);\\n            \\n            // do stuff\\n            \\n            int[] res = new int[2];\\n            // case 1:  add root value, so exclude both left and right\\n            res[0] = left[1] + right[1] + curr.val;  \\n            // case 2: exclued root value, get max from both left child and right child\\n            res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);  \\n            \\n            // done stuff\\n            \\n            return res;\\n        }",
                "solutionTags": [],
                "code": "The naive solution is straightforward, just traverse the tree and in each node, we either take it or not.  If we take it, we cannot take its children, if not take, we can take either or both of the children.  This will cause TLE due to extra calculation.  Since this is a house robber problem, DP is the first come to mind for optimization.  There are two ways to work with this problem.  The top-down is the most intuitive one for me, as follows.  Used two map, hasRoot and noRoot, since we need to keep track of the result for either rob the house or not. \\n\\nThe second approach is bottom-up.  It is not very intuitive for a tree.  But one can think about post-order traversal.  We traverse the left and the right child and return some necessary result, and then process the root.  First, what do we need the child to return?  So from the first solution, we can see that we either rob a house or not, so the child needs to return two values, *rob* or *no rob* for the root.  Here we can just use an int array to keep the two values.   `// traverse the tree   int[] left = helper(curr.left); int[] right = helper(curr.right);`  Here left[0] represents robbing root node, left[1] not robbing.  \\n\\nThen we do stuff for the root node.   We need an int array again to save its result.  We either rob root, and take the `left[1]` and `right[1]` and add root value to it, or we don't rob root, and take the largest one for left and right.  In the end, we just return res.  \\n\\nHere are two solutions, hope it helps!\\n\\n\\nTop-down approach:\\n\\n        Map<TreeNode, Integer> hasRoot = new HashMap<>();\\n        Map<TreeNode, Integer> noRoot = new HashMap<>();\\n        public int rob(TreeNode root) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            int max = Math.max(helper(root, true), helper(root, false));\\n            return max;\\n        }\\n    \\n        private int helper(TreeNode root, boolean canrob) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            int res = 0;\\n            if (canrob) {\\n                // check the hasRoot map for previous calculated\\n                if(hasRoot.containsKey(root)) {\\n                    return hasRoot.get(root);\\n                }\\n                res = Math.max(helper(root.left, false) + helper(root.right, false) + root.val, helper(root.left, true) + helper(root.right, true));\\n                hasRoot.put(root, res);\\n            } else {\\n                // check the noRoot map\\n                if(noRoot.containsKey(root)) {\\n                    return noRoot.get(root);\\n                }\\n                res = helper(root.left, true) + helper(root.right, true);\\n                noRoot.put(root, res);\\n            }\\n            return res;\\n        }\\n\\n\\nBottom-up:\\n\\n        // bottom-up solution\\n        public int rob(TreeNode root) {\\n            int[] num = helper(root);\\n            // nums[0] includes root, nums[1] excludes root\\n            return Math.max(num[0], num[1]);\\n        }\\n        private int[] helper(TreeNode curr) {\\n            if (curr == null) {\\n                return new int[2];\\n            }\\n            // traverse the tree\\n            int[] left = helper(curr.left);\\n            int[] right = helper(curr.right);\\n            \\n            // do stuff\\n            \\n            int[] res = new int[2];\\n            // case 1:  add root value, so exclude both left and right\\n            res[0] = left[1] + right[1] + curr.val;  \\n            // case 2: exclued root value, get max from both left child and right child\\n            res[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);  \\n            \\n            // done stuff\\n            \\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 79525,
                "title": "14ms-java-solution",
                "content": "     public int rob(TreeNode root) {\\n        Map<TreeNode, Integer> include = new HashMap<>();\\n        Map<TreeNode, Integer> exclude = new HashMap<>();\\n        return helper(root, false, exclude, include);\\n    }\\n    \\n    private int helper(TreeNode cur, boolean parentRobbed, Map<TreeNode, Integer> exclude, Map<TreeNode, Integer> include)\\n    {\\n        if (cur == null)\\n        {\\n            return 0;\\n        }\\n        \\n        int ret = Integer.MIN_VALUE;\\n        \\n        int leftMax  = 0;\\n        int rightMax = 0;\\n       \\n        // do not rob the current house\\n        // ------------------------------------ \\n        if (!exclude.containsKey(cur))\\n        {\\n            leftMax  = helper(cur.left, false, exclude, include);\\n            rightMax = helper(cur.right, false, exclude, include);\\n            exclude.put(cur, leftMax + rightMax);\\n        }\\n        ret = Math.max(ret, exclude.get(cur));\\n        \\n        // if parent house is not robbed, rob the current house\\n        // ------------------------------------------------------------------\\n        if (!parentRobbed)\\n        {\\n            // rob the current house\\n            // ----------------------------\\n            if (!include.containsKey(cur))\\n            {\\n                leftMax  = helper(cur.left, true, exclude, include);\\n                rightMax = helper(cur.right, true, exclude, include);\\n                include.put(cur, cur.val + leftMax + rightMax);\\n            }\\n            ret = Math.max(ret, include.get(cur));\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "     public int rob(TreeNode root) {\\n        Map<TreeNode, Integer> include = new HashMap<>();\\n        Map<TreeNode, Integer> exclude = new HashMap<>();\\n        return helper(root, false, exclude, include);\\n    }\\n    \\n    private int helper(TreeNode cur, boolean parentRobbed, Map<TreeNode, Integer> exclude, Map<TreeNode, Integer> include)\\n    {\\n        if (cur == null)\\n        {\\n            return 0;\\n        }\\n        \\n        int ret = Integer.MIN_VALUE;\\n        \\n        int leftMax  = 0;\\n        int rightMax = 0;\\n       \\n        // do not rob the current house\\n        // ------------------------------------ \\n        if (!exclude.containsKey(cur))\\n        {\\n            leftMax  = helper(cur.left, false, exclude, include);\\n            rightMax = helper(cur.right, false, exclude, include);\\n            exclude.put(cur, leftMax + rightMax);\\n        }\\n        ret = Math.max(ret, exclude.get(cur));\\n        \\n        // if parent house is not robbed, rob the current house\\n        // ------------------------------------------------------------------\\n        if (!parentRobbed)\\n        {\\n            // rob the current house\\n            // ----------------------------\\n            if (!include.containsKey(cur))\\n            {\\n                leftMax  = helper(cur.left, true, exclude, include);\\n                rightMax = helper(cur.right, true, exclude, include);\\n                include.put(cur, cur.val + leftMax + rightMax);\\n            }\\n            ret = Math.max(ret, include.get(cur));\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3748838,
                "title": "easy-c-solution-using-c",
                "content": "\\n# Approach\\nThe solve function takes a TreeNode* representing the root of a binary tree and returns a pair of integers. The pair contains two values: the maximum amount of money that can be robbed from the subtree rooted at root if root is included, and the maximum amount of money that can be robbed if root is not included.\\n\\nInside the solve function, the base case is checked first. If the root is NULL, indicating an empty subtree, a pair of zeros is returned.\\n\\nRecursively, the solve function is called for the left and right subtrees, and their results are stored in the left and right pairs.\\n\\nA new pair result is created to store the maximum amounts of money for the current subtree. The first value of result is calculated by adding the value of root->val (the money in the current house) to the sums of the second values from the left and right pairs (representing the maximum amounts when root is not included).\\n\\nThe second value of result is calculated by taking the maximum of the first and second values from the left pair and adding it to the maximum of the first and second values from the right pair.\\n\\nFinally, the maximum value between the first and second values of result is returned as the maximum amount of money that can be robbed.\\n\\nIn the rob function, the solve function is called for the root node, and the maximum of the first and second values from the returned pair is returned as the maximum amount of money that can be robbed from the entire binary tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\npair<int,int >solve(TreeNode* root)\\n{\\n    if(root==NULL)\\n        {\\n           pair<int,int>p=make_pair(0,0);\\n           return p;\\n        }\\n        pair<int,int>left=solve(root->left);\\n        pair<int,int>right=solve(root->right);\\n        pair<int,int > result;\\n        result.first=root->val+left.second+right.second;\\n        result.second=max(left.first,left.second)+max(right.first,right.second);\\n        return {result.first,result.second};\\n\\n}\\n    int rob(TreeNode* root)\\n    {\\n        pair<int,int>n=solve(root);\\n        return max(n.first, n.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\npair<int,int >solve(TreeNode* root)\\n{\\n    if(root==NULL)\\n        {\\n           pair<int,int>p=make_pair(0,0);\\n           return p;\\n        }\\n        pair<int,int>left=solve(root->left);\\n        pair<int,int>right=solve(root->right);\\n        pair<int,int > result;\\n        result.first=root->val+left.second+right.second;\\n        result.second=max(left.first,left.second)+max(right.first,right.second);\\n        return {result.first,result.second};\\n\\n}\\n    int rob(TreeNode* root)\\n    {\\n        pair<int,int>n=solve(root);\\n        return max(n.first, n.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955628,
                "title": "ezz-javascript-solution-dfs",
                "content": "# Intuition\\nGetting Max out of left sub tree and right subree. Calc. max withRoot and withoutRoot\\n\\n# Approach\\nPerform DFS and maintain two states using pair: [MaxValuewithRoot, MaxValueWithoutRoot]\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    const dfs =(root)=>{\\n        //BASE CASE\\n        if(!root)return [0,0]\\n\\n        //RESULT: from LEFT subtree\\n        const left = dfs(root.left);\\n\\n        //RESULT: from LEFT subtree\\n        const right = dfs(root.right);\\n\\n        //result including the root. Cannot include the prev. val(withRoot) from left and right subree\\'s\\n        const withRoot = root.val+left[1]+ right[1];\\n\\n        //result excluding the root. MAX:could be anything out from left and right subtree\\'s (including or excluding from prev result)\\n        const withoutRoot = Math.max(...left) + Math.max(...right);\\n\\n        //FINALLY: returning a pair at each node step\\n        return [withRoot, withoutRoot];\\n    }\\n\\n    //ezz    \\n    return Math.max(...dfs(root));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    const dfs =(root)=>{\\n        //BASE CASE\\n        if(!root)return [0,0]\\n\\n        //RESULT: from LEFT subtree\\n        const left = dfs(root.left);\\n\\n        //RESULT: from LEFT subtree\\n        const right = dfs(root.right);\\n\\n        //result including the root. Cannot include the prev. val(withRoot) from left and right subree\\'s\\n        const withRoot = root.val+left[1]+ right[1];\\n\\n        //result excluding the root. MAX:could be anything out from left and right subtree\\'s (including or excluding from prev result)\\n        const withoutRoot = Math.max(...left) + Math.max(...right);\\n\\n        //FINALLY: returning a pair at each node step\\n        return [withRoot, withoutRoot];\\n    }\\n\\n    //ezz    \\n    return Math.max(...dfs(root));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2845283,
                "title": "c-space-optimized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time complexity - O(N)\\n    // vector<int> of size = 2 where -> [pick, not pick]\\n    vector<int> traverser(TreeNode* curr){\\n        if(!curr){\\n            return {0, 0};\\n        }\\n        \\n        vector<int>l, r, t;\\n        l = traverser(curr->left);\\n        r = traverser(curr->right);\\n        \\n        t.push_back( l[1] + r[1] + curr->val );\\n        t.push_back( max(l[0], l[1]) + max(r[0], r[1]) );\\n        \\n        return t;\\n    }\\n    int rob(TreeNode* root) {\\n        vector<int>holder = traverser(root);\\n        return max(holder[0], holder[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time complexity - O(N)\\n    // vector<int> of size = 2 where -> [pick, not pick]\\n    vector<int> traverser(TreeNode* curr){\\n        if(!curr){\\n            return {0, 0};\\n        }\\n        \\n        vector<int>l, r, t;\\n        l = traverser(curr->left);\\n        r = traverser(curr->right);\\n        \\n        t.push_back( l[1] + r[1] + curr->val );\\n        t.push_back( max(l[0], l[1]) + max(r[0], r[1]) );\\n        \\n        return t;\\n    }\\n    int rob(TreeNode* root) {\\n        vector<int>holder = traverser(root);\\n        return max(holder[0], holder[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599087,
                "title": "c-solution",
                "content": "```\\nstruct Rob\\n{\\n    int withRobbery;\\n    int withoutRobbery;\\n    Rob(){\\n        withRobbery=0;\\n        withoutRobbery=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n      \\nint rob(TreeNode* root) {\\n        Rob result=fun(root);\\n    return max(result.withRobbery,result.withoutRobbery); \\n    }\\n    Rob fun(TreeNode* root)\\n    {\\n      if(!root)\\n          return Rob();\\n        \\n        // Left se kitna aayega\\n        Rob left=fun(root->left);\\n        \\n        // right se kitna aayega\\n        Rob right=fun(root->right);\\n        \\n        // Ab yadi current pr robbery kru \\n           // to left se without robbery kitna max aayega\\n           // to right se without robbery kitna max aayega\\n      Rob ans=Rob();\\n        ans.withRobbery=root->val;\\n        ans.withRobbery+=(left.withoutRobbery+right.withoutRobbery);\\n        \\n        // Ab yadi current pr robbery na kru\\n           // to left se with robbery or without robbery wale me se max \\n           // to right se with robbery or wihtou robbery wale me se max\\n           ans.withoutRobbery=0;\\n          ans.withoutRobbery+=max(left.withoutRobbery,left.withRobbery)+max(right.withoutRobbery,right.withRobbery);\\n        return ans;\\n     \\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n) ----> due to recursion.\\n```\\n\\n***please correct me if done something wrong, especially time and space complexity.***\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELFPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nstruct Rob\\n{\\n    int withRobbery;\\n    int withoutRobbery;\\n    Rob(){\\n        withRobbery=0;\\n        withoutRobbery=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n      \\nint rob(TreeNode* root) {\\n        Rob result=fun(root);\\n    return max(result.withRobbery,result.withoutRobbery); \\n    }\\n    Rob fun(TreeNode* root)\\n    {\\n      if(!root)\\n          return Rob();\\n        \\n        // Left se kitna aayega\\n        Rob left=fun(root->left);\\n        \\n        // right se kitna aayega\\n        Rob right=fun(root->right);\\n        \\n        // Ab yadi current pr robbery kru \\n           // to left se without robbery kitna max aayega\\n           // to right se without robbery kitna max aayega\\n      Rob ans=Rob();\\n        ans.withRobbery=root->val;\\n        ans.withRobbery+=(left.withoutRobbery+right.withoutRobbery);\\n        \\n        // Ab yadi current pr robbery na kru\\n           // to left se with robbery or without robbery wale me se max \\n           // to right se with robbery or wihtou robbery wale me se max\\n           ans.withoutRobbery=0;\\n          ans.withoutRobbery+=max(left.withoutRobbery,left.withRobbery)+max(right.withoutRobbery,right.withRobbery);\\n        return ans;\\n     \\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n) ----> due to recursion.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548096,
                "title": "c-simple-most-intuitive-code-with-comments-dp-on-trees",
                "content": "```\\nclass Solution {\\n    \\n    //Include Exclude Algorithm\\n    \\n    vector<int> solve(TreeNode * root){ \\n        \\n        vector<int> v = {0,0}; // {include, exclude}\\n        \\n        if(!root)\\n            return v;\\n        \\n        vector<int> l = solve(root->left);\\n        vector<int> r = solve(root->right);\\n        \\n        //if we include node\\n        v[0] = root->val + l[1] + r[1];\\n        \\n        //if we exclude node\\n        v[1] = max(v[1], l[0]+r[0]); /*include both lower*/\\n        v[1] = max(v[1], l[1]+r[1]); /*exclude both lower*/\\n        v[1] = max(v[1], l[0]+r[1]); /*include left*/\\n        v[1] = max(v[1], l[1]+r[0]); /*include right*/\\n        \\n        return v;\\n    }\\n    \\npublic:\\n    int rob(TreeNode* root) {\\n        \\n        vector<int> v = solve(root);\\n        return max(v[0],v[1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //Include Exclude Algorithm\\n    \\n    vector<int> solve(TreeNode * root){ \\n        \\n        vector<int> v = {0,0}; // {include, exclude}\\n        \\n        if(!root)\\n            return v;\\n        \\n        vector<int> l = solve(root->left);\\n        vector<int> r = solve(root->right);\\n        \\n        //if we include node\\n        v[0] = root->val + l[1] + r[1];\\n        \\n        //if we exclude node\\n        v[1] = max(v[1], l[0]+r[0]); /*include both lower*/\\n        v[1] = max(v[1], l[1]+r[1]); /*exclude both lower*/\\n        v[1] = max(v[1], l[0]+r[1]); /*include left*/\\n        v[1] = max(v[1], l[1]+r[0]); /*include right*/\\n        \\n        return v;\\n    }\\n    \\npublic:\\n    int rob(TreeNode* root) {\\n        \\n        vector<int> v = solve(root);\\n        return max(v[0],v[1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304649,
                "title": "mast-sol-very-easy-to-understand-simple-recursive-approach",
                "content": "If don\\'t understand comment down below i will try to answer.\\n\\n```class Solution {\\npublic:\\n    map< TreeNode*, int > dp; \\n    int rob(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n      if(dp.count(root)) return dp[root];\\n        \\n        int first  = 0;\\n        int second = 0;\\n        int third = 0;\\n        int fourth = 0;\\n        \\n        if(root->left != NULL) {\\n             first = rob(root->left->left);\\n             second = rob(root->left->right);\\n        }   \\n        if(root->right != NULL) {\\n            third = rob(root->right->left);\\n            fourth = rob(root->right->right);\\n        }\\n        \\n        int firstWay = root->val + first + second + third + fourth;\\n        int secondWay = rob(root->left) + rob(root->right);\\n\\n        return dp[root] = max(firstWay, secondWay);\\n    }\\n};\\n```\\n\\nIf Liked the solution then please upvote.\\nThanks!!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    map< TreeNode*, int > dp; \\n    int rob(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        \\n      if(dp.count(root)) return dp[root];\\n        \\n        int first  = 0;\\n        int second = 0;\\n        int third = 0;\\n        int fourth = 0;\\n        \\n        if(root->left != NULL) {\\n             first = rob(root->left->left);\\n             second = rob(root->left->right);\\n        }   \\n        if(root->right != NULL) {\\n            third = rob(root->right->left);\\n            fourth = rob(root->right->right);\\n        }\\n        \\n        int firstWay = root->val + first + second + third + fourth;\\n        int secondWay = rob(root->left) + rob(root->right);\\n\\n        return dp[root] = max(firstWay, secondWay);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212395,
                "title": "intuitive-c-solution",
                "content": "This is similar to 1-D problem where we need to choose elements from array of elements such that no two of them are adjacent in array and their sum is maximum. Thinking in terms of DP we can denote by DP[i],solution for subarray from first index till ith index. so solution will be. **DP[i]=max(DP[i-1],A[i]+DP[i-2])**(corresponding to two cases where we either include ith index or not).In tree , we have to think in terms of child nodes,here we will make two DP,DP1 and DP2. where DP1[v] will represent case when we include,vertex v and DP2[v] represent maximum sum, not including vth vertex. so, the resulting formula will be.\\n**DP1[v]=v->val+DP2[v->left]+DP2[v->right]. and DP2[v]=max(DP1[v->left],DP2[v->left])+=max(DP1[v->right],DP2[v->right].**.In the solution code pair first element represent DP1[v],and pair\\'s second element represent DP2[v].\\n```\\nclass Solution {\\npublic:\\n   \\n    pair<int,int> dfs(TreeNode* root)\\n    {\\n        if(!root)return {0,0};\\n        auto p1=dfs(root->left);\\n        auto p2=dfs(root->right);\\n        int x,y;\\n        x=root->val+(p1.second+p2.second);\\n        y=max(p1.first,p1.second)+max(p2.first,p2.second);\\n      \\n        return {x,y};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->left==nullptr && root->right==nullptr)return root->val;\\n        \\n        pair<int,int> ans=dfs(root);\\n        \\n        return max(ans.first,ans.second);\\n    }\\n};\\n```\\n\\nP.S if you like the solution,plese upvote.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    pair<int,int> dfs(TreeNode* root)\\n    {\\n        if(!root)return {0,0};\\n        auto p1=dfs(root->left);\\n        auto p2=dfs(root->right);\\n        int x,y;\\n        x=root->val+(p1.second+p2.second);\\n        y=max(p1.first,p1.second)+max(p2.first,p2.second);\\n      \\n        return {x,y};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)return 0;\\n        if(root->left==nullptr && root->right==nullptr)return root->val;\\n        \\n        pair<int,int> ans=dfs(root);\\n        \\n        return max(ans.first,ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893859,
                "title": "easy-understanding-with-comments-java",
                "content": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        //maintain this to avoid repetitive subproblem calculations\\n        HashMap<TreeNode, Integer> memo = new HashMap<>();\\n        return robRecursive(root, memo);\\n    }\\n    \\n    public int robRecursive(TreeNode node, HashMap<TreeNode, Integer> memo){\\n        if(node == null)\\n            return 0;\\n        \\n        //If already calculated, return the result for that node\\n        if(memo.containsKey(node))\\n            return memo.get(node);\\n        \\n        // Selecting current house and skipping it\\'s children if children is not NULL, call its grand children instead, if children is NULL, take 0\\n        int robCurrentHouse = node.val +\\n            (node.left == null? 0: robRecursive(node.left.left, memo) + robRecursive(node.left.right,memo)) +\\n            (node.right == null? 0: robRecursive(node.right.left, memo) + robRecursive(node.right.right,memo));\\n         \\n        //If we are skipping current house, lets consider it\\'s children\\n        int skipCurrentHouse = robRecursive(node.left, memo) + robRecursive(node.right, memo);\\n        \\n        //Add the newly calculated amount to the respective node on the map\\n        memo.put(node, Math.max(robCurrentHouse, skipCurrentHouse));\\n        \\n        return Math.max(robCurrentHouse, skipCurrentHouse);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n        \\n        //maintain this to avoid repetitive subproblem calculations\\n        HashMap<TreeNode, Integer> memo = new HashMap<>();\\n        return robRecursive(root, memo);\\n    }\\n    \\n    public int robRecursive(TreeNode node, HashMap<TreeNode, Integer> memo){\\n        if(node == null)\\n            return 0;\\n        \\n        //If already calculated, return the result for that node\\n        if(memo.containsKey(node))\\n            return memo.get(node);\\n        \\n        // Selecting current house and skipping it\\'s children if children is not NULL, call its grand children instead, if children is NULL, take 0\\n        int robCurrentHouse = node.val +\\n            (node.left == null? 0: robRecursive(node.left.left, memo) + robRecursive(node.left.right,memo)) +\\n            (node.right == null? 0: robRecursive(node.right.left, memo) + robRecursive(node.right.right,memo));\\n         \\n        //If we are skipping current house, lets consider it\\'s children\\n        int skipCurrentHouse = robRecursive(node.left, memo) + robRecursive(node.right, memo);\\n        \\n        //Add the newly calculated amount to the respective node on the map\\n        memo.put(node, Math.max(robCurrentHouse, skipCurrentHouse));\\n        \\n        return Math.max(robCurrentHouse, skipCurrentHouse);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690947,
                "title": "very-clean-simple-c-easy-to-understand-solution-with-image-and-detail-explanation",
                "content": "To solve these type of questions we have to consider two cases.\\n01. To choose the current node in our optimal solution.\\n02. To not choose the current node in our optimal solution.\\n\\nSimple isn\\'t it? If not don\\'t worry read till end.\\n\\nSuppose the robber had robbed the root house then he can\\'t rob the left and right house. right??\\nSo this lies in the first case. To maximize his robbery he will look for next possible houses to rob, which will .....???? guess guess.... Ok those will be left and right child of the left child of root and left and right child of the right child of root. Confusing?? See the image.\\n\\n![image](https://assets.leetcode.com/users/images/7e290b71-6a11-4889-84e9-7b5f698c9ac4_1642224789.9577794.jpeg)\\n\\nWe will rob the houses colored in green. So the final answer will be 3 + 1 + 3 + 1 = 8. So this is the ans of the first case (see above cases) where we chose to rob the root house.\\n\\nNow we will calculate the case where we won\\'t choose to rob the root house. In this case we will rob both left and right child of root and calculate the below tree solution of these subtrees as well. See image.\\n\\n![image](https://assets.leetcode.com/users/images/78ae814b-38e3-478e-8dfe-e6481311715d_1642225086.7021086.jpeg)\\n\\nin this case our answer will be 4+5 = 9, when we don\\'t choose the root house to rob.\\n\\nNow we have to choose the maximum of both case and return it. Clearly the maximum is 9 in case when we don\\'t choose the root house and thats our answer. :)\\n\\nAlso to avoide similar subproblem calculation we will use unordered map to store solutions of subproblems. \\n\\nSee the code below. If you like my explanation please upvote. Thanks.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        if(dp.count(root)) return dp[root];\\n        int incRoot = root->val, excRoot = 0;\\n        \\n        if(root -> left != NULL){\\n            incRoot += rob(root -> left -> left);\\n            incRoot += rob(root -> left -> right);\\n        } \\n        \\n        if(root -> right != NULL){\\n            incRoot += rob(root -> right -> left);\\n            incRoot += rob(root -> right -> right);\\n        } \\n        \\n        excRoot += rob(root -> left);\\n        excRoot += rob(root -> right);\\n        \\n        return dp[root] = max(incRoot, excRoot);  \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<TreeNode*, int> dp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        if(dp.count(root)) return dp[root];\\n        int incRoot = root->val, excRoot = 0;\\n        \\n        if(root -> left != NULL){\\n            incRoot += rob(root -> left -> left);\\n            incRoot += rob(root -> left -> right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1671314,
                "title": "python-linear-time-readable-code-with-explanation",
                "content": "construct a dp tree.\\nEach node (dp_node) in this dp tree is an array of two elements:\\n\\n\\n* **dp_node[0] =[your gain when you ROB the current node / with_root]**\\n* **dp_node[1] =[your gain when you SKIP the current node/ without_root]**\\n\\nwe start by scanning from the leaf: Depth First Search\\n\\nFor each node you have 2 options:\\n\\noption 1: ROB the node, then you can\\'t rob the child/children of the node.\\n**`dp_node[0] = root.val + left[1] + right[1]`**\\noption 2: SKIP the node, then you can ROB or SKIP the child/children of the node.\\n**`dp_node[1] = max(left) + max(right)`**\\nthe maximum of gain of the node depents on max(dp_node[0],dp_node[1])\\n\\n```\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0,0]\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            withroot = root.val + left[1] + right[1]\\n            withoutroot = max(left) + max(right)\\n            \\n            return [withroot, withoutroot]\\n        \\n\\n        return max(dfs(root))\\n```\\n\\n***PLEASE UPVOTE AND SUPPORT FOR MOTIVATION !!!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0,0]\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            withroot = root.val + left[1] + right[1]\\n            withoutroot = max(left) + max(right)\\n            \\n            return [withroot, withoutroot]\\n        \\n\\n        return max(dfs(root))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612825,
                "title": "discussion-on-approach-can-we-do-this-with-level-order-traversal",
                "content": "Hey,\\n\\nI was working on this solution. my approach was to solve this with level order traversal. However it seems to be not possible with that approch. but i would like to hear/thoughts/suggestions from you all. \\n\\nmy approch was:\\n1. Traverse the tree level wise.\\n2. Put values into 1 D (sum of particular level) array now problem reduced to find maximum sum by skipping alternate values. \\n\\nChallange : How it\\'s possibe to implement a solution which involves kth level value + some nth level value in solution.\\n\\nLooking forward to some amazing answers on this. Thanks \\n\\nIn case you want my solution (Not passed) \\n```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        vector<int> vect;\\n        queue<TreeNode*> q;\\n        if(root==NULL) return 0;\\n        q.push(root);\\n        while(q.size()>0){\\n            int n = q.size();\\n            vector<int> t;\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                t.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            int temp = 0;\\n            for(auto item : t) temp+=item;\\n            vect.push_back(temp);\\n            temp = 0;\\n        }\\n        int odd = 0 , even =0 , finalAns = vect[0];\\n        for(int i=0;i<vect.size();i++){\\n            for(int k=i+2;k<vect.size();k+=2){\\n                odd += vect[k];\\n            }\\n            for(int k=i+3;k<vect.size();k+=2){\\n                even = vect[k];\\n            }\\n            if(odd+vect[i] >finalAns){\\n                finalAns = odd+vect[i];\\n            }\\n            if(even+vect[i] > finalAns){\\n                finalAns = even+vect[i];\\n            }\\n            odd = 0;\\n            even = 0;\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        vector<int> vect;\\n        queue<TreeNode*> q;\\n        if(root==NULL) return 0;\\n        q.push(root);\\n        while(q.size()>0){\\n            int n = q.size();\\n            vector<int> t;\\n            for(int i=0;i<n;i++){\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                t.push_back(temp->val);\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            int temp = 0;\\n            for(auto item : t) temp+=item;\\n            vect.push_back(temp);\\n            temp = 0;\\n        }\\n        int odd = 0 , even =0 , finalAns = vect[0];\\n        for(int i=0;i<vect.size();i++){\\n            for(int k=i+2;k<vect.size();k+=2){\\n                odd += vect[k];\\n            }\\n            for(int k=i+3;k<vect.size();k+=2){\\n                even = vect[k];\\n            }\\n            if(odd+vect[i] >finalAns){\\n                finalAns = odd+vect[i];\\n            }\\n            if(even+vect[i] > finalAns){\\n                finalAns = even+vect[i];\\n            }\\n            odd = 0;\\n            even = 0;\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612823,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n\\tpublic int rob(TreeNode root) {\\n\\t\\tint rv[] = helper(root);\\n\\t\\treturn Math.max(rv[0], rv[1]);\\n\\t}\\n\\n//\\t\\tExpectation\\n//\\t\\tOur helper function will fetch us two values present in an array\\n//      rv -> return value array, rv[0] -> maximum value that can be obtained if we don\\'t pick this node\\n//\\t\\trv[1] -> maximum value that can be obtained if we pick this node\\n\\t\\tpublic int[] helper(TreeNode node) {\\n\\t\\t\\tint rv[] = new int[2];\\n//\\t\\t\\tbase case\\n\\t\\t\\tif (node == null) {\\n\\t\\t\\t\\treturn rv;\\n\\t\\t\\t}\\n//\\t\\t\\tRecursive Intuition\\n//\\t\\t\\tFaith -> we believe that our program will work for sub trees\\n\\n\\t\\t\\tint left[] = helper(node.left);\\n\\t\\t\\tint right[] = helper(node.right);\\n\\t\\t\\t\\n// \\t\\t\\tif we are not picking the node itself we can take any of the value\\n\\t\\t\\trv[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n\\t\\t\\t\\n//\\t\\t\\tbut if we take the node value into the consideration then we can consider only\\n//\\t\\t\\tthose value of their left and right arrays where we have not picked their first elements\\n\\t\\t\\trv[1] = left[0] + right[0] + node.val;\\n\\t\\t\\treturn rv;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int rob(TreeNode root) {\\n\\t\\tint rv[] = helper(root);\\n\\t\\treturn Math.max(rv[0], rv[1]);\\n\\t}\\n\\n//\\t\\tExpectation\\n//\\t\\tOur helper function will fetch us two values present in an array\\n//      rv -> return value array, rv[0] -> maximum value that can be obtained if we don\\'t pick this node\\n//\\t\\trv[1] -> maximum value that can be obtained if we pick this node\\n\\t\\tpublic int[] helper(TreeNode node) {\\n\\t\\t\\tint rv[] = new int[2];\\n//\\t\\t\\tbase case\\n\\t\\t\\tif (node == null) {\\n\\t\\t\\t\\treturn rv;\\n\\t\\t\\t}\\n//\\t\\t\\tRecursive Intuition\\n//\\t\\t\\tFaith -> we believe that our program will work for sub trees\\n\\n\\t\\t\\tint left[] = helper(node.left);\\n\\t\\t\\tint right[] = helper(node.right);\\n\\t\\t\\t\\n// \\t\\t\\tif we are not picking the node itself we can take any of the value\\n\\t\\t\\trv[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n\\t\\t\\t\\n//\\t\\t\\tbut if we take the node value into the consideration then we can consider only\\n//\\t\\t\\tthose value of their left and right arrays where we have not picked their first elements\\n\\t\\t\\trv[1] = left[0] + right[0] + node.val;\\n\\t\\t\\treturn rv;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612754,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    HashMap<TreeNode,Integer> map = new HashMap<>();\\n    public int rob(TreeNode root) {\\n        int max = 0;\\n        if(root == null)    return 0;\\n        if(map.containsKey(root))   return map.get(root);\\n        if (root.left != null) \\n            max += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null) \\n            max += rob(root.right.left) + rob(root.right.right);\\n        max = Math.max(max + root.val, rob(root.left) + rob(root.right));\\n        map.put(root, max);\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<TreeNode,Integer> map = new HashMap<>();\\n    public int rob(TreeNode root) {\\n        int max = 0;\\n        if(root == null)    return 0;\\n        if(map.containsKey(root))   return map.get(root);\\n        if (root.left != null) \\n            max += rob(root.left.left) + rob(root.left.right);\\n        if (root.right != null) \\n            max += rob(root.right.left) + rob(root.right.right);\\n        max = Math.max(max + root.val, rob(root.left) + rob(root.right));\\n        map.put(root, max);\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611850,
                "title": "python3-simple-dfs-beats-97",
                "content": "`dfs` function returns two values, the max amount of money with and without this node.\\nAfter `return`, The first one will become OneLayer variable and can\\'t be accumulated with this node.\\nThe second one will become TwoLayer variable and can be used for accumulating with or without this node.\\n\\nWhen under the condition we calculate the max amount of money without this node, we can\\'t use OneLayer and TwoLayer at the same time, so we choose max(onelayer, twolayer) for left and right nodes.\\n```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            leftOneLayer, leftTwoLayer, rightOneLayer, rightTwoLayer = [0] * 4\\n            if node.left:\\n                leftOneLayer, leftTwoLayer = dfs(node.left)\\n            if node.right:\\n                rightOneLayer, rightTwoLayer = dfs(node.right)\\n            if not node.left and not node.right:\\n                return node.val, 0\\n            \\n            return node.val + leftTwoLayer + rightTwoLayer, max(leftOneLayer, leftTwoLayer) + max(rightOneLayer, rightTwoLayer)\\n        return max(dfs(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            leftOneLayer, leftTwoLayer, rightOneLayer, rightTwoLayer = [0] * 4\\n            if node.left:\\n                leftOneLayer, leftTwoLayer = dfs(node.left)\\n            if node.right:\\n                rightOneLayer, rightTwoLayer = dfs(node.right)\\n            if not node.left and not node.right:\\n                return node.val, 0\\n            \\n            return node.val + leftTwoLayer + rightTwoLayer, max(leftOneLayer, leftTwoLayer) + max(rightOneLayer, rightTwoLayer)\\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288893,
                "title": "c-easy-to-understand-dp-solution-clean-and-consize",
                "content": "Please upvote if it helps!\\n```\\n#define mp make_pair\\nclass Solution {\\n    map<pair<TreeNode*,int>, int> m;\\npublic:\\n    int func(TreeNode* root, int f)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(m[mp(root,f)]!=0)\\n            return m[mp(root,f)];\\n        \\n        int ans = func(root->left, 0) + func(root->right, 0);\\n        if(f==0)\\n        {\\n            ans = max(ans, root->val+func(root->left,1) + func(root->right,1));\\n        }\\n        return m[mp(root,f)] = ans;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int ans = func(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define mp make_pair\\nclass Solution {\\n    map<pair<TreeNode*,int>, int> m;\\npublic:\\n    int func(TreeNode* root, int f)\\n    {\\n        if(!root)\\n            return 0;\\n        \\n        if(m[mp(root,f)]!=0)\\n            return m[mp(root,f)];\\n        \\n        int ans = func(root->left, 0) + func(root->right, 0);\\n        if(f==0)\\n        {\\n            ans = max(ans, root->val+func(root->left,1) + func(root->right,1));\\n        }\\n        return m[mp(root,f)] = ans;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        int ans = func(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282448,
                "title": "simple-postorder-with-pairs-easy-to-understand-c",
                "content": "\\n\\n Some observations for this problem. we have two situations for each node either pick current one or skip\\n \\n I\\'m using pair to save the answer for each node.\\n \\n For example lets say pair<int,int> res \\n res.first - sum when current node is skipped \\n res.second- sum when current node is picked\\n\\n1) Pick the current node :-  Think when we can pick the current one, when our left child and right child are not picked ? \\n      res.second= left.first+right.first+root->val (current value)\\n2) Skip the current node- We can pick either left node and right node or skip left node or right node. \\n   res.first=max(left.second+max(right.first,right.second),left.first+max(right.first,right.second));\\n   \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n    \\n     \\n\\t\\t\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tpair<int,int> solve(TreeNode *root,int &ans){ \\n            if(root==NULL){\\n            return {0,0}; //base condition\\n           }\\n\\t\\t   \\n\\t\\t   pair<int,int>left = solve(root->left,ans);\\n\\t       pair<int,int>right = solve(root->right,ans);\\n\\t\\t   pair<int,int>res;\\n\\t\\t  //picking current node\\n\\t\\t  res.second=left.first+right.first+root->val;\\n\\t\\t //skipping current node\\n\\t\\t   res.first=max(left.second+max(right.first,right.second),left.first+max(right.first,right.second));\\n\\t\\t   //answer is maxium of either picking or not picking\\n\\t\\t ans=max(ans,max(res.first,res.second));\\n          return res;\\n\\t\\t}\\n\\t\\tint rob(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int ans=0;\\n        solve(root,ans);\\n        return ans;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tpair<int,int> solve(TreeNode *root,int &ans){ \\n            if(root==NULL){\\n            return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1016383,
                "title": "c-100-space-efficient-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ans(TreeNode* root,int f)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n       \\n        int an=0;\\n        \\n        if(f==0)\\n        {\\n            an=max(root->val+ans(root->left,!f)+ans(root->right,!f),ans(root->left,f)+ans(root->right,f));\\n        }\\n        \\n        else\\n        {\\n            an=ans(root->left,!f)+ans(root->right,!f);\\n        }\\n        \\n        return an;\\n        \\n    }  \\n    \\n    int rob(TreeNode* root) {\\n        return ans(root,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans(TreeNode* root,int f)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n       \\n        int an=0;\\n        \\n        if(f==0)\\n        {\\n            an=max(root->val+ans(root->left,!f)+ans(root->right,!f),ans(root->left,f)+ans(root->right,f));\\n        }\\n        \\n        else\\n        {\\n            an=ans(root->left,!f)+ans(root->right,!f);\\n        }\\n        \\n        return an;\\n        \\n    }  \\n    \\n    int rob(TreeNode* root) {\\n        return ans(root,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955062,
                "title": "the-skyline-problem",
                "content": "```\\n/**\\n * For explanation, refer https://briangordon.github.io/2014/08/the-skyline-problem.html\\n */\\n\\n#define fo(i,n)     for(i=0; i<n; i++)\\n#define pb          push_back\\n#define all(x)      x.begin(), x.end()\\n#define sortall(x)  sort(all(x))\\n#define ll          long long\\n\\ntypedef vector<int>\\tvi;\\ntypedef vector<vi>\\tvvi;\\ntypedef vector<ll>\\tvl;\\ntypedef vector<vl>\\tvvl;\\n\\nclass Solution {\\npublic:\\n    vvi getSkyline(vvi& buildings) {\\n        int i;\\n        vvi L, R;\\n        fo (i, buildings.size()) {\\n            L.pb({buildings[i][0], i});     // L contains {Li, i}\\n            R.pb({buildings[i][1], i});     // R contains {Ri, i}\\n        }\\n        sortall(R);\\n\\n        vvi ans (1, {-1, -1});\\n        priority_queue<vl, vvl> pq;         // max heap has {Hi, Ri}\\n        pq.push({0, (ll)INT_MAX+1});\\n        int l = 0, r = 0, c, h;\\n        while (l < L.size() || r < R.size()) \\n        {\\n            if (l < L.size() && L[l][0] <= R[r][0]) \\n            {\\n                i = L[l][1];\\n                pq.push({buildings[i][2], buildings[i][1]});\\n                c = L[l++][0];\\n            } \\n            else \\n            {\\n                while (!pq.empty() && pq.top()[1] <= R[r][0])\\n                    pq.pop();\\n                c = R[r++][0];\\n            }\\n            \\n            h = pq.top()[0];\\n\\n            if (ans.back()[1] != h) \\n            {\\n                if (ans.back()[0] == c)\\n                    ans.pop_back();\\n                ans.pb({c, h});\\n            }\\n        }\\n        return vector(ans.begin()+1, ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * For explanation, refer https://briangordon.github.io/2014/08/the-skyline-problem.html\\n */\\n\\n#define fo(i,n)     for(i=0; i<n; i++)\\n#define pb          push_back\\n#define all(x)      x.begin(), x.end()\\n#define sortall(x)  sort(all(x))\\n#define ll          long long\\n\\ntypedef vector<int>\\tvi;\\ntypedef vector<vi>\\tvvi;\\ntypedef vector<ll>\\tvl;\\ntypedef vector<vl>\\tvvl;\\n\\nclass Solution {\\npublic:\\n    vvi getSkyline(vvi& buildings) {\\n        int i;\\n        vvi L, R;\\n        fo (i, buildings.size()) {\\n            L.pb({buildings[i][0], i});     // L contains {Li, i}\\n            R.pb({buildings[i][1], i});     // R contains {Ri, i}\\n        }\\n        sortall(R);\\n\\n        vvi ans (1, {-1, -1});\\n        priority_queue<vl, vvl> pq;         // max heap has {Hi, Ri}\\n        pq.push({0, (ll)INT_MAX+1});\\n        int l = 0, r = 0, c, h;\\n        while (l < L.size() || r < R.size()) \\n        {\\n            if (l < L.size() && L[l][0] <= R[r][0]) \\n            {\\n                i = L[l][1];\\n                pq.push({buildings[i][2], buildings[i][1]});\\n                c = L[l++][0];\\n            } \\n            else \\n            {\\n                while (!pq.empty() && pq.top()[1] <= R[r][0])\\n                    pq.pop();\\n                c = R[r++][0];\\n            }\\n            \\n            h = pq.top()[0];\\n\\n            if (ans.back()[1] != h) \\n            {\\n                if (ans.back()[0] == c)\\n                    ans.pop_back();\\n                ans.pb({c, h});\\n            }\\n        }\\n        return vector(ans.begin()+1, ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946184,
                "title": "clean-c-dfs-solution",
                "content": "At any given node in the Tree, the maximum upto that point is either between two values.\\n* Considering the current node and skipping its immediate left and right child and proceeding with its left left, left right, right left, and right right.\\n* Other possible situation is considering the left and right child and performing dfs on them excluding the current value.\\n\\nThe complexity lies here when we need to check for a given node again and again, so we use a map to efficiently store the dfs value of the current node, if it\\'s already visited.\\nSo while performing dfs, we simultaneously store the values to use again.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, map<TreeNode*,int> &m){\\n        if(root==NULL)\\n            return 0;\\n        if(m.count(root))\\n            return m[root];\\n        int val=0;\\n        if(root->left)\\n            val+=dfs(root->left->left,m)+dfs(root->left->right,m);\\n        if(root->right)\\n            val+=dfs(root->right->left,m)+dfs(root->right->right,m);\\n        val=max(val+root->val,dfs(root->left,m)+dfs(root->right,m));\\n        return m[root]=val;\\n    }\\n    int rob(TreeNode* root) {\\n        map<TreeNode*,int> m;\\n        return dfs(root,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, map<TreeNode*,int> &m){\\n        if(root==NULL)\\n            return 0;\\n        if(m.count(root))\\n            return m[root];\\n        int val=0;\\n        if(root->left)\\n            val+=dfs(root->left->left,m)+dfs(root->left->right,m);\\n        if(root->right)\\n            val+=dfs(root->right->left,m)+dfs(root->right->right,m);\\n        val=max(val+root->val,dfs(root->left,m)+dfs(root->right,m));\\n        return m[root]=val;\\n    }\\n    int rob(TreeNode* root) {\\n        map<TreeNode*,int> m;\\n        return dfs(root,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935314,
                "title": "poor-pigs-one-line-solution",
                "content": "Per the hint #3 in the problem \\n\\nFind minimum x such that (T+1)^x >= N\\n\\nwhere\\nT is (minutesToTest/minutesToDie)\\nN is Number of Buckets\\nx is the variable to be solved for\\n\\n```\\nreturn (int)(Math.ceil(Math.log(buckets)/Math.log((minutesToTest+minutesToDie)/minutesToDie)));\\n```\\n\\n**Explanation on Equation for evaluating \\'x\\'**\\n\\nWe have the equation to start with\\n\\n`(T+1)^x >= N`\\n\\n**Step #1** Applying exponent on both sides\\n`x >= log N to base (T+1)`\\n\\n**Step #2** Using the log formula/identity `logb(n) = loge(n) / loge(b)` \\n`x >= (log N to base e) / (log T+1 to base e) `\\n\\n**Step #3** Since we have >= as inequality, we apply Ceil as number of Pigs is an integer \\n`x = Ceil of (log N to base e) / (log T+1 to base e) `\\n\\n",
                "solutionTags": [],
                "code": "```\\nreturn (int)(Math.ceil(Math.log(buckets)/Math.log((minutesToTest+minutesToDie)/minutesToDie)));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826616,
                "title": "my-swift-solution-dfs",
                "content": "My Swift solution (DFS)\\n```\\nclass Solution {\\n    func rob(_ root: TreeNode?) -> Int {\\n        func helper(_ node: TreeNode) -> (now: Int, last: Int) {\\n            let (lnow, llast) = node.left != nil ? helper(node.left!) : (0, 0)\\n            let (rnow, rlast) = node.right != nil ? helper(node.right!) : (0, 0)\\n            return (max(lnow + rnow, llast + rlast + node.val), lnow + rnow)\\n        }\\n        return root != nil ? helper(root!).now : 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rob(_ root: TreeNode?) -> Int {\\n        func helper(_ node: TreeNode) -> (now: Int, last: Int) {\\n            let (lnow, llast) = node.left != nil ? helper(node.left!) : (0, 0)\\n            let (rnow, rlast) = node.right != nil ? helper(node.right!) : (0, 0)\\n            return (max(lnow + rnow, llast + rlast + node.val), lnow + rnow)\\n        }\\n        return root != nil ? helper(root!).now : 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682334,
                "title": "dfs-simple-java-solution-with-bit-explanation",
                "content": "(I couldn\\'t solve myself so saw others solution and tried to write it simple. I felt it hardest problem so far, but after understanding logic, its not so difficult) LC must have solution for this. (missing)\\n\\n```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        //dfs traversal (post order)\\n        int[] ans = dfs(root);\\n        //take max of root robbed or not robbed \\n        return Math.max(ans[0], ans[1]);\\n    }\\n    \\n    // index 0 -> not-robbed, \\n    // index 1 -> robbed\\n    private int[] dfs(TreeNode root){\\n        if(root==null){\\n\\t\\t\\t//initially return a empty arrray, we will return final value later in post order traversal\\n            return new int[]{0,0};\\n        }\\n        \\n        int[] left = dfs(root.left);\\n        int[] right = dfs(root.right);\\n        \\n        //if not-robbed current node then add (left max & right max) values\\n        int not_rob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        //if robbed current node then just take root node value together with not robbed left & right nodes values\\n        int rob = root.val + left[0] + right[0];\\n        \\n        return new int[]{not_rob, rob};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        //dfs traversal (post order)\\n        int[] ans = dfs(root);\\n        //take max of root robbed or not robbed \\n        return Math.max(ans[0], ans[1]);\\n    }\\n    \\n    // index 0 -> not-robbed, \\n    // index 1 -> robbed\\n    private int[] dfs(TreeNode root){\\n        if(root==null){\\n\\t\\t\\t//initially return a empty arrray, we will return final value later in post order traversal\\n            return new int[]{0,0};\\n        }\\n        \\n        int[] left = dfs(root.left);\\n        int[] right = dfs(root.right);\\n        \\n        //if not-robbed current node then add (left max & right max) values\\n        int not_rob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        //if robbed current node then just take root node value together with not robbed left & right nodes values\\n        int rob = root.val + left[0] + right[0];\\n        \\n        return new int[]{not_rob, rob};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647541,
                "title": "c-dp-solution-with-a-vector-to-store-two-states",
                "content": "In this code, at every node, it returns a vector storing two states : rob this node or not rob\\nres[0] means the max value I can get from the botton **if I rob this node**\\nres[1] means the max value I can get from the botton **if I don\\'t rob this node**\\nTime O(n) the recu will visit every node\\nSpace O(1n) every node takes O(1) space\\n```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        vector<int> res = robHelper(root);\\n        return max(res[0], res[1]);\\n    }\\n    vector<int> robHelper(TreeNode* root){\\n        vector<int> res(2, 0);\\n        if(!root) return res;\\n        if(root->left == root->right){\\n            res[0] = root->val;\\n            return res;\\n        } \\n        vector<int> l = robHelper(root->left);\\n        vector<int> r = robHelper(root->right);\\n        res[0] = l[1] + r[1] + root->val;\\n        res[1] = max(max(l[1] + r[1], l[0] + r[0]), max(l[1] + r[0], l[0] + r[1]));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        vector<int> res = robHelper(root);\\n        return max(res[0], res[1]);\\n    }\\n    vector<int> robHelper(TreeNode* root){\\n        vector<int> res(2, 0);\\n        if(!root) return res;\\n        if(root->left == root->right){\\n            res[0] = root->val;\\n            return res;\\n        } \\n        vector<int> l = robHelper(root->left);\\n        vector<int> r = robHelper(root->right);\\n        res[0] = l[1] + r[1] + root->val;\\n        res[1] = max(max(l[1] + r[1], l[0] + r[0]), max(l[1] + r[0], l[0] + r[1]));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642266,
                "title": "python-dfs-with-explanation",
                "content": "```python\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        \"\"\"\\n        1. Each node returns the maximum amount of money that includes the current node and \\n        the max that excludes the curent node. \\n        2. The max that excludes the current node can then \\n        be included in the parents calculations.\\n        \"\"\"\\n        Money = collections.namedtuple(\\'Money\\', [\\'skip_child\\', \\'with_child\\'])\\n        \\n        def rob_recursive(node):\\n            if not node:\\n                return Money(0, 0)\\n            \\n            left = rob_recursive(node.left)\\n            right = rob_recursive(node.right)\\n            \\n            return Money(max(left) + max(right),\\n                         node.val + left.skip_child + right.skip_child)\\n        \\n        return max(rob_recursive(root))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        \"\"\"\\n        1. Each node returns the maximum amount of money that includes the current node and \\n        the max that excludes the curent node. \\n        2. The max that excludes the current node can then \\n        be included in the parents calculations.\\n        \"\"\"\\n        Money = collections.namedtuple(\\'Money\\', [\\'skip_child\\', \\'with_child\\'])\\n        \\n        def rob_recursive(node):\\n            if not node:\\n                return Money(0, 0)\\n            \\n            left = rob_recursive(node.left)\\n            right = rob_recursive(node.right)\\n            \\n            return Money(max(left) + max(right),\\n                         node.val + left.skip_child + right.skip_child)\\n        \\n        return max(rob_recursive(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472740,
                "title": "python-o-n-dfs-dp-explanation-and-commented-code",
                "content": "The solution to this problem relies on the same core intuition as the original House Robber Problem. At any given node in the tree we can be at one of two states \\n\\n\\t\\t1) We take the value at that node (meaning we don\\'t take the \"take\" values from child nodes)\\n\\t\\t2) We skip the value at that node (we can take \"take\" or \"skip\" values from child nodes)\\n\\nWith this understand, we can build our dynamic programming values from the bottom of the tree up - The next problem to overcome is initalizing the first values. Think about how you would initalize the starting values for your DP arrays if you were just working with an array\\n* \\t\\t take[0] = houses[0] \\n* \\t\\t skip[0] = 0\\n\\nWe can translate this thinking into a solution that works with a tree by treating leaf nodes as our starting houses. If we are at a leaf node, bubble up the value and 0 to represent ```take, skip``` in a touple.\\n\\nFrom this point at every parent node we can apply the logic:\\n```\\n * \\ttake = leftSkip + rightSkip + node.val\\n * \\tskip = max(leftSkip+rightSkip, leftTake+rightTake, leftSkip+rightTake, leftTake+rightSkip)\\n```\\nThen we bubble up our results to the root.\\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        if root is None:\\n            return 0\\n        if root.left is None and root.right is None:\\n            return root.val\\n        ans = self.robdfs(root)\\n        take = ans[0]\\n        skip = max(ans[1], ans[0])\\n        return max(take, skip)\\n    \\n    def robdfs(self, node):\\n        if node is None:\\n            return 0, 0 \\n        if node.left is None and node.right is None:\\n\\t\\t\\t# at a leaf node, return node.val,0  as (take,skip)\\n            return node.val, 0\\n\\t\\t# now try cases for left and right children, left child only, right child only\\n        if node.right and node.left: \\n            left = self.robdfs(node.left)\\n            right = self.robdfs(node.right)\\n            take = left[1] + right[1] + node.val\\n            skip = max(left[0]+right[0], left[1]+right[1], left[0] + right[1], right[0]+left[1])\\n            return take, skip\\n        \\n        elif node.right:\\n            right = self.robdfs(node.right)\\n            take = right[1] + node.val\\n            skip = max(right[0], right[1])\\n            return take, skip\\n        \\n        elif node.left:\\n            left = self.robdfs(node.left)\\n            take = left[1] + node.val\\n            skip = max(left[0], left[1])\\n            return take, skip\\n```\\n\\nThe key barrier for myself solving this problem was figuring out how to initalize the start of our DP values. From there we know that each node can be in 1 of 2 states, and we just have to calculate both of those states and pass up the values.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```take, skip```\n```\\n * \\ttake = leftSkip + rightSkip + node.val\\n * \\tskip = max(leftSkip+rightSkip, leftTake+rightTake, leftSkip+rightTake, leftTake+rightSkip)\\n```\n```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        if root is None:\\n            return 0\\n        if root.left is None and root.right is None:\\n            return root.val\\n        ans = self.robdfs(root)\\n        take = ans[0]\\n        skip = max(ans[1], ans[0])\\n        return max(take, skip)\\n    \\n    def robdfs(self, node):\\n        if node is None:\\n            return 0, 0 \\n        if node.left is None and node.right is None:\\n\\t\\t\\t# at a leaf node, return node.val,0  as (take,skip)\\n            return node.val, 0\\n\\t\\t# now try cases for left and right children, left child only, right child only\\n        if node.right and node.left: \\n            left = self.robdfs(node.left)\\n            right = self.robdfs(node.right)\\n            take = left[1] + right[1] + node.val\\n            skip = max(left[0]+right[0], left[1]+right[1], left[0] + right[1], right[0]+left[1])\\n            return take, skip\\n        \\n        elif node.right:\\n            right = self.robdfs(node.right)\\n            take = right[1] + node.val\\n            skip = max(right[0], right[1])\\n            return take, skip\\n        \\n        elif node.left:\\n            left = self.robdfs(node.left)\\n            take = left[1] + node.val\\n            skip = max(left[0], left[1])\\n            return take, skip\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407482,
                "title": "c-solution-using-c-17-structured-bindings",
                "content": "I thought this would be a good problem to try using C++17 structured bindings, as a recusive call that returns multiple value is a natural solution.  The first element of the pair is the value including the given node, and the second element is the maximum value excluding the given node.   When we include the value of the node, we must exclude the values of its two direct children, so we only consider the second element in the pair.  When we don\\'t include the root, then we have to take the sum of the maxes of values returned by the childre.  In the top level we take the max of the two options (include the root, or exclude the root).  Ran in 12ms (beats 93.30% of C++ solutions) and beats 83.33% on memory.  I think using the structured bindings added in C++17 resulted in some nice code that is pretty straightforward to understand.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int rob(TreeNode* root) {\\n        auto [best_with_root, best_without_root] = rob_helper(root);\\n        return max(best_with_root, best_without_root);\\n    }\\n    \\n    std::pair<int, int> rob_helper(TreeNode* root) {\\n        if (!root) {\\n            return {0, 0};\\n        }\\n        auto [left_with_node, left_without_node] = rob_helper(root->left);\\n        auto [right_with_node, right_without_node] = rob_helper(root->right);\\n        \\n        int max_with_val = root->val + left_without_node + right_without_node;\\n        int max_without_val = max(left_with_node, left_without_node)\\n                            + max(right_with_node, right_without_node);\\n        return {max_with_val, max_without_val};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int rob(TreeNode* root) {\\n        auto [best_with_root, best_without_root] = rob_helper(root);\\n        return max(best_with_root, best_without_root);\\n    }\\n    \\n    std::pair<int, int> rob_helper(TreeNode* root) {\\n        if (!root) {\\n            return {0, 0};\\n        }\\n        auto [left_with_node, left_without_node] = rob_helper(root->left);\\n        auto [right_with_node, right_without_node] = rob_helper(root->right);\\n        \\n        int max_with_val = root->val + left_without_node + right_without_node;\\n        int max_without_val = max(left_with_node, left_without_node)\\n                            + max(right_with_node, right_without_node);\\n        return {max_with_val, max_without_val};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375801,
                "title": "easy-python-dp",
                "content": "```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        self.memo = {}\\n        def robber(node,state):\\n            if (node,state) not in self.memo:\\n                if not node:\\n                    return 0\\n                if state:\\n                    self.memo[(node,state)] = robber(node.left,False) + robber(node.right,False)+node.val\\n                else:\\n                    self.memo[(node,state)] = max(robber(node.left,False),robber(node.left,True))+max(robber(node.right,False),robber(node.right,True))\\n            return self.memo[(node,state)]\\n        return max(robber(root,True),robber(root,False))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        self.memo = {}\\n        def robber(node,state):\\n            if (node,state) not in self.memo:\\n                if not node:\\n                    return 0\\n                if state:\\n                    self.memo[(node,state)] = robber(node.left,False) + robber(node.right,False)+node.val\\n                else:\\n                    self.memo[(node,state)] = max(robber(node.left,False),robber(node.left,True))+max(robber(node.right,False),robber(node.right,True))\\n            return self.memo[(node,state)]\\n        return max(robber(root,True),robber(root,False))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249458,
                "title": "a-weakened-binary-tree-camera-java-o-n-dp-solution",
                "content": "```\\nclass Solution {\\n    /*\\n        this is a typical  tree dp problem, very similar to the hard one \\n        binary tree camera.\\n        It used the idea of divide and conquer with a time complexity of O(n).\\n        We let ans[0] and ans[1] to be the maxmoney we can get when we\\n        choose/not choose the current house. \\n        l[0] and l[1] to be the maxmoney we can get when we choose/not choose the current house\\'s left child. \\n        r[0] and r[1] to be the maxmoney we can get when we choose/not choose the current house\\'s right child.\\n        Hence we can deduce that the dp equation to be:\\n        ans[0] = l[1] + r[1] + root.val;\\n        ans[1] = max(l[1] + r[1], l[0] + r[0], l[0] + r[1], l[1] + r[0]);\\n        \\n        final answer is max(ans[0], ans[1]).\\n    */\\n    public int rob(TreeNode root) {\\n        int[] ans = solve(root);\\n        return Math.max(ans[0], ans[1]);\\n    }\\n    \\n    private int[] solve(TreeNode root) {\\n        int[] ans = new int[2];\\n        if (root == null) {\\n            ans[0] = 0;\\n            ans[1] = 0;\\n            return ans;\\n        }\\n        \\n        int[] l = solve(root.left);\\n        int[] r = solve(root.right);\\n        ans[0] = l[1] + r[1] + root.val;\\n        ans[1] = Math.max(Math.max(Math.max(l[1] + r[1], l[0] + r[1]), \\n                                   l[1] + r[0]),l[0] + r[0]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        this is a typical  tree dp problem, very similar to the hard one \\n        binary tree camera.\\n        It used the idea of divide and conquer with a time complexity of O(n).\\n        We let ans[0] and ans[1] to be the maxmoney we can get when we\\n        choose/not choose the current house. \\n        l[0] and l[1] to be the maxmoney we can get when we choose/not choose the current house\\'s left child. \\n        r[0] and r[1] to be the maxmoney we can get when we choose/not choose the current house\\'s right child.\\n        Hence we can deduce that the dp equation to be:\\n        ans[0] = l[1] + r[1] + root.val;\\n        ans[1] = max(l[1] + r[1], l[0] + r[0], l[0] + r[1], l[1] + r[0]);\\n        \\n        final answer is max(ans[0], ans[1]).\\n    */\\n    public int rob(TreeNode root) {\\n        int[] ans = solve(root);\\n        return Math.max(ans[0], ans[1]);\\n    }\\n    \\n    private int[] solve(TreeNode root) {\\n        int[] ans = new int[2];\\n        if (root == null) {\\n            ans[0] = 0;\\n            ans[1] = 0;\\n            return ans;\\n        }\\n        \\n        int[] l = solve(root.left);\\n        int[] r = solve(root.right);\\n        ans[0] = l[1] + r[1] + root.val;\\n        ans[1] = Math.max(Math.max(Math.max(l[1] + r[1], l[0] + r[1]), \\n                                   l[1] + r[0]),l[0] + r[0]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 79391,
                "title": "clean-c-dp-solution",
                "content": "maximum benefit involves decision of whether to rob current one or not.\\n```\\nint rob(TreeNode* root) {\\n        return rob_help(root).first;\\n    }\\n    \\npair<int, int> rob_help(TreeNode *root) {\\n        pair<int, int> result(0, 0);\\n        if (root != NULL) {\\n            pair<int, int> left = rob_help(root->left);\\n            pair<int, int> right = rob_help(root->right);\\n            result.second = left.first + right.first;\\n            result.first = max(root->val + left.second + right.second, result.second);\\n        }\\n        return result;\\n }    \\n```",
                "solutionTags": [],
                "code": "```\\nint rob(TreeNode* root) {\\n        return rob_help(root).first;\\n    }\\n    \\npair<int, int> rob_help(TreeNode *root) {\\n        pair<int, int> result(0, 0);\\n        if (root != NULL) {\\n            pair<int, int> left = rob_help(root->left);\\n            pair<int, int> right = rob_help(root->right);\\n            result.second = left.first + right.first;\\n            result.first = max(root->val + left.second + right.second, result.second);\\n        }\\n        return result;\\n }    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 79446,
                "title": "anybody-knows-why-my-java-solution-is-wrong",
                "content": "After I submit my code, I got the following. However, when I run the code in eclipse. It gives me the correct answer - 7. Anybody knows why?\\n\\n<pre>\\nSubmission Result: Wrong Answer\\nInput:\\n[4,1,null,2,null,3]\\nOutput:\\n6\\nExpected:\\n7\\n</pre>\\n\\n<pre><code>\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int total = 0;\\n    int total2 = 0;\\n    public int rob(TreeNode root) {\\n        innerRob2(root, 1);\\n        return total>total2 ? total : total2;\\n    }\\n    \\n    private void innerRob2(TreeNode node, int level){\\n        if(node == null){\\n            return;\\n        }\\n        if(level%2 == 1){\\n            total += node.val;\\n        }else{\\n            total2 += node.val;\\n        }\\n        if(node.left == null && node.right==null){\\n            \\n            return;\\n        }\\n        if(node.left != null){\\n            innerRob2(node.left, level+1);\\n        }\\n        if(node.right != null){\\n            innerRob2(node.right, level+1);\\n        }\\n    }\\n}\\n</pre></code>",
                "solutionTags": [],
                "code": "class Solution {\\n    int total = 0;\\n    int total2 = 0;\\n    public int rob(TreeNode root) {\\n        innerRob2(root, 1);\\n        return total>total2 ? total : total2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 79448,
                "title": "java-concise-memoization-dp-solution-7ms",
                "content": "    public class Solution {\\n        private Map<TreeNode, Integer> memo = new HashMap<>();\\n        \\n        public int rob(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null && root.right==null) return root.val;\\n            if(memo.containsKey(root)) return memo.get(root);\\n\\n            //case 1\\n            int sum1 = root.val;\\n            if(root.left!=null){\\n                sum1 += rob(root.left.left) + rob(root.left.right);\\n            }\\n            if(root.right!=null){\\n                sum1 += rob(root.right.left) + rob(root.right.right);\\n            }\\n            \\n            //case 2\\n            int sum2 = rob(root.left) + rob(root.right);\\n\\n            int sum = Math.max(sum1, sum2);\\n            memo.put(root, sum);\\n            return sum;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private Map<TreeNode, Integer> memo = new HashMap<>();\\n        \\n        public int rob(TreeNode root) {\\n            if(root==null) return 0;\\n            if(root.left==null && root.right==null) return root.val;\\n            if(memo.containsKey(root)) return memo.get(root);\\n\\n            //case 1\\n            int sum1 = root.val;\\n            if(root.left!=null){\\n                sum1 += rob(root.left.left) + rob(root.left.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 79475,
                "title": "clear-solution-with-concise-explanation-in-c",
                "content": "    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            pair<int, int> p = dp(root);\\n            return max(p.first, p.second);\\n        }\\n        \\n        pair<int, int> dp(TreeNode* root) {\\n            if (!root) return {0, 0};\\n            pair<int, int> left = dp(root->left), right = dp(root->right);\\n            int include = root->val + left.second + right.second;\\n            int exclude = max(left.first, left.second) + max(right.first, right.second);\\n            return {include, exclude};\\n        }\\n    };\\n    \\n    /**\\n     * dp[n] means max amount of money the theif can rob begin with root n,\\n     * include means max amount with robbing n, exclude means max amount without robbing n,\\n     * so we get:\\n     * dp[n] = max(include, exclude), in which:\\n     *  include = n + dp[n->left.exclude] + dp[n->right.exclude]\\n     *  exclude = dp[n->left] + dp[n->right]\\n     **/",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            pair<int, int> p = dp(root);\\n            return max(p.first, p.second);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 79461,
                "title": "1ms-java-ac-solution",
                "content": "    public class Solution {\\n    public int rob(TreeNode root) {\\n       int[] max = robHelper(root);\\n       return Math.max(max[0], max[1]);\\n    }\\n    \\n    private int[] robHelper(TreeNode node){\\n        int[] max = new int[2];\\n        if (node == null)\\n            return max;\\n        int[] left = robHelper(node.left);\\n        int[] right = robHelper(node.right);\\n        max[0] = node.val + left[1] + right[1];\\n        max[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rob(TreeNode root) {\\n       int[] max = robHelper(root);\\n       return Math.max(max[0], max[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 79484,
                "title": "c-bottom-up-iterative-dp-solution",
                "content": "The idea is pretty similar as those of previous House Robber problems. We can use an unordered_map called `value` to record the max value we can get from the binary tree rooted at it.\\n\\nFor a specific node **root**, the max value we can get from the binary tree rooted at it is either:\\n\\nrob **root**, added with the max value we can get from **two children of root->left** and **two children of root->right**, which means  (assuming both root->left and root->right are not NULL)\\n\\n    value[root] = root->val + value[root->left->left] + value[root->left->right] + value[root->right->left] + value[root->right->right]\\n\\n\\nor,\\n\\n\\ndo not rob root, add the max value we can get from **root->left** and **root->right**, which means \\n\\n    value[root] = value[root->left] + value[root->right]\\n\\n\\n\\n\\nWe can traverse the tree in post-order so that when we calculate value[root], the value of all its children is known. We could use a stack to store all the nodes. `cur` is the currently processed node while `pre` is the previous node processed. We keep pushing **cur**'s left child into stack until it becomes NULL, then set **cur** to the top of stack. If **cur->right** is NULL or it's processed before, since **cur**'s left child is already processed, which means all the children of cur are processed, therefore we can calculate value[cur] now. If not, just set cur = cur->right. Finally, just return value[root].\\n\\n\\n\\n    class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            unordered_map<TreeNode*, int> value;\\n            stack<TreeNode*> s;\\n            TreeNode *cur, *pre;\\n            value[NULL] = 0;\\n            for(cur = root, pre = NULL; !s.empty() || cur != NULL; ) {\\n                while(cur != NULL) {\\n                    s.push(cur);\\n                    cur = cur->left;\\n                }\\n                cur = s.top();\\n                if(cur->right == NULL || cur->right == pre) {\\n                    value[cur] = max(value[cur->left] + value[cur->right], cur->val + (cur->left == NULL ? 0 : value[cur->left->left] + value[cur->left->right]) + (cur->right == NULL ? 0 : value[cur->right->left] + value[cur->right->right]));\\n                    pre = cur;\\n                    cur = NULL;\\n                    s.pop();\\n                }\\n                else\\n                    cur = cur->right;\\n            }\\n            \\n            return value[root];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(TreeNode* root) {\\n            unordered_map<TreeNode*, int> value;\\n            stack<TreeNode*> s;\\n            TreeNode *cur, *pre;\\n            value[NULL] = 0;\\n            for(cur = root, pre = NULL; !s.empty() || cur != NULL; ) {\\n                while(cur != NULL) {\\n                    s.push(cur);\\n                    cur = cur->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 79497,
                "title": "simple-1ms-java-solution-with-easy-comments",
                "content": "    /*\\n        \\u5411\\u5de6\\u53f3\\u4e24\\u8fb9\\u8981\\u6570\\u636e, \\u9010\\u5c42\\u5411\\u4e0a\\u8fd4\\u56de\\u3002\\n        \\u8fd4\\u56de\\u7684\\u662fint[2] result.\\n        result[0] -- \\u62a2\\u5f53\\u524droot\\u6240\\u80fd\\u5f97\\u7684\\u6700\\u5927\\u503c\\u3002\\n        result[1] -- \\u4e0d\\u62a2\\u5f53\\u524droot\\u6240\\u80fd\\u5f97\\u7684\\u6700\\u5927\\u503c\\u3002\\n    */\\n    public class Solution {\\n        public int rob(TreeNode root) {\\n            int[] result = findMax(root);\\n            return Math.max(result[0], result[1]);\\n        }\\n        \\n        // returns int[2] result. \\n        // result[0] -- max value robbing current root; result[1] -- max value without robbing current root.\\n        private int[] findMax(TreeNode root) {\\n            if (root == null) {\\n                return new int[] {0, 0};\\n            }\\n            int[] left = findMax(root.left);\\n            int[] right = findMax(root.right);\\n            int result0 = root.val + left[1] + right[1];  // rob current root\\n            int result1 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);  // not rob current root\\n            return new int[] {result0, result1};\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rob(TreeNode root) {\\n            int[] result = findMax(root);\\n            return Math.max(result[0], result[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3763586,
                "title": "neetcode-solution-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> helper(TreeNode* root){\\n        if(root == NULL) return {0,0};\\n\\n        pair<int,int> left1 = helper(root->left);\\n        pair<int,int> right1 = helper(root->right);\\n\\n        int with = root->val + left1.second + right1.second ;\\n        int without = max(left1.first, left1.second) + max(right1.first, right1.second);\\n\\n        return {with, without};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans = helper(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> helper(TreeNode* root){\\n        if(root == NULL) return {0,0};\\n\\n        pair<int,int> left1 = helper(root->left);\\n        pair<int,int> right1 = helper(root->right);\\n\\n        int with = root->val + left1.second + right1.second ;\\n        int without = max(left1.first, left1.second) + max(right1.first, right1.second);\\n\\n        return {with, without};\\n    }\\n    int rob(TreeNode* root) {\\n        pair<int,int> ans = helper(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435510,
                "title": "best-c-solution-well-explained-one-time-traverse-the-tree",
                "content": "\\n\\n# Code\\n```\\n\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    pii solve(TreeNode* root)   {\\n        if(!root)   return {0, 0};\\n        pii l = solve(root -> left), r = solve(root -> right), temp;\\n        temp.first = root -> val + l.second + r.second; // if we include the root then we can not include the left and right child of the root\\n        temp.second = max(l.first, l.second) + max(r.first, r.second);  // if we exclude the root then we can include or exclude the left and right child of the root\\n        return temp;\\n    }\\n\\n    int rob(TreeNode* root) {\\n        if(!root)   return NULL;\\n        pii ans = solve(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    pii solve(TreeNode* root)   {\\n        if(!root)   return {0, 0};\\n        pii l = solve(root -> left), r = solve(root -> right), temp;\\n        temp.first = root -> val + l.second + r.second; // if we include the root then we can not include the left and right child of the root\\n        temp.second = max(l.first, l.second) + max(r.first, r.second);  // if we exclude the root then we can include or exclude the left and right child of the root\\n        return temp;\\n    }\\n\\n    int rob(TreeNode* root) {\\n        if(!root)   return NULL;\\n        pii ans = solve(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923825,
                "title": "simple-and-fastest-java-solution-beats-100-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPostorder traversal\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) (Recursion Stack)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass State\\n{\\n    int notRob;\\n    int rob;\\n\\n    State(int notRob, int rob)\\n    {\\n        this.notRob = notRob;\\n        this.rob = rob;\\n    }\\n}\\n\\nclass Solution {\\n\\n    private State dfs(TreeNode root)\\n    {\\n        if(root == null) return new State(0, 0);\\n\\n        State left = dfs(root.left);\\n        \\n        State right = dfs(root.right);\\n\\n        State node = new State(0, 0);\\n\\n        node.notRob = Math.max(left.rob, left.notRob) + Math.max(right.notRob, right.rob);\\n        \\n        node.rob = left.notRob + right.notRob + root.val;\\n\\n        return node;\\n    }\\n\\n    public int rob(TreeNode root) {\\n        \\n        State ans = dfs(root);\\n\\n        return Math.max(ans.rob, ans.notRob);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass State\\n{\\n    int notRob;\\n    int rob;\\n\\n    State(int notRob, int rob)\\n    {\\n        this.notRob = notRob;\\n        this.rob = rob;\\n    }\\n}\\n\\nclass Solution {\\n\\n    private State dfs(TreeNode root)\\n    {\\n        if(root == null) return new State(0, 0);\\n\\n        State left = dfs(root.left);\\n        \\n        State right = dfs(root.right);\\n\\n        State node = new State(0, 0);\\n\\n        node.notRob = Math.max(left.rob, left.notRob) + Math.max(right.notRob, right.rob);\\n        \\n        node.rob = left.notRob + right.notRob + root.val;\\n\\n        return node;\\n    }\\n\\n    public int rob(TreeNode root) {\\n        \\n        State ans = dfs(root);\\n\\n        return Math.max(ans.rob, ans.notRob);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922607,
                "title": "c-memoization-dp-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)+O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int f(map<TreeNode*, int>& m, TreeNode* root){\\n        if(!root){return 0;}\\n        int ans=root->val;\\n        if(m.find(root)!=m.end()){return m[root];}\\n        if(root->left){ans+=f(m, root->left->left)+f(m, root->left->right);}\\n        if(root->right){ans+=f(m,root->right->left)+f(m, root->right->right);}\\n        return m[root]=max(ans, f(m,root->left)+f(m, root->right));\\n    }\\n    int rob(TreeNode* root) {\\n        map<TreeNode*, int>m;\\n        return f(m, root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int f(map<TreeNode*, int>& m, TreeNode* root){\\n        if(!root){return 0;}\\n        int ans=root->val;\\n        if(m.find(root)!=m.end()){return m[root];}\\n        if(root->left){ans+=f(m, root->left->left)+f(m, root->left->right);}\\n        if(root->right){ans+=f(m,root->right->left)+f(m, root->right->right);}\\n        return m[root]=max(ans, f(m,root->left)+f(m, root->right));\\n    }\\n    int rob(TreeNode* root) {\\n        map<TreeNode*, int>m;\\n        return f(m, root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606956,
                "title": "c-solution-dp-recursion-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int, int> dfs(TreeNode* node) { //post-order\\n        \\n        if ( !node ) return {0, 0};\\n        \\n        pair<int, int> l = dfs( node->left );\\n        pair<int, int> r = dfs( node->right );\\n        \\n        return {\\n            max( l.first, l.second ) + max( r.first, r.second ),\\n            l.first + r.first + node->val\\n        };\\n        \\n    }\\n    \\n    int rob(TreeNode* root) {\\n        \\n        pair<int, int> ans = dfs( root );\\n        \\n        return max( ans.first, ans.second );\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    pair<int, int> dfs(TreeNode* node) { //post-order\\n        \\n        if ( !node ) return {0, 0};\\n        \\n        pair<int, int> l = dfs( node->left );\\n        pair<int, int> r = dfs( node->right );\\n        \\n        return {\\n            max( l.first, l.second ) + max( r.first, r.second ),\\n            l.first + r.first + node->val\\n        };\\n        \\n    }\\n    \\n    int rob(TreeNode* root) {\\n        \\n        pair<int, int> ans = dfs( root );\\n        \\n        return max( ans.first, ans.second );\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597566,
                "title": "c-2-approaches-recur-memoized-better-dp",
                "content": "```\\n//Approach-1 (Recur + Memoized)\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> mp_rob;\\n    unordered_map<TreeNode*, int> mp_not_rob;\\n    int solve(TreeNode* root, bool parentRobbed) {\\n        if(!root)\\n            return 0;\\n       \\n        if(parentRobbed) {\\n            if(mp_rob.count(root))\\n                return mp_rob[root];\\n\\t\\t\\t\\t\\n            return mp_rob[root] = solve(root->left, false) + solve(root->right, false);\\n        \\n\\t\\t} else {\\n            if(mp_not_rob.count(root))\\n                return mp_not_rob[root];\\n\\t\\t\\t\\t\\n            int rob     = root->val + solve(root->left, true) + solve(root->right, true);\\n            int not_rob = solve(root->left, false) + solve(root->right, false);\\n\\t\\t\\t\\n            return  mp_not_rob[root] = max(rob, not_rob);\\n        }\\n    }\\n    int rob(TreeNode* root) {\\n        mp_rob.clear();\\n        mp_not_rob.clear();\\n        return solve(root, false);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Better DP)\\nclass Solution {\\npublic:\\n   \\n    pair<int, int> solve(TreeNode* root) {\\n        if(!root)\\n            return {0, 0};\\n        \\n        auto l = solve(root->left);\\n        auto r = solve(root->right);\\n        \\n        pair<int, int> result;\\n        \\n        //if root is robbed, then we can only take notRobbed from left and right child\\n        result.first = root->val + l.second + r.second;\\n        \\n        //if root is NOT robbed, then we can take maximum from left and right child\\'s\\n        //robbed and not robbed\\n        \\n        result.second = max(l.first, l.second) + max(r.first, r.second);\\n        \\n        return result;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        \\n        pair<int, int> result = solve(root);\\n        \\n        /*\\n            pair.first  = robbed\\n            pair.second = skipped\\n        */\\n        \\n        return max(result.first, result.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Approach-1 (Recur + Memoized)\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, int> mp_rob;\\n    unordered_map<TreeNode*, int> mp_not_rob;\\n    int solve(TreeNode* root, bool parentRobbed) {\\n        if(!root)\\n            return 0;\\n       \\n        if(parentRobbed) {\\n            if(mp_rob.count(root))\\n                return mp_rob[root];\\n\\t\\t\\t\\t\\n            return mp_rob[root] = solve(root->left, false) + solve(root->right, false);\\n        \\n\\t\\t} else {\\n            if(mp_not_rob.count(root))\\n                return mp_not_rob[root];\\n\\t\\t\\t\\t\\n            int rob     = root->val + solve(root->left, true) + solve(root->right, true);\\n            int not_rob = solve(root->left, false) + solve(root->right, false);\\n\\t\\t\\t\\n            return  mp_not_rob[root] = max(rob, not_rob);\\n        }\\n    }\\n    int rob(TreeNode* root) {\\n        mp_rob.clear();\\n        mp_not_rob.clear();\\n        return solve(root, false);\\n    }\\n};\\n```\n```\\n//Approach-2 (Better DP)\\nclass Solution {\\npublic:\\n   \\n    pair<int, int> solve(TreeNode* root) {\\n        if(!root)\\n            return {0, 0};\\n        \\n        auto l = solve(root->left);\\n        auto r = solve(root->right);\\n        \\n        pair<int, int> result;\\n        \\n        //if root is robbed, then we can only take notRobbed from left and right child\\n        result.first = root->val + l.second + r.second;\\n        \\n        //if root is NOT robbed, then we can take maximum from left and right child\\'s\\n        //robbed and not robbed\\n        \\n        result.second = max(l.first, l.second) + max(r.first, r.second);\\n        \\n        return result;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        \\n        pair<int, int> result = solve(root);\\n        \\n        /*\\n            pair.first  = robbed\\n            pair.second = skipped\\n        */\\n        \\n        return max(result.first, result.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477938,
                "title": "c-solution-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(TreeNode* root, unordered_map<TreeNode*, int>& dp){\\n        if(!root)\\n            return 0;\\n        if(dp.find(root) != dp.end())\\n            return dp[root];\\n        \\n        int ex = helper(root->left, dp) + helper(root->right, dp);\\n        int in = 0;\\n        if(root->left)\\n            in += helper(root->left->left, dp) + helper(root->left->right, dp);\\n        if(root->right)\\n            in += helper(root->right->left, dp) + helper(root->right->right, dp);\\n        in += root->val;\\n        \\n        return dp[root] = max(ex, in);\\n    }\\n    int rob(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        return helper(root, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(TreeNode* root, unordered_map<TreeNode*, int>& dp){\\n        if(!root)\\n            return 0;\\n        if(dp.find(root) != dp.end())\\n            return dp[root];\\n        \\n        int ex = helper(root->left, dp) + helper(root->right, dp);\\n        int in = 0;\\n        if(root->left)\\n            in += helper(root->left->left, dp) + helper(root->left->right, dp);\\n        if(root->right)\\n            in += helper(root->right->left, dp) + helper(root->right->right, dp);\\n        in += root->val;\\n        \\n        return dp[root] = max(ex, in);\\n    }\\n    int rob(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        return helper(root, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387036,
                "title": "easy-to-understand-100-fast-0ms-solution",
                "content": "at every step we are using the result from left and right sub tree , Let us understand this by taking an example of array - [1,2,3,1]\\nso for this array if we try to build a dp array it will look something like this dp - [1,2,4,4]\\nat ith index dp[i] means the maximum sum till now either by choosing ith value in array or not  and we are not selecting adjacent values\\narr = [1,2,3,1]\\ndp = [1,2,4,4]\\nso at ith index dp[i] = max(dp[i-1] , dp[i-2]+arr[i])\\nyou can use dp[i-2] along with current value or simply use dp[i-1] , sumply return max of both\\nusing same in the tree , if we reaches any null root simply return {0,0} and at every node we just need to store 2 values in the array - maximum sum till now if we chooses current node , maximum sum till now if we don\\'t choose current node.\\nby the combination of these two values we can simply calculate max sum till now by following the rule not to choose adjacent values\\n\\n\\n**Please upvote if this was helpful and feel free to ask any doubt in the comments\\n**\\n\\'\\'\\'\\n\\n\\tpublic int rob(TreeNode root) {\\n\\t\\t\\tint[] ans = helper(root);\\n\\t\\t\\t//ans[0] means , maximum sum till now if root is selected\\n\\t\\t\\t//ans[1] means , maximum sum till now if root is not selected\\n\\t\\t\\treturn Math.max(ans[0], ans[1]);\\n\\t\\t}\\n\\t\\t\\n    private int[] helper(TreeNode root) \\n\\t{\\n\\t  //check if root is null if it is null the simply return array filled with 0\\n       if(root == null) return new int[2];\\n\\t   //getting array from left\\n        int[] left = helper(root.left);\\n\\t\\t//getting array from right\\n        int[] right = helper(root.right);\\n\\t\\t\\n        int[] ans = new int[2];\\n\\t\\t\\t\\t//0th index with contain maximum sum till now if current root is  choosen\\n        ans[0] = root.val+left[1]+right[1];\\n\\t\\t\\t\\t//1st index will hold the maximum sum till now if current root is not choosen\\n        ans[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n\\t\\t\\n        return ans;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Interactive"
                ],
                "code": "at every step we are using the result from left and right sub tree , Let us understand this by taking an example of array - [1,2,3,1]\\nso for this array if we try to build a dp array it will look something like this dp - [1,2,4,4]\\nat ith index dp[i] means the maximum sum till now either by choosing ith value in array or not  and we are not selecting adjacent values\\narr = [1,2,3,1]\\ndp = [1,2,4,4]\\nso at ith index dp[i] = max(dp[i-1] , dp[i-2]+arr[i])\\nyou can use dp[i-2] along with current value or simply use dp[i-1] , sumply return max of both\\nusing same in the tree , if we reaches any null root simply return {0,0} and at every node we just need to store 2 values in the array - maximum sum till now if we chooses current node , maximum sum till now if we don\\'t choose current node.\\nby the combination of these two values we can simply calculate max sum till now by following the rule not to choose adjacent values\\n\\n\\n**Please upvote if this was helpful and feel free to ask any doubt in the comments\\n**\\n\\'\\'\\'\\n\\n\\tpublic int rob(TreeNode root) {\\n\\t\\t\\tint[] ans = helper(root);\\n\\t\\t\\t//ans[0] means , maximum sum till now if root is selected\\n\\t\\t\\t//ans[1] means , maximum sum till now if root is not selected\\n\\t\\t\\treturn Math.max(ans[0], ans[1]);\\n\\t\\t}\\n\\t\\t\\n    private int[] helper(TreeNode root) \\n\\t{\\n\\t  //check if root is null if it is null the simply return array filled with 0\\n       if(root == null) return new int[2];\\n\\t   //getting array from left\\n        int[] left = helper(root.left);\\n\\t\\t//getting array from right\\n        int[] right = helper(root.right);\\n\\t\\t\\n        int[] ans = new int[2];\\n\\t\\t\\t\\t//0th index with contain maximum sum till now if current root is  choosen\\n        ans[0] = root.val+left[1]+right[1];\\n\\t\\t\\t\\t//1st index will hold the maximum sum till now if current root is not choosen\\n        ans[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n\\t\\t\\n        return ans;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2360507,
                "title": "concise-c-dp-easy-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp(TreeNode* root)\\n    {\\n        vector<int> ans(2,0); //ans[0]: maximal money you can get by robbing current node. ans[1]: maximal money you can get when not rob this node\\n        if(root==NULL) return ans;\\n        vector<int> left=dp(root->left);\\n        vector<int> right=dp(root->right);\\n        ans[0]=root->val+left[1]+right[1];\\n        ans[1]=max(left[0],left[1])+max(right[0],right[1]);\\n        return ans;\\n    }\\n    int rob(TreeNode* root) {\\n        vector<int> ans=dp(root);\\n        return max(ans[0],ans[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp(TreeNode* root)\\n    {\\n        vector<int> ans(2,0); //ans[0]: maximal money you can get by robbing current node. ans[1]: maximal money you can get when not rob this node\\n        if(root==NULL) return ans;\\n        vector<int> left=dp(root->left);\\n        vector<int> right=dp(root->right);\\n        ans[0]=root->val+left[1]+right[1];\\n        ans[1]=max(left[0],left[1])+max(right[0],right[1]);\\n        return ans;\\n    }\\n    int rob(TreeNode* root) {\\n        vector<int> ans=dp(root);\\n        return max(ans[0],ans[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359515,
                "title": "c-solution-faster-than-82",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int>dp;\\n    int ans=0;\\n    int solve(TreeNode* p){\\n        if(p==NULL)return 0;\\n        if(dp.find(p)!=dp.end())return dp[p];\\n        int inc=p->val;\\n        int exc=0;\\n        if(p->left){\\n            exc+=solve(p->left);\\n            inc+=solve(p->left->left)+solve(p->left->right);\\n        }\\n        if(p->right){\\n            exc+=solve(p->right);\\n            inc+=solve(p->right->left)+solve(p->right->right);\\n        }\\n        ans=max(inc,exc);\\n        dp[p]=ans;\\n        return ans;\\n    }\\n    int rob(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int>dp;\\n    int ans=0;\\n    int solve(TreeNode* p){\\n        if(p==NULL)return 0;\\n        if(dp.find(p)!=dp.end())return dp[p];\\n        int inc=p->val;\\n        int exc=0;\\n        if(p->left){\\n            exc+=solve(p->left);\\n            inc+=solve(p->left->left)+solve(p->left->right);\\n        }\\n        if(p->right){\\n            exc+=solve(p->right);\\n            inc+=solve(p->right->left)+solve(p->right->right);\\n        }\\n        ans=max(inc,exc);\\n        dp[p]=ans;\\n        return ans;\\n    }\\n    int rob(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356408,
                "title": "dfs-pick-not-pick-modification-non-dp-approach-c-simple-explanation",
                "content": "Starting from root node, we have a choice either to take it or exclude it.\\nif included -> must have to exclude left and right from final sum.\\nelse if excluded -> can take the maximum ans case and add to final sum.\\n\\n![image](https://assets.leetcode.com/users/images/284447ae-cac2-402e-8f05-435d61f3e0b9_1659204599.337941.png)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> solve(TreeNode* root){\\n        if(!root){\\n            return {0,0};\\n        }\\n        \\n        pair<int,int> ans;      //incl, excl\\n        auto left = solve(root->left);\\n        auto right = solve(root->right);\\n        \\n        ans.first = root->val + left.second + right.second; //incl\\n        ans.second = max(left.first, left.second) + max(right.first, right.second); //excl\\n        return ans;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto x = solve(root);\\n        return max(x.first, x.second);\\n    }\\n};\\n```\\nTC: O(N) \\nSC: O(1)\\n\\nN is the number of nodes in the tree.\\n\\n**Kindly do upvote if it helps!!**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> solve(TreeNode* root){\\n        if(!root){\\n            return {0,0};\\n        }\\n        \\n        pair<int,int> ans;      //incl, excl\\n        auto left = solve(root->left);\\n        auto right = solve(root->right);\\n        \\n        ans.first = root->val + left.second + right.second; //incl\\n        ans.second = max(left.first, left.second) + max(right.first, right.second); //excl\\n        return ans;\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto x = solve(root);\\n        return max(x.first, x.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273804,
                "title": "10-line-c-fastest-code-o-h-recursive-space",
                "content": "class Solution  {\\npublic:\\n\\n    int dfs(int &childsum, TreeNode *root){\\n        if(!root) return 0;\\n        int lcs=0, rcs=0;          //lcs= left child sum  //rcs = right shild sum\\n        childsum = dfs(lcs, root->left) + dfs(rcs, root->right);\\n        return max(root->val + lcs + rcs, childsum);\\n    }    \\n    int rob(TreeNode* root) {\\n        int childsum;\\n        return dfs(childsum,root);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution  {\\npublic:\\n\\n    int dfs(int &childsum, TreeNode *root){\\n        if(!root) return 0;\\n        int lcs=0, rcs=0;          //lcs= left child sum  //rcs = right shild sum\\n        childsum = dfs(lcs, root->left) + dfs(rcs, root->right);\\n        return max(root->val + lcs + rcs, childsum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2254485,
                "title": "c-solution-fully-explained",
                "content": "**Intuition**\\nFor each parent node, we have 2 possibilities - \\n1. Rob that parent node\\n2. Skip that parent node\\n\\nIf we rob that parent node, we will definitely skip it\\'s left child and right child\\nIf we skip parent node, we can have 4 possibilites - \\n1. Rob left child and rob right child\\n2. Skip right child and skip left child\\n3. Rob leftchild  and skip right child\\n4. Rob right child and skip left child\\n\\nSo, skipping the parent would be maximum of all these possible ways.\\nAnd for that parent node sum will be maximum of either robbing the parent node or skipping the parent node.\\n\\nIn reccursion, we return a vector, whose 0th index will be the value of robbing the node and 1st index will be the value of skipping the node.\\n\\nHere is the code.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve (TreeNode *root)\\n    {\\n        if (root==NULL)\\n            return {0,0};\\n        \\n        vector <int> l = solve(root->left);\\n        vector <int> r = solve(root->right);\\n        \\n        int rob_this = root->val + l[1] + r[1];\\n        \\n        int skip_1 = max(l[0] + r[0], l[1] + r[1]);\\n        int skip_2 = max(l[0] + r[1], r[0] + l[1]);\\n        \\n        int skip_this = max(skip_1, skip_2);\\n\\n        return {rob_this, skip_this};  \\n    }\\n    \\n    int rob(TreeNode* root) \\n    {\\n        vector <int> ans = solve (root);\\n        return max(ans[0],ans[1]);\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<int> solve (TreeNode *root)\\n    {\\n        if (root==NULL)\\n            return {0,0};\\n        \\n        vector <int> l = solve(root->left);\\n        vector <int> r = solve(root->right);\\n        \\n        int rob_this = root->val + l[1] + r[1];\\n        \\n        int skip_1 = max(l[0] + r[0], l[1] + r[1]);\\n        int skip_2 = max(l[0] + r[1], r[0] + l[1]);\\n        \\n        int skip_this = max(skip_1, skip_2);\\n\\n        return {rob_this, skip_this};  \\n    }\\n    \\n    int rob(TreeNode* root) \\n    {\\n        vector <int> ans = solve (root);\\n        return max(ans[0],ans[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234306,
                "title": "house-robber-iii",
                "content": "```\\n unordered_map<TreeNode*,int>um;\\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(um.find(root)!=um.end())\\n            return um[root];\\n        int val=root->val;\\n        if(root->left){\\n             val+=rob(root->left->left);\\n             val+=rob(root->left->right);\\n        }\\n           \\n        if(root->right){\\n            val+=rob(root->right->left); \\n             val+=rob(root->right->right);\\n        }\\n        int res=rob(root->left)+rob(root->right);    \\n        return um[root]=max(val,res);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n unordered_map<TreeNode*,int>um;\\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(um.find(root)!=um.end())\\n            return um[root];\\n        int val=root->val;\\n        if(root->left){\\n             val+=rob(root->left->left);\\n             val+=rob(root->left->right);\\n        }\\n           \\n        if(root->right){\\n            val+=rob(root->right->left); \\n             val+=rob(root->right->right);\\n        }\\n        int res=rob(root->left)+rob(root->right);    \\n        return um[root]=max(val,res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2147339,
                "title": "c-dfs-solution-explained-with-image-comments-easy-to-understand",
                "content": "**Explanation**\\n\\nFor a node, there are two possiblities: it will be included (robbed) or not. In the first case, if it is included then its child node (which is directly-linked to it) will not be included. And in the second case, we can maximize the results obtained from both of its child nodes.\\nSo we can use DFS starting from the root node and going in both directions (left & right) till leaf nodes. The return value of DFS function is pair<int, int> - first if the present node is included, second if it isn\\'t.\\n\\n![image](https://assets.leetcode.com/users/images/11e209ec-3079-4465-b5f7-94b0a9881334_1655126934.092918.jpeg)\\nTestCase: [1,7,9,2,6,5,11,null,9,5] || Result: 37\\n<br>\\n**Code**\\n``` \\npair<int,int> dfs(TreeNode* n) {\\n\\tif(n==NULL) return {0,0}; //null\\n\\tif(n->left==NULL && n->right==NULL) return {n->val, 0}; //leaf node ( its value will be (val,0)\\n\\tauto l = dfs(n->left), r = dfs(n->right);\\n\\tpair<int,int> x;\\n\\tx.first = n->val + l.second + r.second; //node included (its children (l&r) are excluded)\\n\\tx.second = max(l.first, l.second) + max(r.first, r.second); //node excluded\\n\\treturn x;\\n}\\n\\nint rob(TreeNode* root) {\\n\\tauto ans = dfs(root);\\n\\treturn max(ans.first, ans.second);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "``` \\npair<int,int> dfs(TreeNode* n) {\\n\\tif(n==NULL) return {0,0}; //null\\n\\tif(n->left==NULL && n->right==NULL) return {n->val, 0}; //leaf node ( its value will be (val,0)\\n\\tauto l = dfs(n->left), r = dfs(n->right);\\n\\tpair<int,int> x;\\n\\tx.first = n->val + l.second + r.second; //node included (its children (l&r) are excluded)\\n\\tx.second = max(l.first, l.second) + max(r.first, r.second); //node excluded\\n\\treturn x;\\n}\\n\\nint rob(TreeNode* root) {\\n\\tauto ans = dfs(root);\\n\\treturn max(ans.first, ans.second);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031987,
                "title": "crystal-clear-approach-with-clean-code-in-c",
                "content": "```\\nclass Solution {  \\npublic:\\n    unordered_map<TreeNode*,int>dp;\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        if(dp.count(root))return dp[root];\\n        int choice1 = root->val;\\n        if(root->left) choice1 += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) choice1 += rob(root->right->right) + rob(root->right->left);\\n        int choice2 = rob(root->left) + rob(root->right);\\n        return dp[root] = max(choice1, choice2);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7deb700c-2a9c-409f-a2ca-79a172273e78_1652712473.0655663.png)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {  \\npublic:\\n    unordered_map<TreeNode*,int>dp;\\n    int rob(TreeNode* root) {\\n        if(!root) return 0;\\n        if(dp.count(root))return dp[root];\\n        int choice1 = root->val;\\n        if(root->left) choice1 += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) choice1 += rob(root->right->right) + rob(root->right->left);\\n        int choice2 = rob(root->left) + rob(root->right);\\n        return dp[root] = max(choice1, choice2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001101,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> dp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(dp[root]){\\n            return dp[root];\\n        }\\n        \\n        int pick = root->val;\\n        if(root->left) pick += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) pick += rob(root->right->left) + rob(root->right->right);\\n        \\n        int notPick = rob(root->left) + rob(root->right);\\n        \\n        return dp[root] = max(pick,notPick);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> dp;\\n    int rob(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        \\n        if(dp[root]){\\n            return dp[root];\\n        }\\n        \\n        int pick = root->val;\\n        if(root->left) pick += rob(root->left->left) + rob(root->left->right);\\n        if(root->right) pick += rob(root->right->left) + rob(root->right->right);\\n        \\n        int notPick = rob(root->left) + rob(root->right);\\n        \\n        return dp[root] = max(pick,notPick);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944049,
                "title": "python-dfs-solution-easy-and-simple-fast-and-memory-efficient-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0, 0]\\n            \\n            leftPair = dfs(root.left)\\n            rightPair = dfs(root.right)\\n            withRoot = root.val + leftPair[1] + rightPair[1]\\n            withoutRoot = max(leftPair) + max(rightPair)\\n            \\n            return [withRoot, withoutRoot]\\n        \\n        return max(dfs(root))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [0, 0]\\n            \\n            leftPair = dfs(root.left)\\n            rightPair = dfs(root.right)\\n            withRoot = root.val + leftPair[1] + rightPair[1]\\n            withoutRoot = max(leftPair) + max(rightPair)\\n            \\n            return [withRoot, withoutRoot]\\n        \\n        return max(dfs(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934745,
                "title": "javascript-simple-solution-100",
                "content": "Runtime: 60 ms, faster than 100.00% of JavaScript online submissions for House Robber III.\\nMemory Usage: 47.6 MB, less than 25.10% of JavaScript online submissions for House Robber III.\\n\\n\\tconst map = new Map()\\n\\n\\tvar rob = function(root) {\\n\\t\\tif(!root) return 0\\n\\n\\t\\tif(map.get(root)) return map.get(root)\\n\\n\\t\\tlet max = rob(root.left) + rob(root.right)\\n\\n\\t\\tlet next_max = root.val\\n\\n\\t\\tif(root.left){\\n\\t\\t\\tnext_max += rob(root.left.left) + rob(root.left.right)\\n\\t\\t}\\n\\n\\t\\tif(root.right){\\n\\t\\t\\tnext_max += rob(root.right.left) + rob(root.right.right)\\n\\t\\t}\\n\\n\\t\\tmap.set(root,Math.max(max,next_max))\\n\\t\\treturn map.get(root)\\n\\t};",
                "solutionTags": [],
                "code": "Runtime: 60 ms, faster than 100.00% of JavaScript online submissions for House Robber III.\\nMemory Usage: 47.6 MB, less than 25.10% of JavaScript online submissions for House Robber III.\\n\\n\\tconst map = new Map()\\n\\n\\tvar rob = function(root) {\\n\\t\\tif(!root) return 0\\n\\n\\t\\tif(map.get(root)) return map.get(root)\\n\\n\\t\\tlet max = rob(root.left) + rob(root.right)\\n\\n\\t\\tlet next_max = root.val\\n\\n\\t\\tif(root.left){\\n\\t\\t\\tnext_max += rob(root.left.left) + rob(root.left.right)\\n\\t\\t}\\n\\n\\t\\tif(root.right){\\n\\t\\t\\tnext_max += rob(root.right.left) + rob(root.right.right)\\n\\t\\t}\\n\\n\\t\\tmap.set(root,Math.max(max,next_max))\\n\\t\\treturn map.get(root)\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1919901,
                "title": "easy-to-understand-runtime-16-ms-faster-than-78-98-of-c-house-robber-iii",
                "content": "```\\nclass Solution {\\npublic:\\n    map<TreeNode* ,int> mp;\\n    \\n    int solve(TreeNode *root){\\n        if(!root)\\n            return 0;\\n        \\n        if(mp[root])\\n            return mp[root];\\n        \\n        //case1: taking root node then we can only take its grandparents\\n        int withnode = root->val;\\n        if(root->left){\\n            withnode += solve(root->left->left);\\n            withnode += solve(root->left->right);\\n        }\\n        \\n        if(root->right){\\n            withnode += solve(root->right->left);\\n            withnode += solve(root->right->right);\\n        }\\n        \\n        //case 2: without root node we can take its child\\n        int withoutnode = solve(root->left)+ solve(root->right);\\n        \\n        return mp[root] = max(withnode, withoutnode);\\n    }    \\n    \\n    int rob(TreeNode* root) {\\n        return solve(root);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<TreeNode* ,int> mp;\\n    \\n    int solve(TreeNode *root){\\n        if(!root)\\n            return 0;\\n        \\n        if(mp[root])\\n            return mp[root];\\n        \\n        //case1: taking root node then we can only take its grandparents\\n        int withnode = root->val;\\n        if(root->left){\\n            withnode += solve(root->left->left);\\n            withnode += solve(root->left->right);\\n        }\\n        \\n        if(root->right){\\n            withnode += solve(root->right->left);\\n            withnode += solve(root->right->right);\\n        }\\n        \\n        //case 2: without root node we can take its child\\n        int withoutnode = solve(root->left)+ solve(root->right);\\n        \\n        return mp[root] = max(withnode, withoutnode);\\n    }    \\n    \\n    int rob(TreeNode* root) {\\n        return solve(root);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613613,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        Map<TreeNode, Integer>hrInc = new HashMap<>();\\n        Map<TreeNode, Integer>hrNotInc = new HashMap<>();\\n        hrInc.put(null, 0);\\n        hrNotInc.put(null, 0);\\n        rob(root, hrInc,hrNotInc);\\n        return Math.max(hrInc.get(root),hrNotInc.get(root));\\n    }\\n    \\n    public void rob(TreeNode root, Map<TreeNode, Integer>hrInc, Map<TreeNode, Integer>hrNotInc){\\n        if (root!=null){\\n            rob(root.left, hrInc,hrNotInc);\\n            rob(root.right, hrInc,hrNotInc);\\n            hrNotInc.put(root, \\n                         Math.max(hrInc.get(root.left),hrNotInc.get(root.left)) + \\n                         Math.max(hrInc.get(root.right),hrNotInc.get(root.right)));\\n            hrInc.put(root, hrNotInc.get(root.left)+hrNotInc.get(root.right)+root.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        Map<TreeNode, Integer>hrInc = new HashMap<>();\\n        Map<TreeNode, Integer>hrNotInc = new HashMap<>();\\n        hrInc.put(null, 0);\\n        hrNotInc.put(null, 0);\\n        rob(root, hrInc,hrNotInc);\\n        return Math.max(hrInc.get(root),hrNotInc.get(root));\\n    }\\n    \\n    public void rob(TreeNode root, Map<TreeNode, Integer>hrInc, Map<TreeNode, Integer>hrNotInc){\\n        if (root!=null){\\n            rob(root.left, hrInc,hrNotInc);\\n            rob(root.right, hrInc,hrNotInc);\\n            hrNotInc.put(root, \\n                         Math.max(hrInc.get(root.left),hrNotInc.get(root.left)) + \\n                         Math.max(hrInc.get(root.right),hrNotInc.get(root.right)));\\n            hrInc.put(root, hrNotInc.get(root.left)+hrNotInc.get(root.right)+root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613284,
                "title": "java-simple-solution",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber III.\\nMemory Usage: 38.4 MB, less than 86.40% of Java online submissions for House Robber III.**\\n```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        int ans[] = helper(root);\\n        return Math.max(ans[0],ans[1]);\\n    }\\n    public int[] helper(TreeNode root){\\n        if(root == null)return new int[]{0,0};\\n                \\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        int[] temp = new int[2];\\n        \\n        temp[0] = left[1] + right[1] + root.val;\\n        temp[1] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        int ans[] = helper(root);\\n        return Math.max(ans[0],ans[1]);\\n    }\\n    public int[] helper(TreeNode root){\\n        if(root == null)return new int[]{0,0};\\n                \\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        int[] temp = new int[2];\\n        \\n        temp[0] = left[1] + right[1] + root.val;\\n        temp[1] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612241,
                "title": "c-2-solutions-with-dp-without-dp",
                "content": "**Solution 1: *with DP (memoization)***\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,unordered_map<bool,int>> map;\\n    int solve(TreeNode* root, bool can){\\n        if(!root) return 0;\\n        if(map.find(root)!=map.end() && map[root].find(can)!=map[root].end()) return map[root][can];\\n        int inc=0, exc=0;\\n        if(can) inc+=root->val + solve(root->left,false) + solve(root->right,false);\\n        exc += solve(root->left,true) + solve(root->right,true);\\n        return map[root][can]=max(inc,exc);\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        return solve(root, true);\\n    }\\n};\\n```\\n**Solution 2: *without DP***\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> postorder(TreeNode* root){\\n        if(!root) return {0,0}; //exc,inc\\n        auto left = postorder(root->left);\\n        auto right = postorder(root->right);\\n        \\n        //exclude current node \\n        int exc = max(left.first, left.second) + max(right.first, right.second);\\n        //include current node\\n        int inc = root->val + left.first + right.first;\\n        return {exc,inc};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto ans = postorder(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,unordered_map<bool,int>> map;\\n    int solve(TreeNode* root, bool can){\\n        if(!root) return 0;\\n        if(map.find(root)!=map.end() && map[root].find(can)!=map[root].end()) return map[root][can];\\n        int inc=0, exc=0;\\n        if(can) inc+=root->val + solve(root->left,false) + solve(root->right,false);\\n        exc += solve(root->left,true) + solve(root->right,true);\\n        return map[root][can]=max(inc,exc);\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        return solve(root, true);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> postorder(TreeNode* root){\\n        if(!root) return {0,0}; //exc,inc\\n        auto left = postorder(root->left);\\n        auto right = postorder(root->right);\\n        \\n        //exclude current node \\n        int exc = max(left.first, left.second) + max(right.first, right.second);\\n        //include current node\\n        int inc = root->val + left.first + right.first;\\n        return {exc,inc};\\n    }\\n    \\n    int rob(TreeNode* root) {\\n        auto ans = postorder(root);\\n        return max(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529885,
                "title": "well-explained-example-easy-to-understand-dfs",
                "content": "## IDEA :\\nImagine, that we have node and L and R are left and right children. Then:\\n\\n\\t* If we rob given node, than we can not rob children, so answer will be node.val + L[1] + R[1]\\n\\t* If we do not rob house, we have two options for L and two options for R, and we choose the best ones, so we have max(L) + max(R).\\n\\t\\n**Complexity :** \\nTime complexity is O(n), because we visit all our tree. \\nSpace complexity is O(h), because we use recursion.\\n\\n**Explaination :**\\n\\'\\'\\'\\n\\t\\n\\tInput: [3,4,5,1,3,null,1]\\n\\t input tree            recursive tree:\\n\\t\\t 3                  [3+3+1,4+5]\\n\\t\\t/ \\\\                /        \\\\\\n\\t   4   5            [4,3]      [5,1]\\n\\t  / \\\\   \\\\          /     \\\\          \\\\\\n\\t 1   2   1      [1,0]    [2,0]     [1,0]\\n\\t\\t\\t\\t\\t/ \\\\       /  \\\\        /  \\\\\\n\\t\\t\\t   [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n\\n**CODE :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if root is None:\\n                return (0,0)\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            return (root.val+left[1]+right[1], max(left)+max(right))\\n        \\n        return max(dfs(root))\\n\\n**Thanks and Upvote If you like the Idea!!\\uD83E\\uDD1E**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "## IDEA :\\nImagine, that we have node and L and R are left and right children. Then:\\n\\n\\t* If we rob given node, than we can not rob children, so answer will be node.val + L[1] + R[1]\\n\\t* If we do not rob house, we have two options for L and two options for R, and we choose the best ones, so we have max(L) + max(R).\\n\\t\\n**Complexity :** \\nTime complexity is O(n), because we visit all our tree. \\nSpace complexity is O(h), because we use recursion.\\n\\n**Explaination :**\\n\\'\\'\\'\\n\\t\\n\\tInput: [3,4,5,1,3,null,1]\\n\\t input tree            recursive tree:\\n\\t\\t 3                  [3+3+1,4+5]\\n\\t\\t/ \\\\                /        \\\\\\n\\t   4   5            [4,3]      [5,1]\\n\\t  / \\\\   \\\\          /     \\\\          \\\\\\n\\t 1   2   1      [1,0]    [2,0]     [1,0]\\n\\t\\t\\t\\t\\t/ \\\\       /  \\\\        /  \\\\\\n\\t\\t\\t   [0,0] [0,0] [0,0] [0,0]  [0,0] [0,0]\\n\\n**CODE :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def rob(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n            if root is None:\\n                return (0,0)\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            return (root.val+left[1]+right[1], max(left)+max(right))\\n        \\n        return max(dfs(root))\\n\\n**Thanks and Upvote If you like the Idea!!\\uD83E\\uDD1E**",
                "codeTag": "Java"
            },
            {
                "id": 1502919,
                "title": "javascript-solution-with-post-order-dfs-recursion",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    const [rootIncluded, rootNotIncluded] = recursion(root, true);\\n    return Math.max(rootIncluded, rootNotIncluded);\\n};\\n\\n/**\\n * @param {TreeNode} root\\n * @return {[number]} values\\n*/\\nfunction recursion(root) {\\n    if (root == null) return [0, 0];\\n    // leaf node \\n    if (!root.left && !root.right) {\\n        return [root.val, 0];\\n    } \\n    const [leftRootIncluded, leftRootNotIncluded] = recursion(root.left);\\n    const [rightRootIncluded, rightRootNotIncluded] = recursion(root.right, true);\\n    \\n    return [root.val + leftRootNotIncluded + rightRootNotIncluded, \\n        Math.max(leftRootIncluded, leftRootNotIncluded) + Math.max(rightRootIncluded, rightRootNotIncluded)];\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function(root) {\\n    const [rootIncluded, rootNotIncluded] = recursion(root, true);\\n    return Math.max(rootIncluded, rootNotIncluded);\\n};\\n\\n/**\\n * @param {TreeNode} root\\n * @return {[number]} values\\n*/\\nfunction recursion(root) {\\n    if (root == null) return [0, 0];\\n    // leaf node \\n    if (!root.left && !root.right) {\\n        return [root.val, 0];\\n    } \\n    const [leftRootIncluded, leftRootNotIncluded] = recursion(root.left);\\n    const [rightRootIncluded, rightRootNotIncluded] = recursion(root.right, true);\\n    \\n    return [root.val + leftRootNotIncluded + rightRootNotIncluded, \\n        Math.max(leftRootIncluded, leftRootNotIncluded) + Math.max(rightRootIncluded, rightRootNotIncluded)];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1455639,
                "title": "time-99-47-space-91-91-simple-considering-with-and-without-the-current-node",
                "content": "here the first element of pair represents the case \"with considering the current node\" and\\nthe second element represents the case \"without considering the current node\"\\npair<int,int> traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return {0,0};\\n        pair<int,int> p1 = traversal(root->left);\\n        pair<int,int> p2 = traversal(root->right);\\n        pair<int,int> p3;\\n        p3.first = p1.second + p2.second + root->val;\\n        p3.second = max(p1.first, p1.second) + max(p2.first, p2.second);\\n        return p3;\\n    }\\n    int rob(TreeNode* root) {\\n        \\n        pair<int,int> ans = traversal(root);\\n        return max(ans.first, ans.second);\\n    }",
                "solutionTags": [],
                "code": "here the first element of pair represents the case \"with considering the current node\" and\\nthe second element represents the case \"without considering the current node\"\\npair<int,int> traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return {0,0};\\n        pair<int,int> p1 = traversal(root->left);\\n        pair<int,int> p2 = traversal(root->right);\\n        pair<int,int> p3;\\n        p3.first = p1.second + p2.second + root->val;\\n        p3.second = max(p1.first, p1.second) + max(p2.first, p2.second);\\n        return p3;\\n    }\\n    int rob(TreeNode* root) {\\n        \\n        pair<int,int> ans = traversal(root);\\n        return max(ans.first, ans.second);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1409247,
                "title": "logic-explanation-in-detail-with-code",
                "content": "Just like the previous two House robber problems, the basic principle of the 3rd one remains the same. \\n*A robber will either rob the current node, or will not rob the current node.*\\n\\nSo at every node we need to have the maximum amount for both the case:\\n1. maximum amount if the current node is robbed\\n2. maximum amount if the current node is not robbed\\n\\nUsing dfs, we start at the bottom, and return both these values to the parent nodes.\\nNow \\n**Case 1: Current node is included.**\\nThis means that the children node cannot be included. So the value for this node becomes current node\\'s value + max sum excluding left child + max sum excluding right child.\\n\\n**Case 2: Current node is not included.**\\nSince this node is not included, we may (or may not) include the children values. But one fact is clear, (max robbed value of the left sub tree) + (the max robbed value of right subtree) = max robbed value for current subtree. \\n\\nUsing these two points we can calculate the max robbed amount at every node. Finally the answer will be max(value with root selected, value with root not selected)\\n\\nCode:\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class MaxRobTillHere {\\n        int including = 0;\\n        int excluding = 0;\\n        public MaxRobTillHere(int including, int excluding) {\\n            this.including = including;\\n            this.excluding = excluding;\\n        }\\n    }\\n    public int rob(TreeNode root) {\\n        MaxRobTillHere pair = maxRob(root);\\n        return max(pair.including, pair.excluding);\\n    }\\n    \\n    private MaxRobTillHere maxRob(TreeNode node) {\\n        if(node == null) {\\n            return new MaxRobTillHere(0,0);\\n        }        \\n        MaxRobTillHere left = maxRob(node.left);\\n        MaxRobTillHere right = maxRob(node.right);\\n        \\n        int maxIncludingCurrent = left.excluding + right.excluding + node.val;\\n        int maxExcludingCurrent = max(left.including, left.excluding) + \\n                                  max(right.including, right.excluding);\\n        \\n        MaxRobTillHere robbed = new MaxRobTillHere(maxIncludingCurrent, maxExcludingCurrent);\\n        \\n        return robbed;\\n    }\\n    \\n    private int max(int ... a) {\\n        int max = 0;\\n        for(int i : a) {\\n            max = max < i ? i : max;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nPlease comment if you have any doubts or suggestions for further optimization.\\nPeace.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class MaxRobTillHere {\\n        int including = 0;\\n        int excluding = 0;\\n        public MaxRobTillHere(int including, int excluding) {\\n            this.including = including;\\n            this.excluding = excluding;\\n        }\\n    }\\n    public int rob(TreeNode root) {\\n        MaxRobTillHere pair = maxRob(root);\\n        return max(pair.including, pair.excluding);\\n    }\\n    \\n    private MaxRobTillHere maxRob(TreeNode node) {\\n        if(node == null) {\\n            return new MaxRobTillHere(0,0);\\n        }        \\n        MaxRobTillHere left = maxRob(node.left);\\n        MaxRobTillHere right = maxRob(node.right);\\n        \\n        int maxIncludingCurrent = left.excluding + right.excluding + node.val;\\n        int maxExcludingCurrent = max(left.including, left.excluding) + \\n                                  max(right.including, right.excluding);\\n        \\n        MaxRobTillHere robbed = new MaxRobTillHere(maxIncludingCurrent, maxExcludingCurrent);\\n        \\n        return robbed;\\n    }\\n    \\n    private int max(int ... a) {\\n        int max = 0;\\n        for(int i : a) {\\n            max = max < i ? i : max;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385015,
                "title": "easy-c-solution-using-post-order-traversal",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    // first --> sum including the root->data;\\n    // second --> sum excluding the root->data\\n    pair<int,int> helper(TreeNode *root)\\n    {\\n        if(!root)\\n        {\\n            return {0,0};\\n        }\\n        auto leftData=helper(root->left);\\n        auto rightData=helper(root->right);\\n        \\n        // now get the answer for including the root->data\\n        int include=root->val+leftData.second+rightData.second;\\n        \\n        \\n        // now get the answer for excluding the root->data\\n        int exclude=max(leftData.first,leftData.second)+max({rightData.first,rightData.second});\\n        \\n        \\n        // return the pair\\n        return {include,exclude};\\n    }\\n    int rob(TreeNode* root)\\n    {\\n        auto data=helper(root);\\n        return max(data.first,data.second);\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // first --> sum including the root->data;\\n    // second --> sum excluding the root->data\\n    pair<int,int> helper(TreeNode *root)\\n    {\\n        if(!root)\\n        {\\n            return {0,0};\\n        }\\n        auto leftData=helper(root->left);\\n        auto rightData=helper(root->right);\\n        \\n        // now get the answer for including the root->data\\n        int include=root->val+leftData.second+rightData.second;\\n        \\n        \\n        // now get the answer for excluding the root->data\\n        int exclude=max(leftData.first,leftData.second)+max({rightData.first,rightData.second});\\n        \\n        \\n        // return the pair\\n        return {include,exclude};\\n    }\\n    int rob(TreeNode* root)\\n    {\\n        auto data=helper(root);\\n        return max(data.first,data.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318279,
                "title": "c-solution-with-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\tunordered_map<TreeNode*, int> table;\\n\\t\\tint rob(TreeNode* root) {\\n\\t\\t\\treturn profit(root);\\n\\t\\t}\\n\\n\\t\\tint profit(TreeNode* root) {\\n\\t\\t\\tif (table.count(root))\\n\\t\\t\\t\\treturn table[root];\\n\\t\\t\\tif (root == NULL)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif (root->left == NULL && root->right == NULL)\\n\\t\\t\\t\\treturn root->val;\\n\\t\\t\\tint c, d, e, f;\\n\\t\\t\\tint l1 = profit(root->left) + profit(root->right);\\n\\t\\t\\tc = root->left != NULL ? profit(root->left->left) : 0;\\n\\t\\t\\td = root->left != NULL ? profit(root->left->right) : 0;\\n\\t\\t\\te = root->right != NULL ? profit(root->right->left) : 0;\\n\\t\\t\\tf = root->right != NULL ? profit(root->right->right) : 0;\\n\\t\\t\\tint l2 = root->val + c + d + e + f;\\n\\t\\t\\treturn table[root] = max (l1, l2);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tunordered_map<TreeNode*, int> table;\\n\\t\\tint rob(TreeNode* root) {\\n\\t\\t\\treturn profit(root);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1281326,
                "title": "simple-c-recursive-solution",
                "content": "here first element of pair will store the ans till the current node , and second  will store the answer till  the previous node .\\n\\nhence **answer till current node** = max( curr->val + ans till previous of previous node (right.prev +left.prev),  ans till previous nodes (right +left)),  and **the previous for curr node**=  ans till previous node(right +left))\\n```\\nclass Solution {\\npublic:\\n   pair<int,int> find(TreeNode* root){\\n      if(!root)\\n          return {0,0};\\n\\t\\t  \\n       \\n       pair<int,int> a=find(root->left);\\n       pair<int,int> b= find(root->right);\\n       \\n       return {max(root->val +b.second + a.second, a.first+b.first ), a.first+b.first};\\n       \\n   }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n      pair<int,int> ans= find(root);\\n        return ans.first;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   pair<int,int> find(TreeNode* root){\\n      if(!root)\\n          return {0,0};\\n\\t\\t  \\n       \\n       pair<int,int> a=find(root->left);\\n       pair<int,int> b= find(root->right);\\n       \\n       return {max(root->val +b.second + a.second, a.first+b.first ), a.first+b.first};\\n       \\n   }\\n    \\n    int rob(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n      pair<int,int> ans= find(root);\\n        return ans.first;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570574,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1574304,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1911190,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569999,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1565914,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1570911,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1575786,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569087,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1575404,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569088,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1570574,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1574304,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1911190,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569999,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1565914,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1570911,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1575786,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569087,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1575404,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1569088,
                "content": [
                    {
                        "username": "Lakshya12",
                        "content": "Why do you want us to help a theif? lol"
                    },
                    {
                        "username": "laticm",
                        "content": "[@KuvonchbekN](/KuvonchbekN)  lmao\\n"
                    },
                    {
                        "username": "KuvonchbekN",
                        "content": "Because you helped him in the first and second part of this question. LOL"
                    },
                    {
                        "username": "t1lu",
                        "content": "Not very good at dp questions, wish this thief be arrested soon lol."
                    },
                    {
                        "username": "yang_tomato",
                        "content": "agree, why should we help a thief ? hhhh"
                    },
                    {
                        "username": "prmems",
                        "content": "Can we bust this house robber? Every time we help him, he seems to find another place to rob."
                    },
                    {
                        "username": "aksharkashyap",
                        "content": "This question can be asked in this way also:\\nIn every house certain number of thief are hiding (instead of money)\\nmaximize the number of thief caught by a police man.\\ngiven that two directly-linked houses cant be broken on the same night."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "fair enough , we are on police side this time ... lol\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/house-robber-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion with Memoization\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coldstone87",
                        "content": "[4,1,null,2,null,3]\\n\\nWhere will we keep last 3 in the tree and how does it affect the output?\\nMy submission is failing due to this."
                    },
                    {
                        "username": "Flecart",
                        "content": "Put it in the testcase, it will show you the tree, it's a linear linked list"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Anyone interested about how to print out the robber house?"
                    },
                    {
                        "username": "lh19900702",
                        "content": "The requirement of the problem is : It will automatically contact the police if two directly-linked houses were broken into on the same night.\\n\\nSo consider the example as below:\\n                 ----1\\n               --8    - 1\\n-1 1 1 9\\n\\nWe can rob 8 & 9 without violating the rule since the two nodes are now not directly-linked. However, this is maximum but not got from odd levels' sum or even levels' sum. Could anyone help me about this?"
                    },
                    {
                        "username": "DwaiBasu",
                        "content": "The robber steals house 8(does not steal the child houses of 8 since its adjacent)  then moves upwards to root (1) , ignores the root house (adjacent) , moves to right child of root( 1 ) , it decides to ignore this house as well and moves further right of 1 to node 9 , It selects to rob house 9.\\nTherefore 8 + 9 = 17 // Output "
                    },
                    {
                        "username": "lizlizlizzy",
                        "content": "Funny background"
                    },
                    {
                        "username": "tswperfect",
                        "content": "Can someone explain this test case? After I drew the tree but still don't get it."
                    }
                ]
            },
            {
                "id": 1954150,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1801476,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1751648,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1574584,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1573592,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 2036041,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 2033442,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 2024793,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 2010751,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1970842,
                "content": [
                    {
                        "username": "shivam_sharma2004",
                        "content": "bruh i helped this robber three times in a single day 😢 and he is not even giving me my shares 😤"
                    },
                    {
                        "username": "ruikunha",
                        "content": "Leetcode, please stop robbing the house... It\\'s illegal."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "[2,1,3,null,4]\\nmy ans is 6 , But expected ans is 7.\\nCan anyone explain this to me?"
                    },
                    {
                        "username": "hiralv",
                        "content": "You came to  answer 6 because you decide to rob 4 and 2. \\nBut if you rob 2, you cannot rob 3 since they are directly linked. \\nSo skip 2 and instead rob 3. This would result in 4 + 3 = 7."
                    },
                    {
                        "username": "maksymilianr",
                        "content": "The image 2nd example of Maximum Difference Between Node and Ancestor has an error. It\\'s nodes are 1,2,0,4 whereas it\\'s Input: root = [1,null,2,null,0,3].\\n(The last node has image with 4, should be 3)\\n\\nIf there is a form for sending errors in problems - I was not able to find anything other than adding a new test case."
                    },
                    {
                        "username": "BigOlogn",
                        "content": "Hello,\\nCan someone let me know what does it mean by two directly linked houses?\\nThanks"
                    },
                    {
                        "username": "Divyanshushukla82",
                        "content": "Someone please call the police, this robber is getting out of hand now."
                    },
                    {
                        "username": "HowardLi0916",
                        "content": "I can really handle a difficult problem on my own !!!"
                    },
                    {
                        "username": "ulairi",
                        "content": "Smart CS student cannot find a job and then become a thief I guess"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Question is similar to \"Maximum sum of non adjacent Nodes\""
                    },
                    {
                        "username": "piyush-yadav162",
                        "content": "java.lang.NullPointerException: Cannot load from int array because \"<local1>\" is null\\n \\ngetting this error"
                    }
                ]
            },
            {
                "id": 1965178,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1915909,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1884512,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1854390,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1783603,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1766972,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1720772,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1704342,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1655135,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            },
            {
                "id": 1575377,
                "content": [
                    {
                        "username": "rustii_rust",
                        "content": "Does this problem have a tabulation/iterative solution?"
                    },
                    {
                        "username": "JToaddler",
                        "content": "do a level order traversal to convert it to an array and apply house robber 1 ?  "
                    },
                    {
                        "username": "Chaitanya_89",
                        "content": "what is the meaning of directly linked houses ? \\nplease give example\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It\\'s a Dp Problem, but the issue is in memonizing the recursive ouputs as the trees have repeating values.\\n\\nOne smart way to do it to use \\n`unordered_map<int,int> dp`\\n\\nGenerate key by using this bit function\\n\\n`\\nint getIdentifier(TreeNode* node, bool took) {\\n        return ((long)node << 1) | took;\\n    }\\n`\\n\\n"
                    },
                    {
                        "username": "khrome",
                        "content": "Can someone help me analyze the space-time complexity of this?\\n \\n    def rob(self, root: Optional[TreeNode]) -> int:\\n            @cache\\n            def dp(root,canRob=True):\\n                if not root:\\n                    return 0\\n                rob = 0\\n                if canRob:\\n                    rob = root.val + dp(root.left,False) + dp(root.right,False)\\n                noRob = dp(root.left,True) + dp(root.right,True)\\n                return max(rob, noRob)\\n            return dp(root)\\n\\nI am thinking its O(N), with N nodes in the tree. This solution is too slow without caching, but wouldnt it just be 2N without caching? "
                    },
                    {
                        "username": "Rupam0710",
                        "content": "This problem could have been done easily by only dfs (122/124 cases running) , but to reduce the TC \\nwe have to apply memoization to get all the test case running."
                    },
                    {
                        "username": "svbrkr545",
                        "content": "You can look at the tree in a top-down manner, there will be two cases \\n1. max containing the root node\\n2. max excluding the root and including the child nodes\\n\\nIn a dfs manner, traverse the tree and for each root return these values as a pair.\\n\\nSo for each node we have a pair containing the max value possible by including/excluding the particular node"
                    },
                    {
                        "username": "saharshjain",
                        "content": "This is throwing TLE in 2 cases, can someone help on what I am doing wrong or optimised in this soln.\\n ```\\nvar rob = function (root) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  return Math.max(Steal(root, 0), Steal(root, 1));\\n};\\n\\nfunction Steal(root, canSteal) {\\n  if (root == null) {\\n    return 0;\\n  }\\n  let lNoSteal = Steal(root.left, 0);\\n  let rNoSteal = Steal(root.right, 0);\\n  if (canSteal) {\\n    //include root val\\n    return Math.max(root.val + lNoSteal + rNoSteal);\\n  } else {\\n    let lSteal = Steal(root.left, 1);\\n    let rSteal = Steal(root.right, 1);\\n    //ignore root\\n    return Math.max(\\n      lNoSteal + rNoSteal,\\n      lNoSteal + rSteal,\\n      lSteal + rNoSteal,\\n      lSteal + rSteal\\n    );\\n  }\\n}```"
                    },
                    {
                        "username": "vijay_2022",
                        "content": "Can some please help me understand what\\'s wrong with my solution\\n\\ndef rob(self, root: Optional[TreeNode]) -> int:\\n        q = deque([root])\\n        i,j, tot= 0 , 0 , 0\\n        while q:\\n            cur = []\\n            tot = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                tot += node.val \\n                if node.left:\\n                    cur.append(node.left)\\n                if node.right:\\n                    cur.append(node.right)\\n            tot = max(tot + i, j)\\n            i,j = j, tot\\n            q.extend(cur)\\n        return max(i,j) \\n\\nits failing for the test case [2,1,3,null,4] my code return 6 as answer but the expected answer is 7, but am not sure how    \\n"
                    },
                    {
                        "username": "harshittrivedi8691",
                        "content": "HashMap<TreeNode,Integer> hm=new HashMap();\\n\\npublic int rob(TreeNode root) {\\n\\n\\tif(root == null)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tif(hm.containsKey(root))\\n\\t{\\n\\t\\treturn hm.get(root);\\n\\t}\\n\\n\\tTreeNode left=root.left;\\n\\tTreeNode right=root.right;\\n\\n\\t// include\\n\\tint include = root.val+ (left!=null?(rob(left.left)+rob(left.right)):0)+\\n\\t(right!=null?(rob(right.left)+rob(right.right)):0);\\n\\n\\t//exclude\\n\\tint exclude=rob(left)+rob(right);\\n\\tint result= Math.max(include,exclude);\\n\\thm.put(root,result);\\n\\treturn result;\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Toeplitz Matrix",
        "question_content": "<p>Given an <code>m x n</code> <code>matrix</code>, return&nbsp;<em><code>true</code>&nbsp;if the matrix is Toeplitz. Otherwise, return <code>false</code>.</em></p>\n\n<p>A matrix is <strong>Toeplitz</strong> if every diagonal from top-left to bottom-right has the same elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nIn the above grid, the&nbsp;diagonals are:\n&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.\nIn each diagonal all elements are the same, so the answer is True.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2],[2,2]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nThe diagonal &quot;[1, 2]&quot; has different elements.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the <code>matrix</code> is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?</li>\n\t<li>What if the <code>matrix</code> is so large that you can only load up a partial row into the memory at once?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113417,
                "title": "java-solution-4-liner",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for (int i = 0; i < matrix.length - 1; i++) {\\n            for (int j = 0; j < matrix[i].length - 1; j++) {\\n                if (matrix[i][j] != matrix[i + 1][j + 1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for (int i = 0; i < matrix.length - 1; i++) {\\n            for (int j = 0; j < matrix[i].length - 1; j++) {\\n                if (matrix[i][j] != matrix[i + 1][j + 1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271388,
                "title": "java-solution-for-follow-up-1-2",
                "content": "Here are what I\\'ve thought so far, please let me know if you have any better ideas!\\n\\nFor the follow-up 1, we are only able to load one row at one time, so we have to use a buffer (1D data structure) to store the row info. When next row comes as a streaming flow, we can compare each value (say, matrix[i][j], i>=1, j>=1) to the \"upper-left\" value in the buffer (buffer[j - 1]); meanwhile, we update the buffer by inserting the 1st element of the current row (matrix[i][0]) to buffer at position 0 (buffer[0]), and removing the last element in the buffer. \\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return true;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        List<Integer> buffer = new LinkedList<>();\\n        for(int j = 0; j < col; j++) buffer.add(matrix[0][j]);\\n        for(int i = 1; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                if(buffer.get(j - 1) != matrix[i][j]) return false;\\n            }\\n            buffer.remove(buffer.size() - 1);\\n            buffer.add(0, matrix[i][0]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nFor the follow-up 2, we can only load a partial row at one time. We could split the whole matrix vertically into several sub-matrices, while each sub-matrix should have one column overlapped. We repeat the same method in follow-up 1 for each sub-matrix. \\n\\nFor example:\\n```\\n[1 2 3 4 5 6 7 8 9 0]              [1 2 3 4]              [4 5 6 7]              [7 8 9 0]\\n[0 1 2 3 4 5 6 7 8 9]              [0 1 2 3]              [3 4 5 6]              [6 7 8 9]\\n[1 0 1 2 3 4 5 6 7 8]     -->      [1 0 1 2]       +      [2 3 4 5]       +      [5 6 7 8]\\n[2 1 0 1 2 3 4 5 6 7]              [2 1 0 1]              [1 2 3 4]              [4 5 6 7]\\n[3 2 1 0 1 2 3 4 5 6]              [3 2 1 0]              [0 1 2 3]              [3 4 5 6]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return true;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        List<Integer> buffer = new LinkedList<>();\\n        for(int j = 0; j < col; j++) buffer.add(matrix[0][j]);\\n        for(int i = 1; i < row; i++){\\n            for(int j = 1; j < col; j++){\\n                if(buffer.get(j - 1) != matrix[i][j]) return false;\\n            }\\n            buffer.remove(buffer.size() - 1);\\n            buffer.add(0, matrix[i][0]);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n[1 2 3 4 5 6 7 8 9 0]              [1 2 3 4]              [4 5 6 7]              [7 8 9 0]\\n[0 1 2 3 4 5 6 7 8 9]              [0 1 2 3]              [3 4 5 6]              [6 7 8 9]\\n[1 0 1 2 3 4 5 6 7 8]     -->      [1 0 1 2]       +      [2 3 4 5]       +      [5 6 7 8]\\n[2 1 0 1 2 3 4 5 6 7]              [2 1 0 1]              [1 2 3 4]              [4 5 6 7]\\n[3 2 1 0 1 2 3 4 5 6]              [3 2 1 0]              [0 1 2 3]              [3 4 5 6]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113385,
                "title": "python-easy-and-concise-solution",
                "content": "```\\ndef isToeplitzMatrix(self, m):\\n        for i in range(len(m) - 1):\\n            for j in range(len(m[0]) - 1):\\n                if m[i][j] != m[i + 1][j + 1]:\\n                    return False\\n        return True\\n```\\nMake it 1 line:\\n```\\n    def isToeplitzMatrix(self, m):\\n        return all(m[i][j] == m[i+1][j+1] for i in range(len(m)-1) for j in range(len(m[0])-1))\\n```\\nOr shorter and more pythonic.\\n```\\n    def isToeplitzMatrix(self, m):\\n        return all(r1[:-1] == r2[1:] for r1,r2 in zip(m, m[1:]))\\n```",
                "solutionTags": [],
                "code": "```\\ndef isToeplitzMatrix(self, m):\\n        for i in range(len(m) - 1):\\n            for j in range(len(m[0]) - 1):\\n                if m[i][j] != m[i + 1][j + 1]:\\n                    return False\\n        return True\\n```\n```\\n    def isToeplitzMatrix(self, m):\\n        return all(m[i][j] == m[i+1][j+1] for i in range(len(m)-1) for j in range(len(m[0])-1))\\n```\n```\\n    def isToeplitzMatrix(self, m):\\n        return all(r1[:-1] == r2[1:] for r1,r2 in zip(m, m[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113422,
                "title": "c-java-clean-code",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                if (matrix[i][j] != matrix[i - 1][j - 1])\\n                    return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                if (matrix[i][j] != matrix[i - 1][j - 1])\\n                    return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                if (matrix[i][j] != matrix[i - 1][j - 1])\\n                    return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        for (int i = 1; i < m; i++)\\n            for (int j = 1; j < n; j++)\\n                if (matrix[i][j] != matrix[i - 1][j - 1])\\n                    return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516366,
                "title": "python-follow-up-1-with-explanation-and-diagrams",
                "content": "# Summary\\nIn order to handle the follow-up, we need to rely on the fact that the next element in a diagonal is on the next row in the next column.\\nWe can keep a Deque/LinkedList tracking what value is expected in each row (expected_row).\\nEvaluate the matrix row by row removing the rightmost element in the deque and adding the current row\\'s first element to the left of the deque.\\nYou can then compare every cell in your expected_row to the current row. The indices will line up.\\nInitially, the expected row just contains the values from the first row in the matrix.\\n\\n# Code\\n\\n```python\\n############################################################################################\\n# Follow-Up Solution\\n#   Runtime: O(MN)\\n#       Every cell is touched about once.\\n#   Space: O(N)\\n#       We need to store a deque of length equal to the number of columns.\\n# Runtime: 72 ms, faster than 99.85% of Python3 online submissions for Toeplitz Matrix.\\n# Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Toeplitz Matrix.\\n############################################################################################\\nfrom collections import deque\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        # Validate Input\\n        if not matrix or not matrix[0]:\\n            return False                \\n        \\n        # Create a deque tracking the expected values for the next row\\n        expected = deque(matrix[0])\\n        \\n        # Iterate through all the remaining rows, verifying they align with the\\n        #   expected row.\\n        for row_i in range(1, len(matrix)):\\n            row = matrix[row_i]\\n            expected.pop()\\n            expected.appendleft(row[0])\\n            \\n\\t\\t\\t# Only check from index 1 and down as we\\'ve just added index 0 to expected\\n            for col_i in range(1, len(row)):\\n                if row[col_i] != expected[col_i]:\\n                    return False\\n        \\n        # If we\\'ve reached here, all diagonals aligned\\n        return True\\n```\\nBonus: this solution solves the original problem fairly efficiently as well.\\n\\n\\n# Extended Breakdown\\nGrabbing this image from [WolframAlpha](http://mathworld.wolfram.com/Diagonal.html):\\n![image](https://assets.leetcode.com/users/bshaibu/image_1582332290.png)\\n\\nWe know that a_11 needs to match a_2,2 and a_1,2 needs to match a_2,3 and so on. Instead of comparing each cell to its top right neighbor or tracking a mapping of the diagonals\\' value , we can persist the value of the top most element in each diagonal.\\n\\nWorking with the matrix from the problem explanation,\\n```\\nmatrix = [\\n  [1,2,3,4],\\n  [5,1,2,3],\\n  [9,5,1,2]\\n]\\n```\\n\\nthe diagonals line up like so:\\n![image](https://assets.leetcode.com/users/bshaibu/image_1582332786.png)\\n\\nWe can notice that if we shift the previous row to the right it aligns with the next row and we can easily verify if the value in that column matches the next value in the diagonal. \\n![image](https://assets.leetcode.com/users/bshaibu/image_1582333036.png)\\n\\nWe also know that the first element in the diagonal should match all other elements in the diagonal so no there\\'s need to change the value/we can keep re-using that element. \\n\\nWe also know the column that we expect to match our element increments by 1 in every subsequent row (e.g. we know the value 1 should be at col 0 in row 0, col 1 in row 1, col 2 in row 2 and so on). That means we just need to slide each value down one col everytime we go to a new row.\\n\\nThe first element (col 0) of every row is the first element of a new diagonal and should be added to what we\\'re checking for the next row.\\n\\nPutting that all together, we can just use a deque/linked list to track\\n![image](https://assets.leetcode.com/users/bshaibu/image_1582333705.png)\\n\\nSpecifically,\\n* At step 0, we set our buffer to `expected = [1, 2, 3, 4]`\\n\\t* we can skip comparing row 0.\\n* At step 1, we can drop the last element (4) as it has nothing to be compared to anymore. We add 5 to the left of `expected` as it needs to be compared to elements in the next row.\\n\\t* so `expected = [5 1 2 3]`\\n\\t* We compare that to row 1, `[5 1 2 3]` and it checks out.\\n\\t* note: we can start comparing expected to the row from index 1 since we know index 0 is the same.\\n* At step 2, we drop 3 as it has nothing else to be compared to and add 9 to the left of expected.\\n\\t* So `expected = [9 5 1 2]` and that also checks out.\\n* We\\'re done for this matrix and never saw a mismatch.\\n\\n# Notes\\nI didn\\'t come up with a solution to Follow-Up 2, but there\\'s a good high-level explanation here: https://leetcode.com/problems/toeplitz-matrix/discuss/271388/Java-Solution-for-Follow-Up-1-and-2.\\n\\nPlease let me know if you have any other thoughts on Follow Up 2 or suggestions for my Follow Up 1 idea/code!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n############################################################################################\\n# Follow-Up Solution\\n#   Runtime: O(MN)\\n#       Every cell is touched about once.\\n#   Space: O(N)\\n#       We need to store a deque of length equal to the number of columns.\\n# Runtime: 72 ms, faster than 99.85% of Python3 online submissions for Toeplitz Matrix.\\n# Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Toeplitz Matrix.\\n############################################################################################\\nfrom collections import deque\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        # Validate Input\\n        if not matrix or not matrix[0]:\\n            return False                \\n        \\n        # Create a deque tracking the expected values for the next row\\n        expected = deque(matrix[0])\\n        \\n        # Iterate through all the remaining rows, verifying they align with the\\n        #   expected row.\\n        for row_i in range(1, len(matrix)):\\n            row = matrix[row_i]\\n            expected.pop()\\n            expected.appendleft(row[0])\\n            \\n\\t\\t\\t# Only check from index 1 and down as we\\'ve just added index 0 to expected\\n            for col_i in range(1, len(row)):\\n                if row[col_i] != expected[col_i]:\\n                    return False\\n        \\n        # If we\\'ve reached here, all diagonals aligned\\n        return True\\n```\n```\\nmatrix = [\\n  [1,2,3,4],\\n  [5,1,2,3],\\n  [9,5,1,2]\\n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761329,
                "title": "python-c-java-rust-4-different-one-liners-follow-up-bonus-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nHere is a collection of one-liners and other concise solutions to this problem. Time complexity is linear (in the number of elements): **O(m\\\\*n)**. Space complexity vary. \\n\\n**For the BONUS with the solution to the FOLLOW-UP question, please scroll down till the end.**\\n\\n**Python #1.** Numpy solution: check unique values in each diagonal.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # check that each diagonal has a single unique value\\n        return all(len(set(np.diagonal(m,d)))==1 for d in range(-len(m)+1,len(m[0])))\\n```\\n\\n**Python #2.** Scipy version: construct Toeplitz matrix, then compare.\\n```\\nfrom scipy.linalg import toeplitz\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n\\t    # construct Toeplitz matrix using first row and first column, then compare\\n        return (toeplitz(list(zip(*m))[0], m[0]) == m).all()\\n```\\n**Python #3.** Shifted rows, using *zip*.\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # compare each row to the next row shifted by 1 \\n        return all(r1[:-1] == r2[1:] for r1,r2 in zip(m, m[1:]))\\n```\\n\\n**Python #4.** Shifted rows, without *zip*.\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # compare each row to the next row shifted by 1 \\n        return all(m[r+1][1:] == m[r][:-1] for r in range(len(m)-1))\\n```\\n\\n**Rust.** Shifted rows.\\n```\\nimpl Solution \\n{\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool \\n    {\\n        // compare each row to the next row shifted by 1 \\n        matrix\\n            .windows(2)\\n            .all(|w| &w[0][0..w[0].len() - 1] == &w[1][1..w[1].len()])\\n    }\\n}\\n```\\nNext, a bunch of imperative solutions.\\n<iframe src=\"https://leetcode.com/playground/dxwj5Q49/shared\" frameBorder=\"0\" width=\"800\" height=\"280\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS FOLLOW-UP SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nIf we\\'re limited to just reading *one value at a time*, we can still scan the whole matrix diagonal-by-diagonal with **O(1)** space compleixty. Here is the solution in **Python**. Generalization to *reading n values at a time* is trivial.\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        \\n        # [1] here, I specify placeholders for the actual\\n        #     functions that should perform disk operations;\\n        #     it is assumed that the we can access any\\n        #     matrix value by specifying column and row\\n        def get_n_rows() : return len(m)\\n        def get_n_cols() : return len(m[0])\\n        def get_val(i,j) : return m[i][j]\\n            \\n        nr = get_n_rows()\\n        nc = get_n_cols()\\n        \\n        # [2] this generator yields indices for a given diagonal;\\n        #     space complexity is O(1), indices are not stored!\\n        def diag_indices(d):\\n            if d >= 0 : i0, j0, k0 = 0,      d, min(nr, nc-d)\\n            else      : i0, j0, k0 = abs(d), 0, min(nc, nr-abs(d))\\n            for k in range(k0):\\n                yield (i0+k, j0+k)\\n        \\n        # [3] iterate over all diagonals and make sure that\\n        #     all values on each diagonal are equal\\n        for d in range(-nr+1,nc):\\n            v = -1\\n            for i, j in diag_indices(d):\\n                if v < 0             : v = get_val(i,j)\\n                if get_val(i,j) != v : return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # check that each diagonal has a single unique value\\n        return all(len(set(np.diagonal(m,d)))==1 for d in range(-len(m)+1,len(m[0])))\\n```\n```\\nfrom scipy.linalg import toeplitz\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n\\t    # construct Toeplitz matrix using first row and first column, then compare\\n        return (toeplitz(list(zip(*m))[0], m[0]) == m).all()\\n```\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # compare each row to the next row shifted by 1 \\n        return all(r1[:-1] == r2[1:] for r1,r2 in zip(m, m[1:]))\\n```\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        # compare each row to the next row shifted by 1 \\n        return all(m[r+1][1:] == m[r][:-1] for r in range(len(m)-1))\\n```\n```\\nimpl Solution \\n{\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool \\n    {\\n        // compare each row to the next row shifted by 1 \\n        matrix\\n            .windows(2)\\n            .all(|w| &w[0][0..w[0].len() - 1] == &w[1][1..w[1].len()])\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        \\n        # [1] here, I specify placeholders for the actual\\n        #     functions that should perform disk operations;\\n        #     it is assumed that the we can access any\\n        #     matrix value by specifying column and row\\n        def get_n_rows() : return len(m)\\n        def get_n_cols() : return len(m[0])\\n        def get_val(i,j) : return m[i][j]\\n            \\n        nr = get_n_rows()\\n        nc = get_n_cols()\\n        \\n        # [2] this generator yields indices for a given diagonal;\\n        #     space complexity is O(1), indices are not stored!\\n        def diag_indices(d):\\n            if d >= 0 : i0, j0, k0 = 0,      d, min(nr, nc-d)\\n            else      : i0, j0, k0 = abs(d), 0, min(nc, nr-abs(d))\\n            for k in range(k0):\\n                yield (i0+k, j0+k)\\n        \\n        # [3] iterate over all diagonals and make sure that\\n        #     all values on each diagonal are equal\\n        for d in range(-nr+1,nc):\\n            v = -1\\n            for i, j in diag_indices(d):\\n                if v < 0             : v = get_val(i,j)\\n                if get_val(i,j) != v : return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761319,
                "title": "c-compare-with-element-to-the-left-and-up-clean-code",
                "content": "# Approach 1: compare with element to the left and up\\n\\nThis is pretty straight forward, for the rows > 0 and cols > 0 we just check if each element is equal to the element to the left and up.\\n\\n```cpp\\n    static bool isToeplitzMatrix(const vector<vector<int>>& matrix) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        for (int r = 1; r < rows; ++r)\\n            for (int c = 1; c < cols; ++c)\\n                if (matrix[r][c] != matrix[r - 1][c - 1]) return false;\\n        \\n        return true;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(rows * cols)$$ and we can\\'t do better than that, as we need to look at every element in the matrix to decide if it\\'s Toeplitz matrix.\\n  * Space Complexity: $$O(1)$$\\n\\n## Further thoughts and comments\\n  * A [Toeplitz matrix](https://en.wikipedia.org/wiki/Toeplitz_matrix) has some interesting properties which are worth taking look.\\n  * For the follow up question [this post](https://leetcode.com/problems/toeplitz-matrix/discuss/271388/Java-Solution-for-Follow-Up-1-and-2) from @zyuan18 outlines the approach that I would take as well, i.e. break up the matrix column wise with one column overlap. With that we would also reading large chunks from disk sequentially. Leaving enough memory for 3 partial rows in memory would allow to process two while reading the 3rd chunk from disk in the background. Accessing anything out of order would be rather expensive.\\n  * For cache locality and prefetching IMO the input matrix is just too small for that really to matter, as the size is restricted to 20x20. For larger input\\'s this would really start to matter though.\\n  * Dragons here: Strictly speaking we should be using ```size_t``` instead of ```int``` for ```rows```, ```cols```, ```r```, and ```c``` and use the code below. What we need to watch out for when using ```size_t``` instead of ```int``` is that ```size_t``` is an unsigned type and ```size(matrix) - 1``` could _underflow_ if the matrix is empty. The program would crash and burn in this case. Not a problem in the way the code is written, but if we would have written ```for (int i = 0; i < size(matrix) - 1; ++i)``` instead we could potential run into problems here. What\\'s interesting is that the compiler seems to generate slight more compact code for the version using ```size_t```, see https://godbolt.org/z/rYW55ddr1\\n\\n```cpp\\n    static bool isToeplitzMatrix(const vector<vector<int>>& matrix) {\\n        const size_t rows = matrix.size();\\n        const size_t cols = matrix[0].size();\\n        for (size_t r = 1; r < rows; ++r)\\n            for (size_t c = 1; c < cols; ++c)\\n                if (matrix[r][c] != matrix[r - 1][c - 1]) return false;\\n        \\n        return true;\\n    }\\n```\\n  * What\\'s the deal with ```static``` you might ask? We are not using any member variables of ```class Solution```. That ```static``` makes this explicit and we are also not passing the implicit ```this``` pointer around.\\n  * Why all the ```const```? Using ```const``` has more than once helped the compiler in protecting me from myself and making it clear what I intend not to modify.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static bool isToeplitzMatrix(const vector<vector<int>>& matrix) {\\n        const int rows = matrix.size();\\n        const int cols = matrix[0].size();\\n        for (int r = 1; r < rows; ++r)\\n            for (int c = 1; c < cols; ++c)\\n                if (matrix[r][c] != matrix[r - 1][c - 1]) return false;\\n        \\n        return true;\\n    }\\n```\n```size_t```\n```int```\n```rows```\n```cols```\n```r```\n```c```\n```size_t```\n```int```\n```size_t```\n```size(matrix) - 1```\n```for (int i = 0; i < size(matrix) - 1; ++i)```\n```size_t```\n```cpp\\n    static bool isToeplitzMatrix(const vector<vector<int>>& matrix) {\\n        const size_t rows = matrix.size();\\n        const size_t cols = matrix[0].size();\\n        for (size_t r = 1; r < rows; ++r)\\n            for (size_t c = 1; c < cols; ++c)\\n                if (matrix[r][c] != matrix[r - 1][c - 1]) return false;\\n        \\n        return true;\\n    }\\n```\n```static```\n```class Solution```\n```static```\n```this```\n```const```\n```const```",
                "codeTag": "Java"
            },
            {
                "id": 2761639,
                "title": "java-easy-and-clean-solution",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582164,
                "title": "python-easy-solution",
                "content": "```\\ndef isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(1,len(matrix)):\\n            for j in range(1,len(matrix[0])):\\n                if matrix[i-1][j-1] != matrix[i][j]:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(1,len(matrix)):\\n            for j in range(1,len(matrix[0])):\\n                if matrix[i-1][j-1] != matrix[i][j]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1494954,
                "title": "java-tc-o-m-n-sc-o-1-compare-top-left-neighbor",
                "content": "```java\\n/**\\n * Compare top left neighbor.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        if (matrix.length <= 1 || matrix[0].length <= 1) {\\n            return true;\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++) {\\n            for (int j = 1; j < matrix[0].length; j++) {\\n                if (matrix[i][j] != matrix[i - 1][j - 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\nFor Follow-Up refer this leetcode post: https://leetcode.com/problems/toeplitz-matrix/discuss/271388/Java-Solution-for-Follow-Up-1-and-2\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Compare top left neighbor.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        if (matrix.length <= 1 || matrix[0].length <= 1) {\\n            return true;\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++) {\\n            for (int j = 1; j < matrix[0].length; j++) {\\n                if (matrix[i][j] != matrix[i - 1][j - 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147808,
                "title": "java-answers-to-the-follow-ups-load-partial-row-column-one-time-the-3rd-one-beats-98",
                "content": "\\n//Solution 1: simple traversal\\n```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n        int height = matrix.length, width = matrix[0].length;\\n        if (height<=1 || width<=1) return true;\\n        for (int i=1; i<height; i++){\\n            for (int j=1; j<width; j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n//Solution 2: Load one row each time, store,compare (with the crietria stored in Queue) and update it row by row.\\n```\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if (matrix.length <= 1 || matrix[0].length <= 1) return true;\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i=matrix[0].length-1; i>=0; i--){ //set criteria\\n            q.add(matrix[0][i]);\\n        }\\n        for (int j=1; j<matrix.length; j++){ \\n            q.poll();\\n            for (int k=matrix[j].length-1; k>0; k--){\\n                if (matrix[j][k] == q.poll()) // compare\\n                    q.add(matrix[j][k]);\\n                else\\n                    return false; \\n            }\\n            q.add(matrix[j][0]);\\n        }\\n        return true;\\n    }\\n ```\\n    \\n//Solution 3: Load a partial row/column each time, the length of \"piece\" is defined as variable \\'step\\'\\n```\\n    public int min(int a, int b){\\n        return((a>b)?b:a);\\n    }\\n    \\n    public int max(int a, int b){\\n        return((a<b)?b:a);\\n    }\\n    \\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int width = matrix[0].length; \\n        int height = matrix.length; \\n        int step = 3; //This step indicates the maximum length of \\'piece\\' which can be loaded at one time.\\n        int size = 1;\\n        int index = width - 1; \\n        \\n        while (index >= 0){ \\n            size = min(index+1, step); \\n            int[] memory = new int[size];\\n            for (int i=0; i<size; i++){\\n                memory[size-i-1] = matrix[0][index-i]; //set memory\\n            }\\n            for(int j=1; j<min(height,width); j++){ //check the related pieces of rows\\n                //set boundary \\n                int rightbound = min(index+j, width-1);\\n                int leftbound = max(index-step+1+j, j);\\n                for(int m=0, n=leftbound; m<size&&n<=rightbound; m++, n++)\\n                    if(matrix[j][n] != memory[m])\\n                        return false;\\n            }\\n        index -= step;\\n        }\\n        \\n        index = 0;\\n        while (index < height){ //for the purpose of completeness, the criteria should include two sides of the matrix\\n            size = min(height-1-index, step);\\n            int[] memory = new int[size];\\n            for (int i=0; i<size; i++){\\n                memory[size-1-i] = matrix[height-index-1-i][0];\\n            }\\n            for (int j=1; j<min(height,width); j++){ \\n                int upperbound = max(height-index-step+j,j+1);\\n                int lowerbound = min(height-index-1+j,height-1);\\n                for(int m=0, n=upperbound; m<size&&n<=lowerbound; m++, n++)\\n                    if(matrix[n][j] != memory[m])\\n                        return false;\\n            }\\n            index+=step;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n        int height = matrix.length, width = matrix[0].length;\\n        if (height<=1 || width<=1) return true;\\n        for (int i=1; i<height; i++){\\n            for (int j=1; j<width; j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if (matrix.length <= 1 || matrix[0].length <= 1) return true;\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i=matrix[0].length-1; i>=0; i--){ //set criteria\\n            q.add(matrix[0][i]);\\n        }\\n        for (int j=1; j<matrix.length; j++){ \\n            q.poll();\\n            for (int k=matrix[j].length-1; k>0; k--){\\n                if (matrix[j][k] == q.poll()) // compare\\n                    q.add(matrix[j][k]);\\n                else\\n                    return false; \\n            }\\n            q.add(matrix[j][0]);\\n        }\\n        return true;\\n    }\\n ```\n```\\n    public int min(int a, int b){\\n        return((a>b)?b:a);\\n    }\\n    \\n    public int max(int a, int b){\\n        return((a<b)?b:a);\\n    }\\n    \\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int width = matrix[0].length; \\n        int height = matrix.length; \\n        int step = 3; //This step indicates the maximum length of \\'piece\\' which can be loaded at one time.\\n        int size = 1;\\n        int index = width - 1; \\n        \\n        while (index >= 0){ \\n            size = min(index+1, step); \\n            int[] memory = new int[size];\\n            for (int i=0; i<size; i++){\\n                memory[size-i-1] = matrix[0][index-i]; //set memory\\n            }\\n            for(int j=1; j<min(height,width); j++){ //check the related pieces of rows\\n                //set boundary \\n                int rightbound = min(index+j, width-1);\\n                int leftbound = max(index-step+1+j, j);\\n                for(int m=0, n=leftbound; m<size&&n<=rightbound; m++, n++)\\n                    if(matrix[j][n] != memory[m])\\n                        return false;\\n            }\\n        index -= step;\\n        }\\n        \\n        index = 0;\\n        while (index < height){ //for the purpose of completeness, the criteria should include two sides of the matrix\\n            size = min(height-1-index, step);\\n            int[] memory = new int[size];\\n            for (int i=0; i<size; i++){\\n                memory[size-1-i] = matrix[height-index-1-i][0];\\n            }\\n            for (int j=1; j<min(height,width); j++){ \\n                int upperbound = max(height-index-step+j,j+1);\\n                int lowerbound = min(height-index-1+j,height-1);\\n                for(int m=0, n=upperbound; m<size&&n<=lowerbound; m++, n++)\\n                    if(matrix[n][j] != memory[m])\\n                        return false;\\n            }\\n            index+=step;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113411,
                "title": "one-line-easy-python-solution-using-slice-only-1-for-loop",
                "content": "Here is a *Toeplitz* matrix:\\n\\n\\t1234\\n\\t5123\\n\\t9512\\n\\nAs we can see,  the first line slice from `0` to `len(row)-1`  equals to the second line slice from `1` to `len(row)`.\\n\\nSo we can get this simple solution without any thinking.\\n\\n```python\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        return all(matrix[row+1][1:] == matrix[row][:-1] for row in range(len(matrix)-1))\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        return all(matrix[row+1][1:] == matrix[row][:-1] for row in range(len(matrix)-1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196821,
                "title": "javascript-solution-compare-to-previous-diagonal-cell",
                "content": "I think the trap or mistake that one can fall into trying to solve this problem is trying to write an algorithm to move diagonally. This makes it confusing. However, instead, we can move the normally way to usually do through a matrix and just compare the value of the current cell to the one diagonal of it. Since we can\\'t compare outside the boundary of the matrix, we need to start our row at 1 and the column for each row at 1 also.\\n\\n```\\nvar isToeplitzMatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 1; j < n; j++) {\\n            if (matrix[i][j] != matrix[i - 1][j - 1]) return false;\\n        }     \\n    }\\n\\t\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\nvar isToeplitzMatrix = function(matrix) {\\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    \\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 1; j < n; j++) {\\n            if (matrix[i][j] != matrix[i - 1][j - 1]) return false;\\n        }     \\n    }\\n\\t\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761628,
                "title": "simplepython",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:\\n        rows,colms = len(matrix),len(matrix[0])\\n        for r in range (1,rows):\\n            for c in range (1,colms):\\n                if matrix[r][c]!=matrix[r-1][c-1]:\\n                    return 0\\n        return 1\\n```\\nSimple Soln.......",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:\\n        rows,colms = len(matrix),len(matrix[0])\\n        for r in range (1,rows):\\n            for c in range (1,colms):\\n                if matrix[r][c]!=matrix[r-1][c-1]:\\n                    return 0\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607862,
                "title": "c-python-easy-efficient-solution-trick",
                "content": "Let m be rows and n be the columns of the matrix.\\nFor each row, we can observe that first n-1 cols are equivalent to next row\\'s last n-1 cols.\\nSo we can compare them for each row in the matrix.\\n\\nDiagramatically :\\n![image](https://assets.leetcode.com/users/images/85eb8bec-23bd-404c-b0f4-f087c84ade4c_1638446238.172023.jpeg)\\n\\nPython Solution:\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        for i in range(rows-1):\\n            if matrix[i][:cols-1] != matrix[i+1][1:cols]:\\n                return False\\n        return True\\n```\\n\\nC++ Solution:\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        for(int i=0;i<rows-1;i++)\\n        {\\n            for(int j=0;j<cols-1;j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nDo upvote if you understood the solution :)",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        for i in range(rows-1):\\n            if matrix[i][:cols-1] != matrix[i+1][1:cols]:\\n                return False\\n        return True\\n```\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        for(int i=0;i<rows-1;i++)\\n        {\\n            for(int j=0;j<cols-1;j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697246,
                "title": "c-solution",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\tfor (int i = 0; i < matrix.size() - 1; i++) {\\n\\t\\tfor (int j = 0;  j < matrix[0].size() - 1; j++) {\\n\\t\\t\\tif (matrix[i][j] != matrix[i + 1][j + 1])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\tfor (int i = 0; i < matrix.size() - 1; i++) {\\n\\t\\tfor (int j = 0;  j < matrix[0].size() - 1; j++) {\\n\\t\\t\\tif (matrix[i][j] != matrix[i + 1][j + 1])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761981,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        int r = matrix.size();\\n        int c = matrix[0].size();\\n        \\n        for(int i=0; i<r-1; i++)\\n        {\\n            for(int j=0; j<c-1; j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        int r = matrix.size();\\n        int c = matrix[0].size();\\n        \\n        for(int i=0; i<r-1; i++)\\n        {\\n            for(int j=0; j<c-1; j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761624,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/iHYMQQj4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/iHYMQQj4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 113391,
                "title": "4-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(matrix[i][j] != matrix[i - 1][j - 1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(matrix[i][j] != matrix[i - 1][j - 1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762086,
                "title": "simple-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) \\n    {\\n        for (int i = 1; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[0].size()-1; j++)\\n                if (matrix[i-1][j] != matrix[i][j+1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) \\n    {\\n        for (int i = 1; i < matrix.size(); i++)\\n            for (int j = 0; j < matrix[0].size()-1; j++)\\n                if (matrix[i-1][j] != matrix[i][j+1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194877,
                "title": "java-solution-two-follow-ups-solved-as-well",
                "content": "As for the follow ups, we only need to add counters to track which row and column an element is. Then map the values into a file.\\nEventually, we can check if the values in the same file are equal.\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                int index = i - j;\\n                if (!map.containsKey(i - j)) {\\n                    map.put(i - j, matrix[i][j]);\\n                } else {\\n                    if (matrix[i][j] != map.get(i - j)) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                int index = i - j;\\n                if (!map.containsKey(i - j)) {\\n                    map.put(i - j, matrix[i][j]);\\n                } else {\\n                    if (matrix[i][j] != map.get(i - j)) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113390,
                "title": "c-1-liner",
                "content": "One-liners are possible even in C++ if we go functional :)\\n\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& m, int i = 0, int j = 0) {\\n    return i == m.size() - 1 || j == m[i].size() - 1 || (m[i][j] == m[i + 1][j + 1] \\n        && isToeplitzMatrix(m, j < m[i].size() - 2 ? i : i + 1, j < m[i].size() - 2 ? j + 1 : 0));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& m, int i = 0, int j = 0) {\\n    return i == m.size() - 1 || j == m[i].size() - 1 || (m[i][j] == m[i + 1][j + 1] \\n        && isToeplitzMatrix(m, j < m[i].size() - 2 ? i : i + 1, j < m[i].size() - 2 ? j + 1 : 0));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761458,
                "title": "very-easy-java-solution-faster-than-100",
                "content": "Instead of keeping track of every number in each diagonal, just check if the previous number in the diagonal is the same.\\n\\n\\nJava code:\\n```\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for (int i = 1; i < matrix.length; i++) {\\n            for (int j = 1; j < matrix[0].length; j++) {\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f2b8d2a8-91be-422c-8437-7fb451ebdd69_1667179015.161095.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for (int i = 1; i < matrix.length; i++) {\\n            for (int j = 1; j < matrix[0].length; j++) {\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761330,
                "title": "java-explained-in-detail-simple-fast-solution",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n### Approach\\nTraverse through the array to check the next element matrix[i + 1][j + 1] if it is different.\\n\\nIf all is the same, then return through.\\n\\n##### Extra:\\nFor the follow up scenarios of loading one row at a time and partial disc, we can store a row / column of date in a Linked List.\\n\\nAs we traverse, we continue to shift the elements by adding the new element at Index 0 and remove the last element from the Linked List.\\nNote that we are shifting the elements to the left if we check by rows, and shift the elements down if we check by columns.\\n\\n```\\n    // One row at a time.\\n    // For this, we use a Linked List to add the new element into index 0 and remove the last element,\\n    // to check if it is the same as the previous row.\\n    // For Example:\\n    // [[ 0 1 2 3 4 ]\\n    //  [ 9 0 1 2 3 ]\\n    //  [ 8 9 0 1 2 ]\\n    //  [ 7 8 9 0 1 ]\\n    //  [ 6 7 8 9 0 ]]\\n    //\\n    // We compare [ 0 1 2 3 4 ] with [ 9 0 1 2 3 ], if the 0, 1, 2 and 3 is identical, proceed the next line,\\n    // but update by removing the last element in the list (integer 4), and at integer 9 at index 0.\\n```\\n\\nFor the partial disc, we need to check if we have the full column length or full row length, as we need to store the full length of a row or column to be able to check everything.\\n```\\n    // Partial Disc.\\n    // For Example:\\n    // [[ 0 1 2 ]   [[ 3 4 ]\\n    //  [ 9 0 1 ]    [ 2 3 ]\\n    //  [ 8 9 0 ]    [ 1 2 ]\\n    //  [ 7 8 9 ]    [ 0 1 ]\\n    //  [ 6 7 8 ]]   [ 9 0 ]]\\n    //\\n    // Here, we need to store the data of the column.\\n    //\\n    // For Example:\\n    // [[ 0 1 2 3 4 ]   [[ 7 8 9 0 1 ]\\n    //  [ 9 0 1 2 3 ]    [ 6 7 8 9 0 ]]\\n    //  [ 8 9 0 1 2 ]]\\n    //\\n    // Here, we need to store the data of the row.\\n\\n```\\n\\n### Complexity\\n- Time complexity:O(m * n)\\n\\n- Space complexity:O(1)\\n\\nwhere m is the number of rows and n is the number of columns.\\n\\n---\\n### Java - Clean Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i + 1 < m && j + 1 < n && matrix[i][j] != matrix[i + 1][j + 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n### Java - With Explanation\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Make sure to check if i + 1 and j + 1 is within the matrix.\\n                // If not, there will be IndexOutOfBound error.\\n                if (i + 1 < m && j + 1 < n && matrix[i][j] != matrix[i + 1][j + 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If successfully traverse the whole array, return true.\\n        return true;\\n    }\\n}\\n```\\n---\\n\\n### Java - Solution when Only Load Data One Row at a Time\\n```\\nimport java.util.LinkedList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int totalRows = matrix.length;\\n        int totalColumns = matrix[0].length;\\n\\n        // Initiate the linked list and add the first row to the linked list.\\n        List<Integer> linkedList = new LinkedList<>();\\n        for (int integer : matrix[0]) linkedList.add(integer);\\n\\n        for (int row = 1; row < totalRows; row++) {\\n            // Check the row to see if any is not identical to the linked list elements.\\n            for (int column = 1; column < totalColumns; column++)\\n                if (matrix[row][column] != linkedList.get(column - 1))\\n                    return false;\\n            // Update the linked list for the next line.\\n            linkedList.remove(linkedList.size() - 1);\\n            linkedList.add(0, matrix[row][0]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n### Java - Solution when Only Load Data One Column at a Time\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int totalRows = matrix.length;\\n        int totalColumns = matrix[0].length;\\n\\n        // Initiate the linked list and add the first column to the linked list.\\n        List<Integer> linkedList = new LinkedList<>();\\n        for (int i = 0; i < totalRows; i++) linkedList.add(matrix[i][0]);\\n\\n        for (int column = 1; column < totalColumns; column++) {\\n            // Check the column to see if any is not identical to the linked list elements.\\n            for (int row = 1; row < totalRows; row++)\\n                if (matrix[row][column] != linkedList.get(row - 1))\\n                    return false;\\n            // Update the linked list for the next line.\\n            linkedList.remove(linkedList.size() - 1);\\n            linkedList.add(0, matrix[0][column]);\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n    // One row at a time.\\n    // For this, we use a Linked List to add the new element into index 0 and remove the last element,\\n    // to check if it is the same as the previous row.\\n    // For Example:\\n    // [[ 0 1 2 3 4 ]\\n    //  [ 9 0 1 2 3 ]\\n    //  [ 8 9 0 1 2 ]\\n    //  [ 7 8 9 0 1 ]\\n    //  [ 6 7 8 9 0 ]]\\n    //\\n    // We compare [ 0 1 2 3 4 ] with [ 9 0 1 2 3 ], if the 0, 1, 2 and 3 is identical, proceed the next line,\\n    // but update by removing the last element in the list (integer 4), and at integer 9 at index 0.\\n```\n```\\n    // Partial Disc.\\n    // For Example:\\n    // [[ 0 1 2 ]   [[ 3 4 ]\\n    //  [ 9 0 1 ]    [ 2 3 ]\\n    //  [ 8 9 0 ]    [ 1 2 ]\\n    //  [ 7 8 9 ]    [ 0 1 ]\\n    //  [ 6 7 8 ]]   [ 9 0 ]]\\n    //\\n    // Here, we need to store the data of the column.\\n    //\\n    // For Example:\\n    // [[ 0 1 2 3 4 ]   [[ 7 8 9 0 1 ]\\n    //  [ 9 0 1 2 3 ]    [ 6 7 8 9 0 ]]\\n    //  [ 8 9 0 1 2 ]]\\n    //\\n    // Here, we need to store the data of the row.\\n\\n```\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i + 1 < m && j + 1 < n && matrix[i][j] != matrix[i + 1][j + 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Make sure to check if i + 1 and j + 1 is within the matrix.\\n                // If not, there will be IndexOutOfBound error.\\n                if (i + 1 < m && j + 1 < n && matrix[i][j] != matrix[i + 1][j + 1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        // If successfully traverse the whole array, return true.\\n        return true;\\n    }\\n}\\n```\n```\\nimport java.util.LinkedList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int totalRows = matrix.length;\\n        int totalColumns = matrix[0].length;\\n\\n        // Initiate the linked list and add the first row to the linked list.\\n        List<Integer> linkedList = new LinkedList<>();\\n        for (int integer : matrix[0]) linkedList.add(integer);\\n\\n        for (int row = 1; row < totalRows; row++) {\\n            // Check the row to see if any is not identical to the linked list elements.\\n            for (int column = 1; column < totalColumns; column++)\\n                if (matrix[row][column] != linkedList.get(column - 1))\\n                    return false;\\n            // Update the linked list for the next line.\\n            linkedList.remove(linkedList.size() - 1);\\n            linkedList.add(0, matrix[row][0]);\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int totalRows = matrix.length;\\n        int totalColumns = matrix[0].length;\\n\\n        // Initiate the linked list and add the first column to the linked list.\\n        List<Integer> linkedList = new LinkedList<>();\\n        for (int i = 0; i < totalRows; i++) linkedList.add(matrix[i][0]);\\n\\n        for (int column = 1; column < totalColumns; column++) {\\n            // Check the column to see if any is not identical to the linked list elements.\\n            for (int row = 1; row < totalRows; row++)\\n                if (matrix[row][column] != linkedList.get(row - 1))\\n                    return false;\\n            // Update the linked list for the next line.\\n            linkedList.remove(linkedList.size() - 1);\\n            linkedList.add(0, matrix[0][column]);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524508,
                "title": "concise-javascript-solution",
                "content": "```\\nconst isToeplitzMatrix = (matrix) => {\\n    for(let i = 0; i < matrix.length-1;i++){\\n        for(let j = 0; j < matrix[i].length-1; j++){\\n            if(matrix[i+1][j+1] !== matrix[i][j])return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isToeplitzMatrix = (matrix) => {\\n    for(let i = 0; i < matrix.length-1;i++){\\n        for(let j = 0; j < matrix[i].length-1; j++){\\n            if(matrix[i+1][j+1] !== matrix[i][j])return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975049,
                "title": "c-o-n-m-easiest-solution",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach :**\\n* Assign a diagonal number to each element of the matrix\\n* diagonal number of [i,j] for matrix size (NxM) = i - j + M - 1\\n* check if the diagonal already has a number assigned or not\\n* if already assigned, new number should be similar to the previous\\n* if not assigned, assign new number to diagonal\\n\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size(), m=mat[0].size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int d = i-j+m-1;\\n                \\n\\t\\t\\t\\t// check if diagonal already has a number asigned or not\\n                if(mp.find(d) != mp.end() && mp[d] != mat[i][j]) return false;\\n                \\n                mp[d] = mat[i][j];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size(), m=mat[0].size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int d = i-j+m-1;\\n                \\n\\t\\t\\t\\t// check if diagonal already has a number asigned or not\\n                if(mp.find(d) != mp.end() && mp[d] != mat[i][j]) return false;\\n                \\n                mp[d] = mat[i][j];\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763399,
                "title": "100-fast",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)):\\n                if(j-i>=0 and matrix[i][j]!=matrix[0][j-i] or i-j>=0 and matrix[i][j]!=matrix[i-j][0]):\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for j in range(len(matrix[0])):\\n            for i in range(len(matrix)):\\n                if(j-i>=0 and matrix[i][j]!=matrix[0][j-i] or i-j>=0 and matrix[i][j]!=matrix[i-j][0]):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762094,
                "title": "simple-c-solution",
                "content": "**Simple C++ Solution**\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=1; i<matrix.size(); i++) {\\n            for(int j=1; j<matrix[0].size(); j++) {\\n                if(matrix[i][j] != matrix[i-1][j-1]) \\n\\t\\t\\t\\t\\treturn false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=1; i<matrix.size(); i++) {\\n            for(int j=1; j<matrix[0].size(); j++) {\\n                if(matrix[i][j] != matrix[i-1][j-1]) \\n\\t\\t\\t\\t\\treturn false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761975,
                "title": "c-good-code-quality-easy-understanding-solution-with-picture-and-follow-ups-as-well",
                "content": "# Intuition\\nAs we read the follow ups to this problem we are asked to what happen if you can only read atmost one row at a time. It hints us in thinking of this solution where we match previous row item and current row items and if they match then the matrix is toeplitz.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2022-10-31 at 10.33.02 AM.jpeg](https://assets.leetcode.com/users/images/ecf3472b-274c-4068-9488-ab140a9bb408_1667280017.8400116.jpeg)\\n\\nWe only need to compare elements at these points where arrows are focusing.\\n\\n- We skip first row as we are approaching and comparing matrix elements backwards i.e the previous row index is matched with the current one.\\n- We always start our columns from 1 index as on 0 index they will match anyway as they don\\'t have diagonal on thier previous row.\\n- If at any moment we see our elements dont match the previous row diagonal element we return false\\n- After successful scanning of whole matrix if we didn\\'t encounter above condition then we return true.\\n\\n**Note**: If rows or columns of any matrix is 1 then we return true directly as they always be toeplitz.\\n\\n# Complexity\\n- Time complexity:\\nO(R*C) where R is number of rows and C is number of colums.\\n\\n- Space complexity:\\nO(1) In place\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(),cols = matrix[0].size();\\n        if(rows == 1 || cols == 1) \\n            return true;\\n        for(int row=1;row<rows;++row){\\n            for(int col=1;col<cols;++col){\\n                if(matrix[row-1][col-1]!=matrix[row][col])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nDon\\'t worry if you can\\'t able to solve this easy problem. There are always be ups and downs all you need is believe yourself and work on yourself.You are doing great\\u2764\\uFE0F, Keep Doing !!\\uD83D\\uDCAA",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(),cols = matrix[0].size();\\n        if(rows == 1 || cols == 1) \\n            return true;\\n        for(int row=1;row<rows;++row){\\n            for(int col=1;col<cols;++col){\\n                if(matrix[row-1][col-1]!=matrix[row][col])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761843,
                "title": "c-clean-and-simple-solution",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& mat) {\\n        \\n        for(int i=0;i<mat.size()-1;i++)\\n        {\\n            for(int j=0;j<mat[0].size()-1;j++)\\n            {\\n                if(mat[i][j]!=mat[i+1][j+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& mat) {\\n        \\n        for(int i=0;i<mat.size()-1;i++)\\n        {\\n            for(int j=0;j<mat[0].size()-1;j++)\\n            {\\n                if(mat[i][j]!=mat[i+1][j+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761314,
                "title": "daily-leetcoding-challenge-october-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/toeplitz-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Group by Category [Accepted]\n\n  \n**Approach 2:** Compare With Top-Left Neighbor [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/toeplitz-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 176987,
                "title": "simple-python-code-beats-100",
                "content": "```\\ndef isToeplitzMatrix(self, matrix):\\n        i=0\\n        while i+1<len(matrix):\\n            if matrix[i][:-1]!=matrix[i+1][1:]:\\n                return False\\n            i+=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isToeplitzMatrix(self, matrix):\\n        i=0\\n        while i+1<len(matrix):\\n            if matrix[i][:-1]!=matrix[i+1][1:]:\\n                return False\\n            i+=1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2762906,
                "title": "comparing-entire-rows-using-sequenceequal-and-ranges",
                "content": "We compare each row except the last element (hence `[..^1])` with the next row except the first element (hence `[1..]`):\\n```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tbool equal = matrix[i][..^1].SequenceEqual(matrix[i + 1][1..]);\\n\\t\\tif (!equal) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\\n`Enumerable`\\'s SequenceEqual can also be used this way:\\n```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tbool equal = Enumerable.SequenceEqual\\n\\t\\t(\\n\\t\\t\\tmatrix[i][..^1],\\n\\t\\t\\tmatrix[i + 1][1..]\\n\\t\\t);\\n\\t\\tif (!equal) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\\n\\nGiving up some readability, you can put the check inside the if condition:\\n```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tif (!matrix[i][..^1].SequenceEqual(matrix[i + 1][1..])) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tbool equal = matrix[i][..^1].SequenceEqual(matrix[i + 1][1..]);\\n\\t\\tif (!equal) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\n```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tbool equal = Enumerable.SequenceEqual\\n\\t\\t(\\n\\t\\t\\tmatrix[i][..^1],\\n\\t\\t\\tmatrix[i + 1][1..]\\n\\t\\t);\\n\\t\\tif (!equal) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\n```csharp\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t{\\n\\t\\tif (!matrix[i][..^1].SequenceEqual(matrix[i + 1][1..])) return false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761568,
                "title": "clean-concise-code-c",
                "content": "# Complexity\\n- Time complexity: O(n * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (storing in stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n     stack<pair<int,int>> st;   \\n    for(int i =0;i<matrix.size();i++){\\n        st.push({i,0});\\n    }  \\n    for(int i=0;i<matrix[0].size();i++){\\n        st.push({0,i});\\n    }\\n    //****** all the starting elements pushed down in the stack\\n    \\n    while(st.size()){\\n      int x = st.top().first;\\n      int y = st.top().second;\\n      int val  = matrix[x][y];\\n      st.pop();\\n        //**** checking for each of the diagonal \\n           while(x<matrix.size()&& y<matrix[0].size()){\\n               if(matrix[x][y]!=val)return false;\\n               x++,y++;\\n           }\\n    }\\n\\n    return true;\\n```\\n\\nThis could be done even without using any extra space if we just check at every element instead of pushing in the stack!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n     stack<pair<int,int>> st;   \\n    for(int i =0;i<matrix.size();i++){\\n        st.push({i,0});\\n    }  \\n    for(int i=0;i<matrix[0].size();i++){\\n        st.push({0,i});\\n    }\\n    //****** all the starting elements pushed down in the stack\\n    \\n    while(st.size()){\\n      int x = st.top().first;\\n      int y = st.top().second;\\n      int val  = matrix[x][y];\\n      st.pop();\\n        //**** checking for each of the diagonal \\n           while(x<matrix.size()&& y<matrix[0].size()){\\n               if(matrix[x][y]!=val)return false;\\n               x++,y++;\\n           }\\n    }\\n\\n    return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024420,
                "title": "python-check-every-diagonal-64ms-beats-92-19-with-explanation",
                "content": "**Explanation**\\nWe loop through the entire matrix (the range is `len - 1` to prevent the `matrix[i+1][j+1]` from going out of bounds), and each time compare that element to the one diagonally down from it.\\n\\n![image](https://assets.leetcode.com/users/images/66c5bcbf-7a7f-49b9-81c9-760c4d6840bb_1652156039.610421.png)\\n\\n\\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(matrix) - 1):\\n            for j in range(len(matrix[0]) - 1):\\n                if matrix[i][j] != matrix[i + 1][j + 1]:\\n                    return False\\n        return True\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(matrix) - 1):\\n            for j in range(len(matrix[0]) - 1):\\n                if matrix[i][j] != matrix[i + 1][j + 1]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791961,
                "title": "java-easy-to-understand-solution",
                "content": "(0,0) (0,1) (0,2) (0,3)\\n(1,0) (1,1) (1,2) (1,3)\\n(2,0) (2,1) (2,2) (2,3)\\n\\npairs would be, [(1,0), (2,1)],  [(0,0), (1,1), (2,2)],  [(0,1), (1,2), (2,3)],  [(0,2), (1,3)] \\nyou can see that all pairs are like (i, j), (i+1, j+1), (i+2, j+2).... \\n\\nplease comment if you need more assistance.\\n\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++)  \\n            for(int j=1;j<matrix[i].length;j++)\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n        return true;\\n    }\\n}\\n```\\n\\nPlease **UPVOTE** if you find this helpful.\\nThanks : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++)  \\n            for(int j=1;j<matrix[i].length;j++)\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400967,
                "title": "easy-python-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef isToeplitzMatrix(self, matrix):\\n\\t\\t\\tfor i in range(len(matrix)-1):\\n\\t\\t\\t\\tfor j in range(len(matrix[0])-1):\\n\\t\\t\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef isToeplitzMatrix(self, matrix):\\n\\t\\t\\tfor i in range(len(matrix)-1):\\n\\t\\t\\t\\tfor j in range(len(matrix[0])-1):\\n\\t\\t\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 3461482,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        if(matrix.size() == 1) {\\n            return true;\\n        }\\n        int i = matrix.size() - 2;\\n        int j = 0;\\n\\n        \\n         while(i != matrix.size() - 1 && j != matrix[0].size() - 1) {\\n            int row = i;\\n            int col = j;\\n\\n            int num = matrix[row++][col++];\\n            while(row < matrix.size() && col < matrix[0].size()) {\\n                if(matrix[row][col] != num) {\\n                    return false;\\n                }\\n                row++;\\n                col++;\\n            }\\n\\n            if(i != 0) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        if(matrix.size() == 1) {\\n            return true;\\n        }\\n        int i = matrix.size() - 2;\\n        int j = 0;\\n\\n        \\n         while(i != matrix.size() - 1 && j != matrix[0].size() - 1) {\\n            int row = i;\\n            int col = j;\\n\\n            int num = matrix[row++][col++];\\n            while(row < matrix.size() && col < matrix[0].size()) {\\n                if(matrix[row][col] != num) {\\n                    return false;\\n                }\\n                row++;\\n                col++;\\n            }\\n\\n            if(i != 0) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762077,
                "title": "easy-one-liner",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        return all(r1[:-1] == r2[1:]   for r1,r2 in zip(m, m[1:]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n        return all(r1[:-1] == r2[1:]   for r1,r2 in zip(m, m[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761919,
                "title": "easy-java-solution-faster-than-98",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761873,
                "title": "java-easy-fast-and-simple-solution",
                "content": "Simple solution -> **Having for 2 for loops to traverse across each diagonal and checking elements of a given diagonal.**\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        int n = matrix.length , m = matrix[0].length;\\n        // loop from (column - 1) to row to check all the diagonals from top left to bottom right\\n\\t\\t\\n        for( int i = -(m - 1); i < n; i++ ) {\\n            // row and col initialized as per the conditions.\\n            int row = ( i < 0 ) ? 0 : i;\\n            int col = ( i < 0 ) ? -i : 0;\\n            int prev = -1;\\n            \\n            for( ; row < n && col < m; row++,col++ ) {\\n                \\n                if( prev != -1 && prev!=matrix[row][col] ) return false;\\n                prev = matrix[row][col];\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        int n = matrix.length , m = matrix[0].length;\\n        // loop from (column - 1) to row to check all the diagonals from top left to bottom right\\n\\t\\t\\n        for( int i = -(m - 1); i < n; i++ ) {\\n            // row and col initialized as per the conditions.\\n            int row = ( i < 0 ) ? 0 : i;\\n            int col = ( i < 0 ) ? -i : 0;\\n            int prev = -1;\\n            \\n            for( ; row < n && col < m; row++,col++ ) {\\n                \\n                if( prev != -1 && prev!=matrix[row][col] ) return false;\\n                prev = matrix[row][col];\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761795,
                "title": "python-simple-and-easy-way-to-solve-97-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:\\n        r_len, c_len = len(matrix),len(matrix[0])\\n        \\n        for r in range (1, r_len):\\n            for c in range (1, c_len):\\n                if matrix[r][c]!=matrix[r-1][c-1]:\\n                    return False\\n        \\n        return True\\n```\\n**For Detail explaination with diagram read this blog:\\nhttps://www.python-techs.com/2022/10/Toeplitz-Matrix.html**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]])->bool:\\n        r_len, c_len = len(matrix),len(matrix[0])\\n        \\n        for r in range (1, r_len):\\n            for c in range (1, c_len):\\n                if matrix[r][c]!=matrix[r-1][c-1]:\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761413,
                "title": "daily-leetcode-solution-easy-c-soluiton",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                int prow=i-1;\\n                int pcol=j-1;\\n                if(prow>=0&&prow<m&&pcol>=0&&pcol<n&&matrix[prow][pcol]!=matrix[i][j])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                int prow=i-1;\\n                int pcol=j-1;\\n                if(prow>=0&&prow<m&&pcol>=0&&pcol<n&&matrix[prow][pcol]!=matrix[i][j])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630154,
                "title": "simple-java-solution-1ms-run-with-given-follow-up-and-optimized",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int[] tmp = new int[22];\\n        for(int i = 0; i < matrix[0].length; i++){\\n            tmp[i] = matrix[0][i];\\n        }\\n        for(int i = 1; i < matrix.length; i++){\\n            for(int k = matrix[0].length-1; k > 0; k--){\\n                tmp[k] = tmp[k-1];\\n            }\\n            tmp[0] = matrix[i][0];\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(tmp[j] != matrix[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int[] tmp = new int[22];\\n        for(int i = 0; i < matrix[0].length; i++){\\n            tmp[i] = matrix[0][i];\\n        }\\n        for(int i = 1; i < matrix.length; i++){\\n            for(int k = matrix[0].length-1; k > 0; k--){\\n                tmp[k] = tmp[k-1];\\n            }\\n            tmp[0] = matrix[i][0];\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(tmp[j] != matrix[i][j])return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787310,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[i].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505378,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix.length == 1 && matrix[0].length == 1)\\n            return true;\\n        \\n        for(int i = 1; i < matrix.length; i++) {\\n            for(int j = 1; j < matrix[i].length; j++) {\\n                if(matrix[i][j] != matrix[i -1][j - 1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix.length == 1 && matrix[0].length == 1)\\n            return true;\\n        \\n        for(int i = 1; i < matrix.length; i++) {\\n            for(int j = 1; j < matrix[i].length; j++) {\\n                if(matrix[i][j] != matrix[i -1][j - 1])\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1494741,
                "title": "easy-swift-solution-faster-than-100",
                "content": "Compare each cell to the cell diagonally right and below it. Don\\'t compare if you are on last row or column.  \\n\\n```\\nclass Solution {\\n    func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\\n        \\n        let colLast =  matrix[0].count - 1 \\n        let rowLast = matrix.count - 1 \\n        \\n        for c in (0..<colLast) {\\n            for r in (0..<rowLast) {\\n                if matrix[r][c] != matrix[r+1][c+1] {\\n                    return false\\n                }\\n            } \\n        }\\n        \\n        return true\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\\n        \\n        let colLast =  matrix[0].count - 1 \\n        let rowLast = matrix.count - 1 \\n        \\n        for c in (0..<colLast) {\\n            for r in (0..<rowLast) {\\n                if matrix[r][c] != matrix[r+1][c+1] {\\n                    return false\\n                }\\n            } \\n        }\\n        \\n        return true\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193046,
                "title": "javascript-solution-beats-100-no-extra-space",
                "content": "```\\nvar isToeplitzMatrix = function(matrix) {\\n\\n    for (var i = 0; i < matrix.length - 1; i++) {\\n        for (var j = 0; j < matrix[0].length - 1; j++) {\\n            if (matrix[i][j] != matrix[i+1][j+1]) {\\n                return false;\\n            }   \\n        }   \\n    }   \\n\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isToeplitzMatrix = function(matrix) {\\n\\n    for (var i = 0; i < matrix.length - 1; i++) {\\n        for (var j = 0; j < matrix[0].length - 1; j++) {\\n            if (matrix[i][j] != matrix[i+1][j+1]) {\\n                return false;\\n            }   \\n        }   \\n    }   \\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763442,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int rows = matrix.length, columns = matrix[0].length;\\n        int row = rows - 1, column = 0;\\n        while (row > 0) {\\n            row--;\\n            int num = matrix[row][column];\\n            for (int i = row + 1, j = column + 1; i < rows && j < columns; i++, j++) {\\n                int ourNum = matrix[i][j];\\n                if (ourNum != num)\\n                    return false;\\n            }\\n        }\\n        while (column < columns) {\\n            int num = matrix[row][column];\\n            for (int i = row + 1, j = column + 1; i < rows && j < columns; i++, j++) {\\n                int ourNum = matrix[i][j];\\n                if (ourNum != num)\\n                    return false;\\n            }\\n            column++;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int rows = matrix.length, columns = matrix[0].length;\\n        int row = rows - 1, column = 0;\\n        while (row > 0) {\\n            row--;\\n            int num = matrix[row][column];\\n            for (int i = row + 1, j = column + 1; i < rows && j < columns; i++, j++) {\\n                int ourNum = matrix[i][j];\\n                if (ourNum != num)\\n                    return false;\\n            }\\n        }\\n        while (column < columns) {\\n            int num = matrix[row][column];\\n            for (int i = row + 1, j = column + 1; i < rows && j < columns; i++, j++) {\\n                int ourNum = matrix[i][j];\\n                if (ourNum != num)\\n                    return false;\\n            }\\n            column++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762597,
                "title": "rust-6-solutions-with-comments",
                "content": "The problem is easy enough - compare each entry with another on the same diagonal to see that all elements on the same diagonal have the same value. So let us have some fun with different ways of solving this with Rust.\\n\\n**One-liner 1**\\n\\nIterate over all elements not on the first row or first column, and check if they have the same values as their north-west neighbors. Here we use iterators over the indicies, and index into `matrix` directly.\\n\\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        (1..matrix.len()).all(|r| (1..matrix[0].len()).all(|c| matrix[r][c] == matrix[r-1][c-1]))\\n    }\\n}\\n```\\n\\n**One-liner 2**\\n\\nUse `windows` to get pairs of matrix rows and `zip` and `skip` to get pairs of elements on the same diagonal. Check that all pairs match up.\\n\\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0].iter().zip(w[1].iter().skip(1)).all(|(a,b)| a.eq(b)))\\n    }\\n}\\n```\\n\\n**One-liner 3**\\n\\nUse `windows` and `skip` like before, but also `take` to get iterators of equal length that we can compare directly with `eq`.\\n\\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0].iter().take(w[0].len() - 1).eq(w[1].iter().skip(1)))\\n    }\\n}\\n```\\n\\n**One-liner 4**\\n\\nUse `windows` as before, but instead of iterators, take slices of the rows that can be compared directly.\\n\\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0][..w[0].len()-1] == w[1][1..])\\n    }\\n}\\n```\\n\\n**Cache the Diagonal Values**\\n\\nWe use a cache-friendly stack-allocated array that we fill with the top and left elements. Check that other elements are the same as the cached diagonal elements, using the fact that `r - c` is unique for each diagonal.\\n\\n```\\nconst MAX_DIM: usize = 20 as _;\\n\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let mut diags = [0; 2*MAX_DIM];\\n        (0..matrix.len()).map(|r| (r, 0)).chain((0..matrix[0].len()).map(|c| (0, c)))\\n            .for_each(|(r, c)| diags[MAX_DIM + r - c] = matrix[r][c]);\\n        (1..matrix.len()).all(|r| (1..matrix[0].len()).all(|c| matrix[r][c] == diags[MAX_DIM + r - c]))\\n    }\\n}\\n```\\n\\n**Hardcore Imperative**\\n\\nFor true C fans - our only grief is that we don\\'t have C-style for loops in Rust. But we make that up by unecessarily using a `return` statement as our last line instead of just `true`. :)\\n\\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        for r in 1..matrix.len() {\\n            for c in 1..matrix[0].len() {\\n                if matrix[r][c] != matrix[r-1][c-1] {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        (1..matrix.len()).all(|r| (1..matrix[0].len()).all(|c| matrix[r][c] == matrix[r-1][c-1]))\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0].iter().zip(w[1].iter().skip(1)).all(|(a,b)| a.eq(b)))\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0].iter().take(w[0].len() - 1).eq(w[1].iter().skip(1)))\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix.windows(2).all(|w| w[0][..w[0].len()-1] == w[1][1..])\\n    }\\n}\\n```\n```\\nconst MAX_DIM: usize = 20 as _;\\n\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let mut diags = [0; 2*MAX_DIM];\\n        (0..matrix.len()).map(|r| (r, 0)).chain((0..matrix[0].len()).map(|c| (0, c)))\\n            .for_each(|(r, c)| diags[MAX_DIM + r - c] = matrix[r][c]);\\n        (1..matrix.len()).all(|r| (1..matrix[0].len()).all(|c| matrix[r][c] == diags[MAX_DIM + r - c]))\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        for r in 1..matrix.len() {\\n            for c in 1..matrix[0].len() {\\n                if matrix[r][c] != matrix[r-1][c-1] {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762517,
                "title": "82-faster-solution-easy-to-undertsand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int flag=-1;\\n        for(int i=0;i<m;i++)\\n        { \\n            map<int,int>mp;\\n            flag=0;\\n            int x=i;\\n            int y=0;\\n            while((x<m)&&(y<n)){\\n                mp[matrix[x][y]]++;\\n                x++;\\n                y++; }\\n            if(mp.size()==1) {\\n                flag=1;\\n            }\\n            else{\\n                flag=0;\\n            }\\n            \\n            if(flag==0){\\n                break;\\n            }\\n              mp.clear();\\n        }\\n        if(flag==0){\\n            return false; }\\n        int flg=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<int,int>mp;\\n             flg=0;\\n             int x=0;\\n             int y=i;     \\n            while((x<m)&&(y<n)) {\\n                mp[matrix[x][y]]++;\\n                x++;\\n                y++;}\\n            if(mp.size()==1){\\n                flg=1;\\n            } else\\n            {\\n                flg=0;\\n            }\\n            if(flg==0) {\\n                break;\\n            }\\n            mp.clear();\\n        }\\n         if(flg==0){\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/37b4d18e-fa80-48f0-8549-45b8cb9abb77_1667203391.11747.png)\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int flag=-1;\\n        for(int i=0;i<m;i++)\\n        { \\n            map<int,int>mp;\\n            flag=0;\\n            int x=i;\\n            int y=0;\\n            while((x<m)&&(y<n)){\\n                mp[matrix[x][y]]++;\\n                x++;\\n                y++; }\\n            if(mp.size()==1) {\\n                flag=1;\\n            }\\n            else{\\n                flag=0;\\n            }\\n            \\n            if(flag==0){\\n                break;\\n            }\\n              mp.clear();\\n        }\\n        if(flag==0){\\n            return false; }\\n        int flg=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<int,int>mp;\\n             flg=0;\\n             int x=0;\\n             int y=i;     \\n            while((x<m)&&(y<n)) {\\n                mp[matrix[x][y]]++;\\n                x++;\\n                y++;}\\n            if(mp.size()==1){\\n                flg=1;\\n            } else\\n            {\\n                flg=0;\\n            }\\n            if(flg==0) {\\n                break;\\n            }\\n            mp.clear();\\n        }\\n         if(flg==0){\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/37b4d18e-fa80-48f0-8549-45b8cb9abb77_1667203391.11747.png)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762273,
                "title": "c-o-n-m-simple",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\t\\n\\tint r = matrix.size(); // rows\\n\\tint c = matrix[0].size(); // columns\\n\\t\\n\\t// Iterate through matrix and check the upper left element of each element.\\n\\tfor (int i = 1; i < r; ++i)\\n\\t{\\n\\t\\tfor (int j = 1; j < c; ++j)\\n\\t\\t{\\n\\t\\t\\t// If condition not met for any element return false.\\n\\t\\t\\tif (matrix[i][j] != matrix[i - 1][j - 1]) return false; \\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\t\\n\\tint r = matrix.size(); // rows\\n\\tint c = matrix[0].size(); // columns\\n\\t\\n\\t// Iterate through matrix and check the upper left element of each element.\\n\\tfor (int i = 1; i < r; ++i)\\n\\t{\\n\\t\\tfor (int j = 1; j < c; ++j)\\n\\t\\t{\\n\\t\\t\\t// If condition not met for any element return false.\\n\\t\\t\\tif (matrix[i][j] != matrix[i - 1][j - 1]) return false; \\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2762223,
                "title": "simple-easy-solution-in-c-tc-o-n-2-sc-o-1",
                "content": "**Time complexity: O(N^2)**\\n**Space Complexity: O(1)**\\n\\n\\nApproach:\\nTraverse along the diagonal and check elements are equal or not?\\nIf diagonal elements are not equal then simply return \"false\".\\n\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\t\\tint r = matrix.size();\\n        int c = matrix[0].size();\\n        \\n        for(int i=0; i<r-1; i++)\\n        {\\n            for(int j=0; j<c-1; j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\t\\tint r = matrix.size();\\n        int c = matrix[0].size();\\n        \\n        for(int i=0; i<r-1; i++)\\n        {\\n            for(int j=0; j<c-1; j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762164,
                "title": "js-two-loop",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(matrix) {\\n    for (let i = 1; i < matrix.length; i++) {\\n              \\n        for (let j = 1; j < matrix[i].length; j++) {\\n                if (matrix[i - 1][j - 1] !== matrix[i][j]){\\n                    return false \\n                } \\n        \\n\\n        }\\n}\\n    return true\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(matrix) {\\n    for (let i = 1; i < matrix.length; i++) {\\n              \\n        for (let j = 1; j < matrix[i].length; j++) {\\n                if (matrix[i - 1][j - 1] !== matrix[i][j]){\\n                    return false \\n                } \\n        \\n\\n        }\\n}\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762120,
                "title": "c-cpp-solution-easy-to-understand-begineer-friendly",
                "content": "approach:\\nwe need to compare the consecutive two rows,\\nif in any two consecutive rows, we find that diagonal elements are not same , we return false,\\nother wise return true.\\ntime complexity:O(N^2)\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])\\n                    return false;\\n            }\\n                \\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])\\n                    return false;\\n            }\\n                \\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761517,
                "title": "answer-for-follow-up-approach",
                "content": "**Implementation of follow-up:**\\n\\n1) I just read the partial row from the disk.\\n2) At any given time, Memory of one row size is utilized.\\n\\n***Happy coding!***\\n\\n```\\nclass Solution {\\n    int offset(int i, int j, int C) {\\n        return (i * C) + j;\\n    }\\n\\n    int readFromFile(vector<vector<int>> &file, int offset) {\\n        int line = offset / file[0].size(), pos = offset % file[0].size();\\n        return file[line][pos];\\n    }\\n\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>> &matrix) {\\n        /**\\n         * **Problem**:\\n         *\\n         * Follow-up-1: What if the matrix is stored on disk, and the memory is limited such that\\n         * you can only load at most one row of the matrix into the memory at once?\\n         *\\n         * Follow-up-2: What if the matrix is so large that you can only load up a partial row into\\n         * the memory at once?\\n         * */\\n\\n\\n        deque<int> buffer;\\n        const int R = matrix.size(), C = matrix[0].size();\\n        // reading first row from\\n        for (int j = 0; j < C; ++j) buffer.push_back(readFromFile(matrix, offset(0, j, C)));\\n\\n        for (int i = 1; i < R; ++i) {\\n            // free up one space\\n            buffer.pop_back();\\n            // read first \\n            buffer.push_front(readFromFile(matrix, offset(i, 0, C)));\\n            for (int j = 1; j < C; j++) if (buffer[j] != readFromFile(matrix, offset(i, j, C))) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int offset(int i, int j, int C) {\\n        return (i * C) + j;\\n    }\\n\\n    int readFromFile(vector<vector<int>> &file, int offset) {\\n        int line = offset / file[0].size(), pos = offset % file[0].size();\\n        return file[line][pos];\\n    }\\n\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>> &matrix) {\\n        /**\\n         * **Problem**:\\n         *\\n         * Follow-up-1: What if the matrix is stored on disk, and the memory is limited such that\\n         * you can only load at most one row of the matrix into the memory at once?\\n         *\\n         * Follow-up-2: What if the matrix is so large that you can only load up a partial row into\\n         * the memory at once?\\n         * */\\n\\n\\n        deque<int> buffer;\\n        const int R = matrix.size(), C = matrix[0].size();\\n        // reading first row from\\n        for (int j = 0; j < C; ++j) buffer.push_back(readFromFile(matrix, offset(0, j, C)));\\n\\n        for (int i = 1; i < R; ++i) {\\n            // free up one space\\n            buffer.pop_back();\\n            // read first \\n            buffer.push_front(readFromFile(matrix, offset(i, 0, C)));\\n            for (int j = 1; j < C; j++) if (buffer[j] != readFromFile(matrix, offset(i, j, C))) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761427,
                "title": "java-c-python-very-easy-solution-simple-with-comments",
                "content": "**Java Solution**\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                //Checking for every element to be equal to its top left neighbor.\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                //Checking for every element to be equal to its top left neighbor.\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Python Solution**\\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        return all(i == 0 or j == 0 or matrix[i-1][j-1] == val\\n                   for i, row in enumerate(matrix)\\n                   for j, val in enumerate(row))\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                //Checking for every element to be equal to its top left neighbor.\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                //Checking for every element to be equal to its top left neighbor.\\n                if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        return all(i == 0 or j == 0 or matrix[i-1][j-1] == val\\n                   for i, row in enumerate(matrix)\\n                   for j, val in enumerate(row))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761411,
                "title": "java-runtime-1-ms-faster-than-93-83-of-java-online-submissions",
                "content": "\\uD83D\\uDD08 \\uD83D\\uDD09 \\uD83D\\uDD0A LeetCode Video Alert: LeetCode #766. Toeplitz Matrix | [Java] | Facebook Interview Question\\n\\u26A1 Turkish version is ready. English and German versions on the way!!!\\nhttps://www.youtube.com/watch?v=NJukrSOkz24\\n\\uD83D\\uDC68\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB Don\\'t forget to subscribe to the our YouTube channel to be notified of videos. https://www.youtube.com/channel/UCQZQ28Fbsb4D9yNjKVe8X0Q\\n\\uD83D\\uDFE2 Give a star on GitHub repository https://github.com/fatmaerturk/leetCode/\\nand upvote this post https://leetcode.com/fatmaerturk/ if you like it!!! \\n\\uD83E\\uDD17 Join our Discord community to solve the daily questions together https://discord.gg/9gQcPQ9K \\n\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1; i<matrix.length;i++){\\n            for(int j=1; j<matrix[0].length; j++) {\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false; }}\\n        return true;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1; i<matrix.length;i++){\\n            for(int j=1; j<matrix[0].length; j++) {\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false; }",
                "codeTag": "Java"
            },
            {
                "id": 2761327,
                "title": "c-intuitive-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n\\t\\t       //just check that whether previous diagonal element for curr element is equal to current one or not\\n                int prevForCurrDiag = (i < 1 || j < 1)? matrix[i][j] : matrix[i - 1][j - 1]; \\n                if (matrix[i][j] != prevForCurrDiag) return false;\\n            }\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size(), n = matrix[0].size();\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n\\t\\t       //just check that whether previous diagonal element for curr element is equal to current one or not\\n                int prevForCurrDiag = (i < 1 || j < 1)? matrix[i][j] : matrix[i - 1][j - 1]; \\n                if (matrix[i][j] != prevForCurrDiag) return false;\\n            }\\n        }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607463,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let l = matrix.len();\\n        if l == 1 || matrix[0].len() == 1 {\\n            return true;\\n        }\\n\\n        for (i, row) in matrix[..l - 1].iter().enumerate() {\\n            let next_row_it = matrix[i + 1][1..].iter();\\n            if row.iter().zip(next_row_it).any(|(x, y)| *x != *y) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let l = matrix.len();\\n        if l == 1 || matrix[0].len() == 1 {\\n            return true;\\n        }\\n\\n        for (i, row) in matrix[..l - 1].iter().enumerate() {\\n            let next_row_it = matrix[i + 1][1..].iter();\\n            if row.iter().zip(next_row_it).any(|(x, y)| *x != *y) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986568,
                "title": "java-easy-to-understand-with-different-ways",
                "content": "Solution 1: 100% faster and 0ms\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n       int lengthM = matrix.length - 1, lengthN = matrix[0].length - 1;\\n       for (var i = 0; i < lengthM; i++) {\\n        for (var j = 0; j < lengthN; j++) {\\n            if (matrix[i][j] != matrix[i+1][j+1]) {\\n                return false;\\n            }   \\n        }   \\n    }   \\n    return true;\\n    }\\n}\\n```\\n\\n\\nSolution 2: with comment to solve it different way\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int lengthM = matrix.length, lengthN = matrix[0].length;        \\n        int possiblePair = (lengthM + lengthN)-1; // possibility of pair : (m+n)-1\\n        int[] tarr = new int[possiblePair];\\n        int incrX = lengthM - 1, incrY = 0, initialIndex = possiblePair, currentValue = 0;\\n        \\n        for(int i = lengthM-1; i >= 0; i--) { // start filling array from end   \\n            if(incrY >= lengthN) return true; // check if reaches to n length\\n            --initialIndex;\\n             currentValue = matrix[incrX][incrY] == 0 ? -1 : matrix[incrX][incrY]; // add value -1 for 0 to work for condition like:[0,33][33,34]\\n            //System.out.println(\"initialIndex: \"+initialIndex);\\n            //System.out.println(\"X:\"+incrX+\":\"+\" Y:\"+incrY + \" value: \"+currentValue);            \\n            if((tarr[initialIndex]) != 0) {\\n                if(tarr[initialIndex] == currentValue) { // check if array has same value and skip\\n                    if(i != 0) --incrX;\\n                    //System.out.println(\"\");\\n                    continue;\\n                }\\n                else // array has different value\\n                    return false;\\n            }\\n            else { // add value to particular index\\n                tarr[initialIndex] = currentValue;\\n                if(i != 0) --incrX;\\n            }\\n            //System.out.println(\"Value in new tarr: \"+initialIndex+\" : \"+(tarr[initialIndex]));   \\n            //System.out.println(\"\");\\n            if(i == 0) {\\n                initialIndex = possiblePair - 1; // set index to start filling tarr\\n                --possiblePair;\\n                ++incrY;\\n                incrX = lengthM - 1;\\n                i = lengthM; //set again to m length\\n               //System.out.println(\"--------------------------\");                \\n            }\\n         \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n       int lengthM = matrix.length - 1, lengthN = matrix[0].length - 1;\\n       for (var i = 0; i < lengthM; i++) {\\n        for (var j = 0; j < lengthN; j++) {\\n            if (matrix[i][j] != matrix[i+1][j+1]) {\\n                return false;\\n            }   \\n        }   \\n    }   \\n    return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int lengthM = matrix.length, lengthN = matrix[0].length;        \\n        int possiblePair = (lengthM + lengthN)-1; // possibility of pair : (m+n)-1\\n        int[] tarr = new int[possiblePair];\\n        int incrX = lengthM - 1, incrY = 0, initialIndex = possiblePair, currentValue = 0;\\n        \\n        for(int i = lengthM-1; i >= 0; i--) { // start filling array from end   \\n            if(incrY >= lengthN) return true; // check if reaches to n length\\n            --initialIndex;\\n             currentValue = matrix[incrX][incrY] == 0 ? -1 : matrix[incrX][incrY]; // add value -1 for 0 to work for condition like:[0,33][33,34]\\n            //System.out.println(\"initialIndex: \"+initialIndex);\\n            //System.out.println(\"X:\"+incrX+\":\"+\" Y:\"+incrY + \" value: \"+currentValue);            \\n            if((tarr[initialIndex]) != 0) {\\n                if(tarr[initialIndex] == currentValue) { // check if array has same value and skip\\n                    if(i != 0) --incrX;\\n                    //System.out.println(\"\");\\n                    continue;\\n                }\\n                else // array has different value\\n                    return false;\\n            }\\n            else { // add value to particular index\\n                tarr[initialIndex] = currentValue;\\n                if(i != 0) --incrX;\\n            }\\n            //System.out.println(\"Value in new tarr: \"+initialIndex+\" : \"+(tarr[initialIndex]));   \\n            //System.out.println(\"\");\\n            if(i == 0) {\\n                initialIndex = possiblePair - 1; // set index to start filling tarr\\n                --possiblePair;\\n                ++incrY;\\n                incrX = lengthM - 1;\\n                i = lengthM; //set again to m length\\n               //System.out.println(\"--------------------------\");                \\n            }\\n         \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938520,
                "title": "rust-solution-fully-functionnal",
                "content": "```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix\\n            .iter()\\n            .skip(1)\\n            .zip(matrix.iter())\\n            .all(|(current, last)| current.iter().skip(1).eq(last.iter().take(last.len() - 1)))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        matrix\\n            .iter()\\n            .skip(1)\\n            .zip(matrix.iter())\\n            .all(|(current, last)| current.iter().skip(1).eq(last.iter().take(last.len() - 1)))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 922734,
                "title": "rust-oneliner",
                "content": "```rust\\npub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n    matrix\\n        .windows(2)\\n        .all(|win| &win[0][0..win[0].len() - 1] == &win[1][1..win[1].len()])\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n    matrix\\n        .windows(2)\\n        .all(|win| &win[0][0..win[0].len() - 1] == &win[1][1..win[1].len()])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816501,
                "title": "c-java-4-lines",
                "content": "**C++:**\\n\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n  for(int i=1;i<matrix.size();++i)\\n\\tfor(int j=1;j<matrix[i].size();++j)\\n\\t  if(matrix[i][j]!= matrix[i-1][j-1]) return false;\\n  return true;\\n}\\n```\\n\\n**Java:**\\n\\n```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n  for(int i=0;i<matrix.length-1;++i)\\n\\tfor(int j=0;j<matrix[i].length-1;++j)\\n\\t  if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n  for(int i=1;i<matrix.size();++i)\\n\\tfor(int j=1;j<matrix[i].size();++j)\\n\\t  if(matrix[i][j]!= matrix[i-1][j-1]) return false;\\n  return true;\\n}\\n```\n```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n  for(int i=0;i<matrix.length-1;++i)\\n\\tfor(int j=0;j<matrix[i].length-1;++j)\\n\\t  if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609344,
                "title": "java-o-n-2-simple-and-concise",
                "content": "```\\npublic boolean isToeplitzMatrix(int[][] mx) {\\n        int m = mx.length, n = mx[0].length;\\n        for (int k = 0; k < n - 1; k++) {\\n            int i = 1, j = k + 1, t = mx[0][k];\\n            while (i < m && j < n) {\\n                if (mx[i++][j++] != t) return false;\\n            }\\n        }\\n        for (int k = 1; k < m - 1; k++) {\\n            int i = k + 1, j = 1, t = mx[k][0];\\n            while (i < m && j < n) {\\n                if (mx[i++][j++] != t) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isToeplitzMatrix(int[][] mx) {\\n        int m = mx.length, n = mx[0].length;\\n        for (int k = 0; k < n - 1; k++) {\\n            int i = 1, j = k + 1, t = mx[0][k];\\n            while (i < m && j < n) {\\n                if (mx[i++][j++] != t) return false;\\n            }\\n        }\\n        for (int k = 1; k < m - 1; k++) {\\n            int i = k + 1, j = 1, t = mx[k][0];\\n            while (i < m && j < n) {\\n                if (mx[i++][j++] != t) return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563408,
                "title": "python-dp-solution",
                "content": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        d = {}\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if i - j in d and d[i-j] != matrix[i][j]:\\n                    return False\\n                else: d[i-j] = matrix[i][j]\\n                    \\n        return True\\n```\\n\\n- **Time**: `O(n*m)`\\n- **Space**: `O(n+m-1)`",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        d = {}\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if i - j in d and d[i-j] != matrix[i][j]:\\n                    return False\\n                else: d[i-j] = matrix[i][j]\\n                    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264264,
                "title": "javascript-solution",
                "content": "```\\nvar isToeplitzMatrix = function(matrix) {\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (matrix[i+1] !== undefined && matrix[i+1][j+1] !== undefined) {\\n        if(matrix[i][j] !== matrix[i+1][j+1]) {\\n          return false;\\n        }\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isToeplitzMatrix = function(matrix) {\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (matrix[i+1] !== undefined && matrix[i+1][j+1] !== undefined) {\\n        if(matrix[i][j] !== matrix[i+1][j+1]) {\\n          return false;\\n        }\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147857,
                "title": "javascript-o-n-accepted-solution",
                "content": "```\\nvar isToeplitzMatrix = function(matrix) {\\n    for (var i = matrix.length - 1; i>0; i--) {\\n        if(matrix[i].slice(1, matrix[i].length).join(\\'\\') !== matrix[i-1].slice(0, matrix[i].length - 1).join(\\'\\')) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isToeplitzMatrix = function(matrix) {\\n    for (var i = matrix.length - 1; i>0; i--) {\\n        if(matrix[i].slice(1, matrix[i].length).join(\\'\\') !== matrix[i-1].slice(0, matrix[i].length - 1).join(\\'\\')) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 145725,
                "title": "python-beats-100",
                "content": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for idx, row in enumerate(matrix):\\n            if idx == 0:\\n                pass\\n            elif row[1:] != matrix[idx-1][0:-1]:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for idx, row in enumerate(matrix):\\n            if idx == 0:\\n                pass\\n            elif row[1:] != matrix[idx-1][0:-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113401,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix)==1:\\n            return True\\n        for i in xrange(len(matrix[0])-1):\\n            for j in xrange(len(matrix)-1):\\n                if matrix[j+1][i+1]!=matrix[j][i]:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix)==1:\\n            return True\\n        for i in xrange(len(matrix[0])-1):\\n            for j in xrange(len(matrix)-1):\\n                if matrix[j+1][i+1]!=matrix[j][i]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037107,
                "title": "fast-and-memory-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nLet there be $c$ columns. Test if the first $c-1$ columns on row $r$ match the last $c-1$ columns on row $r + 1$. If this does not hold, return False. Else, return True.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for idx in range(0, len(matrix) - 1):\\n            if matrix[idx][0:-1] != matrix[idx+1][1:]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for idx in range(0, len(matrix) - 1):\\n            if matrix[idx][0:-1] != matrix[idx+1][1:]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680568,
                "title": "c-solution-easy-to-understand",
                "content": "bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n     int m = matrix.size();\\n     int n = matrix[0].size();\\n     int p =(m*n)-(m+n);\\n      int c=0;\\n     for(int i=0;i<m-1;i++){\\n         for(int j=0;j<n-1;j++){\\n             if(matrix[i][j]==matrix[i+1][j+1])\\n             { c=c+1;\\n             }\\n         }\\n     }\\n    //cout<<c;\\n    if(c==(p+1)){\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n     int m = matrix.size();\\n     int n = matrix[0].size();\\n     int p =(m*n)-(m+n);\\n      int c=0;\\n     for(int i=0;i<m-1;i++){\\n         for(int j=0;j<n-1;j++){\\n             if(matrix[i][j]==matrix[i+1][j+1])\\n             { c=c+1;\\n             }\\n         }\\n     }\\n    //cout<<c;\\n    if(c==(p+1)){\\n        return true;\\n    }\\n    else {\\n        return false;\\n    }\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3528012,
                "title": "beginners-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[0].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[0].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460097,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int m = 0; m < matrix.size(); m++){\\n            for(int n = 0; n < matrix[0].size(); n++){\\n                if(m > 0 && n > 0 && matrix[m - 1][n - 1] != matrix[m][n]){\\n                    return false; \\n                }\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        n_rows = len(matrix)\\n        n_cols = len(matrix[0])\\n\\n        for r in range(n_rows):\\n            for c in range(n_cols):\\n                if r > 0 and c > 0 and matrix[r - 1][c - 1] != matrix[r][c]:\\n                    return False\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++){\\n\\t\\t\\t\\tfor(int j=0;j<matrix[0].length-1;j++){\\n\\t\\t\\t\\t\\t\\tif(matrix[i][j]!=matrix[i+1][j+1])\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int m = 0; m < matrix.size(); m++){\\n            for(int n = 0; n < matrix[0].size(); n++){\\n                if(m > 0 && n > 0 && matrix[m - 1][n - 1] != matrix[m][n]){\\n                    return false; \\n                }\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        n_rows = len(matrix)\\n        n_cols = len(matrix[0])\\n\\n        for r in range(n_rows):\\n            for c in range(n_cols):\\n                if r > 0 and c > 0 and matrix[r - 1][c - 1] != matrix[r][c]:\\n                    return False\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++){\\n\\t\\t\\t\\tfor(int j=0;j<matrix[0].length-1;j++){\\n\\t\\t\\t\\t\\t\\tif(matrix[i][j]!=matrix[i+1][j+1])\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378441,
                "title": "easy-js-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(arr) {\\n    for(let i = 0; i < arr.length - 1; i++) {\\n        for(let j = 0; j < arr[i].length - 1; j++) {\\n            if(arr[i][j] != arr[i + 1][j + 1]) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(arr) {\\n    for(let i = 0; i < arr.length - 1; i++) {\\n        for(let j = 0; j < arr[i].length - 1; j++) {\\n            if(arr[i][j] != arr[i + 1][j + 1]) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232986,
                "title": "c-5-lines-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105380,
                "title": "java-1ms-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n   \\n        \\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[0].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n   \\n        \\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[0].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764963,
                "title": "c-easy-solution-beginner-friendly",
                "content": "CODE\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row-1;i++)\\n        {\\n            for(int j=0;j<col-1;j++)\\n            {\\n                if(matrix[i][j] == matrix[i+1][j+1])\\n                    continue;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row-1;i++)\\n        {\\n            for(int j=0;j<col-1;j++)\\n            {\\n                if(matrix[i][j] == matrix[i+1][j+1])\\n                    continue;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764732,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    public bool IsToeplitzMatrix(int[][] matrix) \\n    {\\n        for(int i=1; i<matrix.Length; i++)\\n        {\\n            for(int j=1; j<matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsToeplitzMatrix(int[][] matrix) \\n    {\\n        for(int i=1; i<matrix.Length; i++)\\n        {\\n            for(int j=1; j<matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764423,
                "title": "c-clean-code-easy-matrix-solution-self-explanatory-tc-0-n-n",
                "content": "**Upvote If It Helps**\\n\\n*Ask me in comments if you have any doubts \\uD83D\\uDE09*\\n\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        for(int i=1;i<rows;++i){\\n            for(int j=1;j<cols;++j){\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        for(int i=1;i<rows;++i){\\n            for(int j=1;j<cols;++j){\\n                if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764419,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1; i<matrix.length; i++){\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1; i<matrix.length; i++){\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763415,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n          for(int j=1;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n          }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n          for(int j=1;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=matrix[i-1][j-1]) return false;\\n          }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763387,
                "title": "two-approaches-straight-forword-and-observation-based",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n            int n=matrix[0].size();\\n    if(m<=1 || n<=1)return true;\\n        // int i=m-1;\\n        // int j=0;\\n        for(int i=m-1;i>=0;i--){\\n           int j=0;\\n            int i1=i;\\n            int t=matrix[i][j];\\n            while(j<=n-1 && i1<=m-1){\\n                if(matrix[i1][j]!=t)return false;\\n                j++;\\n                i1++;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n           int i=0;\\n            int j1=j;\\n            int t=matrix[i][j];\\n            while(j1<=n-1 && i<=m-1){\\n                if(matrix[i][j1]!=t)return false;\\n                j1++;\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        int r = matrix.size();\\n        int c = matrix[0].size();\\n        \\n        for(int i=0; i<r-1; i++)\\n        {\\n            for(int j=0; j<c-1; j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n            int n=matrix[0].size();\\n    if(m<=1 || n<=1)return true;\\n        // int i=m-1;\\n        // int j=0;\\n        for(int i=m-1;i>=0;i--){\\n           int j=0;\\n            int i1=i;\\n            int t=matrix[i][j];\\n            while(j<=n-1 && i1<=m-1){\\n                if(matrix[i1][j]!=t)return false;\\n                j++;\\n                i1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2763185,
                "title": "cpp-solution-c",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()-1;i++)\\n        {\\n            for(int j=0;j<matrix[0].size()-1;j++)\\n\\t\\t\\t{\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()-1;i++)\\n        {\\n            for(int j=0;j<matrix[0].size()-1;j++)\\n\\t\\t\\t{\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762872,
                "title": "unique-way-simple-approach-c-easy-understanding",
                "content": "* Moving diagonally and checking each diagonal element\\n**EXAMPLE:**\\n![image](https://assets.leetcode.com/users/images/bcd90050-dd02-40bd-b4f7-707e1942b975_1667211462.8870497.jpeg) \\nTraversal order:\\n1. matrix[2][0]\\n2. matrix[1][0]\\n3. matrix[2][1]\\n4. matrix[0][0]\\n5. matrix[1][1]\\n6. matrix[2][2]\\n7. matrix[0][1]\\n8. matrix[1][2]\\n9. matrix[2][3]\\n10. matrix[0][2]\\n11. matrix[1][3]\\n12. matrix[0][3]\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n    int i=m,j=0,s=m,t=0;\\n        ///// traversing lower left side diagonals\\n// i.e. matrix[2][0]\\n//matrix[1][0]\\n//matrix[2][1]\\n//matrix[0][0]\\n//matrix[1][1]\\n//matrix[2][2]\\n\\n    while(s>=0)\\n    {\\n        i=s;\\n        j=0;\\n        while(i<m-1&&j<n-1)\\n        {\\n            if(matrix[i][j]!=matrix[i+1][j+1])\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        s--;\\n    }  \\n\\n            ///// traversing upper right side diagonals\\n// i.e. matrix[0][1]\\n//matrix[1][2]\\n//matrix[2][3]\\n//matrix[0][2]\\n//matrix[1][3]\\n//matrix[0][3]\\n        i=0,j=1;\\n         while(t<n)\\n    {\\n        i=0;\\n        j=t;\\n        while(i<m-1&&j<n-1)\\n        {\\n            if(matrix[i][j]!=matrix[i+1][j+1])\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        t++;\\n    }  \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n    int i=m,j=0,s=m,t=0;\\n        ///// traversing lower left side diagonals\\n// i.e. matrix[2][0]\\n//matrix[1][0]\\n//matrix[2][1]\\n//matrix[0][0]\\n//matrix[1][1]\\n//matrix[2][2]\\n\\n    while(s>=0)\\n    {\\n        i=s;\\n        j=0;\\n        while(i<m-1&&j<n-1)\\n        {\\n            if(matrix[i][j]!=matrix[i+1][j+1])\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        s--;\\n    }  \\n\\n            ///// traversing upper right side diagonals\\n// i.e. matrix[0][1]\\n//matrix[1][2]\\n//matrix[2][3]\\n//matrix[0][2]\\n//matrix[1][3]\\n//matrix[0][3]\\n        i=0,j=1;\\n         while(t<n)\\n    {\\n        i=0;\\n        j=t;\\n        while(i<m-1&&j<n-1)\\n        {\\n            if(matrix[i][j]!=matrix[i+1][j+1])\\n                return false;\\n            i++;\\n            j++;\\n        }\\n        t++;\\n    }  \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762638,
                "title": "python-solution-october-leetcoding",
                "content": "\\n\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n\\t   #storing the last row elements of the matrix\\n        a=m[0]\\n        for i in range(1,len(m)):\\n\\t\\t   #first element of the i th row\\n            z=m[i][0]\\n\\t\\t\\t#inserting the element z in matrix a and poping out the last element \\n            a.insert(0,z)\\n            a.pop()\\n            if m[i]!=a:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, m: List[List[int]]) -> bool:\\n\\t   #storing the last row elements of the matrix\\n        a=m[0]\\n        for i in range(1,len(m)):\\n\\t\\t   #first element of the i th row\\n            z=m[i][0]\\n\\t\\t\\t#inserting the element z in matrix a and poping out the last element \\n            a.insert(0,z)\\n            a.pop()\\n            if m[i]!=a:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762314,
                "title": "java-guaranteed-optimised-easy-solution",
                "content": "***Please do upvote, if you find it helpful***\\uD83D\\uDE0A\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        for(int i=1; i<matrix.length; i++){         // Starting from 2nd row as 1st will be for the \\n                                                    // checking purpose only\\n            for(int j=0; j<matrix[0].length; j++){\\n                \\n                if(j>0){\\n                    if(matrix[i][j]!=matrix[i-1][j-1])  // Checking with previous row \\n                        return false;\\n                }\\n            }\\n        }      \\n        return true;        // if in any case if in previous condition we won\\'t get false,\\n                            // then return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        \\n        for(int i=1; i<matrix.length; i++){         // Starting from 2nd row as 1st will be for the \\n                                                    // checking purpose only\\n            for(int j=0; j<matrix[0].length; j++){\\n                \\n                if(j>0){\\n                    if(matrix[i][j]!=matrix[i-1][j-1])  // Checking with previous row \\n                        return false;\\n                }\\n            }\\n        }      \\n        return true;        // if in any case if in previous condition we won\\'t get false,\\n                            // then return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762287,
                "title": "java-easy-4-line-solution-100-faster-easy",
                "content": "if u like it kindly upvote \\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] arr) {\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=1;j<arr[0].length;j++){\\n                if(arr[i-1][j-1]!=arr[i][j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] arr) {\\n        for(int i=1;i<arr.length;i++){\\n            for(int j=1;j<arr[0].length;j++){\\n                if(arr[i-1][j-1]!=arr[i][j]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762061,
                "title": "java-easy-and-fast-solution-with-explanation",
                "content": "# Approach (Bruteforce)\\n<!-- Describe your approach to solving the problem. -->\\nA Toeplitz matrix is a matrix where every left-to-right descending diagonal has the same element. \\nThe algorithm checks if all elements in each row are equal to their corresponding elements in the previous row, starting from column 1.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$  We have used 2 loops here.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ No Extra Space is used. here\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        boolean ans = true;\\n        for(int i=1; i<matrix.length; ++i){\\n            for(int  j=1; j<matrix[i].length; ++j){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    ans = false;\\n                }\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Upvote me if you like the solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        boolean ans = true;\\n        for(int i=1; i<matrix.length; ++i){\\n            for(int  j=1; j<matrix[i].length; ++j){\\n                if(matrix[i][j]!=matrix[i-1][j-1]){\\n                    ans = false;\\n                }\\n                }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761830,
                "title": "toeplitz-matrix-2-ways-python",
                "content": "# Introduction\\nA Toeplitz matrix is a diagonal-constant matrix, in which all elements along a diagonal have the same value, For a Toeplitz matrix A, we have A[i][j]=A[i-1][j-1] r A[i][j]=A[i+1][j+1].\\n\\n<hr>\\n\\n# Approach\\n- For each element, just check whether its equal to the element just diagonally above it, i.e., for all matrix[i][j] for i,j>0, check whether its equal to matrix[i-1][j-1]\\n- Same problem can also be solved the other way around, by comparing the element with next diagonal element below it, i.e., for all matrix[i][j] for i,j<len(matrix)-1, check whether its equal to matrix[i+1][j+1]\\n\\n<hr>\\n\\n# Complexity\\n- Time complexity:\\nO(n*m) [n=len(matrix), m=len(matrix[0])]\\n\\n\\n- Space complexity:\\nO(1)\\n\\n<hr>\\n\\n# Code\\n- By comparing with the diagonally previous element\\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        for i in range(1,len(matrix)):\\n            for j in range(1,len(matrix[i])):\\n                if matrix[i][j]!=matrix[i-1][j-1]:\\n                    return False \\n        return True\\n```\\n- By comparing with the diagonally next element\\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        for i in range(len(matrix)-1):\\n            for j in range(len(matrix[i])-1):\\n                if matrix[i][j]!=matrix[i+1][j+1]:\\n                    return False \\n        return True\\n```\\n\\n<hr>\\n\\n# Do upvote if u like my approach :)\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        for i in range(1,len(matrix)):\\n            for j in range(1,len(matrix[i])):\\n                if matrix[i][j]!=matrix[i-1][j-1]:\\n                    return False \\n        return True\\n```\n```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        for i in range(len(matrix)-1):\\n            for j in range(len(matrix[i])-1):\\n                if matrix[i][j]!=matrix[i+1][j+1]:\\n                    return False \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761645,
                "title": "js-easy-to-understand-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(matrix) {\\n    if(matrix.length == 1 ) return true;\\n    return checkHorizontal(matrix) && checkVertical(matrix)\\n}\\n\\nvar checkVertical  = (matrix) => {\\n    if(matrix.length == 1 ) return true;\\n    for(let i = matrix.length - 1; i >= 0; i--){\\n        let num = matrix[i][0];\\n        let j = i + 1;\\n        let p = 1;\\n        while(matrix[j] && matrix[j][p] != undefined) {\\n            if(num^matrix[j][p]){\\n                return false;\\n            }\\n            else {\\n                j++;\\n                p++;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nvar checkHorizontal = (matrix) => {\\nif(matrix.length == 1 ) return true;\\n    for(let i = 1; i < matrix[0].length; i++){\\n        let num = matrix[0][i];\\n        let j = i + 1;\\n        let p = 1;\\n        while(matrix[p] && matrix[p][j] != undefined) {\\n            if(num^matrix[p][j]) {\\n                return false;\\n            }\\n            else {\\n                p++;\\n                j++;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar isToeplitzMatrix = function(matrix) {\\n    if(matrix.length == 1 ) return true;\\n    return checkHorizontal(matrix) && checkVertical(matrix)\\n}\\n\\nvar checkVertical  = (matrix) => {\\n    if(matrix.length == 1 ) return true;\\n    for(let i = matrix.length - 1; i >= 0; i--){\\n        let num = matrix[i][0];\\n        let j = i + 1;\\n        let p = 1;\\n        while(matrix[j] && matrix[j][p] != undefined) {\\n            if(num^matrix[j][p]){\\n                return false;\\n            }\\n            else {\\n                j++;\\n                p++;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nvar checkHorizontal = (matrix) => {\\nif(matrix.length == 1 ) return true;\\n    for(let i = 1; i < matrix[0].length; i++){\\n        let num = matrix[0][i];\\n        let j = i + 1;\\n        let p = 1;\\n        while(matrix[p] && matrix[p][j] != undefined) {\\n            if(num^matrix[p][j]) {\\n                return false;\\n            }\\n            else {\\n                p++;\\n                j++;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761478,
                "title": "elixir-cryptic-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec is_toeplitz_matrix(matrix :: [[integer]]) :: boolean\\n  def is_toeplitz_matrix(matrix) do\\n    matrix\\n    |> Stream.chunk_every(2, 1, :discard)\\n    |> Stream.flat_map(fn [r1, r2] ->\\n      Stream.zip_with(r1, tl(r2), &==/2)\\n    end)\\n    |> Enum.all?()\\n  end\\nend\\n```\\n\\nO(m * n) time, O(1) space.",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec is_toeplitz_matrix(matrix :: [[integer]]) :: boolean\\n  def is_toeplitz_matrix(matrix) do\\n    matrix\\n    |> Stream.chunk_every(2, 1, :discard)\\n    |> Stream.flat_map(fn [r1, r2] ->\\n      Stream.zip_with(r1, tl(r2), &==/2)\\n    end)\\n    |> Enum.all?()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761455,
                "title": "fastest-and-easiest-runtime-0-ms-intuitive-approach-faster-than-99-submissions",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++)\\n        {\\n            for(int j=0;j<matrix[0].length-1;j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++)\\n        {\\n            for(int j=0;j<matrix[0].length-1;j++)\\n            {\\n                if(matrix[i][j]!=matrix[i+1][j+1])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761425,
                "title": "java-easy-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i = 1;i<matrix.length;i++){\\n            for(int j = 1;j<matrix[i].length;j++){\\n                if(matrix[i][j] != matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i = 1;i<matrix.length;i++){\\n            for(int j = 1;j<matrix[i].length;j++){\\n                if(matrix[i][j] != matrix[i-1][j-1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625404,
                "title": "checking-every-row-92ms",
                "content": "![image](https://assets.leetcode.com/users/images/912bfea0-81ed-45f4-88a2-ae25eacb6bee_1664168592.4732552.png)\\n\\n\\n*Simply checking every row is equal to the next row but from next element.*\\n\\n```\\n\\nFor every row in the given matrix;\\n\\n\\t [1, 2, 3],4\\n\\t  5,[1, 2, 3]                     For the first iteration;\\n\\t  9, 5, 1, 2                              [1, 2, 3] == [1, 2, 3]  which returns True.\\n\\t  \\n\\t   1, 2,  3, 4\\n\\t  [5, 1, 2], 3                     For the second iteration;\\n\\t   9, [5, 1, 2]                              [5, 1, 2] == [5, 1, 2]  which returns True.\\n\\t   \\n\\t   If in any iteration when the check fails, False wil be returned and the code stops executing.\\n\\t  \\n```\\n\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        prev = matrix[0][:-1]\\n        for i in matrix[1:]:\\n            if i[1:] != prev:\\n                return False\\n            else:\\n                prev = i[:-1]\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nFor every row in the given matrix;\\n\\n\\t [1, 2, 3],4\\n\\t  5,[1, 2, 3]                     For the first iteration;\\n\\t  9, 5, 1, 2                              [1, 2, 3] == [1, 2, 3]  which returns True.\\n\\t  \\n\\t   1, 2,  3, 4\\n\\t  [5, 1, 2], 3                     For the second iteration;\\n\\t   9, [5, 1, 2]                              [5, 1, 2] == [5, 1, 2]  which returns True.\\n\\t   \\n\\t   If in any iteration when the check fails, False wil be returned and the code stops executing.\\n\\t  \\n```\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        prev = matrix[0][:-1]\\n        for i in matrix[1:]:\\n            if i[1:] != prev:\\n                return False\\n            else:\\n                prev = i[:-1]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535965,
                "title": "java-simple-and-easy-solution-1ms",
                "content": "class Solution {\\n\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0; i<matrix.length-1; i++) {\\n            for(int j=0; j<matrix[0].length-1; j++) {\\n                if(matrix[i][j] != matrix[i+1][j+1]) {\\n                    return false;\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0; i<matrix.length-1; i++) {\\n            for(int j=0; j<matrix[0].length-1; j++) {\\n                if(matrix[i][j] != matrix[i+1][j+1]) {\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2369754,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        row, col = len(matrix), len(matrix[0])\\n        \\n        for i in range(row):\\n            for j in range(col):\\n\\t\\t\\t\\t# check the (00, 11, 22) and (01, 12, 23) and so on...\\n                if (i - 1) >= 0 and j - 1 >= 0:\\n                    if matrix[i][j] != matrix[i-1][j-1]:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        row, col = len(matrix), len(matrix[0])\\n        \\n        for i in range(row):\\n            for j in range(col):\\n\\t\\t\\t\\t# check the (00, 11, 22) and (01, 12, 23) and so on...\\n                if (i - 1) >= 0 and j - 1 >= 0:\\n                    if matrix[i][j] != matrix[i-1][j-1]:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326235,
                "title": "c-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(!fun(matrix,i,0,matrix[i][0]))\\n                return 0;\\n        }\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            if(!fun(matrix,0,i,matrix[0][i]))\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    int fun(vector<vector<int>>& matrix,int i,int j,int val)\\n    {\\n        while(i<matrix.size() && j<matrix[i].size())\\n        {\\n            if(matrix[i][j]!=val)\\n                return 0;\\n            i++;\\n            j++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(!fun(matrix,i,0,matrix[i][0]))\\n                return 0;\\n        }\\n        for(int i=0;i<matrix[0].size();i++)\\n        {\\n            if(!fun(matrix,0,i,matrix[0][i]))\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    int fun(vector<vector<int>>& matrix,int i,int j,int val)\\n    {\\n        while(i<matrix.size() && j<matrix[i].size())\\n        {\\n            if(matrix[i][j]!=val)\\n                return 0;\\n            i++;\\n            j++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291363,
                "title": "my-javascript-answer",
                "content": "```\\nvar isToeplitzMatrix = function(matrix) {\\n    for (let i=0; i < matrix.length-1; i++) {\\n        for (let j=0; j < matrix[i].length-1; j++) {    \\n            if (matrix[i][j] !== matrix[i+1][j+1]) {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isToeplitzMatrix = function(matrix) {\\n    for (let i=0; i < matrix.length-1; i++) {\\n        for (let j=0; j < matrix[i].length-1; j++) {    \\n            if (matrix[i][j] !== matrix[i+1][j+1]) {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256099,
                "title": "fastest-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix.length==1 || matrix[0].length==1)\\n            return true;\\n        for(int i=0;i<matrix.length-1;i++)\\n        {\\n            int ele = matrix[i][0];\\n            int k=i+1;\\n            for(int j=1;j<matrix[0].length && j<matrix.length-i;j++)\\n                if(matrix[k++][j]!=ele)\\n                    return false;\\n        }\\n        for(int j=1;j<matrix[0].length-1;j++)\\n        {\\n            int ele = matrix[0][j];\\n            int k=j+1;\\n            for(int i=1;i<matrix.length && i<matrix[0].length-j;i++)\\n                if(matrix[i][k++]!=ele)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        if(matrix.length==1 || matrix[0].length==1)\\n            return true;\\n        for(int i=0;i<matrix.length-1;i++)\\n        {\\n            int ele = matrix[i][0];\\n            int k=i+1;\\n            for(int j=1;j<matrix[0].length && j<matrix.length-i;j++)\\n                if(matrix[k++][j]!=ele)\\n                    return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2134952,
                "title": "c-easiest-one-liner",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n       for (int i = 0; i < matrix.size() - 1; i++) {\\n\\t\\tfor (int j = 0;  j < matrix[0].size() - 1; j++) {\\n\\t\\t\\tif (matrix[i][j] != matrix[i + 1][j + 1])\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065535,
                "title": "python-simple-o-m-n-covered-follow-up-cases",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(len(matrix)-1):\\n            if matrix[i][0:-1] != matrix[i+1][1:]:\\n                return False\\n        return True\\n                \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(len(matrix)-1):\\n            if matrix[i][0:-1] != matrix[i+1][1:]:\\n                return False\\n        return True\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958252,
                "title": "problem-no-766-easy-solution-for-beginners-c",
                "content": "```\\nTime complexity - O(M*N) \\nSpace complexity - O(1)\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();    \\n        for(int r = 1; r < m; r++){\\n            for (int c = 1; c < n; c++){\\n                if(matrix[r][c] != matrix[r-1][c-1]) return false; \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nTime complexity - O(M*N) \\nSpace complexity - O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();    \\n        for(int r = 1; r < m; r++){\\n            for (int c = 1; c < n; c++){\\n                if(matrix[r][c] != matrix[r-1][c-1]) return false; \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833359,
                "title": "toeplitz-matrix-solution-java",
                "content": "class Solution {\\n  public boolean isToeplitzMatrix(int[][] matrix) {\\n    for (int i = 0; i + 1 < matrix.length; ++i)\\n      for (int j = 0; j + 1 < matrix[0].length; ++j)\\n        if (matrix[i][j] != matrix[i + 1][j + 1])\\n          return false;\\n    return true;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\n  public boolean isToeplitzMatrix(int[][] matrix) {\\n    for (int i = 0; i + 1 < matrix.length; ++i)\\n      for (int j = 0; j + 1 < matrix[0].length; ++j)\\n        if (matrix[i][j] != matrix[i + 1][j + 1])\\n          return false;\\n    return true;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1686198,
                "title": "short-javascript-solution",
                "content": "*Found this solution helpful? Consider showing support by upvoting this post. Thank you and happy hacking!*\\n```\\nconst isToeplitzMatrix =  (matrix) => { \\n    \\n    for (let i = 0; i < matrix.length - 1; i++) {\\n        for (let j = 0; j < matrix[0].length - 1; j++){\\n            if(matrix[i][j] !== matrix[i + 1][j + 1]){\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isToeplitzMatrix =  (matrix) => { \\n    \\n    for (let i = 0; i < matrix.length - 1; i++) {\\n        for (let j = 0; j < matrix[0].length - 1; j++){\\n            if(matrix[i][j] !== matrix[i + 1][j + 1]){\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645660,
                "title": "c-straightforward",
                "content": "class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        //Time Complexity-O(m*n) as we are iterating through all elements\\n       //Space Complexity=O(1) as no extra space is used\\n        \\n        \\n        int rowSize=matrix.size();\\n        int colSize=matrix[0].size();\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                \\n                if(i>0 && j>0 && matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        //Time Complexity-O(m*n) as we are iterating through all elements\\n       //Space Complexity=O(1) as no extra space is used\\n        \\n        \\n        int rowSize=matrix.size();\\n        int colSize=matrix[0].size();\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                \\n                if(i>0 && j>0 && matrix[i][j]!=matrix[i-1][j-1]){\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1638985,
                "title": "rust-matrix-manipulation",
                "content": "```\\n/// https://leetcode.com/problems/toeplitz-matrix/\\n/// Time Complexity:    O(`len_r` * `len_c`)\\n/// Space Copmlexity:   O(1)\\n/// Reference:\\n/// https://leetcode.com/problems/toeplitz-matrix/discuss/113417/Java-solution-4-liner.\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let len_r = matrix.len();\\n        let len_c = matrix[0].len();\\n        for r in 0..len_r - 1 {\\n            for c in 0..len_c - 1 {\\n                if matrix[r][c] != matrix[r + 1][c + 1] {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/// https://leetcode.com/problems/toeplitz-matrix/\\n/// Time Complexity:    O(`len_r` * `len_c`)\\n/// Space Copmlexity:   O(1)\\n/// Reference:\\n/// https://leetcode.com/problems/toeplitz-matrix/discuss/113417/Java-solution-4-liner.\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let len_r = matrix.len();\\n        let len_c = matrix[0].len();\\n        for r in 0..len_r - 1 {\\n            for c in 0..len_c - 1 {\\n                if matrix[r][c] != matrix[r + 1][c + 1] {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1614223,
                "title": "short-4-line-code",
                "content": "```\\n// O(n2)\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& v) {\\n        \\n        for(int i = 1; i < v.size(); i++)\\n            for(int j = 1; j < v[0].size(); j++)\\n                if(v[i][j] != v[i-1][j-1])\\n                    return false;\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& v) {\\n        \\n        for(int i = 1; i < v.size(); i++)\\n            for(int j = 1; j < v[0].size(); j++)\\n                if(v[i][j] != v[i-1][j-1])\\n                    return false;\\n        return true;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1611546,
                "title": "i-am-stupid-i-checked-every-diagonal-using-gap-method",
                "content": "Sorry for the atrocious title. After getting AC, i checked other people\\'s code and it turned out to be way simpler than I thought. \\n\\nBasically I checked every diagonal in the matrix - diagonal by diagonal.\\nThis is also called gap method or the diagonal traversal of the matrix which is a pretty common trick in DP problems. \\nIn the gap method, we utilise the fact that in every diagonal of a matrix there is a constant between the row and column index.\\n\\nHere is code if anyone is interested\\n\\n```\\npublic class Solution {\\n    /**\\n     * @param matrix: the given matrix\\n     * @return: True if and only if the matrix is Toeplitz\\n     */\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        // Write your code here\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int g = 0; g<n; g++){\\n            for(int i = 0, j = i+g; j < n-1; i++,j++){\\n                if(i+1 <m && j+1 < n && matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n         for(int g = -1; g>-m; g--){\\n            for(int i = -g, j = i+g; i < m-1; i++,j++){\\n                if(i+1 <m && j+1 < n && matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n    /**\\n     * @param matrix: the given matrix\\n     * @return: True if and only if the matrix is Toeplitz\\n     */\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        // Write your code here\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int g = 0; g<n; g++){\\n            for(int i = 0, j = i+g; j < n-1; i++,j++){\\n                if(i+1 <m && j+1 < n && matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1329738,
                "title": "rust-and-racket",
                "content": "Rust:\\n```rust\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let (rows, cols) = (matrix.len(), matrix[0].len());\\n\\n        for j in 1..rows {\\n            for i in 1..cols {\\n                if matrix[j][i] != matrix[j-1][i-1] {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\\n\\nAnd Racket:\\n```scheme\\n(define/contract (is-toeplitz-matrix matrix)\\n  (-> (listof (listof exact-integer?)) boolean?)\\n  (letrec ([go (lambda (cs)\\n                 (if (null? cs)\\n                   #t\\n                   (let ([row (caar cs)]\\n                         [col (cadar cs)])\\n                     (cond [(not (= (list-ref (list-ref matrix row) col)\\n                                    (list-ref (list-ref matrix (- row 1)) (- col 1))))\\n                            #f]\\n                           [else (go (cdr cs))]))))])\\n    (go (cartesian-product (range 1 (length matrix))\\n                           (range 1 (length (car matrix))))))\\n  )\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_toeplitz_matrix(matrix: Vec<Vec<i32>>) -> bool {\\n        let (rows, cols) = (matrix.len(), matrix[0].len());\\n\\n        for j in 1..rows {\\n            for i in 1..cols {\\n                if matrix[j][i] != matrix[j-1][i-1] {\\n                    return false\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\n```scheme\\n(define/contract (is-toeplitz-matrix matrix)\\n  (-> (listof (listof exact-integer?)) boolean?)\\n  (letrec ([go (lambda (cs)\\n                 (if (null? cs)\\n                   #t\\n                   (let ([row (caar cs)]\\n                         [col (cadar cs)])\\n                     (cond [(not (= (list-ref (list-ref matrix row) col)\\n                                    (list-ref (list-ref matrix (- row 1)) (- col 1))))\\n                            #f]\\n                           [else (go (cdr cs))]))))])\\n    (go (cartesian-product (range 1 (length matrix))\\n                           (range 1 (length (car matrix))))))\\n  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282165,
                "title": "c-easy-solution-with-explanation",
                "content": "Exxplanation:= The idea is simple \\u2013 traverse the matrix once, and for each element (i, j) , check if it is the same as its immediate diagonal element (i+1, j+1) or not. If any element differs from its immediate diagonal element, the matrix cannot be Toeplitz.\\n```\\n bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        bool res;\\n        if(matrix.size() == 1)\\n            res = true;\\n        \\n        else{\\n            for(int i=0; i < matrix.size()-1; i++){\\n                for(int j=0; j < matrix[i].size()-1; j++){\\n\\t\\t\\t\\t\\n                    if(matrix[i][j] == matrix[i+1][j+1])\\n                        res = true;\\n                    else{\\n                       res = false;\\n                        break;\\n                    }\\n                }\\n                if(res == false)\\n                    break;\\n            }\\n        }\\n       \\n        return res;\\n    }\\n```       \\n",
                "solutionTags": [],
                "code": "```\\n bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        bool res;\\n        if(matrix.size() == 1)\\n            res = true;\\n        \\n        else{\\n            for(int i=0; i < matrix.size()-1; i++){\\n                for(int j=0; j < matrix[i].size()-1; j++){\\n\\t\\t\\t\\t\\n                    if(matrix[i][j] == matrix[i+1][j+1])\\n                        res = true;\\n                    else{\\n                       res = false;\\n                        break;\\n                    }\\n                }\\n                if(res == false)\\n                    break;\\n            }\\n        }\\n       \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198028,
                "title": "c-4ms-99-51-iterative",
                "content": "Runtime: 4 ms, faster than 99.51% of C++ online submissions for Toeplitz Matrix.\\nMemory Usage: 17.3 MB, less than 75.28% of C++ online submissions for Toeplitz Matrix.\\n```\\nclass Solution {\\npublic:\\n  bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n    int y = matrix.size(), x = matrix[0].size();\\n    int sty = y - 1, stx = 0;\\n    \\n    while(sty != 0 || stx != x){\\n      for(int ptx= stx, tx= stx+1, pty= sty, ty= sty+1; tx !=x && ty !=y; tx++, ptx++, ty++, pty++)\\n        if(matrix[pty][ptx] != matrix[ty][tx]) return false;\\n      \\n      if(sty) sty--;\\n      else stx++;\\n    }  \\n      \\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n    int y = matrix.size(), x = matrix[0].size();\\n    int sty = y - 1, stx = 0;\\n    \\n    while(sty != 0 || stx != x){\\n      for(int ptx= stx, tx= stx+1, pty= sty, ty= sty+1; tx !=x && ty !=y; tx++, ptx++, ty++, pty++)\\n        if(matrix[pty][ptx] != matrix[ty][tx]) return false;\\n      \\n      if(sty) sty--;\\n      else stx++;\\n    }  \\n      \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170866,
                "title": "python3-simple-and-readable-solution",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        arr = matrix[0]\\n        \\n        for i in range(1 , len(matrix)):\\n            arr = [matrix[i][0]] + arr[:-1]\\n            \\n            if(matrix[i] != arr): return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        arr = matrix[0]\\n        \\n        for i in range(1 , len(matrix)):\\n            arr = [matrix[i][0]] + arr[:-1]\\n            \\n            if(matrix[i] != arr): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042459,
                "title": "answers-with-follow-ups",
                "content": "This solution takes care of the follow up 1 and also can be extended to follow up 2. \\nNotice that a matrix can be shown as\\n```\\n [     [  1, 2, 3, 4],\\n\\t [ 5, 1, 2, 3],\\n [  9, 5, 1, 2]]\\n\\n```\\nso that in a Toeplitz matrix previous row with range 0..n-2 is equal to the current row with range 1..n -1. Using CRC check sum function we need to calculate only two range sums and unload the current row from memory. Even if a row is so large that it doesn\\'t fit into memory we can load the row partially and calculate CRC sum part by part.\\n\\n```java\\nimport java.util.zip.CRC32;\\nclass Solution {\\n    \\n    private byte[] toByteArray(int[] arr) {\\n        byte[] ans = new byte[arr.length];\\n        for(int i = 0; i < arr.length; i++) {\\n            ans[i] = (byte) arr[i];\\n        }\\n        return ans;\\n    }\\n    \\n    private long getCheckSum(int[] arr, int from, int to) {\\n        CRC32 crc = new CRC32();\\n        crc.update(toByteArray(arr), from, to);\\n        return crc.getValue();\\n    }\\n    \\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        // load first row\\n        long checksum = getCheckSum(matrix[0], 0, n - 1);\\n        // load rows one by one\\n        for(int row = 1; row < m; row++) {\\n            if(checksum != getCheckSum(matrix[row], 1, n - 1)){\\n                return false;\\n            }\\n            checksum = getCheckSum(matrix[row], 0, n - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n [     [  1, 2, 3, 4],\\n\\t [ 5, 1, 2, 3],\\n [  9, 5, 1, 2]]\\n\\n```\n```java\\nimport java.util.zip.CRC32;\\nclass Solution {\\n    \\n    private byte[] toByteArray(int[] arr) {\\n        byte[] ans = new byte[arr.length];\\n        for(int i = 0; i < arr.length; i++) {\\n            ans[i] = (byte) arr[i];\\n        }\\n        return ans;\\n    }\\n    \\n    private long getCheckSum(int[] arr, int from, int to) {\\n        CRC32 crc = new CRC32();\\n        crc.update(toByteArray(arr), from, to);\\n        return crc.getValue();\\n    }\\n    \\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        // load first row\\n        long checksum = getCheckSum(matrix[0], 0, n - 1);\\n        // load rows one by one\\n        for(int row = 1; row < m; row++) {\\n            if(checksum != getCheckSum(matrix[row], 1, n - 1)){\\n                return false;\\n            }\\n            checksum = getCheckSum(matrix[row], 0, n - 1);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029352,
                "title": "why-is-this-wrong",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        if n==1:\\n            return True\\n        else:\\n            for i in range(n):\\n                m = len(matrix[i])\\n                if m==1:\\n                    return True\\n                else:\\n                    for j in range(m):\\n                        if matrix[i][j] != matrix[i+1][j+1]:\\n                            return False\\n                        else:\\n                            return True\\n```\\n\\nMy solution is giving wrong ans for this particular testcase : [[11,74,0,93],[40,11,74,7]]\\nPlease help!!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        if n==1:\\n            return True\\n        else:\\n            for i in range(n):\\n                m = len(matrix[i])\\n                if m==1:\\n                    return True\\n                else:\\n                    for j in range(m):\\n                        if matrix[i][j] != matrix[i+1][j+1]:\\n                            return False\\n                        else:\\n                            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944149,
                "title": "with-1-for-loop-3-solutions-using-zip-better-than-solution-i-think-96",
                "content": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        \\n        # solution 1 O(nm) time O(1) space\\n        # element element comparision two for loop \\n        rlength = len(matrix)\\n        clength = len(matrix[0])\\n\\n        for i in range(rlength-1):\\n            for i, j in zip(matrix[i][:-1],matrix[i+1][1:]):\\n                if i != j:\\n                    return False\\n        return True\\n    \\n        # solution 2  O(nm) time ? O(1) space\\n        # One for loop %65 fast, \\n        rlength = len(matrix)\\n        clength = len(matrix[0])\\n\\n        for i in range(rlength-1):\\n            if matrix[i][:-1] != matrix[i+1][1:]: #compare row by row\\n                return False\\n        return True\\n    \\n        # solution 3 same above\\n        # compare after building a generator % 96 fast\\n        return all(matrix[i][:-1] == matrix[i+1][1:] for i in range(rlength-1)) \\n```\\nplease do not forget to upvote. Thank you.\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        \\n        # solution 1 O(nm) time O(1) space\\n        # element element comparision two for loop \\n        rlength = len(matrix)\\n        clength = len(matrix[0])\\n\\n        for i in range(rlength-1):\\n            for i, j in zip(matrix[i][:-1],matrix[i+1][1:]):\\n                if i != j:\\n                    return False\\n        return True\\n    \\n        # solution 2  O(nm) time ? O(1) space\\n        # One for loop %65 fast, \\n        rlength = len(matrix)\\n        clength = len(matrix[0])\\n\\n        for i in range(rlength-1):\\n            if matrix[i][:-1] != matrix[i+1][1:]: #compare row by row\\n                return False\\n        return True\\n    \\n        # solution 3 same above\\n        # compare after building a generator % 96 fast\\n        return all(matrix[i][:-1] == matrix[i+1][1:] for i in range(rlength-1)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 876305,
                "title": "c",
                "content": "```\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t\\tfor (int j = 0; j < matrix[0].Length - 1; j++)\\n\\t\\t\\tif (matrix[i][j] != matrix[i + 1][j + 1])\\n\\t\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool IsToeplitzMatrix(int[][] matrix)\\n{\\n\\tfor (int i = 0; i < matrix.Length - 1; i++)\\n\\t\\tfor (int j = 0; j < matrix[0].Length - 1; j++)\\n\\t\\t\\tif (matrix[i][j] != matrix[i + 1][j + 1])\\n\\t\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747348,
                "title": "toeplitz-matrix",
                "content": "\"\"\"\\n\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n       \\n\\t   return all(matrix[row+1][1:] == matrix[row][:-1] for row in range(len(matrix)-1)) \\n\\t   \\n\"\"\"\\n\\n\"\"\"\\n[1, 2, 3]  [ ]\\n[ ]  [1, 2, 3] \\n\\n[5, 1, 2]  [ ]\\n[ ]  [5, 1, 2] \\n\\n\"\"\"",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\"\"\"\\n\\n\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n       \\n\\t   return all(matrix[row+1][1:] == matrix[row][:-1] for row in range(len(matrix)-1)) \\n\\t   \\n\"\"\"\\n\\n\"\"\"\\n[1, 2, 3]  [ ]\\n[ ]  [1, 2, 3] \\n\\n[5, 1, 2]  [ ]\\n[ ]  [5, 1, 2] \\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 664762,
                "title": "succint-solution-with-stl",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& m) \\n{\\n\\tfor(int i{1}; i<size(m); ++i)\\n\\t\\tif(!equal(next(begin(m[i])), end(m[i]), begin(m[i-1]))) return false;           \\n\\treturn true;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& m) \\n{\\n\\tfor(int i{1}; i<size(m); ++i)\\n\\t\\tif(!equal(next(begin(m[i])), end(m[i]), begin(m[i-1]))) return false;           \\n\\treturn true;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548404,
                "title": "simple-c-solution",
                "content": "\\'\\'\\'\\nbool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    \\n    int i=0,j=0,l=0,k=0;\\n    int r = matrixSize;\\n    int c = matrixColSize[0];\\n    for(i=0;i<r;i++)\\n    {\\n        for(j=0;j<c;j++)\\n        {\\n            l= i+1;\\n            k = j+1;\\n            while((l<r)&&(k<c))\\n            {\\n                if(matrix[l][k] != matrix[i][j])\\n                {\\n                    return false;\\n                }\\n                k++;\\n                l++;\\n            }\\n        }\\n    }\\n    return true;\\n    \\n\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\nbool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    \\n    int i=0,j=0,l=0,k=0;\\n    int r = matrixSize;\\n    int c = matrixColSize[0];\\n    for(i=0;i<r;i++)\\n    {\\n        for(j=0;j<c;j++)\\n        {\\n            l= i+1;\\n            k = j+1;\\n            while((l<r)&&(k<c))\\n            {\\n                if(matrix[l][k] != matrix[i][j])\\n                {\\n                    return false;\\n                }\\n                k++;\\n                l++;\\n            }\\n        }\\n    }\\n    return true;\\n    \\n\\n}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 371667,
                "title": "my-thoughts-for-the-follow-ups",
                "content": "My thoughts for the follow-ups. And welcome for discussion.\\n\\n# Follow1:\\nwe can read the data in diagnal order.\\n\\nWe can read half first row and half second row.  Then we delete half first row in the memory and keep the second row and read half third row. so on and so for.\\n\\n# Follow2:\\nRead a part of the matrix and compare from right to left(except the top right and the bottom left). as the compare going, we can delete 2 and then read 2 more elements.\\n\\nAlso the approach 1 in solution is applicable for follow-ups 2.\\n\\nSome people propose to hash and compare every 2 rows. I think is applicable too if each row is really large.\\n\\n\\n## Also following is my python solution.\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        r=len(matrix)\\n        c=len(matrix[0])\\n        if (r==1 or c==1):\\n            return True\\n        for i in range(r-1):\\n            for j in range(c-1):\\n                if (matrix[i][j]!=matrix[i+1][j+1]):\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        r=len(matrix)\\n        c=len(matrix[0])\\n        if (r==1 or c==1):\\n            return True\\n        for i in range(r-1):\\n            for j in range(c-1):\\n                if (matrix[i][j]!=matrix[i+1][j+1]):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293640,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t# if you notice carefully we see that in the subsequent rows the all elements are same as the previous row except one.\\n\\t\\t# Leveraging this observation we can ignore the first elem of each row and just compare the rest elem in the previous row( starting from first)\\n\\t\\t # eg: 1 2 3 4 -> first row\\n\\t     #     5 1 2 3 -> second row\\n\\t     # So we compare firstrow first elem to second row second elem, first row second elem to second row third elem and so on.\\n  \\n        temp = matrix[0]\\n        for index in range(1, len(matrix)):\\n            currRow = matrix[index]\\n            for i in range(1,len(currRow)):\\n                if currRow[i] != temp[i-1]:\\n                    return False\\n            temp = currRow\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isToeplitzMatrix(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t# if you notice carefully we see that in the subsequent rows the all elements are same as the previous row except one.\\n\\t\\t# Leveraging this observation we can ignore the first elem of each row and just compare the rest elem in the previous row( starting from first)\\n\\t\\t # eg: 1 2 3 4 -> first row\\n\\t     #     5 1 2 3 -> second row\\n\\t     # So we compare firstrow first elem to second row second elem, first row second elem to second row third elem and so on.\\n  \\n        temp = matrix[0]\\n        for index in range(1, len(matrix)):\\n            currRow = matrix[index]\\n            for i in range(1,len(currRow)):\\n                if currRow[i] != temp[i-1]:\\n                    return False\\n            temp = currRow\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292695,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\n \\n        for(int i=0;i<matrix.size()-1;i++)\\n        {\\n           for(int j=0;j<matrix[0].size()-1;j++)\\n           {\\n           if(matrix[i][j]!=matrix[i+1][j+1]) return false;//Only compare with 1 next element\\n           }      \\n         }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n\\n \\n        for(int i=0;i<matrix.size()-1;i++)\\n        {\\n           for(int j=0;j<matrix[0].size()-1;j++)\\n           {\\n           if(matrix[i][j]!=matrix[i+1][j+1]) return false;//Only compare with 1 next element\\n           }      \\n         }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272773,
                "title": "java-solution-1ms-beats-100",
                "content": "```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[i].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=0;i<matrix.length-1;i++){\\n            for(int j=0;j<matrix[i].length-1;j++){\\n                if(matrix[i][j]!=matrix[i+1][j+1]) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 221903,
                "title": "c-4ms-o-m-n",
                "content": "```\\nbool isToeplitzMatrix(int** matrix, int matrixRowSize, int *matrixColSizes) {\\n    for (int r = 1; r < matrixRowSize; ++r) {\\n        int* a   = matrix[r - 1];\\n        int* b   = matrix[r] + 1;\\n        int  len = (matrixColSizes[r] - 1)*sizeof(int);\\n        \\n        if (memcmp(a, b, len)) return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isToeplitzMatrix(int** matrix, int matrixRowSize, int *matrixColSizes) {\\n    for (int r = 1; r < matrixRowSize; ++r) {\\n        int* a   = matrix[r - 1];\\n        int* b   = matrix[r] + 1;\\n        int  len = (matrixColSizes[r] - 1)*sizeof(int);\\n        \\n        if (memcmp(a, b, len)) return false;\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148264,
                "title": "java-beat-99",
                "content": "\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int height = matrix.length;\\n        int width = matrix[0].length;\\n        for (int i = 1 - height; i < width; i++) {\\n            int x = i > 0 ? i : 0;\\n            int y = i < 0 ? -i : 0;\\n            while (x < width - 1 && y < height - 1) {\\n                if (matrix[y + 1][x + 1] != matrix[y++][x++]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int height = matrix.length;\\n        int width = matrix[0].length;\\n        for (int i = 1 - height; i < width; i++) {\\n            int x = i > 0 ? i : 0;\\n            int y = i < 0 ? -i : 0;\\n            while (x < width - 1 && y < height - 1) {\\n                if (matrix[y + 1][x + 1] != matrix[y++][x++]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 113399,
                "title": "javascript-86ms-accepted-solution",
                "content": "var isToeplitzMatrix = function(matrix) {\\n    \\n     for(x=0;x<matrix.length-1;x++){\\n        for(y=0;y<matrix[x].length-1;y++){\\n            console.log(matrix[x][y], matrix[x+1][y+1])\\n            if(matrix[x][y] != matrix[x+1][y+1])\\n                return false;\\n        }\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "var isToeplitzMatrix = function(matrix) {\\n    \\n     for(x=0;x<matrix.length-1;x++){\\n        for(y=0;y<matrix[x].length-1;y++){\\n            console.log(matrix[x][y], matrix[x+1][y+1])\\n            if(matrix[x][y] != matrix[x+1][y+1])\\n                return false;\\n        }\\n    }\\n    return true;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3997070,
                "title": "c-brute-force-beginner-friendly-o-m-n",
                "content": "\\n**Intuition** \\uD83E\\uDD14\\nThe solution iterates through the matrix, comparing each element with the one diagonally above and to the left. If all such comparisons are equal, the matrix is considered Toeplitz, as it ensures that all diagonals from top-left to bottom-right contain the same elements.\\n\\n**Time Complexity** \\u23F0\\nThe time complexity of the solution is O(m * n), where \\'m\\' is the number of rows and \\'n\\' is the number of columns in the matrix. This is because the code iterates through all elements of the matrix once.\\n\\n**Explaination** \\uD83D\\uDCDD\\n\\nMatrix with diagonal elements:\\n1     2     3     4\\n5     1     2     3\\n9     5     1     2\\n\\nThe diagonal elements are the ones along the diagonal from top-left to bottom-right:\\nDiagonal 1: [1]\\nDiagonal 2: [5, 1]\\nDiagonal 3: [9, 5, 1]\\nDiagonal 4: [2, 2, 2]\\nDiagonal 5: [3, 3]\\nDiagonal 6: [4]\\n\\nIn a Toeplitz matrix, all elements on these diagonals should have the same value. In the given example, all the elements on these diagonals have the same value, so the matrix is Toeplitz.\\n\\n**Code** \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int reference = matrix[0][0]; // Store the value of the top-left element as a reference\\n        \\n        // Iterate through the matrix starting from the second row and second column\\n        for (int i = 1; i < matrix.size(); i++) {\\n            for (int j = 1; j < matrix[0].size(); j++) {\\n                // Check if the current element does not match the element one position diagonally above and to the left\\n                if (matrix[i - 1][j - 1] != matrix[i][j]) {\\n                    return false; // If not, the matrix is not Toeplitz\\n                }\\n            }\\n        }\\n        \\n        return true; // If all diagonal elements match, the matrix is Toeplitz\\n    }\\n};\\n```\\n\\nPlease consider upvoting and leaving any comments or feedback if you found the solution helpful. Thank you! \\uD83D\\uDE0A\\n\\nF1O1R T1H1E S1W1E1E1T1E1S1T P1E1R1S1O1N E1VE1R11R1R! \\u2764\\uFE0F",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int reference = matrix[0][0]; // Store the value of the top-left element as a reference\\n        \\n        // Iterate through the matrix starting from the second row and second column\\n        for (int i = 1; i < matrix.size(); i++) {\\n            for (int j = 1; j < matrix[0].size(); j++) {\\n                // Check if the current element does not match the element one position diagonally above and to the left\\n                if (matrix[i - 1][j - 1] != matrix[i][j]) {\\n                    return false; // If not, the matrix is not Toeplitz\\n                }\\n            }\\n        }\\n        \\n        return true; // If all diagonal elements match, the matrix is Toeplitz\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333113,
                "title": "toeplitz-matrix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int i, j, k, l, n, m;\\n        n = matrix.size();\\n        m = matrix[0].size();\\n        for(i=0 ; i<n-1 ; i++)\\n        {\\n            if(i==0)\\n            {\\n                for(j=0 ; j<(m-1) ; j++)\\n                {\\n                    l=j, k=0;\\n                    while(l<m-1 && k<n-1)\\n                    {\\n                        if(matrix[k][l]!=matrix[k+1][l+1])\\n                        {\\n                            return false;\\n                        }\\n                        l++, k++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                l=0, k=i;\\n                while(l<m-1 && k<n-1)\\n                {\\n                    if(matrix[k][l]!=matrix[k+1][l+1])\\n                    {\\n                        return false;\\n                    }\\n                    l++, k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int i, j, k, l, n, m;\\n        n = matrix.size();\\n        m = matrix[0].size();\\n        for(i=0 ; i<n-1 ; i++)\\n        {\\n            if(i==0)\\n            {\\n                for(j=0 ; j<(m-1) ; j++)\\n                {\\n                    l=j, k=0;\\n                    while(l<m-1 && k<n-1)\\n                    {\\n                        if(matrix[k][l]!=matrix[k+1][l+1])\\n                        {\\n                            return false;\\n                        }\\n                        l++, k++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                l=0, k=i;\\n                while(l<m-1 && k<n-1)\\n                {\\n                    if(matrix[k][l]!=matrix[k+1][l+1])\\n                    {\\n                        return false;\\n                    }\\n                    l++, k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078063,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0; i< matrix.size()-1; i++) {\\n            for(int j=0; j< matrix[i].size()-1; j++) {\\n                    if(matrix[i][j]!= matrix[i+1][j+1]) return false;\\n                \\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        for(int i=0; i< matrix.size()-1; i++) {\\n            for(int j=0; j< matrix[i].size()-1; j++) {\\n                    if(matrix[i][j]!= matrix[i+1][j+1]) return false;\\n                \\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075172,
                "title": "100-faster-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int i = 0; i < m - 1; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                if(matrix[i][j] != matrix[i + 1][j + 1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        for(int i = 0; i < m - 1; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                if(matrix[i][j] != matrix[i + 1][j + 1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887472,
                "title": "97-solution-golang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc isToeplitzMatrix(matrix [][]int) bool {\\n\\tm := len(matrix)-1\\n\\tn := len(matrix[0])-1\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tif fun(matrix,i,0, m, n) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif fun(matrix,0,i, m, n) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn true;\\n}\\nfunc fun(mtx [][]int, x int, y int, m int, n int) bool {\\n\\n\\tnum := mtx[x][y];\\n\\n\\tfor x<m && y<n {\\n\\t\\tx++;\\n\\t\\ty++;\\n\\t\\tif mtx[x][y]!=num {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isToeplitzMatrix(matrix [][]int) bool {\\n\\tm := len(matrix)-1\\n\\tn := len(matrix[0])-1\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tif fun(matrix,i,0, m, n) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif fun(matrix,0,i, m, n) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn true;\\n}\\nfunc fun(mtx [][]int, x int, y int, m int, n int) bool {\\n\\n\\tnum := mtx[x][y];\\n\\n\\tfor x<m && y<n {\\n\\t\\tx++;\\n\\t\\ty++;\\n\\t\\tif mtx[x][y]!=num {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849256,
                "title": "java-code-runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int m = 1; m < matrix.length; m++) {\\n            for(int n = 1; n < matrix[m].length; n++) {\\n                if(matrix[m - 1][n - 1] != matrix[m][n]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int m = 1; m < matrix.length; m++) {\\n            for(int n = 1; n < matrix[m].length; n++) {\\n                if(matrix[m - 1][n - 1] != matrix[m][n]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768160,
                "title": "python-solution-simple-approach",
                "content": "class Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        \\n        for i in range(0, len(matrix)-1):\\n            \\n            for j in range(0, len(matrix[i])-1):\\n                \\n                if matrix[i][j] != matrix[i+1][j+1]:\\n                    return False\\n                \\n                \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        \\n        for i in range(0, len(matrix)-1):\\n            \\n            for j in range(0, len(matrix[i])-1):\\n                \\n                if matrix[i][j] != matrix[i+1][j+1]:\\n                    return False\\n                \\n                \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2767749,
                "title": "easy-c-solution-beginner-18ms-beats-87-19",
                "content": "### Code\\n```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& a) {\\n        int m = a.size(),n = a[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(a[i+1][j+1]!=a[i][j])\\n                    return false;\\n        return true;\\n    }\\n};\\n```\\n\\n### Complexity\\n* Time Complexity: $$O(m*n)$$\\n* Space Complexity: $$O(1)$$",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& a) {\\n        int m = a.size(),n = a[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(a[i+1][j+1]!=a[i][j])\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766175,
                "title": "just-record-an-interesting-solution-here-by-python",
                "content": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        # Corner case\\n        if not matrix or len(matrix) == 0 or len(matrix[0]) == 0:\\n            return True\\n        rows, cols = len(matrix), len(matrix[0])\\n        return self.isleftDiagonal(matrix, rows, cols, 0, 0) and self.isrightDiagonal(matrix, rows, cols, 0, 0)\\n    \\n    def isleftDiagonal(self, matrix, rows, cols, i, j) -> bool:\\n        # Base case\\n        if i == rows or j == cols:\\n            return True\\n        # Recursion Rule\\n        value = matrix[i][j]\\n        m, n = i, j\\n        while i < rows and j < cols:\\n            if value != matrix[i][j]:\\n                return False\\n            i += 1\\n            j += 1\\n        return self.isleftDiagonal(matrix, rows, cols, m + 1, n)\\n    \\n    def isrightDiagonal(self, matrix, rows, cols, i, j) -> bool:\\n        # Base case\\n        if i == rows or j == cols:\\n            return True\\n        # Recursion Rule\\n        value = matrix[i][j]\\n        m, n = i, j\\n        while i < rows and j < cols:\\n            if value != matrix[i][j]:\\n                return False\\n            i += 1\\n            j += 1\\n        return self.isrightDiagonal(matrix, rows, cols, m, n + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        # Corner case\\n        if not matrix or len(matrix) == 0 or len(matrix[0]) == 0:\\n            return True\\n        rows, cols = len(matrix), len(matrix[0])\\n        return self.isleftDiagonal(matrix, rows, cols, 0, 0) and self.isrightDiagonal(matrix, rows, cols, 0, 0)\\n    \\n    def isleftDiagonal(self, matrix, rows, cols, i, j) -> bool:\\n        # Base case\\n        if i == rows or j == cols:\\n            return True\\n        # Recursion Rule\\n        value = matrix[i][j]\\n        m, n = i, j\\n        while i < rows and j < cols:\\n            if value != matrix[i][j]:\\n                return False\\n            i += 1\\n            j += 1\\n        return self.isleftDiagonal(matrix, rows, cols, m + 1, n)\\n    \\n    def isrightDiagonal(self, matrix, rows, cols, i, j) -> bool:\\n        # Base case\\n        if i == rows or j == cols:\\n            return True\\n        # Recursion Rule\\n        value = matrix[i][j]\\n        m, n = i, j\\n        while i < rows and j < cols:\\n            if value != matrix[i][j]:\\n                return False\\n            i += 1\\n            j += 1\\n        return self.isrightDiagonal(matrix, rows, cols, m, n + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764852,
                "title": "easy-python-solution-with-1-for-loop",
                "content": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(len(matrix)-1): # Loop Through All Rows\\n\\t\\t# Check if shifting correct\\n            if matrix[i][:-1]==matrix[i+1][1:]: \\n                continue\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for i in range(len(matrix)-1): # Loop Through All Rows\\n\\t\\t# Check if shifting correct\\n            if matrix[i][:-1]==matrix[i+1][1:]: \\n                continue\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764794,
                "title": "c-solution-2-lines",
                "content": "![image](https://assets.leetcode.com/users/images/f4fad1f0-b4aa-40e1-8fb9-254d1bd3e62c_1667255920.5168514.png)\\n\\n```\\nbool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    if (*matrixColSize > 1) for (int i = 1, width = *matrixColSize - 1; i < matrixSize; ++i) if (memcmp(matrix[i - 1], matrix[i] + 1, sizeof(int) * width)) return false;\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){\\n    if (*matrixColSize > 1) for (int i = 1, width = *matrixColSize - 1; i < matrixSize; ++i) if (memcmp(matrix[i - 1], matrix[i] + 1, sizeof(int) * width)) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764363,
                "title": "c-easy-solution-clean-and-concise-code-matrix",
                "content": "Check whether each value is equal to the value of it\\'s top-left neighbour;\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "Check whether each value is equal to the value of it\\'s top-left neighbour;\\n```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        for(int i = 1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(matrix[i][j] != matrix[i-1][j-1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2764258,
                "title": "python-solution-by-comparing-top-left-neighbour",
                "content": "* Here we are comparing the elements in the matrix with it\\'s top left neighbour\\n* If all the values are equal to it\\'s top left neighbour we can say that the given matrix is Toeplitz Matrix\\n* Here the time complexity would be O(M\\\\*N)\\n* Space complexity would be O(1) \\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for row in range(1,len(matrix)):\\n            for col in range(1,len(matrix[0])):\\n                top_left=matrix[row-1][col-1]\\n                if top_left!=matrix[row][col]:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        for row in range(1,len(matrix)):\\n            for col in range(1,len(matrix[0])):\\n                top_left=matrix[row-1][col-1]\\n                if top_left!=matrix[row][col]:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764052,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n\\t\\t\\tfor i in range (1,len(matrix)):\\n\\t\\t\\t\\tfor j in range (1,len(matrix[0])):\\n\\t\\t\\t\\t\\tif matrix[i][j]!=matrix[i-1][j-1]:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn 1\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n\\t\\t\\tfor i in range (1,len(matrix)):\\n\\t\\t\\t\\tfor j in range (1,len(matrix[0])):\\n\\t\\t\\t\\t\\tif matrix[i][j]!=matrix[i-1][j-1]:\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2763843,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ret= {}\\n\\n        for i in range(m):\\n            for j in range(n):\\n                a = i-j\\n                b = ret.get(a,matrix[i][j])\\n                if b!= matrix[i][j]:\\n                    return False\\n                ret[a] = matrix[i][j]\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        ret= {}\\n\\n        for i in range(m):\\n            for j in range(n):\\n                a = i-j\\n                b = ret.get(a,matrix[i][j])\\n                if b!= matrix[i][j]:\\n                    return False\\n                ret[a] = matrix[i][j]\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763748,
                "title": "toeplitz-simplest-code-cpp-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(a[i][j]!=a[i+1][j+1])\\n                    return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& a) {\\n        int m=a.size(),n=a[0].size();\\n        for(int i=0;i<m-1;i++)\\n            for(int j=0;j<n-1;j++)\\n                if(a[i][j]!=a[i+1][j+1])\\n                    return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763673,
                "title": "java-solution",
                "content": "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++)\\n           for(int j=1;j<matrix[0].length;j++)\\n             if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n                   return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++)\\n           for(int j=1;j<matrix[0].length;j++)\\n             if(matrix[i-1][j-1]!=matrix[i][j]) return false;\\n                   return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2763661,
                "title": "if-memory-is-too-large-to-put-one-row-at-a-time-c",
                "content": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix[0].size();i++){\\n            row[i]= matrix[0][i];\\n        }\\n        int j=1;\\n        while(j<matrix.size()){\\n            int ck;\\n            for(int i=0;i<matrix[0].size();i++){\\n                if(i==0){\\n                    ck= row[i];\\n                   row[i]= matrix[j][i];\\n                }\\n                else{\\n                    if(ck!=matrix[j][i]) return false;\\n                    ck= row[i];\\n                    row[i]= matrix[j][i];\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        \\n        vector<int> row(matrix[0].size());\\n        for(int i=0;i<matrix[0].size();i++){\\n            row[i]= matrix[0][i];\\n        }\\n        int j=1;\\n        while(j<matrix.size()){\\n            int ck;\\n            for(int i=0;i<matrix[0].size();i++){\\n                if(i==0){\\n                    ck= row[i];\\n                   row[i]= matrix[j][i];\\n                }\\n                else{\\n                    if(ck!=matrix[j][i]) return false;\\n                    ck= row[i];\\n                    row[i]= matrix[j][i];\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2763628,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "# Simple Solution: \\n\\n```\\nclass Solution {\\n    func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\\n        \\n        for i in 0..<matrix.count{\\n            for j in 0..<matrix[i].count{\\n                if i > 0 && j > 0 && matrix[i][j] != matrix[i-1][j-1]{\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func isToeplitzMatrix(_ matrix: [[Int]]) -> Bool {\\n        \\n        for i in 0..<matrix.count{\\n            for j in 0..<matrix[i].count{\\n                if i > 0 && j > 0 && matrix[i][j] != matrix[i-1][j-1]{\\n                    return false\\n                }\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763413,
                "title": "simplest-python-solution-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        for i in range(col):\\n            first = matrix[0][i]\\n            j = i \\n            r = 0\\n            while j<col and r<row:\\n                if first != matrix[r][j]:\\n                    return False\\n                j += 1\\n                r += 1\\n        \\n        for i in range(1,row):\\n            first = matrix[i][0]\\n            j = 0 \\n            r = i\\n            while j<col and r<row:\\n                if first != matrix[r][j]:\\n                    return False\\n                j += 1\\n                r += 1\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        for i in range(col):\\n            first = matrix[0][i]\\n            j = i \\n            r = 0\\n            while j<col and r<row:\\n                if first != matrix[r][j]:\\n                    return False\\n                j += 1\\n                r += 1\\n        \\n        for i in range(1,row):\\n            first = matrix[i][0]\\n            j = 0 \\n            r = i\\n            while j<col and r<row:\\n                if first != matrix[r][j]:\\n                    return False\\n                j += 1\\n                r += 1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763362,
                "title": "c-simple-matric-traverse",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int temp =matrix[0][0];\\n         for(int i=1;i<matrix.size();i++){\\n             for(int j=1;j<matrix[0].size();j++){\\n             if(matrix[i-1][j-1]!=matrix[i][j])\\n                 return false;\\n             }\\n         }\\n        return true;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int temp =matrix[0][0];\\n         for(int i=1;i<matrix.size();i++){\\n             for(int j=1;j<matrix[0].size();j++){\\n             if(matrix[i-1][j-1]!=matrix[i][j])\\n                 return false;\\n             }\\n         }\\n        return true;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763317,
                "title": "simple-c-traversal-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int head = 0;\\n        int i = 0;\\n        for(int j = col - 1; j >= 0; j--){\\n            head = matrix[i][j];\\n            int k = j + 1;\\n            int z = i + 1;\\n            while((k < col) && (z < row)){\\n                if(matrix[z][k] == head){\\n                    k++;\\n                    z++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        int j = 0;\\n        for(int n = 1; n < row; n++){\\n            head = matrix[n][j];\\n            int k = j + 1;\\n            int z = n + 1;\\n            while((z < row) && (k < col)){\\n                if(matrix[z][k] == head){\\n                    k++;\\n                    z++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        int head = 0;\\n        int i = 0;\\n        for(int j = col - 1; j >= 0; j--){\\n            head = matrix[i][j];\\n            int k = j + 1;\\n            int z = i + 1;\\n            while((k < col) && (z < row)){\\n                if(matrix[z][k] == head){\\n                    k++;\\n                    z++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2763297,
                "title": "java-1-ms",
                "content": "class Solution {\\n\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=1;j<matrix[0].length;j++){\\n                if(matrix[i][j]!=matrix[i-1][j-1])return false;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564884,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1574813,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1569179,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1572121,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1802828,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1572007,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 2068407,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 2028068,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1855551,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1784907,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1564884,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1574813,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1569179,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1572121,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1802828,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1572007,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 2068407,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 2028068,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1855551,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            },
            {
                "id": 1784907,
                "content": [
                    {
                        "username": "parmenio",
                        "content": "No online judge for the follow-up questions so let\\'s discuss:\\n`1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?`\\nCompare half of 1 row with half of the next/previous row.\\n`2. What if the matrix is so large that you can only load up a partial row into the memory at once?`\\nHash 2 rows (so only 1 element needs to be loaded at a time) and compare the results, excluding the appropriate beginning or ending element.\\n\\nOther ideas?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "what do you mean by hashing here ? loading two diagonal elements can be done I guess "
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tfor i in range(len(matrix) - 1):\\n\\t\\tfor j in range(len(matrix[0]) - 1):\\n\\t\\t\\tif matrix[i][j] != matrix[i + 1][j + 1]:\\n\\t\\t\\t\\treturn False\\n\\treturn True"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "we have the same solution but the case\\uFF1AWrong Answer\\n346 / 483 testcases passed\\nEditorial\\nInput\\nmatrix =\\n[[11,74,0,93],[40,11,74,7]]\\nwhy\\uFF1F\\nthis is my code\\uFF1A\\nclass Solution {\\n    public boolean isToeplitzMatrix(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        if(m ==1 || n ==1){\\n            return true;\\n        }else{\\n            for(int col = 0; col < m-1; col++){\\n                for(int row = 0; row < n-1; row++){\\n                if(matrix[col][row] == matrix[col+1][row+1]){\\n                    return true;\\n                }\\n                 break;\\n                }\\n               \\n            }\\n          return false;\\n            }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "sparkchu777",
                        "content": "use[i-1][j-1] instead plus 1."
                    },
                    {
                        "username": "iamanant7",
                        "content": "This will access the memory which is not there, hence segmentation fault will occur."
                    },
                    {
                        "username": "heavenhunter",
                        "content": "I found that some of accepted solutions is actually incorrect, e.g. for one of these tests:\\n\\n`[[1,2,3,4],[5,1,2,3],[9,5,1,6]]`\\nor\\n`[[1,2,3,4],[5,1,2,3],[9,6,1,2]]`\\n\\nOutput from some of the already accepted solutions will be true, while the judge answer is false.\\n\\nMay need to improve the test cases & rejudge again?"
                    },
                    {
                        "username": "ye40",
                        "content": "It seems to you can work out the first follow up with only comparing the row and the next row one by one. \\n\\nBut how to answer the second follow up?"
                    },
                    {
                        "username": "jrcheenu",
                        "content": "For follow up question :\\nFirst 1: read one row, hash all element except last one.\\nRead next row, except first element hash and compare with existing hash. Now create hash with all element except last.\\nFor q 2: may be same approached can be used"
                    },
                    {
                        "username": "heygauri",
                        "content": "hey what did you meant by hashing a row."
                    },
                    {
                        "username": "Patchett",
                        "content": "Let\\'s start a discussion about how you would modify your solution to the follow ups:\\n\\n1. What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\\n2. What if the matrix is so large that you can only load up a partial row into the memory at once?\\n\\nWhat would you guys say in response to these questions?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "All you need to know is if `matrix[i][j] == matrix[i - 1][j - 1]`\\n\\n`Hint`"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone With 100% beats C++ users???????\\n"
                    },
                    {
                        "username": "prashantsengar18101999",
                        "content": "Test case 273 is incorrect.\\nThe matrix given in the test case is 1-D and thus there are no other rows to compare so it should return false unlike the expected output which is true for the test case.\\nMatrix= [[84]]"
                    },
                    {
                        "username": "BigBull_Coder",
                        "content": "The only thing is observe the pattern"
                    }
                ]
            }
        ]
    }
]