[
    {
        "title": "Remove Duplicates from Sorted Array II",
        "question_content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;k&nbsp;elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.",
        "solutions": [
            {
                "id": 27976,
                "title": "3-6-easy-lines-c-java-python-ruby",
                "content": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "solutionTags": [],
                "code": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27987,
                "title": "short-and-simple-java-solution-easy-to-understand",
                "content": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 967951,
                "title": "python-two-pointers-approach-explained",
                "content": "Let us use two pointers approach here: `slow` pointer and `fast` pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more `2` of them, so we start with `slow` and `fast` equal to `2`.\\n\\nThen we iterate through our data and check if `nums[slow - 2] == nums[fast]`: what does it mean? It means, that in fact `nums[slow-2] = ... = nums[fast]` and that we already have group of `3` or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\n**Complexity**: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not `2` duplicates, but `k`: in this case we just need to change all 3 occurences of `2` to `k`.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748592,
                "title": "0ms-100-faster-c-solution-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28067,
                "title": "o-n-time-and-o-1-java-solution-when-allowed-at-most-k-times-of-duplicates",
                "content": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1329356,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748197,
                "title": "java-simple-any-repetitions-explained",
                "content": "**Idea:** 2 pointers\\n* If array length is less than 3, there\\'s nothing to do so exit\\n* Since the array is sorted, all duplicates will be consecutive. So use 2 pointers, one to point at the 3rd or higher occurence of a num, and another one to find the number that can replace the num at the first pointer\\n* Keep doing this until all 3+ repetitions of nums have been overwritten\\n* Example: `[0, 0, 1, 1, 1, 1, 2, 3, 3]`\\n\\n![image](https://assets.leetcode.com/users/images/ba998bdb-4241-469a-85e7-13f5ab60a97e_1644108233.2912471.png)\\n> **T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\nGeneric solution for when k repetitions are allowed\\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374696,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others**Bold**\\n![download.jfif](https://assets.leetcode.com/users/images/e1f75de3-02bf-44d0-bb86-208e5309d274_1680526945.9427269.jpeg)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28004,
                "title": "my-c-solution-16ms-5-lines",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2415500,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\\n\\t\\t\\tSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. At last return k after placing the final result in the first k slots of nums.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 96.73% of Java online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 41.8 MB, less than 87.33% of Java online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 4 ms, faster than 83.16% of C++ online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 7.7 MB, less than 99.73% of C++ online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 24 ms, faster than 74.03% of Python online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n                    \\n# **JavaScript Solution:**\\nRuntime: 88 ms, faster than 76.14% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 43.5 MB, less than 98.04% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347871,
                "title": "6-lines-c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835835,
                "title": "runtime-faster-than-99-39-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921824,
                "title": "simple-easy-100-beats-java-solution",
                "content": "# Intuition\\nIn this solution, we\\'re iterating through the array once. We maintain an index variable that points to the position where the next unique element should be placed. If the current element is not equal to the element at index - 2, it means we haven\\'t encountered this element twice yet, so we can include it in the result array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach works because we\\'re allowed to keep up to two duplicates. If there are more than two duplicates, the elements that are allowed to remain in the array are those that are not equal to the element at index - 2, ensuring that only two duplicates are present.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062386,
                "title": "0-n-easy-to-understand-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n#### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe goal of this function is to remove duplicates from the nums vector while keeping at most two occurrences of any element. The function returns the length of the modified vector after removing duplicates.\\n\\nHere\\'s the approach implemented in the code:\\n\\n- Initialize an integer variable i to 0. This variable will keep track of the current position in the modified nums vector.\\n\\n- Use a for loop to iterate through each element ele in the nums vector using the range-based for loop.\\n\\n- Inside the loop, check the following conditions:\\n\\n---\\n\\n\\n1. i == 0: This condition ensures that the first element is always included in the modified vector.\\n2. i == 1: This condition ensures that the second element is always included in the modified vector.\\n3. nums[i-2] != ele: This condition checks if the current element ele is not the same as the element two positions before the current position i. This ensures that only two occurrences of any element are included in the modified vector.\\n---\\n-  If any of the above conditions are met, copy the current element ele to the nums[i] position in the modified vector, and increment i by 1 to move to the next position.\\n\\n\\n- Repeat this process for all elements in the nums vector.\\n\\n- Finally, return the value of i, which represents the length of the modified vector with duplicates removed.\\n\\nThis approach effectively modifies the nums vector in place, removing duplicates while keeping at most two occurrences of each element. The function returns the length of the modified vector, which can be used to access the unique elements in the first i positions of the vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote.png](https://assets.leetcode.com/users/images/91a084df-cac4-4805-8bbf-78afd5e22977_1695092464.1321526.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750063,
                "title": "python-implementation-using-two-pointers-o-n-time-space-complexity-95-faster",
                "content": "#### **If You Find This Post Helpful Please Upvote**\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529357,
                "title": "java-tc-o-n-sc-o-1-optimized-two-pointers-solution-followup",
                "content": "**In place, one pass solution using 2 pointers**\\n\\n```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n**Follow-Up: Each unique element should appear at most K times**\\n\\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Remove Element questions on LeetCode:\\n- [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/discuss/1529341/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution)\\n- [27. Remove Element + Follow Up](https://leetcode.com/problems/remove-element/discuss/1529351/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025001,
                "title": "accepted-fast-java-code-beats-100-o-n",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968051,
                "title": "remove-duplicates-o-n-time-o-1-space-complexity",
                "content": "Let us use two pointers approach here: ``slow`` pointer and ``fast ``pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more 2 of them, so we start with slow and fast equal to 2.\\n\\nThen we iterate through our data and check if ``nums[slow - 2] == nums[fast]``: what does it mean? It means, that in fact ``nums[slow-2] = ... = nums[fast]`` and that we already have group of `3 `or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\nComplexity: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not 2 duplicates, but k: in this case we just need to change all `3 `occurences of `2` to` k.`\\n```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\\nOne more easy solution that comes to my mind after attempting above solution\\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```\\n**If you have any questions, feel free to ask. If you like solution and explanations, please Upvote!,It inspires me alot.Happy Coding!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755474,
                "title": "super-simple-concise-cute-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\\n\\nOk, I saw some of your solutions are not getting accepted.\\nThe main reason for this is because you are writing it in another language. Such as C or C++. In this language, the storage management is not properly done as they are legacy languages and there is no garbage collection.\\n\\nIf you are using such languages then I will suggest you write the following line the the return statement. \\n\\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```\\nsuggested by @IILuciferII\\n\\nHope it Helps. Thanks!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599075,
                "title": "javascript-pretty-simple",
                "content": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602362,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499165,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\ntake a map<int, int> which stores the count of each element if the count is less than equal to 2 then insert the element in the required position of the array else skip and go to the next element.\\n> Please see the approach - 2 that is more optimized. no extra space is required for this. We can think about sliding window size 2.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\nhere the given array is sorted. we use this consept here => at index **i** the element **nums[i]** is present more than two times in the array is **nums[i] == nums[i-2]**\\n> let assume nums [0,0,1,1,1,1,2,3,3]\\n> We start from index 2\\n> so nums[2] != nums[0] then the element in 2nd index is not more than 2 times. so we can add nums[2]\\n> but for index 4\\n> nums[4] == nums[2]\\n> sowe can not add the element nums[4]\\n\\nplease dry run the solution for better understanding\\n\\n**One edge case is if the size of nums is less than 2 then simple return the size**\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28114,
                "title": "simple-java-solution-with-explanation",
                "content": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "codeTag": "Unknown"
            },
            {
                "id": 3741215,
                "title": "simple-two-pointer-approach-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf an element has appeared twice already in the array, we ignore the extra appearances of the element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote: assuming 0-based index; extra appearance = additional to 2 appearances\\n1. if the size(nums) <= 2, then there is no chance that an element would have appeared more than twice, so then we can return the size\\n2. we form the resultant array in-place by overriding the extra appearances of elements.\\n3. we have two variable to track indices: $$i$$ for iterating over elements of given array, $$rIndex$$ to track our resultant array.\\n4. we initiate $$rIndex$$ = 1 and start $$i$$ from 2. why? have look at (1.)\\n5. we iterate $$i$$ from 2 to (n - 1)\\n    a) if nums[$$i$$] same as nums[$$rIndex$$] and nums[$$rIndex$$ - 1], then ignore and continue to next iteration. why? the current element has made it\\'s 2 appearances already.\\n    b) else, the current element can be included in the resultant array. so, increment $$rIndex$$ and assign nums[$$rIndex$$] with nums[$$i$$].\\n6. return $$rIndex$$ + 1. why? we return the size, not the last index value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749637,
                "title": "c-with-easy-explanation",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Count of any element shoud not be greater than 2 within the limit or return variable.\\n#### \\u2714\\uFE0F **Solution - I (My Best Approach)**\\n##### **Intuition :-**\\n* Take a variable `prev` and point it with element at 0th index of `vector nums`.\\n* Take a variable count and initialize it with 1 as we are already escaping the 0th index.\\n* Take a variable pos in which we will insert any new element which is not equal to prev and update prev with new and increment the pos and count at same time.\\n* Go through the code for better understanding\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\\nJust have a question would you like a solution that is concise like the above where it will give the correct result but for dry run purposes, you have to make changes like putting brackets or the solution which I am pasting below. Let me know in the comments because I think brackets play a major role when we want to see the dry run of every iteration what changes are going to be done by the code using the print statement.\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity** : `O(N)`, traverse is done only for once.\\n**Space Complexity** : `O(1)`, No extra space is used.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28128,
                "title": "python-9-lines-2-extra-variables-76ms-any-simpler-solution-else",
                "content": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "solutionTags": [
                    "Python"
                ],
                "code": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "codeTag": "Python3"
            },
            {
                "id": 632374,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27967,
                "title": "clean-python-solution",
                "content": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "codeTag": "Java"
            },
            {
                "id": 28120,
                "title": "c-code-quite-standard",
                "content": "You only need to change K to allow K repetitions.\\nOne common mistake one can make is \" if(nums[i] != nums[i-K])\" : it is wrong since nums[i-k] can be overwritten in a previous iteration.\\n\\n    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }\\n            return last;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4006464,
                "title": "simple-beats-100",
                "content": "\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506920,
                "title": "java-solution-for-remove-duplicates-from-sorted-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code removes duplicates from the sorted array \"nums\" and keeps at most two occurrences of each unique element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the length of the array \"nums\" is less than or equal to 2. If true, return the length as there are no duplicates to remove.\\n- Initialize two pointers: \"prev\" points to the position where the next unique element will be placed, and \"curr\" points to the current element being checked.\\n- Iterate through the array starting from the third element (index 2) until the end.\\n- Check if the current element \"nums[curr]\" is equal to the previous two elements \"nums[prev]\" and \"nums[prev - 1]\". If true, it means there are more than two occurrences of this element, so increment \"curr\" to skip it.\\n- If the current element is not a duplicate, move the \"prev\" pointer forward, update \"nums[prev]\" with the current element, and increment both \"prev\" and \"curr\".\\n- Repeat steps 4 and 5 until all elements have been checked.\\n- Return \"prev + 1\" as the new length of the modified array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) since it iterates through the array once, where n is the length of the input array \"nums\".\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the algorithm modifies the input array in-place without using any additional data structures, regardless of the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918873,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654614,
                "title": "super-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740702,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600043,
                "title": "0ms-beats-most-intuitive-java-solution",
                "content": "# Intuition and Approach\\nHey Folks\\uD83D\\uDC4B\\uD83C\\uDFFC,\\nI am back with another **AMAZING** solution to a pretty complex problem (that you might think at this point) but let me give you a little spoiler\\uD83D\\uDE02 I will take the solution of an easy problem and add 3 lines of code (one extra condition) and it will solve this problem.\\n\\nAs always , To solve this problem there is a pre-requisite.\\nYou must first solve/try this problem\\uD83D\\uDC47\\uD83C\\uDFFC\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\\n\\nNow, Assuming that you have solved or at least read the problem description, the question basically asks to group the unique elements in the starting part of the array (in-place) and return the count of unique elements.\\n\\nLogic is a simple Two-pointer Approach\\n\\n**Step 1:** we keep a pointer named $$lastUnique$$ pointing to the last unique element that we processed and another pointer $$current$$ pointing to the current element we are standing at.$$lastUnique$$ will start from 0 as first element is always unique.\\n\\n**Step2:** At each $$current$$, check two conditions\\n- If $$current$$ element is equal to the lastUnique element then we can ignore the $$current$$ element.\\n\\n- Otherwise, swap the $$current$$ element with $$lastUnique + 1$$ index and move $$lastUnique$$ one step ahead. (Now this is my lastUnique element processed)\\n\\n**Step 3:** In the End , return $$lastUnique + 1$$ as we need to return count and $$lastUnique$$ signifies the index.\\n\\nCode(Linked Question):\\n```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\\n\\n\\nNow, Coming back to this problem, if you see carefully this question also asks us to group unique elements in the starting part of array **(problem statement of Linked Question)** but know one extra condition is added that the unique element can appear at most twice.\\n\\nSo , now we simply can\\'t ignore the $$current$$ element if it is equal to $$lastUnique$$, **we need to check if there exists an element to the left of $$lastUnique$$ that is equal to $$current$$ element, if it is then ignore the $$current$$ element (as duplicate already considered) otherwise we need to add the $$current$$ element to $$lastUnique$$. (Read the bold part again to get better clarity)**\\n\\nYou are done. Just copy the code and in place of $$continue$$ add the extra condition check and submit it to beat \\uD83D\\uDCAF%.\\nCongratulations, you have developed a 0ms solution to a complex(not now\\uD83D\\uDE09) problem.\\n\\nI know this solution can be compressed to 5-6 lines of code but \\n**Are those solutions really intuitive..?\\uD83E\\uDD14** **Can you come up with those solutions directly in an interview..?\\uD83E\\uDD14**  Not for an average Coder like me.\\n\\n> **INTUITION COMES FIRST, OPTIMISATIONS COME LATTER**\\n\\n\\uD83D\\uDE4F\\uD83C\\uDFFCPlzz Upvote if you found this solution helpful and interesting\\uD83D\\uDE4F\\uD83C\\uDFFC\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$-> S*ingle Iteration*\\n\\n- Space complexity: $$O(1)$$-> *No extra space used*",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759575,
                "title": "precise-c-two-pointers-o-n-time-o-1-space",
                "content": "# Approach\\nIf the array\\'s length is less than 3, we could safely return the length of the array as any element present in it will either appear once or twice which satisfies the given condition.\\n\\nVariable \\'k\\' stores the length of \\'in-place subarray\\' with unique elements which appears at most twice.\\n\\nWe begin with value of \\'k\\' and \\'i\\' as 2 as the array will have at most twice unique elements till 1.\\nThen we check \\'nums[i]\\' with \\'nums[k-2]\\' i.e current element with second element from length of \\'in-place subarray\\' with unique elements and if they are not equal we store current element at end of in-place subarray\\nand increment k by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n \\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750807,
                "title": "js-really-short-and-simple-solution",
                "content": "**Go through the list backwards and remove the excess numbers**\\n```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28053,
                "title": "share-my-o-n-time-and-o-1-space-short-and-simple-solution-when-duplicates-are-allowed-at-most-k-times",
                "content": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "solutionTags": [],
                "code": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3142015,
                "title": "0-ms-easy-best-solution-brute-force-solution-java",
                "content": "# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n# Code\\n```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n\\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529279,
                "title": "java-o-n-time-100-beats-o-1-space-simple-easy-to-understand-counter",
                "content": "if you like this aproach kindly upvote and comment so that i can share more my solutions and your one upvote will motivate me to post more precise solutions\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749252,
                "title": "two-pointer-approach-in-o-n-time-complexity-with-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we are using ***Two pointer approach.***\\n- We are taking i & j as pointers and count as counter.\\n- if i & j are equal, we\\u2019ll increase count & if count is less then 3 then we\\u2019ll replace j with i. and increase j value.\\n- else we\\u2019ll store next i value to j & make count 1, then increase j.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28051,
                "title": "easy-to-understand-java-solution",
                "content": "Save count for distinct numbers. \\nIf the count is less than 3 we can keep it.\\n\\n\\n----------\\n\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n                if(cnt<3){\\n                    nums[len++] = nums[i];\\n                }\\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27974,
                "title": "c-simple-ac-solution-in-10-lines-21ms",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }\\n            }\\n            return rear+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3958748,
                "title": "simple-python-3-solution-beats-98-7",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183342,
                "title": "80-remove-duplicates-from-sorted-array-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize a variable i to 0.\\n- Loop through each n in nums.\\n- Check if i is less than 2 or n is greater than the nums[i-2].\\n  - If the condition is true, assign n to nums[i] and increment i by 1.\\n- Return i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542066,
                "title": "faster-than-98-66-memory-usage-less-than-100",
                "content": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192080,
                "title": "2-pointers-simplest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749406,
                "title": "short-and-simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230086,
                "title": "java-100-o-1-space-5-lines-of-code-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28175,
                "title": "o-n-in-place-solution",
                "content": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3896472,
                "title": "c-easy-shortest-solution",
                "content": "Just check if the i+2 th element is same or not, if not then use the second pointer to fill the array.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3589635,
                "title": "js-ts-2-simple-solutions-100-explained-and-commented",
                "content": "# Solution #1\\nWorks for at most any number if we change the comparison value in the if block.\\n## Approach\\n- Check if the input array `nums` is empty. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop. For each element:\\n    - Check if we have not yet seen this element (i.e., if `k` is less than `2`), or if the current element is greater than the second-to-last unique element (i.e., `nums[i] > nums[k-2]`). If either of these conditions is `true`, then we have a new unique element.\\n- Assign the current element to the new position indicated by `k` in the array `nums`.\\n- Increment `k` to move the pointer to the next position.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k` as the function output.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\\n\\n# Solution #2\\nWorks only for at most twice\\n## Approach\\n- Check if the input array `nums` is `empty`. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop, starting at index `1` (since the first element is always unique).\\n    - Check if the current element is not equal to the previous unique element (i.e., `nums[i] !== nums[k]`), or if the current element is equal to the previous unique element but the previous two elements are not equal (i.e., `nums[i] === nums[k] && nums[k] !== nums[k - 1`]). If either of these conditions is `true`, then we have a new unique element.\\n    - Increment `k` to move the pointer to the next position.\\n    - Assign the current element to the new position indicated by `k` in the array `nums`.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k + 1` as the function output, since `k` is a zero-based index and we need to add `1` to get the number of unique elements.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141821,
                "title": "0ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420762,
                "title": "3-simple-steps-to-solve-same-types-without-if-else",
                "content": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "codeTag": "Unknown"
            },
            {
                "id": 1752202,
                "title": "python-2-solutions-naive-and-efficient-explained",
                "content": "## The naive approach is using the inbuilt count() method in python, and removing (count-2) instances of the element.\\n## For example the array nums = [1,1,1,1,2,2,2,3,3], it will delete (count of 1 - 2) 1\\'s, that is 4-2 = 2 ones, and so on.\\n## count() method in python returns the frequency of the element, if the frequency is less than 2 skip one place and go ahead if it\\'s more than 2, delete (count-2) elements and then skip 2 places.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```\\n# Efficient 2-pointer approach\\n## This approach has a start and an end pointer which is 2 indices ahead of start, everytime nums[end] == nums[start], it deleted nums[end]. Once 1st element is done, start shifts to end, and end shifts to start+2.\\n\\n```def  removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if length < 2:\\n            return length\\n        start = 0\\n        end = start + 2\\n\\n        while(end <= length-1):\\n            if nums[start+1] == nums[start]:\\n                if nums[end] > nums[start]:\\n                    start = end\\n                    end += 2\\n                else:\\n                    nums.pop(end)\\n                    length -= 1\\n            else:\\n                start += 1\\n                end += 1\\n        \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1750032,
                "title": "java-3ms-solution-leetcode-dc",
                "content": "**please upvote if you like my solution**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749976,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749376,
                "title": "c-simple-and-easy-solution-using-two-pointers-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271806,
                "title": "c-using-unordered-map",
                "content": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 377132,
                "title": "python-solution-upvote-if-you-understood",
                "content": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "codeTag": "Python3"
            },
            {
                "id": 3720279,
                "title": "best-solution-c-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585412,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347800,
                "title": "java-100-faster-two-pointer-method-in-java-simplify-your-code-and-save-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c1be1504-3486-4267-a051-24173837f10d_1679924192.437104.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137326,
                "title": "python3-o-n-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```\\n# **Please upvote guys if you find the solution helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114911,
                "title": "js-ts-easy-solution",
                "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513788,
                "title": "go-o-n",
                "content": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732669,
                "title": "c-easy-to-understand-3-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\\n**Without any extra space and linear time complexity**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193869,
                "title": "c-easy-code",
                "content": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "solutionTags": [],
                "code": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980297,
                "title": "simplest-python-4-lines-solution",
                "content": "* Iterating over the array from last index (i.e. using  for loop reversely ) to eliminate range errors.\\n* Deleting the number that is repeating.\\n\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208796,
                "title": "python-solution",
                "content": "We use the two pointer approach as in 26. Remove Duplicates from Sorted Array, except that we will use an extra `flag` variable to indicate the number of duplicates of `nums[j]` in `nums[:i+1]`. If `flag = False`, then there are `0` or `1` duplicate of `nums[j]` in `nums[:i+1]`, and we should increment `i`, and swap `nums[i]` and `nums[j]`; Else if `flag = True`, there are `2` or more duplicates of `nums[j]` in `nums[:i+1]`, and we should do nothing and continue with the next iteration of `j`. The loop invariant is that `nums[:i+1]` is always the sorted array `nums[:j+1]` with duplicates appear at most twice. Hence when `j` reaches `len(nums)-1`, `nums[:i+1]` is `nums` with duplicates appear at most twice.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28072,
                "title": "share-my-o-n-time-and-o-1-space-solution-with-duplicates-are-allowed-at-most-n-times",
                "content": "    public class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }\\n        int dif = 2;\\n        for(int i=2;i<nums.length;i++){\\n            if(nums[i]!=nums[dif-2]){\\n                nums[dif++]=nums[i];\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n\\n\\nif N duplicates are allowed,you just need to change the nums[dif-2] to nums[dif-N] ,welcome to discuss with me .",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4045552,
                "title": "javascript-easy-and-very-understandable-2-pointers-solution",
                "content": "# Intuition / Approach\\nSince the nums array is already sorted, its actually really easy to see when we have more than 2 duplicates of any given integer. Sounds very simple and stupid, but if you look at 3 numbers at once and you see that they are all the same integer, then we have an obvious extra duplicate. We could drop the right element, and keep incrementing r. As we increment r, if the element reoccurs, then we keep dropping them. However, if we see that our r pointer element breaks from our element at l and mid, then we know that there are no more extra duplicates, and we can start checking the next batch of 3 elements from the first occurance of an integer we havent seen yet (which is at pointer r). Here is where we will fix our pointers, where l = r, mid = l+1, and r = mid+1. And the check from above starts again. In any other situation, we can just move all our pointers by 1 and keep checking the same conditions we listed above.\\n\\nSince I decided to use a placeholder (\"_\") in places where I dropped the integer, for the test cases to pass given the criteria, I need to move all the place holders to the right. \\n\\nI know that I did a lot of extra work with the placeholders and 2nd loop to move the \"_\" to the right, but I wanted to solve this problem clearly as possible and where anyone can see what is happening at any given moment, so I thought that this was the most simplest solution to understand.\\n\\nHope this helps! I thought it was kind of confusing first, but once you realize how the array being sorted works in your favor, its really easy to do. \\n\\n# Complexity\\n- Time complexity:\\n    - First while loop iterates through nums once using 3 pointers. Since the loop passes through the array once-> O(N);\\n    - Second while loop iterates through nums once using 2 pointers. Since the loop passes through the array once -> O(N);\\n    - O(N + N) => O(2N) => (Constants are dropped) O(N); \\n\\n- Space complexity:\\n    - Constant number of extra variables used (k, l, mid, r, i, j)\\n    - No additional data structures used to store inputs with respect to the input size\\n    -  O(1); \\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907328,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointers\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878331,
                "title": "o-n-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompared to \"Remove Elementes From A Sorted Array I\": The key differences are the \">\" symbol and l- 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPlaceholder \\'l\\' stops at the 3rd repeated value while \\'i\\' continues and looks for then next different value. The \">\" symbol prevents cases where 2 == 2 would be true and allows \\'i\\' to continue.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861369,
                "title": "3-line-easy-to-understand-code-beats-86-in-runtime-99-31-in-memory-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859756,
                "title": "simple-2-pointers-solution-speed-94-67-memory-86-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738535,
                "title": "two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717239,
                "title": "the-solution-from-beginner-perspective-easy-to-understand",
                "content": "# Intuition\\nMy program is checking from the first element of the array then it goes one by one until the the 3rd from last element. \\n\\n# Approach\\nif  nums[i]  equals to  nums[i+2]  the program just continue because it means there is more than 2 of this element so we are not going to take it this one.\\nif it\\'s not equal it means this element less than 3 so we take it to our nums array like nums[index] = nums[i] index starting from zero when we arrived to last 3rd element of array we checked last time if it equals to last elemnet of the array we didnt take it but it\\'s not we take this one too. Then we automatically take it last two element of array to our nums array because we checked the last 3rd element then the last 2 elemen either equol or diffrent these two sitsituation is okey for the question.\\n\\nFeetback : I\\'am a beginner for java maybe this code slow which is not i checked :) or maybe it is not suitable for code standards but i think it easy to understand. if you understand that code you can make me understand by upvote my solutions.\\nthanks in advance\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585488,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541541,
                "title": "c-time-o-n-memory-o-1-10-line-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433964,
                "title": "easiest-handwritten-approach-with-dry-run-check-it-out",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/bf2875ee-778b-4ce2-9e02-c140706a3949_1681889805.5851915.png)\\n![image.png](https://assets.leetcode.com/users/images/bea318f3-e9ef-42f2-af88-36157512e861_1681889822.9460862.png)\\n![image.png](https://assets.leetcode.com/users/images/17b032ff-d978-4d80-83a2-4d26c2262a56_1681889851.0495398.png)\\n![image.png](https://assets.leetcode.com/users/images/a19c445f-d6f8-46d0-a039-de5617ef44bd_1681889868.721397.png)\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115163,
                "title": "easy-c-uniform-coding-style-that-works-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that go through all the elements, along with that check if the current element has been included previously or not if included skip it, else add it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep two pointers:\\nWhile moving left will store the position to store the newly found element. At the end it will containt the number of unique elements.\\nRight(r) will move forward till the end of the given array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\nFor [26. Remove Duplicates from Sorted Array\\n](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) Allowed to keep only one instance\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\\n\\nFor [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)   \\nAllowed to keep atmost two instances\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472886,
                "title": "python-elegant-short-99-6-faster-two-variables-one-pass-o-1-memory",
                "content": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1758413,
                "title": "simple-solution-in-python-with-clean-code",
                "content": "\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749926,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "\\n\\nHere, we will keep tab on the current element in the variable \\'now\\'. And we are keeping a counter to count the number of elements with the value \\'now\\'.\\n\\nIf the count becomes more than 2, we will remove that element from the list. \\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749815,
                "title": "python-naive-efficient-approach",
                "content": "Naive approach:\\n\\n- store the count of each number appearing.\\n- if count is greater than 2 then pop and append it to the last of the list \\n- increase the k count by 1 and return length of nums - k as the answer\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\\n\\nEfficient Approach:\\n\\n- As the array is already sorted we know can track the count of each number by going to next second element to it.\\n- And replace it whenever there is count > 2 and increase k value for both appending and traversal.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749743,
                "title": "python3-simple-and-easy-faster-90",
                "content": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749068,
                "title": "easy-to-understand-c-solution-in-linear-time-and-constant-space",
                "content": "Use two pointers i and j, i => to iterate through the array, j => to maintain writing pos for the next element.\\nWhile iterating through the array, keep count of elements having same value as current:\\n-if you encounter same element  and count is less than 2, then store the element in the next position\\n-else if you encounter a different element, then reset the count to 1 and store that element in the next position.\\nreturn j\\n\\nTC: O(n)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708962,
                "title": "java-remove-duplicates-o-n-two-pointer-solution",
                "content": "For reference, a solution from which I will build up on:\\n\\n**Remove Duplicates From Sorted Array**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nSince now two duplicates are allowed, I introduce a boolean flag to indicate duplicates occurring.\\n\\n**Remove Duplicates From Sorted Array II**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nTo see why both 1 and 2 cases should overwrite, consider the example `[0,0,1,1,1,1,2,3,3]`.\\nFor case 2, it is clear that the array index at res should be overwritten: a new unduplicated number has been introduced.\\nFor case 1, without the array index at res overwritten the solution would return `[0,0,1,1,2,3,2,_,_]` not `[0,0,1,1,2,3,3,_,_]`.\\nTo see why, note that at index `i == 8` index `res == 5`. We see a smaller number 2 after the 3 that overwrote index `res`.\\n\\n\\nThis is indicative of a corner case in which the duplicate of the last overwriting number was not reflected properly.\\nTo reflect this corner case the solution faithfully overwrites value at `res` whenever it finds a new duplicate. In the best case, it just redundantly overwrites the duplicate that occurred right before. In the worst case, it properly overwrites the value right next to the duplicate that occurred somewhere much before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356963,
                "title": "most-optimised-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355654,
                "title": "python-simple-two-pointers-with-explanation",
                "content": "`cur_idx` is the current index at which we\\'ll place `nums[i]`\\n\\n`count` is the current count of consecutive elements\\n\\nWe increment `count` if `i` isn\\'t the last index of the array and the next element of the array is equal to the current element of the array. Then, we swap the elements at `i` and `cur_idx`. \\n\\nWe only increment `cur_idx` if the count of duplicate elements is two or less because if the current count is greater than that, we only want to write that element at most two times.\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 744616,
                "title": "nice-and-easy-c-solution-using-two-pointers",
                "content": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "solutionTags": [],
                "code": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "codeTag": "Unknown"
            },
            {
                "id": 618939,
                "title": "generic-solution-o-n-time-and-o-1-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "\\n[Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\n[Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391499,
                "title": "javascript-solution-56ms",
                "content": "\\n>\\u221A Accepted\\n  \\u221A 166/166 cases passed (56 ms)\\n  \\u221A Your runtime beats 98.23 % of javascript submissions\\n  \\u221A Your memory usage beats 100 % of javascript submissions (35.6 MB)\\n  \\n```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/tiokang/image_1569737680.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 174982,
                "title": "python-solution-100-32ms",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28099,
                "title": "java-1ms-solution",
                "content": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "codeTag": "Unknown"
            },
            {
                "id": 3964930,
                "title": "javascript-typescript-efficient-algorithm",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable j to 2. This will keep track of the index where the next non-duplicate element should be placed.\\n\\n2. Iterate over the array nums starting from index 2 (since the first two elements are allowed to appear twice).\\n\\n   a. For each index i starting from 2 and going up to the length of nums:\\n      i. Check if the current element nums[i] is not equal to the element at index j - 2. This condition ensures that we\\'re only allowing duplicates to appear twice.\\n      ii. If the condition is true, assign the value of nums[i] to the position nums[j] (j being the next available index for a non-duplicate element) and increment j by 1.\\n\\n3. After the loop, the variable j now holds the count of unique elements with duplicates allowed at most twice.\\n\\n4. Return the value of j as the new length of the modified array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n# Code\\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933663,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923393,
                "title": "easiest-solution-using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661984,
                "title": "java-solution-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602270,
                "title": "java-4-codes-actually-2-but-the-3rd-one-is-interesting-xd-4th-one-beats-100-time-and-space",
                "content": "# Method 1: Frequency Array\\n\\n## Intuition\\nSo the first intuition on seeing this problem and its constraints was to solve this using frequency array. But the problem is that there are negative numbers also, so had to think of a way to tackle those. Read below to learn how I solved this.\\n\\n## Approach\\nSo the approach is simple:\\n1. There will be an array `freqp[]` for handling the normal positive numbers.\\n\\n2. There will be an array `freqn[]` for handling the negative numbers.\\n\\n3. Next, start filling the `freqp[]` and `freqn[]` arrays (as mentioned in the code given below).\\n\\n4. Now, building of the `freqp[]` is simple, but for `freqn[]`, since we can\\'t have negative array indices, so I will mark the particular negative number at the index `-1*(negative number)` in the `freqn[]` array.\\n\\n5. Next, I run 2 while loops, each with 2 variables, `i` which is used for traversing the frequency arrays, first `freqn[]` (since negative numbers are smaller than the positive numbers), starting with `i=10000` up to `i=0`, because the greater the magnitude the smaller the negative of it (10000>1 but -10000<-1), and later for `freqp[]`, starting with `i=0` up to `i=10000`. And the other variable is `p`, which is used for filling `nums[]`.\\n\\n6. Now, inside each while loop wherever the frequency is greater than `0`, we first check if the frequency is greater than `2`, if so, then replace it with `2`, and fill next 2 positions of nums using `p`, while decrementing the frequency until it becomes `0`.\\n\\n7. After going through both the while loops, `p` will be last index where any value was manually filled, so it is that `k` which is to be returned.\\n\\n## Complexity\\n- **Time complexity:**\\nTime complexity is `O(n+k)`, where `n` is the size of input array, and `k` is the range of numbers (constraints).\\n\\n- **Space complexity:**\\nSpace complexity is also `O(n+k)`.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/ce865d3d-1256-4f85-8d09-047be9d6908a_1685997186.793973.png)\\n\\n\\n---\\n\\n# Method 2: Two Pointers\\n\\n## Intuition\\nI got intuition on seeing that my previous solution had beaten too less of the available JAVA solutions. So, I started thinking in another way. I knew this could be solved by 2 pointers, but the thing was how?\\n\\n## Approach\\nThe approach to this solution needed testing on edges, but rest was easy to think of:\\n1. Have 3 pointers (indexes), `i`, `j`, and `p`. `i` will be used to determine the number which is currently being repeated. `j` is used to traverse the repeated instances of the number at index `i`. And `p` is used to fill the array `nums[]` (in-place). *Yes if it was not mentioned that the solution had to be in-place, then making another `ans[]` array, we could solve the problem with just `i` and `p`.*\\n\\n2. Figuring out 3 pointers were needed was easy but a bit tricky, but the next part is just easy to think of, however slightly complex to implement.\\n\\n3. So, we initialize `i`, `j`, `p` all to `0`, and have a `cnt` variable to count the number of times any particular value has been repeated (however it stops incrementing once it reaches `2`, so it is more sort of a check variable).\\n\\n4. Now, a while loop runs until `j` reaches the end of the `nums[]` array. In each iteration of the while loop:\\n\\n    1. If the value at index `j` is equal to that of `i`, that means, there is a repetition, and the `cnt` variable is incremented until it reaches `2`.\\n\\n        1. If the cnt variable hasn\\'t reached 2, then nums[p] will be filled with the same value at index `i` and `j`. And `p` is also incremented after each fill.\\n\\n        2. If the `cnt` variable has reached `2`, then we won\\'t increment `p`, because we can\\'t have more than 2 occurences in the final array.\\n\\n    2. If the value isn\\'t equal, that means we have found a new value and at this point `nums[i]!=nums[j]`. Hence, we change `i=j`, increment `j`, and set `cnt` to `1` (because the new number itself is also counted). And we also increment `p`, and the rest of the while loop continues.\\n\\n5. After the while loop is terminated, `p` gives the last index at which value was filled, `i` and `j` reach end of the array. So, we return `p`, while our array `nums[]` has been properly modified.\\n\\n\\n\\n## Complexity\\n- **Time complexity:**\\nTime Complexity is `O(n)`, where `n` is the size of the `nums[]` array.\\n\\n- **Space complexity:**\\nSpace Complexity is `O(1)` with in-place operations.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n![image.png](https://assets.leetcode.com/users/images/19e0b885-f997-426c-b7cd-2b236dc3c366_1685998948.7063458.png)\\n\\n\\n\\n---\\n\\n# Method 3 : Method 2 + Garbage Collector (XD)\\n\\n## Intuition\\nSo, it\\'s obvious when you grind 15 minutes (check difference between time stamps of previous 2 solutions), you won\\'t expect your code\\'s space complexity to just beat 47.15% of the other JAVA solutions. Hence, this is the intuition to do something crazy!\\n\\n## Approach\\nThe approach was nothing, but see the best solution that beats 100% space, so I found a solution (by clicking the first bar in the distribution chart).\\n\\nAnd you know what? I got to know an amazing technique to tease the LeetCode Judge, by manually running the Garbage Collector of JAVA before returning the answer to each test case.\\n\\nAnd the answer is `System.gc();`.\\n\\n# Complexity\\n- **Space complexity:**\\nSpace complexity of this new code as expected, did beat all JAVA solutions, (because you literally cleanup everything before returning lol).\\n\\n- **Time complexity:**\\nNow, the time complexity (`O(t*c),` where t is number of tc and c is the time to run the garbage collector in 1 call) was definitely a concern, because running so many test cases, everytime manually clearing up memory, would take more worth of time than it took to cleanup some small space in memory. This solution took less time than method 1, but no signs of beating 100% solutions.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\\n\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/a8f2bf24-97f9-4094-a9b0-dd663b4d3b99_1685999693.956865.png)\\n\\n\\n---\\n\\n# Method 4 : Method 3 (but optimized!)\\n\\n## Intuition\\nSo, by now I had understood the fact that at this point with this 2 pointer solution, it was just space-time tradeoff using the garbage collector. And I just wanted to find some point where it gives the best combination of them.\\n\\n## Approach\\nSo, my approach now was to reduce the number of times that garbage collector was being run. Why not, just run it once in 5 or once in 10 times, and clear up all the space in minimal time?\\n\\nIf it was in my hands (or basically if I knew how the judge worked), I would have called the System.gc() command just before the last return value, but the fact is I don\\'t know how it functions.\\n\\n\\nBut I do have access to the current time in the System clock and how it works, so with different modulo hashes, I tried to get the best performance, and well starting from `%2`, then `%3`, finally `%4` gave me the best result.\\n\\nNow what do I mean by `%4`? It means I added just one line in my code which is of this structure:\\n\\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\\n\\nNow, this `m` can vary for different constraints, while here `m=4` worked for me. And so, finally, below you can see a code that beats 100% of space and 100% time in all JAVA solutions across LeetCode for this problem.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/313d42a3-fbed-4d2b-9a8e-f52bc68a366e_1686000339.0158308.png)\\n\\n\\n\\n\\n---\\n\\n# A Request!\\n\\n***Please upvote this post so that other people can also learn something new, a part of which is logical, and the rest is crazy XD!***\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576995,
                "title": "general-for-k-duplicates-easy-c-understandable-solution-beats-100",
                "content": "# Intuition\\nThe given array is sorted. This means next element will be either same element or bigger one. Store current element in a variable and keep comparing it with next element, also keep an eye that count does not exceed K (Here K is 2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: I come up with the idea that if I swap array for every duplicates, it will be costly, so I thought why not mark that place and swap everything at last.\\nThere will be three cases as you can see in code\\nCase 1: Element of array is same as current element and count is still postive.\\nCase 2: Element of array is same as current element but count is not positive.\\nCase 3: Element of array is not equal to current.\\n\\nStep 2: I sort the array. \\nStep 3: Found the length using loop.\\nStep 4: Check Corner Cases for array size = 1 or 2 or 0;\\nYou are done!!!\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569694,
                "title": "same-approach-as-easy-one-0ms-beats-100-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486377,
                "title": "classical-two-pointer-approach-with-little-tweak-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437027,
                "title": "using-java-beats-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328439,
                "title": "simple-0ms-solution-beats-100-with-explanation-java-c",
                "content": "# Explanation & Example\\nSo from the question we can see **we need to remove duplicates in place and each element can appear atmost twice**.\\n\\nlet\\'s take the below array for **example**\\n**arr = [0,0,1,1,1,1,2,3,3]**\\n\\nSo in the initial observation we can see everything appears in correct count except 1.\\nWe initialize prev with 1st element(0) in array and we start with index 1,as we know the 1st element in array gonna be unique so we also initialize k with 1.as we are doing it in-place **assume our array(arr) has[0,-,-,-,-,-,-,-,-] for better understanding**.\\n\\n\\n- In 1st iteration prev = 0 as it is equal to ith value(0) we\\'ll increase the count to 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(0) and increment k [0,0,-,-,-,-,-,-,-].\\n\\n- In 2nd iteration prev = 0 and arr[i]=1 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,-,-,-,-,-,-]\\n\\n- In 3rd iteration prev = 1 and arr[i]=1 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,1,-,-,-,-,-]\\n\\n- In 4th & 5th iteration prev = 1 and arr[i]=1 so the count becomes 2 & 3 respectively as it does not pass the condition(c<=1) the array remains same[0,0,1,1,-,-,-,-,-]\\n\\n- In 6th iteration prev = 1 and arr[i]=2 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(2) and increment k [0,0,1,1,2,-,-,-,-]\\n\\n- In 7th iteration prev = 2 and arr[i]=3 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,-,-,-]\\n\\n- In 8th iteration prev = 3 and arr[i]=3 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,3,-,-]\\n\\n- In 8th iteration the k will be in 6th index and as usual we\\'ll increment and k becomes 7\\n\\n- so we got the **output as 7** and we can see the array(arr) becomes [0,0,1,1,2,3,3,-,-] and the **first 7 value(0-6 index) in the array has unique elements appears at most twice**.\\n\\n# Complexity\\n- Time complexity : O(N)\\n\\n- Space complexity : O(1)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196900,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090684,
                "title": "remove-duplicates-from-sorted-array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080349,
                "title": "easy-solution-using-maps-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852511,
                "title": "java-o-n-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786407,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427237,
                "title": "a-simple-java-solution-that-beats-100-with-explanation",
                "content": "Since the array is already sorted and we want to keep at most two duplicates, we only need to compare `nums[i]` and `nums[i - 2]` if the original array is not modified. For the array `nums = [1,1,1,2,2,3]`, we saw `nums[2] == nums[0]`, which means there are more than 2 duplicates and we should remove one of them. \\n\\nTo remove the duplicates, we need a pointer `current` that points to the index, where the elements before it has at most 2 duplicates. In this way, we can overwrite it with a valid number later. For example, for the array `nums = [1,1,1,2,2,3]`, `2` would be our index because there are only two numbers before. We noticed `nums[2] == nums[0]`. So we may want to replace `nums[2]` with some value after it. Since `nums[3] != nums[1]`, we can replace `nums[2]` with `nums[3]`. Thus the array becomes `[1,1,2,2,2,3]`. For this new array, we saw that `nums[4] == nums[2]`. But we don\\'t want to remove it since we added the extra `2`. We must add the offset, which is `i - current`, where `i` is the pointer of the original array. So the comparation will be between `nums[i]` and `nums[i - 2 - (i - current)]`, which is `nums[current - 2]`.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195204,
                "title": "o-n-with-o-1-extra-memory-java-c-c",
                "content": "**Algorithm**\\n* If length of nums is less than 2 then simply return length of array\\n* We can solve this question using two pointers i.e., i and count. Count will track the index of array to be sent and i will track the index of next bigger element\\n* If current element is less than next element that means only one element is present, then add the ith element in array at count index, incrementing count for next element.\\n* Else, that means there are more than one elements of that current element. We know that we can add at most two elements, so we will add ith element in the array upto next 2 count pointers. \\n* We need to shift the ith element to the next greater element.\\n* There might be chances that the last element of nums can be remained uncheckd, so once the ith pointer is at second last element then we can add the i+1th element at count place in array.\\n\\nTime Complexity: O(n) with O(1) extra memory\\n**Code in Java**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Code in C**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```\\n\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750932,
                "title": "very-very-easy-java-with-o-1-memory",
                "content": "```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750790,
                "title": "swapping-to-preserve-the-relative-order",
                "content": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "solutionTags": [],
                "code": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1750721,
                "title": "c-simple-solution-easy-to-understand-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749171,
                "title": "cpp-easy-solution-with-time-o-n-space-o-1-and-o-n",
                "content": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1650174,
                "title": "c-using-single-loop",
                "content": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1377370,
                "title": "ez-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271028,
                "title": "c-solution",
                "content": "**intuition**\\nmaintain two pointers ```i``` and ```j```.\\npointer ```i``` is used to traverse the array, pointer ```j``` is used to mark the position where needs a replace.\\nwhen ```nums[i] == nums[j-2]```, then there are 3 duplicates  (```nums[j] = nums[j-1] = nums[j-2]```). ```j``` is pointing at the position where needs a replacement, so we don\\'t move ```j``` until we find the next number that can replace ```nums[j]```.\\nwhen ```nums[i] > nums[j-2]```, we find the number that can be used to replace ```nums[j]```.\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```j```\n```i```\n```j```\n```nums[i] == nums[j-2]```\n```nums[j] = nums[j-1] = nums[j-2]```\n```j```\n```j```\n```nums[j]```\n```nums[i] > nums[j-2]```\n```nums[j]```\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208200,
                "title": "two-pointers-c",
                "content": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 969763,
                "title": "two-pointer-approach-o-n-time-java",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968082,
                "title": "c-4ms-fast-solution-easy-to-understand",
                "content": "simple approach \\nStoring the value of last element in the variable a\\n using k to know whether it has iterated for more than two times \\n erasing the element if it comes for third time \\n ans stores the required size of vector\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }\\n                else\\n                {\\n                    k=1;\\n                    ans++;\\n                }\\n            }\\n            else\\n            {\\n                a=n[i];\\n                k=0;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 968049,
                "title": "c-simple-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968017,
                "title": "python-binary-search-solution-upper-bound-aka-bisect-right",
                "content": "Something like this maybe, wrote linear search first then replaced with upper bound:\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```\\n\\nSolutions in this discussion remind me the Silicon Valley episode about brute search on a sorted list:\\n\\nhttps://www.youtube.com/watch?v=9FzT2I21F3k",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967991,
                "title": "remove-duplicates-from-sorted-array-ii-c",
                "content": "**My Approach** : I used a pointer  --> i, for keeping track of the position I am currently in and a variable --> count, to count the occurence of the same element. Whenever the count exceeds 2 i.e more than 2 same elements, I erase it from the vector using the inbuilt erase() function; otherwise, I increase the pointer and reset the count variable to 1.\\nPls read the code for better clarity.\\nThanks!\\n**Pls upvote if you find this helpful.**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679623,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 4 ms, faster than 90.35% of Go online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 3 MB, less than 75.25% of Go online submissions for Remove Duplicates from Sorted Array II.\\n\\n```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674085,
                "title": "python3-linear-scan",
                "content": "**Algo**\\nSimilar to [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```",
                "codeTag": "Java"
            },
            {
                "id": 533779,
                "title": "simplest-swift-solution",
                "content": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509355,
                "title": "python3-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462841,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{};\\n        for(int i=0;i<n-2;i++){\\n            if(nums[i]==nums[i+1]&& nums[i+1]==nums[i+2]){\\n                nums[i]=INT_MAX;\\n                count++;\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        return n-count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{}",
                "codeTag": "Java"
            },
            {
                "id": 386869,
                "title": "python-2-variables-inplace-popping-easy-to-understand-with-explanation",
                "content": "The approach is quite simple, keep track of the current element in consideration and the count of the element. Initiate the track as the first element in the array and  have the occurence count as the second element, you may use a tuple for this of some simpler structure to save more memory. As you iterate, check if the count of the current element under consideration exceeds that under track, in which case we pop it but do not increment out tracker. While loops are convenient here since the array size changes and the len(nums) si computed prior to every iteration. In case they are different, reinitiate the tracker with the new value and set the second frequency element to 1.\\n \\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352667,
                "title": "java-simplest-approach-for-this-exercise",
                "content": "We can copy the exact same solution from https://leetcode.com/problems/remove-duplicates-from-sorted-array/\\nThe only trick is that we allow j to move forward n times when we find duplicates, where n = 2 for this exercise.\\nMake sure to add +1 to j when you return it because we want the length of the new array and not the last valid index.\\n\\n**Remove Duplicates from Sorted Array (LC #26)**\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\\n\\n**Remove Duplicates from Sorted Array II**\\n\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314125,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27982,
                "title": "6-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28071,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }\\n            \\n            return newSize;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 28098,
                "title": "my-easy-c-solution",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28142,
                "title": "java-solution-generalized-to-maximal-k-time-occurences",
                "content": "This solution is inspired by @tech-wonderland.net\\n\\nIn this solution, I use a **for** loop instead of a **while** since we know for sure the iteration will end after loop through the array one time.\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }\\n        \\n        public int removeDuplicates(int[] nums, int k) {\\n            \\n            int len = nums.length, count = 1;\\n            \\n            // j points the position where the next qualified number \\n            // found by i pointer will be written\\n            for ( int i = 1, j = 1; i < nums.length; i++ ) {\\n    \\n                count = (nums[i] != nums[i-1]) ? 1 : count+1;\\n                \\n                if ( count > k ) {\\n                    len--;\\n                } else {\\n                    nums[j++] = nums[i];\\n                }\\n    \\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 28145,
                "title": "iterative-python-solution-o-n-88ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def removeDuplicates(self, nums):\\n            n = len(nums)\\n            if n < 3:\\n                return n\\n    \\n            start, tail = 0, 2\\n    \\n            for i in range(2, n):\\n                if nums[i] != nums[tail - 1] or nums[i] != nums[tail - 2]:\\n                    nums[tail] = nums[i]\\n                    tail += 1\\n    \\n            return tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 28132,
                "title": "in-place-solution-in-python-for-reference",
                "content": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "codeTag": "Java"
            },
            {
                "id": 3989902,
                "title": "simple-easy-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880642,
                "title": "best-javascript-simple-solution-easy-to-understand-quickly-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659959,
                "title": "java-best-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629267,
                "title": "python-intuitive-optimal-2-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 pointers, one goes first to find the next unique element, the slower one waits until the first one find a new element and fill its current position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate over `nums`, we first set the amount of the number of duplicates for the current element to 2, `cnt_left = 2`. We only do this when we found a new element: `num != nums[j - 1]` or `j == 0`\\n\\nWe then update the slow pointer and reduce the `cnt_left` when:\\n- We need another duplicate: `cnt_left > 0 and num == nums[j - 1]`\\n- New element found: `j == 0` or `num != nums[j - 1]`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627809,
                "title": "simple-solution-java",
                "content": "# Intuition\\nThe given code aims to remove duplicates from an array nums and return the new length of the array.\\n\\n# Approach\\n1) Create a new array n1 with the same length as nums. This array will store the non-duplicate elements.\\n2) Initialize variables c, c1, and n to keep track of counts and the length of the new array.\\n3) Iterate over the elements of nums using the outer for loop.\\n4) Reset c to zero at the beginning of each outer loop iteration. c will count the number of occurrences of the current element.\\n5) Use the inner for loop to iterate over nums and check for occurrences of the current element. Increment c for each occurrence.\\n6) If c is greater than 1, it means the current element is a duplicate.\\n7) Add the current element twice to n1 (to remove duplicates).\\nUpdate c1 and n accordingly.\\n8) If c is 1, it means the current element is not a duplicate.\\nAdd the current element once to n1.\\nUpdate c1 and n accordingly.\\n9) After the loop ends, copy the elements from n1 back to nums.\\nReturn the final count n, representing the new length of the array after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\n**Please upvote if you like my solution!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625795,
                "title": "kotlin-simple-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598061,
                "title": "easy-c-solution-o-n",
                "content": "\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571777,
                "title": "combining-both-versions-easy-and-medium-c-o-1-space",
                "content": "Problem 26. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\\n\\n\\n\\n\\n\\n\\nProblem 80. [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564625,
                "title": "remove-duplicates-from-sorted-array-ii",
                "content": "**Simple** Solution :\\n1. **step1: **pick the first element from the array( hence given minimum length of array is 1).\\n1. step2: count the frequency of element.\\n1. step3: if count==3  remove the element at that index and decrease the count and length of array(because we deleted one element from array). and stay at that index don\\'t increment the index(i) because next element comes to current index when we delete an element at present index).\\n1. \\xA0step4: if new element comes into picture then change pointer(p) to new element and count to 1.\\n1.  step5: return the final length of the array(l).\\n\\n``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545339,
                "title": "simple-two-pointers-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1983237,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1982040,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1929287,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1736627,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2075933,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2073357,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2071883,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2065028,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2064125,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2057740,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2056728,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2055605,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2051670,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050718,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050414,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2029005,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2020620,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2005189,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2003421,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2002773,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 1994697,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1986159,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1958088,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1932780,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1916491,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1767478,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754137,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1741175,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1648709,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709320,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Consecutive Numbers",
        "question_content": "<p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n",
        "solutions": [
            {
                "id": 321205,
                "title": "runtime-299-ms-faster-than-94-39",
                "content": "Runtime: 299 ms, faster than 94.39% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: N/A\\n\\n```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359304,
                "title": "easy-and-simple-solution-using-lead-try-this",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```\\n**If U like the solution, Pls Upvote**\\n\\n![cat.png](https://assets.leetcode.com/users/images/cb4680e8-b410-4c2f-a9f7-914b5be19e87_1680183976.0080035.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53418,
                "title": "simple-solution",
                "content": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "solutionTags": [],
                "code": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 237228,
                "title": "my-version-is-more-flexible-we-can-change-3-to-4-or-5-or-10",
                "content": "#### Question\\n```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\\n#### Answer\\n##### Approach1\\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```\\n\\n##### Approach2\\n```SQL\\nselect distinct num as ConsecutiveNums from\\n(select num, id - row_number() over (order by num, id) rank from logs) a\\ngroup by num,rank\\nhaving count(*) >2\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420941,
                "title": "mysql-2-different-approach-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509769,
                "title": "easy-approach-clear-code-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Easily taking out the distinct num from the table whose occurence >= 3. \\n- To check that consecutively occurence is atleast 3 times, we do it by `creating 3 tables for every other id by +1 increment` & `matching them that they are equal.` \\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/59140048-d0f2-482b-8ec7-28bbf0126f63_1683741800.9033337.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53420,
                "title": "solution-with-user-defined-variables",
                "content": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "solutionTags": [],
                "code": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 3824916,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```\\nIF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/d5520730-3315-4ebe-a865-3a6bd4416173_1690477599.7336297.jpeg)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700299,
                "title": "faster-than-99-simple-self-join",
                "content": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 213003,
                "title": "",
                "content": "\\u5927\\u6982\\u4EE3\\u7801\\u8FD9\\u6837\\n```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```\\n\\u8BB0\\u5F97\\u52A0\\u4E2Adistinct\\uFF0C\\u4E0D\\u52A0\\u5C31\\u4F1A\\u6709\\u91CD\\u590D\\u7684",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214755,
                "title": "180-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we need to identify the rows that have at least two consecutive numbers equal to each other. We can do this by joining the table with itself twice, with the second copy offset by 1 row, and the third copy offset by 2 rows. If the values in the num column match for all three copies, then we have found a row where the number appears at least three times consecutively. We can use the DISTINCT keyword to remove duplicates and the ORDER BY keyword to sort the result table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\\nWe join the table Logs with itself three times, using aliases l1, l2, and l3. We then check that l1.num = l2.num and l2.num = l3.num, meaning that the number in the num column appears at least three times consecutively. We select the num column from the first copy of the table and use the DISTINCT keyword to remove duplicates.\\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```\\nIn this case, the only number that appears at least three times consecutively is 1.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53439,
                "title": "an-ugly-solution",
                "content": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "solutionTags": [],
                "code": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "codeTag": "Unknown"
            },
            {
                "id": 410442,
                "title": "sql-server-91-faster-using-lead",
                "content": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53447,
                "title": "simple-sql-with-join-1484-ms",
                "content": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1186678,
                "title": "easy-solution-can-be-extended-to-n-consecutive-numbers",
                "content": "This solution is the variation from https://leetcode.com/problems/consecutive-numbers/discuss/237228/My-version-is-more-flexible.-We-could-change-3-to-4-or-5-or-10\\n\\nThe solution provided was brilliant but no longer works in the latest tests because of UNSIGNED BIGINT OUT OF RANGE. This is caused by the negative results from the calculation of `id - row_number()`. By default, row_number() returns a number that is stored in UNSIGNED format, making the calculation result stored in UNSIGNED as well. This will encounter an error when a negative number is passed. (Actually there\\'s a more complex logic to convert them automatically)\\n\\nYou may not expect that `SELECT CAST(-1 AS UNSIGNED)` yields 18446744073709551615 , right? Always be careful when calculating numbers between UNSIGNED and SIGNED!!! Try to manually cast them into the same type before processing.\\n\\n```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53460,
                "title": "accepted-solution-without-joins-works-in-n-consecutive-cases-with-slight-modification",
                "content": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "solutionTags": [],
                "code": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 2243677,
                "title": "a-clean-solution-using-ctes-and-analytical-functions-mssql",
                "content": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997112,
                "title": "mysql-gaps-and-islands-problem-bigint-unsigned-value-is-out-of-range",
                "content": "This problem can be categorized as a gaps-and-islands problem.\\n\\nThe only issue is that there are test cases having id starts with 0 and that caused the error \"BIGINT UNSIGNED value is out of range\" which can be resolved by casting the row_number as signed. The cause of the error is \"Subtraction between integer values, where one is of type UNSIGNED, produces an unsigned result by default.\"\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\\n\\nOther ways of solving this problem includes,\\nself join:\\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\\n\\nLAG() / LEAD():\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548839,
                "title": "3-solutions-compared-performance-and-readability",
                "content": "# Option 1: Derived table\\n```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\\n- Performance: This option uses window functions to compare the current row with the previous and next rows. Window functions can be efficient, but the performance can be influenced by the size of the logs table and the ordering requirements. It\\'s important to ensure appropriate indexes are in place to support the window functions and sorting.\\n\\n- Readability: This option utilizes the power of window functions to compare consecutive rows. It expresses the logic succinctly, making it easier to understand for developers familiar with window functions. However, for those less familiar with window functions, the syntax and the concept of lag and lead functions might require some understanding.\\n\\n# Option 2: Joins\\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\\n- Performance: This option uses self-joins to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes on the `id` and `num` columns. Joins can be efficient, but it\\'s crucial to ensure the indexes are optimized.\\n- Readability: This option expresses the logic using self-joins, which can be more familiar to developers with SQL background. The joins represent the consecutive row comparison, and the logic is relatively straightforward to follow.\\n\\n# Option 3: Implicit Joins\\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```\\n- Performance: This option uses implicit joins in the WHERE clause to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes. Similar to Option 2, it\\'s important to optimize the indexes for better performance.\\n- Readability: Implicit joins can be less readable compared to explicit joins. While the logic is expressed using simple comparisons in the WHERE clause, it might require careful examination to understand the relationship between the joins and the consecutive row comparison.\\n\\n# Conclusion:\\n\\n- If performance is a top priority, Option 1 (Derived Table) is likely to perform well, especially if appropriate indexes are in place. Window functions can be efficient for comparing consecutive rows.\\n- If readability is a priority, Option 2 (Joins) might be the preferred choice. Self-joins are more familiar to SQL developers and can be easier to understand.\\n- Option 3 (Implicit Joins) may be less preferred in terms of readability due to the implicit nature of the joins.\\n\\nIt\\'s important to benchmark and test the performance of these options with your specific dataset and workload to determine the best-performing option in your environment. Unfortunately, leetcode runtime does not provide fair time, and is not supposed to used as such metric.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654155,
                "title": "mysql-lag-and-lead-window-functions",
                "content": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399362,
                "title": "simple-mysql-solution",
                "content": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "solutionTags": [],
                "code": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "codeTag": "Unknown"
            },
            {
                "id": 1720116,
                "title": "best-practice-for-row-number-and-subqueries",
                "content": "The solution may looks intimidating, but **the logic is very simple.**\\nIt is definitely **great** for anyone wants to practice the logic of using Window Function, RowNumber() and subqueries\\n\\n## Solution\\n``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\\n\\n## Explanation\\n### Let\\'s dive to the deepest nested subquery\\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\\nThis part\\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\\nmay be the most difficult part to understand\\n\\n![image](https://assets.leetcode.com/users/images/7dc764cb-d1d3-422e-bc71-2df5323e9118_1643164851.0240996.png)\\n\\nUsing the example provided in the question\\n\\nOn this image, notice that third column, row_number(), is as expected just producing the row index, which is the same value as id.\\n\\nHowever, one thing to notice is that the **order of id changes**, id 5 and id 4\\'s positions are exchanged. This is due to the last colum\\'s ```Partition By num```. ```Partition By``` works like ```Group By```, but display all the records and the record in the same group are displayed together. Therefore, to make sure all the 1s are displayed together, id 5 and id 4 are exchanged. Since we have also included ```order by id```, then in every group, the ids should be in ascending order.\\n\\nYou may wonder \"What\\'s the matter about the grouping with partition by? Isn\\'t every same number put in the same group, how can we find consecutive ones?\" \\n\\n**Note that your row number of the nums does not change** \\n\\nWhen you do a subtraction, you\\'ll see\\n![image](https://assets.leetcode.com/users/images/f6786f16-aace-41f6-884a-5305df029fd3_1643164944.063975.png)\\n\\nHey, those consecutive number have the same value(look at the 1s at the top and 2s at the bottom)\\n\\n#### Why those consecutive number have the same value?\\nNote that the first row_number() gives a row value to the nums, the second partition by in the row_number also gives a row value to the nums. The second row value increment 1 as id increases, no matter the value is consecutive or not. The first value increment 1 only if the nums are consecutive. If your nums are consecutive, then both value increment 1, thus the **difference is always the same**!\\n\\n### For the result of the query\\nYou are basically only grabing the part where values in the third column, \\'ConsecutiveGroup\\' or ```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ``` that are same and count for the number of consecutive value you want.\\n\\n## Comment Below if You have any question or confusion!!!\\n\\nThis solution is inspired by [@neilsons](https://leetcode-cn.com/u/neilsons/)",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\n```Partition By num```\n```Partition By```\n```Group By```\n```order by id```\n```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484648,
                "title": "three-lines-solution-easy-to-understand",
                "content": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261534,
                "title": "mysql-self-join-easy-and-simple",
                "content": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795404,
                "title": "a-general-solution-for-consecutive-problems",
                "content": "Posted solutions are very nice for 3 consecutive number. However, when the consecutive number becomes higher, for example 5, it become too much trouble to put 5 tables in the where clause.\\n\\nBelow is a code inspired by niradranjan\\' s solution on question #1454. It could work for any number of consecutive number.\\n\\n```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53467,
                "title": "explanation-of-consecutive-numbers-problems",
                "content": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "solutionTags": [],
                "code": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "codeTag": "Unknown"
            },
            {
                "id": 3516976,
                "title": "easy-solution-with-join-and-distinct",
                "content": "# code\\n\\n```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451973,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please Press Star ^ above**\\n\\nHere We Use JOIN two time\\n\\nFirst Time to check if first Consecutive number is coming above second Consecutive and same value.\\n```\\n a.id=b.id+1 AND a.num=b.num\\n```\\nSecond Time to check if first Consecutive number is coming above Third Consecutive and same value.\\n```\\na.id=c.id+2 AND a.num=c.num\\n```\\n**Code**\\n\\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n a.id=b.id+1 AND a.num=b.num\\n```\n```\\na.id=c.id+2 AND a.num=c.num\\n```\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696606,
                "title": "easiest-solution-simple",
                "content": "if you like it pls upvote\\n\\njust check three items , if they are in the order and their nums equal eachother just add to result.\\n\\n\\n```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292939,
                "title": "mysql-simple-solution-use-lag",
                "content": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255565,
                "title": "mysql-simple-easy-with-lead-and-lag",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 420588,
                "title": "simple-solution-mysql",
                "content": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "solutionTags": [],
                "code": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "codeTag": "Unknown"
            },
            {
                "id": 3370881,
                "title": "use-lead-and-lag-windows-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nM1: Using LEAD\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\\n\\nM2: Using LEAD and LAG\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097822,
                "title": "easy-simple-solution-using-window-function-lead-and-lag",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971912,
                "title": "easy-to-follow-solution-with-explanation-window-functions",
                "content": "**Runtime**: 426 ms, faster than 81.70% of MySQL online submissions\\n\\n**Solution**: \\n```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```\\n\\n**Explanation**:\\n\\nThis solution uses the `LAG()` and `LEAD()` window functions. As the name suggests, the `LAG` function has the ability to fetch data from a previous row, while `LEAD` fetches data from a subsequent row. You can visit [this website](https://www.mssqltips.com/sqlservertutorial/9127/sql-server-window-functions-lead-and-lag/) if you want to know more.\\n\\nFirst, we create a Common Table Expression (CTE) named `logs_lag_lead`. This CTE retrieves the `id` and `num` columns from the `Logs` table along with two new columns:\\n\\n- `lag_num`, which stores the preceding number (if one exists, else `null`), and\\n- `lead_num`, which stores the succeeding number (if one exists, else `null`).\\n\\nThe contents of the cte are shown below:\\n\\n![image](https://assets.leetcode.com/users/images/c2e62932-4a50-49f8-bded-cd88c5d05666_1650615007.1811059.png)\\n\\nNotice that when we have three consecutive numbers (first three rows, marked by the red rectangle), the row corresponding to the middle number will have an equal value for `num`, `lag_num`, and `lead_num` (marked by the blue rectangle). That\\'s because these two window functions retrieve the previous and following row values that are equal to `num`. \\n\\nWe finalise our solution by writing a simple query that contains the condition `num = lag_num AND num = lead_num` in the `WHERE` clause. Notice that we need to retrieve distinct rows. That\\'s because there might be more than three consecutive numbers; in that case, all middle rows will satisfy the `WHERE` condition, and the query will return the same number multiple times.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698703,
                "title": "faster-than-96-mysql-solution",
                "content": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1648643,
                "title": "easy-mysql-solution",
                "content": "Here is my simple yet effective MySQL Solution:\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444382,
                "title": "window-function-with-partition-flexible-with-any-consecutive-numbers",
                "content": "# **Solution 1: Use Window function, Partition by and order by**\\n\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n # **Solution 2: Multiple by 1.0 to float to avoid the bigINT error**\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n# **Problem Solving Process**\\nThis is the problem\\n![image](https://assets.leetcode.com/users/images/6eb3c961-7109-489b-8cd0-1752f369af96_1630774962.319755.png)\\n\\nWe partition the data by Nums and order by Id to get the row_number(). Then we calculate the difference between the id and row_number() to define as the new_group. \\n![image](https://assets.leetcode.com/users/images/188b2519-66a4-4c46-adfa-f5acee3cc033_1630774936.7532938.png)\\n\\nWe group by Nums and new_group and calcuate the count. We filter out the count >= number ( 3 in this problem)\\n![image](https://assets.leetcode.com/users/images/2ff1390a-9bfc-4f3b-aa38-e07fda3de015_1630775196.275442.png)\\n\\n# **Similar Problems**\\n1. 603. Consecutive Available Seats ( Easy )\\n2. 1811. Find Interview Candidates ( Medium )",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696618,
                "title": "distinct-lead-solution",
                "content": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53458,
                "title": "be-sure-to-use-order-by-id",
                "content": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "solutionTags": [],
                "code": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "codeTag": "Unknown"
            },
            {
                "id": 3109417,
                "title": "180-consecutive-numbers-too-hard-approach-sql-solution",
                "content": "**Understandable Solution using **`With Clouse` , `row_number() `and `order by `\\n1. use with clouse assume table as t1 Get Row number based on order id\\n2. Get number partition based on num order based on id\\n3. take the diffrence in 1 and 2 to get the diff\\n4. select distinct value based on num\\n5. just write condition  `having Count(*) >= n` ;  ``\\n```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658920,
                "title": "consecutive-numbers-easiest-approach",
                "content": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2016799,
                "title": "3-different-solutions",
                "content": "## Solution 1: window function `lag` and `lead`, beat 43%\\n\\n**Logic**: \\n1. for each row attach the previous number and next number next to the current number, and store in `cte`\\n2. condition the `cte` on current number = previous number = next number\\n3. select only `distinct` and rename to `ConsecutiveNums`\\n\\n```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\\n\\n### Solution 2: using `where`, beat 23%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\\n\\n### Solution 3: using `inner join`, beat 46%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803779,
                "title": "simplest-easy-mysql-solution-180-consecutive-numbers",
                "content": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529243,
                "title": "mysql-two-methods",
                "content": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "codeTag": "Unknown"
            },
            {
                "id": 1411179,
                "title": "easy-to-understand-mysql-solution",
                "content": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000765,
                "title": "faster-than-90",
                "content": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874390,
                "title": "use-distinct-and-dense-rank-row-number",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u9898\\u76EE\\u8981\\u6C42\\u627E\\u51FA\\u8FDE\\u7EED3\\u4E2A\\u76F8\\u540CNum\\u7684\\u8BB0\\u5F55\\n\\u4E00\\u5F00\\u59CB\\u4E5F\\u60F3\\u4E0D\\u51FA\\u89E3\\u6CD5\\uFF0C\\u867D\\u7136\\u8FD9\\u4E2A\\u4EBA\\u773C\\u770B\\u662F\\u633A\\u7B80\\u5355\\u7684\\n\\u7ECF\\u641C\\u7D22\\u53D1\\u73B0\\u4E00\\u4E2A\\u5173\\u952E\\u70B9\\uFF0C\\u5C31\\u662F\\u5982\\u679C\\u6570\\u5B57\\u8FDE\\u7EED\\uFF0C\\u90A3\\u4E48\\u4ED6\\u4EECid\\u589E\\u957F\\u548C\\u5206\\u7EC4\\u5185\\u6392\\u5E8F\\u7684\\u589E\\u957F\\u901F\\u5EA6\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\n\\u53C2\\u8003  https://blog.csdn.net/iteye_20478/article/details/82202514?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf[](http://)\\n*\\u56E0\\u4E3Adenserank() \\u548Crownum\\u90FD\\u662F\\u8FDE\\u7EED\\u7684\\u8BA1\\u6570\\u7684\\uFF0C\\u4E00\\u4E2A\\u662F\\u5168\\u5C40\\u8BA1\\u6570\\uFF0C\\u4E00\\u4E2A\\u662F\\u5C40\\u90E8\\u5206\\u7EC4\\u8BA1\\u6570\\uFF0C\\u56E0\\u6B64\\uFF0C\\u4E24\\u4E2A\\u9012\\u589E\\u9891\\u7387\\u90FD\\u662F1\\u7684\\u8FDE\\u7EED\\u76F8\\u51CF\\uFF0C\\u503C\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\uFF0C\\u6BD4\\u5982 \\u5168\\u5C40\\u4E3A 1,2,3,4,5\\uFF0C\\u5206\\u7EC4\\u4E3A 1,2 \\uFF1B1;1,2 \\u7ED3\\u679C 1-1=0,2-2=0\\uFF1B 3-1=2\\uFF1B 4-1=3,5-2=3\\uFF1B \\u56E0\\u6B64 1,2\\uFF1B4,5\\u662F\\u8FDE\\u7EED\\u7684*\\n\\u6240\\u4EE5\\u8FD9\\u9898\\u4F7F\\u7528row_number\\u5E94\\u8BE5\\u4E5F\\u53EF\\u4EE5,\\u8BD5\\u4E86\\u4E00\\u4E0B\\u8FD8\\u5FEB1ms\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u7136\\u540E\\u4F7F\\u7528group by\\u6309Num\\u548C\\u5DEE\\u503C\\u5206\\u7EC4\\n\\u6700\\u540E\\u63D0\\u4EA4\\u7684\\u65F6\\u5019\\u53D1\\u73B0\\u8F93\\u5165\\u7684\\u8BB0\\u5F55\\u91CD\\u590D\\u5F88\\u591A\\uFF0C\\u8FD8\\u8981\\u7528distinct\\u53BB\\u91CD\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820303,
                "title": "mysql-using-just-count-easy-to-be-generalized",
                "content": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767760,
                "title": "simple-mysql",
                "content": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "solutionTags": [],
                "code": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 256431,
                "title": "sql-server-mysql-faster-than-75-join-table-two-times-with-its-own-easy-to-understand",
                "content": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53442,
                "title": "who-said-the-id-increments-by-1",
                "content": "There has been posted many solutions assuming that next row should be identified with Id = Id + 1. As there is no explicit reference in the condition for that, I considered it is fair to give a generic case solution. It is built around a view that identifies the next element:\\n```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\\nWith the original example it'll produce a rather trivial table:\\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\\nAnother view appends a value for the next element:\\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\\nAnd the last query finally \\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```\\nUnfortunately, creating a view is denied by the OJ: \"CREATE VIEW command denied to user 'student'@'localhost' for table 'Next'\".\\nOtherwise it seems reasonable solution working on my private MySQL DB just fine.",
                "solutionTags": [],
                "code": "```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899091,
                "title": "easy-approach-using-nested-query-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explanatory.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing nested queries.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523717,
                "title": "mysql-solution-for-consecutive-numbers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve all the numbers that appear consecutively three or more times in the Logs table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a subquery to select the Num column from the Logs table, along with a calculated column freq that represents the frequency of each number in the sequence of numbers.\\n2. Use the @prev and @cnt variables to keep track of the previous number and the frequency of the current number, respectively.\\n3. If the current number is the same as the previous number, increment the frequency by 1. Otherwise, reset the frequency to 1.\\n4. Use the outer query to select the distinct numbers that have a frequency greater than 2 (i.e., appear consecutively three or more times).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the Logs table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a subquery with a GROUP BY clause is O(n * log n), where n is the number of rows in the table. However, the use of variables to calculate the frequency may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the number of distinct numbers that appear consecutively three or more times in the Logs table. Therefore, the space complexity is O(k), where k is the number of distinct numbers that meet the criteria. The space used by the variables @prev and @cnt is constant, so it does not affect the overall space complexity.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484633,
                "title": "easiest-and-clear-approach",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324154,
                "title": "mysql-solution",
                "content": "# Code 1\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\\n\\n# Code 2\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322142,
                "title": "runtime-129-ms-beats-96-28-one-solution-for-mysql-ms-sql-and-oracle",
                "content": "\\n\\n# Approach\\nUsing $$LAG$$ and $$LEAD$$ to get the numbers before and after the current number\\n\\n\\n\\n# Code\\n```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\\n\\n# Explanation\\n\\n\\nSince, we want to find a number appearing three consecutive times, we need to select a particular number whose previous and next numbers are the same.\\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```\\nThis part of code will give us the selected columns. You can verify your output is correct by checking if *prev_num* for the first num and *next_num* for the last num are *NULL*.\\n\\nThen, we simply need to find numbers that have the same value in three columns i.e., *num*, *prev_num* and *next_num*. Put *DISTINCT* keyword in the outer *SELECT* statement to get unique values.\\n\\nCheck out LAG and LEAD functions on this URL:\\nhttps://learnsql.com/blog/lead-and-lag-functions-in-sql/\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661795,
                "title": "left-join",
                "content": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551312,
                "title": "180-consecutive-numbers",
                "content": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2507961,
                "title": "mysql-windows-functions",
                "content": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "solutionTags": [],
                "code": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386497,
                "title": "mysql-lead-lag-no-joins",
                "content": "Problem is really easy if you are aware of some window functions.\\n**LAG(col_name)** function returns previous record from col_name\\n**LEAD(col_name**) function returns next record from col_name\\n\\nAdditionally you can specify offset and default value.\\n\\n```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314821,
                "title": "mysql-multiple-approaches-cte-inner-join-cross-join-subqueries",
                "content": "1. Using `CROSS JOIN`:\\n```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\\n\\n2. Using subqueries:\\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\\n\\n3. Using `INNER JOIN`:\\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\\n\\n4. Using Common Table Expressions with `LAG` and `LEAD`:\\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```\\n\\n* All solutions will work if the id is incremented regularly (as stated in the problem description). If that\\'s not the case, only the last one will work.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189466,
                "title": "simple-and-fast-sql-solution",
                "content": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1594501,
                "title": "combined-lead-with-lag-in-window-function",
                "content": "What I did was I used the function LEAD and LAG to give me the values after and before, added a condition where they are equal to each other, AND added another condition where either one of those values is equal to the number being evaluated.\\n\\n```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "solutionTags": [],
                "code": "```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497543,
                "title": "beats-100",
                "content": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1360281,
                "title": "used-window-function-ms-sql-server-solution",
                "content": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128822,
                "title": "mysql-solution-with-windows-function",
                "content": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "solutionTags": [],
                "code": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "codeTag": "Unknown"
            },
            {
                "id": 1040628,
                "title": "easy-mysql-solution-w-joins",
                "content": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851140,
                "title": "expandable-solution-using-recursive-cte",
                "content": "The given solution of 2 offest inner joins makes the most sense if the \"consecutive number\" you\\'re looking for is guaranteed to be fixed. But if it was a parameter in a stored procedure or something I think the below solution works better.\\n\\nThis has the same issue as the inner join solution in that it relies on the Id being guaranteed consecutive, which might not be the case in the real world. This could be solved by first dumping the necessary data into a temp table and including a ROW_NUMBER() column, and using that in place of the Id.\\n\\nAnother potential issue is that I\\'m not sure how it would scale with a very large dataset. If you\\'re looking at data in the 100,000+ rows range, and still need the consecutive number you\\'re checking to be dynamic, then maybe a cursor, a while loop, or dynamic SQL would perform better.\\n\\n```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836424,
                "title": "intuitive-solution",
                "content": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687891,
                "title": "simple-ms-sql-solution-with-row-number",
                "content": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 500601,
                "title": "without-using-join-and-it-beat-98-75",
                "content": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498428,
                "title": "mysql-two-methods",
                "content": "The performance of below methods/implementations are very comparable. \\n\\nMethod 1 - `JOIN`\\nBelow are the various flavors for implementations. \\n\\n(396ms, 98.91%):\\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(337ms, 99.08%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(326ms, 99.25%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\nMethod 2 - variables (276ms, 99.69%): \\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468726,
                "title": "ms-sql-solution",
                "content": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238029,
                "title": "simple-sql-solution",
                "content": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133361,
                "title": "oracle-solution-with-lead-window-function",
                "content": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "solutionTags": [],
                "code": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4067837,
                "title": "using-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to find the number which was repeated consecutively three times we are self joining the original table three times by comparing the num value in the first table with the num value in the second table and num value in the second table with the num value in the third table.As mentioned in the problem statement as id is incremented by 1 for every new row.We are joining the tables based on the condition id in the first table should combine with the (id+1) row in the second table when both num values are equal and id in the second table should combine with the (id+1) row in the third table when both num values match\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043322,
                "title": "using-cte-and-lag-lead",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881598,
                "title": "pandas-filter-over-diff-and-diff-diff",
                "content": "# Intuition\\nIf values appear twice in a row, then `.diff() == 0`.\\nif they appear thrice, then `.diff().diff() == 0` as well\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf a value appears a second time consecutively, then `.diff() == 0` for the lower row. If it appears a third time then `.diff() == 0` both for the third and second row. Hence, for the last (third) row we also have `.diff().diff() == 0.` Thus, we arrive at a laconic way to filter values which are consecutive triplicates: `.diff() == 0 & .diff().diff() == 0`. \\n\\nNote that in the actual code we must add `()` around the two conditions since `&` has precedence over `==`. This is because `&` in Python means binary `and` which conventionally precedes equality `==`. However, in `pandas` and `numpy` `&` is overloaded for arrays to function as a vectorized `and`.\\n\\nThe rest of the code is trivial: only keep `num`, drop duplicates, rename column to fit required output format.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ since the table comes sorted\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ bound by worst-case output size\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3867334,
                "title": "easy-solution-using-lead-and-lag-window-function",
                "content": "Lead funtion is used to find the next record and lag is used to find the previous record. I\\'m just comparing whether next number and previous number and current number are equal.\\n\\nUsed CTE (common table expression) for adding lead and lag.\\n\\n```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862867,
                "title": "one-tough-problem-to-solve-but-we-are-tougher-than-this",
                "content": "# Intuition\\nFInd consecutive number which appears three times.\\nWe need to solve this problem using Three columns and assigning equality operator\\n\\n# Approach\\nUse Lag to get previous Number,\\nLead to get Next Number,\\nNum is current Num \\nWhen Curr Num is equal to previous Num and Next Num we know that the number appeared atleast three times in a row\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545415,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433334,
                "title": "mssql-solution-using-lead",
                "content": "# Approach\\nWe can use LEAD() to see what the num values are one and two ids ahead of the current id. If we store these values in a CTE, we can reference them later in the WHERE statement and isolate nums that are the same as one and two ids ahead.\\n\\n# Code\\n```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373892,
                "title": "oracle-easy-solution-2-lines",
                "content": "# Intuition\\n-First, decide that you want to show only the distinct element\\n-Then, think how you are going to put condition in it\\n\\n# Approach\\n-I have said that if the number that we have chosen from Logs table is equal to numbers from logs table with id=id+1 and id=id+2 then that number should be displayed.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327383,
                "title": "simple-lag-window-functions",
                "content": "# Intuition\\nSimple lag Window functions\\n\\n# Approach\\nUsing lag window function to find elements 1 lag and 2 lag away and comparing them against the current number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158342,
                "title": "simple-join-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888747,
                "title": "consecutive-number-with-cte-lead-over",
                "content": "# Intuition\\nComparing rows to find the consecutive sequence \\n\\n# Approach\\nUse CTE to define value from row, row+1 and row+2 using LEAD() OVER() function by id, and then select the distinct value where the conditions are met in sequence\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674379,
                "title": "simple-solution",
                "content": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644029,
                "title": "mysql-lead-over",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601896,
                "title": "clean-simple",
                "content": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "solutionTags": [],
                "code": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "codeTag": "Unknown"
            },
            {
                "id": 2547902,
                "title": "simple-and-easy-to-understand-using-window-function",
                "content": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2327239,
                "title": "simple-lag-lead-solution-for-beginners",
                "content": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317121,
                "title": "oracle",
                "content": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "codeTag": "Unknown"
            },
            {
                "id": 2277787,
                "title": "cte-using-lag-and-lead",
                "content": "This one was kind of tricky and at first I was doing my ORDER BY in the OVER() function by number. But that doesn\\'t make sense since we are looking at order of each number BY id value: so we really want to order the OVER() function by ID not by number:\\n\\nCODE:\\n```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "solutionTags": [],
                "code": "```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271059,
                "title": "with-triple-self-join",
                "content": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "solutionTags": [],
                "code": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2260423,
                "title": "t-sql-with-only-self-joins",
                "content": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202207,
                "title": "mysql-lead-lag-easy-fast-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135338,
                "title": "mysql-solutions",
                "content": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128640,
                "title": "mssql-mysql-query-statement",
                "content": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123589,
                "title": "using-self-joins",
                "content": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2061109,
                "title": "simple-mysql-solution-for-this-tough-question-explanation-in-comments",
                "content": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030606,
                "title": "using-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1995624,
                "title": "logic-that-works-for-all-consecutive-questions",
                "content": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1981277,
                "title": "mysql-easy-solution-two-approaches-window-function-and-inner-join",
                "content": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890960,
                "title": "mysql-solution",
                "content": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861792,
                "title": "2-solutions-with-and-without-window-functions",
                "content": "With window function LAG:\\n\\n```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\\n\\nWith JOIN (faster):\\n\\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813485,
                "title": "easy-solution-2-approaches",
                "content": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575044,
                "title": "ms-sql-faster-than-99-01",
                "content": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "solutionTags": [],
                "code": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1569990,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```\\nSimilar to id == id - 1 && id - 1 == id - 2",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524966,
                "title": "using-rank-can-be-customized-on-any-number-of-consecutive-time",
                "content": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430260,
                "title": "ms-sql-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392637,
                "title": "classical-gaps-islands-problem-window-functions",
                "content": "\\n```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```\\n\\nSee for more details https://explainextended.com/2011/02/18/things-sql-needs-series/",
                "solutionTags": [],
                "code": "```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313518,
                "title": "easiest-solution-which-works-for-any-number-of-consecutive-asked",
                "content": "In the solution below, we select distinct numbers that appear consecutively atleast 3 times. The @counter and @prev are pointer variables. These variables scan the entire table and keep a count of the numbers in the @counter variable whereas @prev keeps track of the previous number to match with the next. If @prev is same as the current row Num, then @counter is increased by 1, else @counter remains valued at 1. @prev is now set to the recently encountered Num. table1 is an alias for the temporary table containing Num and the occurrences column. SELECT @counter:=1, @prev:=NULL is for the first record encountered.\\n```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308569,
                "title": "sql",
                "content": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1286043,
                "title": "easy-mysql-query",
                "content": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "solutionTags": [],
                "code": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 1220736,
                "title": "ms-sql-simple-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150002,
                "title": "mysql-using-lag-and-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146422,
                "title": "ms-sql-using-lead",
                "content": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024006,
                "title": "lag-lead",
                "content": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014073,
                "title": "tsql-100-time-space-using-cte-lag-and-lead",
                "content": "\\nCreate a CTE (nums), creating additional before and after columns for each num. Use `DISTINCT` and simple logical operators\\nand your off!\\n```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "solutionTags": [],
                "code": "```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989843,
                "title": "using-self-join-70-faster",
                "content": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "solutionTags": [],
                "code": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 955363,
                "title": "using-recursive-cte-scalable-to-any-variable",
                "content": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954556,
                "title": "find-consecutive-numbers-with-just-inner-joins-and-where-clause",
                "content": "Here is my code for just using  Inner Joins and Where clause (T-SQL).\\n\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930813,
                "title": "mysql-very-easy-to-understand",
                "content": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "solutionTags": [],
                "code": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "codeTag": "Unknown"
            },
            {
                "id": 843375,
                "title": "mysql-self-join",
                "content": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "solutionTags": [],
                "code": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 802658,
                "title": "simple-mysql-with-lead",
                "content": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793378,
                "title": "ms-sql-server",
                "content": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769884,
                "title": "ms-sql-using-lag-function",
                "content": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 714701,
                "title": "mysql-soln-faster-than-97-8",
                "content": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 637730,
                "title": "msql-very-easy-solution-cross-join",
                "content": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "solutionTags": [],
                "code": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 524379,
                "title": "no-assumption-on-id-uses-lag",
                "content": "no reason to believe the ID numbers are consecutive or give the relevant ordering... if this column was `row_number` or something then it would be reasonable to use it. \\n\\ni\\'m using `lag()` here with `order by null` to leave the ordering as is (and because `order by` specification is mandatory). i couldn\\'t find anything in the docs to support my assumption about the `NULL` behavior but i guess [ppl use it](https://stackoverflow.com/questions/25377014/what-does-this-mean-order-by-null).\\n\\n```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282107,
                "title": "simple-mysql-tuple-check-fast",
                "content": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "solutionTags": [],
                "code": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 185180,
                "title": "solution-without-using-id",
                "content": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "solutionTags": [],
                "code": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172590,
                "title": "my-solution",
                "content": "The idea is from '178.Rank Score'. https://leetcode.com/problems/rank-scores/discuss/53094/Simple-Short-Fast\n\n'''\nSELECT DISTINCT T1.Num ConsecutiveNums\nFROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      GROUP BY Rank\n      HAVING COUNT(Rank) >=3) T1;\n\t\t\t'''",
                "solutionTags": [],
                "code": "FROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      HAVING COUNT(Rank) >=3) T1;",
                "codeTag": "Unknown"
            },
            {
                "id": 140359,
                "title": "simple-solution-no-variables-beats-100-310-ms",
                "content": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 137203,
                "title": "t-sql-windows-function-lag-lead",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53464,
                "title": "solution-sharing",
                "content": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "solutionTags": [],
                "code": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 4078209,
                "title": "python-intuitive-answer-vs-swe-appproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse `rolling()` function to look at windows of size 3\\n\\ncheck if the window has all the same number either using\\n\\n1. `len(set(lst)) == 1`\\n\\nor\\n\\n2. `lst.nunique() == 1`\\n\\nThen do a simple select distinct, filter, and rename to format your output\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\\n\\n\\n# The SWE way\\n\\nSliding window using 2 pointers. \\n\\nPro: intuitive\\nCon: not in the style of data analyst/engineer\\n\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975767,
                "title": "unique-and-simple-approach-using-join-only",
                "content": "\\n\\n# PLEASE UPVOTE\\n\\n\\n```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908675,
                "title": "indexing-with-join-operation",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866747,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582251,
                "title": "simple-mysql-solution-using-select",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339622,
                "title": "correct-approach-to-get-the-answer-in-three-3-lines",
                "content": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "codeTag": "Unknown"
            },
            {
                "id": 2801130,
                "title": "oracle-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584833,
                "title": "simple-mysql",
                "content": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2559254,
                "title": "simple-solution-with-lag",
                "content": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554031,
                "title": "sql-easy-self-join-solution",
                "content": "self joining and comparing the id values and by incrementing and comparing num values.\\n```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539036,
                "title": "mysql-2-simple-solutions",
                "content": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510165,
                "title": "mysql-consecutive-numbers-sol-500ms",
                "content": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491554,
                "title": "by-using-only-where-clause",
                "content": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576547,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576529,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576217,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1575200,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574803,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574675,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573730,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573254,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1572978,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2076376,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2055133,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2034541,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2033887,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2009540,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1987675,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1981201,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1968192,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964519,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964515,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1928129,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1894173,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1891502,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1886034,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1885098,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1876500,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1840378,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1834277,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1823743,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1812353,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1811468,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1798581,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1783851,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1774651,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1771052,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1770055,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1767919,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1761908,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1750843,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736853,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736542,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1734397,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1722840,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1719668,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1714715,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1705254,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1692697,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682725,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682689,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1672485,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1666852,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            }
        ]
    }
]