[
    {
        "title": "Video Stitching",
        "question_content": "You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\nEach video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\nWe can cut these clips into segments freely.\n\n\tFor example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\n\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\n&nbsp;\nExample 1:\n\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\nOutput: 3\nExplanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut [1,9] into segments [1,2] + [2,8] + [8,9].\nNow we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\n\nExample 2:\n\nInput: clips = [[0,1],[1,2]], time = 5\nOutput: -1\nExplanation: We cannot cover [0,5] with only [0,1] and [1,2].\n\nExample 3:\n\nInput: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\nOutput: 3\nExplanation: We can take clips [0,4], [4,7], and [6,9].\n\n&nbsp;\nConstraints:\n\n\t1 <= clips.length <= 100\n\t0 <= starti <= endi <= 100\n\t1 <= time <= 100",
        "solutions": [
            {
                "id": 270036,
                "title": "java-c-python-greedy-solution-o-1-space",
                "content": "## Solution 1: Sort\\n\\nTime `O(NlogN)`, Space `O(1)`\\n**Java**\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.length && clips[i][0] <= st; ++i)\\n                end = Math.max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(begin(clips), end(clips));\\n        int res = 0;\\n        for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.size() && clips[i][0] <= st; ++i)\\n                end = max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def videoStitching(self, clips, T):\\n        end, end2, res = -1, 0, 0\\n        for i, j in sorted(clips):\\n            if end2 >= T or i > end2:\\n                break\\n            elif end < i <= end2:\\n                res, end = res + 1, end2\\n            end2 = max(end2, j)\\n        return res if end2 >= T else -1\\n```\\n\\n<br>\\n\\n## Solution 2: Sort + DP\\nSort clips first.\\nThen for each clip, update `dp[clip[0]] ~ dp[clip[1]]`.\\n\\nTime `O(NlogN + NT)`, Space `O(T)`\\n\\n**C++**\\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        vector<int> dp(101, 101);\\n        dp[0] = 0;\\n        for (auto& c : clips)\\n            for (int i = c[0] + 1; i <= c[1]; i++)\\n                dp[i] = min(dp[i], dp[c[0]] + 1);\\n        return dp[T] >= 100 ? -1 : dp[T];\\n    }\\n```\\n\\n<br>\\n\\n## Solution 3: DP\\n\\nLoop on i form `0` to `T`,\\nloop on all `clips`,\\nIf `clip[0] <= i  <= clip[1]`, we update `dp[i]`\\n\\nTime `O(NT)`, Space `O(T)`\\n\\n**Java**\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, T + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= T && dp[i - 1] < T; i++) {\\n            for (int[] c : clips) {\\n                if (c[0] <= i && i <= c[1])\\n                    dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n        }\\n        return dp[T] == T + 1 ? -1 : dp[T];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.length && clips[i][0] <= st; ++i)\\n                end = Math.max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(begin(clips), end(clips));\\n        int res = 0;\\n        for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.size() && clips[i][0] <= st; ++i)\\n                end = max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def videoStitching(self, clips, T):\\n        end, end2, res = -1, 0, 0\\n        for i, j in sorted(clips):\\n            if end2 >= T or i > end2:\\n                break\\n            elif end < i <= end2:\\n                res, end = res + 1, end2\\n            end2 = max(end2, j)\\n        return res if end2 >= T else -1\\n```\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        vector<int> dp(101, 101);\\n        dp[0] = 0;\\n        for (auto& c : clips)\\n            for (int i = c[0] + 1; i <= c[1]; i++)\\n                dp[i] = min(dp[i], dp[c[0]] + 1);\\n        return dp[T] >= 100 ? -1 : dp[T];\\n    }\\n```\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, T + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= T && dp[i - 1] < T; i++) {\\n            for (int[] c : clips) {\\n                if (c[0] <= i && i <= c[1])\\n                    dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n        }\\n        return dp[T] == T + 1 ? -1 : dp[T];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 269988,
                "title": "c-java-6-lines-o-n-log-n",
                "content": "# Intuition\\nWe track our current stitching position (```st```). For each iteration, we check all overlapping clips, and pick the one that advances our stitching position the furthest.\\n# Solution\\nWe sort our clips by the starting point. Since clips are sorted, we need to only analyze each clip once. For each round, we check all overlapping clips (```clips[i][0] <= st```) and advance our stitching position as far as we can (```end = max(end, clips[i][1])```).\\n\\nReturn ```-1``` if we cannot advance our stitching position (```st == end```).\\n```\\nint videoStitching(vector<vector<int>>& clips, int T, int res = 0) {\\n  sort(begin(clips), end(clips));\\n  for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    while (i < clips.size() && clips[i][0] <= st) end = max(end, clips[i++][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\\nJava version:\\n```\\npublic int videoStitching(int[][] clips, int T) {\\n  int res = 0;\\n  Arrays.sort(clips, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) { return a[0] - b[0]; }\\n  });\\n  for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    for (; i < clips.length && clips[i][0] <= st; ++i)\\n      end = Math.max(end, clips[i][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n log n)*, where n is the number of clips. We sort all clips, and then processing each clip only once.\\nMemory: *O(1)*.",
                "solutionTags": [],
                "code": "```st```\n```clips[i][0] <= st```\n```end = max(end, clips[i][1])```\n```-1```\n```st == end```\n```\\nint videoStitching(vector<vector<int>>& clips, int T, int res = 0) {\\n  sort(begin(clips), end(clips));\\n  for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    while (i < clips.size() && clips[i][0] <= st) end = max(end, clips[i++][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\n```\\npublic int videoStitching(int[][] clips, int T) {\\n  int res = 0;\\n  Arrays.sort(clips, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) { return a[0] - b[0]; }\\n  });\\n  for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    for (; i < clips.length && clips[i][0] <= st; ++i)\\n      end = Math.max(end, clips[i][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270680,
                "title": "c-o-n-no-sorting-greedy-explained",
                "content": "**Observation 1:** We will always pick a clip with the maximum coverage if they have same starting points.\\n\\neg: [0,3],[0,7],[0,5] -> We pick [0,7] , there is no point of picking others as the problem states that we need to minimize the number of clips picked, and this can only be done if we maximize the gap between start and end point of each clip.\\n\\n**Observation 2:** Once we start picking the clips from the minimum starting point, we only increase the count if we find a starting point greater than previously selected clip\\'s end, from then on we keep maximizing the reachable end without increasing count.\\n\\neg: [[0,4],[1,4],[2,6],[3,4],[4,7],[5,7],[6,9]], T=9\\n\\n* We select [0,4], count=1 ,selectedEnd=0,reachableEnd=4\\n* We select [1,4], start > selectedEnd we increase count=2 and reachableEnd=4, selectedEnd=4 (Previously selected end)\\n* We encounter [2,6], we increase rechableEnd=6, we don\\'t increase count asthe clip\\'s starting point is still between [0,4] (previously selected clip)\\n* Similarly We encounter [4,7], we increase reachableEnd=7.\\n* When we reach [5,7] increase count=3 as 5 > [0,4] interval\\'s end (It is here that we decide that the previously selected interval is actually [4,7] and not [1,4] where we actually increased count(step 2))\\n* We encounter [6,7] increase reachableEnd=7 and return count=3.\\n\\n```c++\\n// Similar to find #55 Jump game with count of selected indices\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        unordered_map<int,int> max_ends(clips.size());\\n        for(vector<int> &clip:clips)                                            //Get max end for each starting point.\\n            max_ends[clip[0]]=max(max_ends[clip[0]],clip[1]);\\n        int selectedEnd=-1,reachableEnd=0,count=0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(reachableEnd>=T||i>reachableEnd)        //If there is a break between clips or we already reached the end, return\\n                break;\\n            if(max_ends.count(i))                                 //If clip with i as starting point exists.\\n            {\\n                if(i>selectedEnd)                   //Increase the count if starting point is greater than previously selected clip end\\n                    count++,selectedEnd=reachableEnd;              //New selected clip ends at max end\\n                reachableEnd=max(reachableEnd,max_ends[i]);//Maximize reachable end till starting point is less than or equal to previously selected clip\\n            }\\n        }\\n        return reachableEnd>=T?count:-1;\\n    }\\n};\\n```\\n\\nSince, in the worst case clips.length<=100 and T<=100 O(T)=O(n)",
                "solutionTags": [],
                "code": "```c++\\n// Similar to find #55 Jump game with count of selected indices\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        unordered_map<int,int> max_ends(clips.size());\\n        for(vector<int> &clip:clips)                                            //Get max end for each starting point.\\n            max_ends[clip[0]]=max(max_ends[clip[0]],clip[1]);\\n        int selectedEnd=-1,reachableEnd=0,count=0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(reachableEnd>=T||i>reachableEnd)        //If there is a break between clips or we already reached the end, return\\n                break;\\n            if(max_ends.count(i))                                 //If clip with i as starting point exists.\\n            {\\n                if(i>selectedEnd)                   //Increase the count if starting point is greater than previously selected clip end\\n                    count++,selectedEnd=reachableEnd;              //New selected clip ends at max end\\n                reachableEnd=max(reachableEnd,max_ends[i]);//Maximize reachable end till starting point is less than or equal to previously selected clip\\n            }\\n        }\\n        return reachableEnd>=T?count:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707876,
                "title": "c-dp-solution-explained-thoroughly",
                "content": "**C++ Solution**\\n\\n`dp[i]` here means the minimum number of clips needed to atleast cover ith time .\\nFor Eg : `dp[3]` gives the number of clips required to atleast cover a time of 3.\\nSo returning a `dp[T]` is needed.\\n\\n**If condition requirement  `if(clip[0] <= i && i <= clip[1])` :** \\nThis If condition checks if the taken video clip\\'s starting time is smaller or equal to the `i`(which represents the max time for the clip to run or the least time we need to cover).\\n\\n`dp[i] = min(dp[i], dp[clip[0]] + 1);` tells that if we find a clip whose starting time is smaller than ith time and ending time is bigger than ith time. Then we can effectively take this clip for our use and check if this gives us minimum answer.\\nWe take the amount of clips required till starting time of taken clip and then add 1 to it.\\n\\nEnjoy :)\\n\\n```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> dp(T+2,T+1);\\n        dp[0] = 0;\\n        for(int i=0;i<=T;i++){\\n            for(auto clip : clips){\\n                if(clip[0] <= i && i <= clip[1]){\\n                    dp[i] = min(dp[i], dp[clip[0]] + 1);\\n                }\\n            }\\n            if(dp[i] >= T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> dp(T+2,T+1);\\n        dp[0] = 0;\\n        for(int i=0;i<=T;i++){\\n            for(auto clip : clips){\\n                if(clip[0] <= i && i <= clip[1]){\\n                    dp[i] = min(dp[i], dp[clip[0]] + 1);\\n                }\\n            }\\n            if(dp[i] >= T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270350,
                "title": "java-dp-short-solution",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+ 1];\\n        Arrays.fill(dp, T+1);\\n        dp[0] = 0;\\n        for(int i = 0; i <= T; i++) {\\n            for(int[] c : clips) {\\n                if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n            if(dp[i] == T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+ 1];\\n        Arrays.fill(dp, T+1);\\n        dp[0] = 0;\\n        for(int i = 0; i <= T; i++) {\\n            for(int[] c : clips) {\\n                if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n            if(dp[i] == T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269984,
                "title": "java-o-n-lgn-greedy",
                "content": "http://www.noteanddata.com/leetcode-5019-Video-Stitching-java-solution-note.html\\n\\n```\\n      public int videoStitching(int[][] clips, int T) {\\n          Arrays.sort(clips, new Comparator<int[]>() {\\n              public int compare(int[] a, int[] b) {\\n                  return a[0]-b[0];\\n              }\\n          });    \\n          int count = 0;\\n          int curend = 0;\\n          int laststart = -1;\\n          \\n          for(int i = 0; i < clips.length; ) {\\n              if(clips[i][0] > curend) {\\n                  return -1;\\n              }\\n              int maxend = curend;\\n              while(i < clips.length && clips[i][0] <= curend) { // while one clip\\'s start is before or equal to current end\\n                  maxend = Math.max(maxend, clips[i][1]); // find out the one with the max possible end\\n                  i++;\\n              }\\n              count++;\\n              curend = maxend;\\n              if(curend >= T) {\\n                  return count;    \\n              }\\n          }\\n          return -1;        \\n      }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n      public int videoStitching(int[][] clips, int T) {\\n          Arrays.sort(clips, new Comparator<int[]>() {\\n              public int compare(int[] a, int[] b) {\\n                  return a[0]-b[0];\\n              }\\n          });    \\n          int count = 0;\\n          int curend = 0;\\n          int laststart = -1;\\n          \\n          for(int i = 0; i < clips.length; ) {\\n              if(clips[i][0] > curend) {\\n                  return -1;\\n              }\\n              int maxend = curend;\\n              while(i < clips.length && clips[i][0] <= curend) { // while one clip\\'s start is before or equal to current end\\n                  maxend = Math.max(maxend, clips[i][1]); // find out the one with the max possible end\\n                  i++;\\n              }\\n              count++;\\n              curend = maxend;\\n              if(curend >= T) {\\n                  return count;    \\n              }\\n          }\\n          return -1;        \\n      }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269976,
                "title": "screencast-of-leetcode-weekly-contest-131",
                "content": "https://www.youtube.com/watch?v=sO1OVZFA_fE&feature=youtu.be\\n\\nAfter weeks of bad performance, I finally gain some confidence this time. Thanks",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=sO1OVZFA_fE&feature=youtu.be\\n\\nAfter weeks of bad performance, I finally gain some confidence this time. Thanks",
                "codeTag": "Unknown"
            },
            {
                "id": 484877,
                "title": "python-24-ms-beats-99-jump-game-ii-o-n-time-o-1-memory",
                "content": "Idea: \\n1. Convert `clips` to the furthest point you can jump from each point. O(N)\\n2. Do a jump game O(N).\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        max_jumps = [0]*101\\n        for l,r in clips:\\n            max_jumps[l] = max(max_jumps[l], r)\\n            \\n        # it is then a jump game\\n\\t\\tres = lo = hi = 0\\n        while hi < T:\\n            lo, hi = hi, max(max_jumps[lo:hi+1])\\n            if hi <= lo: return -1\\n            res += 1\\n        return res\\n\\t\\t# AC: 24 ms, beats 99%\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        max_jumps = [0]*101\\n        for l,r in clips:\\n            max_jumps[l] = max(max_jumps[l], r)\\n            \\n        # it is then a jump game\\n\\t\\tres = lo = hi = 0\\n        while hi < T:\\n            lo, hi = hi, max(max_jumps[lo:hi+1])\\n            if hi <= lo: return -1\\n            res += 1\\n        return res\\n\\t\\t# AC: 24 ms, beats 99%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273347,
                "title": "python-greedy",
                "content": "The intuitve heuristic is that we iterate clips with order by their starting time and keep increasing furthest ending time we can reach.\\n\\nIf the starting time of current clips is later than current furthest ending time, then stitching is not doable since none of the rest clips\\' starting time is earlier. Once furthest ending time >= T, we have finished video stitching.\\n\\nAnd to get the minimal number of clips we need, we need to remove all unncessary clips during the scan. \\nSuppose we already have clips ```[s0, e0]``` and next two clips are ```[s1, e1]``` and ```[s2, e2]```. If ```s2 <= e0```, then ```s0 <= s1 <= s2 <= e0 ``` and only one of two clips are needed. Thus, we use ```prev_end``` to store ```e0``` and each time ```s <= prev_end```, we don\\'t add up ```cnt```. Othwise, we have to add one more clip and update ```prev_end``` accordingly. The furthest ending time just gets updated each time as ```max(furthest_end, e)```.\\n```\\ndef videoStitching(clips, T):\\n\\tprev_end, end, cnt = -1, 0, 0\\n\\tfor i, j in sorted(clips):\\n\\t\\tif i > end or end >= T: break\\n\\t\\tif prev_end < i <= end: prev_end, cnt = end, cnt + 1\\n\\t\\tend = max(end, j)\\n\\treturn cnt if end >= T else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[s0, e0]```\n```[s1, e1]```\n```[s2, e2]```\n```s2 <= e0```\n```s0 <= s1 <= s2 <= e0 ```\n```prev_end```\n```e0```\n```s <= prev_end```\n```cnt```\n```prev_end```\n```max(furthest_end, e)```\n```\\ndef videoStitching(clips, T):\\n\\tprev_end, end, cnt = -1, 0, 0\\n\\tfor i, j in sorted(clips):\\n\\t\\tif i > end or end >= T: break\\n\\t\\tif prev_end < i <= end: prev_end, cnt = end, cnt + 1\\n\\t\\tend = max(end, j)\\n\\treturn cnt if end >= T else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 270149,
                "title": "c-dp-solution-very-similar-to-minimum-number-of-refueling-stops",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        int i, j;\\n        /*\\n            dp[i] refers to the furthest valid duration that could be\\n            gained with i clips\\n            dp[i] = max(dp[i-1], clips[j][1] which clips[j][0] <= dp[i])\\n        */\\n        \\n        vector<int> dp = vector<int>(n + 1, -1);\\n        dp[0] = 0;\\n        for (i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1];\\n            for (j = 0; j < n; j++) {\\n                if (clips[j][0] <= dp[i-1]) {\\n                    dp[i] = max(dp[i], clips[j][1]);\\n                }\\n            }\\n        }\\n        /*\\n\\t\\t\\twe get the smallest i such that dp[i] >= T\\n\\t\\t*/\\n        for (i = 1; i <= n; i++) {\\n            if (dp[i] >= T) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        int i, j;\\n        /*\\n            dp[i] refers to the furthest valid duration that could be\\n            gained with i clips\\n            dp[i] = max(dp[i-1], clips[j][1] which clips[j][0] <= dp[i])\\n        */\\n        \\n        vector<int> dp = vector<int>(n + 1, -1);\\n        dp[0] = 0;\\n        for (i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1];\\n            for (j = 0; j < n; j++) {\\n                if (clips[j][0] <= dp[i-1]) {\\n                    dp[i] = max(dp[i], clips[j][1]);\\n                }\\n            }\\n        }\\n        /*\\n\\t\\t\\twe get the smallest i such that dp[i] >= T\\n\\t\\t*/\\n        for (i = 1; i <= n; i++) {\\n            if (dp[i] >= T) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270070,
                "title": "easy-solution-with-step-by-step-explanation",
                "content": "Take clips with maximum  ends at time one by one\\nFor example, `clips = [[0,2],[4,6],[0,1],[8,10],[1,9],[1,5],[5,9],[1,3]], T = 10`\\nLet\\'s set `start=0`\\n1. We take `[0,2]`, because it has maximum ends time between the clips (`[0,2],[0,1]`) whose starts are smaller or equal to `start` (which is `0` by now). set `start=2` end time of the selected clip(`[0,2]`)\\n2. Now we take `[1,9]`, since it has maximum ends time (`9`) between the clips whose starts are smaller or equal to `start` (which is `2` by now). set `start=9`\\n3. Finally, we take `[8,10]` with the same reason above.\\nResult is `3`.\\n```\\nvar videoStitching = function(clips, T) {\\n  let canCover = false;\\n  for(let i=0;i<clips.length;i++) {\\n    if(clips[i][1]>=T) canCover = true;\\n  }\\n  if(!canCover) return -1;\\n  \\n  let start = 0, s=0;\\n  while(start<T) {\\n    let max=-1, index=-1;\\n    for(let i=0;i<clips.length;i++) {\\n      if(clips[i][0]<=start && max<clips[i][1]) {\\n        max = clips[i][1];\\n        index = i;\\n      }\\n    }\\n    if(index==-1) return -1;\\n    start = clips[index][1];\\n    //console.log(start,clips[index],s);\\n    s++;\\n  }\\n  return s;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar videoStitching = function(clips, T) {\\n  let canCover = false;\\n  for(let i=0;i<clips.length;i++) {\\n    if(clips[i][1]>=T) canCover = true;\\n  }\\n  if(!canCover) return -1;\\n  \\n  let start = 0, s=0;\\n  while(start<T) {\\n    let max=-1, index=-1;\\n    for(let i=0;i<clips.length;i++) {\\n      if(clips[i][0]<=start && max<clips[i][1]) {\\n        max = clips[i][1];\\n        index = i;\\n      }\\n    }\\n    if(index==-1) return -1;\\n    start = clips[index][1];\\n    //console.log(start,clips[index],s);\\n    s++;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269964,
                "title": "python-solution-based-on-sorting-and-end-time",
                "content": "The solution is a bit similar to 435. https://leetcode.com/problems/non-overlapping-intervals/\\n\\nThe idea is, to keep gathering intervals in a result list.\\n\\nthe different cases are:\\n\\n1. If the interval is covering a point not covered by the result list, add it to the result.\\n2. If its leaving a gap, then we cant fill that gap, hence return -1\\n3. If its overlapping, based on end time, \\n\\ta) we can either discard this one, or \\n\\tb) include this one and replace the last interval of the result or\\n\\tc) append this one \\n```\\n    def videoStitching(self, clips, T):\\n        timepoint = namedtuple(\\'timepoint\\', [\\'start\\', \\'end\\'])\\n        times = sorted([timepoint(clip[0], clip[1]) for i, clip in enumerate(clips)])\\n        res = [times[0]]\\n        for time in times:\\n            if res[-1].end >= T or time.start > res[-1].end:\\n                break\\n            if time.start == res[-1].start and time.end > res[-1].end:\\n                res[-1] = time\\n            elif time.end <= res[-1].end:\\n                continue\\n            elif time.start <= res[-1].start:\\n                res[-1] = timepoint(res[-1].start, time.end)\\n            else:\\n                res.append(timepoint(res[-1].end, time.end))\\n        return len(res) if res[0].start == 0 and res[-1].end >= T else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def videoStitching(self, clips, T):\\n        timepoint = namedtuple(\\'timepoint\\', [\\'start\\', \\'end\\'])\\n        times = sorted([timepoint(clip[0], clip[1]) for i, clip in enumerate(clips)])\\n        res = [times[0]]\\n        for time in times:\\n            if res[-1].end >= T or time.start > res[-1].end:\\n                break\\n            if time.start == res[-1].start and time.end > res[-1].end:\\n                res[-1] = time\\n            elif time.end <= res[-1].end:\\n                continue\\n            elif time.start <= res[-1].start:\\n                res[-1] = timepoint(res[-1].start, time.end)\\n            else:\\n                res.append(timepoint(res[-1].end, time.end))\\n        return len(res) if res[0].start == 0 and res[-1].end >= T else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307648,
                "title": "from-recursion-to-dp-greedy-5-solutions-java",
                "content": "**Solutions**\\nN = size of clips array\\nT = time\\n\\n**1. Recursion**\\nTime complexity: O(2^N)\\nSpace complexity: O(N)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size) {\\n        // base case\\n        if (time == 0) {\\n            return 0;\\n        }\\n        else if (size == 0) {\\n            return -1;\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**2. Memoization (Top-Down)**\\nTime complexity: O(N * T)\\nSpace complexity: O(N * T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length, dp);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size, Integer[][] dp) {\\n        // check dp table\\n        if (dp[time][size] != null) {\\n            return dp[time][size];\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1, dp);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1, dp);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        // update dp table\\n        dp[time][size] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n**3. Tabulation (Bottom-Up)**\\nTime complexity: O(N * T)\\nSpace complexity: O(N * T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int t = 1; t <= time; t++) {\\n            for (int s = 1; s <= clips.length; s++) {\\n                // skip the current clip\\n                int skip = dp[t][s - 1];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = dp[newClip[0]][s - 1];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t][s] = res;\\n            }\\n        }\\n        \\n        return dp[time][clips.length];\\n    }\\n}\\n```\\n\\n**4. Tabulation (Bottom-Up) with Space Optimization**\\nTime complexity: O(N * T)\\nSpace complexity: O(T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[] dp = new Integer[time + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int s = 1; s <= clips.length; s++) {\\n            Integer[] prevDp = dp;\\n            dp = new Integer[time + 1];\\n            \\n            for (int t = 0; t <= time; t++) {\\n                if (t == 0) {\\n                    dp[t] = 0;\\n                    continue;\\n                }\\n                \\n                // skip the current clip\\n                int skip = prevDp[t];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = prevDp[newClip[0]];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t] = res;\\n            }\\n        }\\n        \\n        return dp[time];\\n    }\\n}\\n```\\n\\n**5. Greedy**\\nTime complexity: O(NlogN)\\nSpace complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //sort array by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        int cur = 0;\\n        int low = 0;\\n        int count = 0;\\n        while (cur < clips.length && clips[cur][0] <= low && low < time) {\\n            int maxUp = 0;\\n            \\n            while (cur < clips.length && clips[cur][0] <= low) {\\n                maxUp = Math.max(maxUp, clips[cur][1]);\\n                cur++;\\n            }\\n            \\n            count++;\\n            low = maxUp;\\n        }\\n        \\n        return low >= time ? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size) {\\n        // base case\\n        if (time == 0) {\\n            return 0;\\n        }\\n        else if (size == 0) {\\n            return -1;\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length, dp);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size, Integer[][] dp) {\\n        // check dp table\\n        if (dp[time][size] != null) {\\n            return dp[time][size];\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1, dp);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1, dp);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        // update dp table\\n        dp[time][size] = res;\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int t = 1; t <= time; t++) {\\n            for (int s = 1; s <= clips.length; s++) {\\n                // skip the current clip\\n                int skip = dp[t][s - 1];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = dp[newClip[0]][s - 1];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t][s] = res;\\n            }\\n        }\\n        \\n        return dp[time][clips.length];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[] dp = new Integer[time + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int s = 1; s <= clips.length; s++) {\\n            Integer[] prevDp = dp;\\n            dp = new Integer[time + 1];\\n            \\n            for (int t = 0; t <= time; t++) {\\n                if (t == 0) {\\n                    dp[t] = 0;\\n                    continue;\\n                }\\n                \\n                // skip the current clip\\n                int skip = prevDp[t];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = prevDp[newClip[0]];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t] = res;\\n            }\\n        }\\n        \\n        return dp[time];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //sort array by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        int cur = 0;\\n        int low = 0;\\n        int count = 0;\\n        while (cur < clips.length && clips[cur][0] <= low && low < time) {\\n            int maxUp = 0;\\n            \\n            while (cur < clips.length && clips[cur][0] <= low) {\\n                maxUp = Math.max(maxUp, clips[cur][1]);\\n                cur++;\\n            }\\n            \\n            count++;\\n            low = maxUp;\\n        }\\n        \\n        return low >= time ? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195564,
                "title": "recursion-memoization-in-c",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n    {\\n        if(T<=last_end)\\n            return 0;\\n        if(idx>=clips.size() )\\n            return 100;\\n        if(dp[last_end]!=-1)\\n            return dp[last_end];\\n         if(clips[idx][0]<=last_end)\\n        {\\n            return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n        }\\n        else\\n        {\\n            return dp[last_end]=100;\\n        }\\n           \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T)\\n    {\\n        dp.resize(T+1,-1);\\n        sort(clips.begin(),clips.end());\\n        int p=solve(clips,T,0,0);\\n        if(p>=100)\\n            return -1;\\n        else\\n            return p;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n    {\\n        if(T<=last_end)\\n            return 0;\\n        if(idx>=clips.size() )\\n            return 100;\\n        if(dp[last_end]!=-1)\\n            return dp[last_end];\\n         if(clips[idx][0]<=last_end)\\n        {\\n            return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 466261,
                "title": "python-short-dp-solution-with-explanation",
                "content": "Define `dp(i)` as the minimum number of clips needed to cover `[0, i]` sporting event.\\nWe\\'ll get the recursion below:\\n`dp(i) = min(dp(j) + 1, dp(i)) if the clip covers [j, i] exists`\\n\\n```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [float(\\'inf\\')] * (T + 1)\\n        dp[0] = 0\\n        for i in range(1, T + 1):\\n            for start, end in clips:\\n                if start <= i <= end:\\n                    dp[i] = min(dp[start] + 1, dp[i])\\n        if dp[T] == float(\\'inf\\'):\\n            return -1\\n        return dp[T]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [float(\\'inf\\')] * (T + 1)\\n        dp[0] = 0\\n        for i in range(1, T + 1):\\n            for start, end in clips:\\n                if start <= i <= end:\\n                    dp[i] = min(dp[start] + 1, dp[i])\\n        if dp[T] == float(\\'inf\\'):\\n            return -1\\n        return dp[T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270054,
                "title": "java-simple-solution-without-sorting",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dic = new int[T+1];\\n        Arrays.fill(dic,-1);\\n        for(int j = 0; j < clips.length; j++){\\n            for(int i = clips[j][0]; i <= Math.min(T,clips[j][1]); i++) dic[i]=Math.max(dic[i],clips[j][1]);\\n        }        \\n        for(int i = 0; i <= T; i++){\\n            if(dic[i]==-1) return -1;\\n        }\\n        int cur = 0;\\n        int ans = 0;\\n        int max = 0;\\n        while(max<T){\\n            max= dic[cur];\\n            ans++;\\n            cur = max;\\n        } \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dic = new int[T+1];\\n        Arrays.fill(dic,-1);\\n        for(int j = 0; j < clips.length; j++){\\n            for(int i = clips[j][0]; i <= Math.min(T,clips[j][1]); i++) dic[i]=Math.max(dic[i],clips[j][1]);\\n        }        \\n        for(int i = 0; i <= T; i++){\\n            if(dic[i]==-1) return -1;\\n        }\\n        int cur = 0;\\n        int ans = 0;\\n        int max = 0;\\n        while(max<T){\\n            max= dic[cur];\\n            ans++;\\n            cur = max;\\n        } \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032762,
                "title": "python-3-11-lines-w-explanation-t-m-98-81",
                "content": "Here\\'s the plan:\\n- We sort `clip` by increasing `start` and then by decreasing `end` for those clips with same `start`.\\n- We initiate `t` to keep track of the`end`of the most recent clip we use. If and when `t` equals or exceeds `time`, we return the number of clips. If we run out of clips before that happens, then we return `-1`.\\n- We iterate through clips. First, grabbing the initial clip in the sorted list. Second, we discard all clips that end before that clip\\'s`end`. \\n- Third, we acrete all clips that start before `t` in `cSet`and then select from`cSet`the clip with the greatest`end`as the new most recent clip.\\n- Fouth, we increment`ans`, flush`cSet`, and check whether we are finished.\\n\\nNote: Originally I checked whether a clip starting at zero did actually exist, but the code passed without the check, so I removed it.\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        clips.sort(key = lambda x: (x[0],-x[1]))\\n        t, cSet, ans = 0, set(), 0\\n\\n        while clips:\\n            while clips and clips[0][1] <= t: clips.pop(0)\\n            while clips and clips[0][0] <= t: cSet.add(clips.pop(0)[1])\\n\\n            if clips and not cSet: return -1\\n            t = max(cSet)\\n            ans+= 1\\n            if t >= time: return ans \\n            cSet.clear()\\n\\n        return -1\\n```\\n[https://leetcode.com/problems/video-stitching/submissions/875736467/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is worstcase *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        clips.sort(key = lambda x: (x[0],-x[1]))\\n        t, cSet, ans = 0, set(), 0\\n\\n        while clips:\\n            while clips and clips[0][1] <= t: clips.pop(0)\\n            while clips and clips[0][0] <= t: cSet.add(clips.pop(0)[1])\\n\\n            if clips and not cSet: return -1\\n            t = max(cSet)\\n            ans+= 1\\n            if t >= time: return ans \\n            cSet.clear()\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834720,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr = new int[T+1];\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int left = Math.min(T, clips[i][0]);\\n            int right = clips[i][1];\\n            \\n            arr[left] = Math.max(arr[left], right);\\n        }\\n        int currEnd = 0, currFarthest = 0, jumps = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            if(i > currFarthest)return -1;\\n            \\n            currFarthest = Math.max(currFarthest, arr[i]);\\n            \\n            if(i == currEnd && i != T){\\n                currEnd = currFarthest;\\n                jumps++;\\n            }\\n        }\\n        //if(currFarthest < T)return -1;\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr = new int[T+1];\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int left = Math.min(T, clips[i][0]);\\n            int right = clips[i][1];\\n            \\n            arr[left] = Math.max(arr[left], right);\\n        }\\n        int currEnd = 0, currFarthest = 0, jumps = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            if(i > currFarthest)return -1;\\n            \\n            currFarthest = Math.max(currFarthest, arr[i]);\\n            \\n            if(i == currEnd && i != T){\\n                currEnd = currFarthest;\\n                jumps++;\\n            }\\n        }\\n        //if(currFarthest < T)return -1;\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806748,
                "title": "c-greedy-sorting-clean-code-similar-to-leetcode-1326",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 284998,
                "title": "python-timeline-solution-easy-to-understand",
                "content": "Create a Timeline list, the index is each second of starting time, value is the largest end time can be reached at this second. Search the maximum of each starting-ending interval till the end or stay fixed. \\n```\\n        //input: [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T=10\\n\\t\\t\\n        maxlen = max([i[1] for i in clips])\\n        timeline = [0]*(maxlen+1)\\n        for clipstart, clipend in clips:\\n            timeline[clipstart] = max(timeline[clipstart], clipend)\\n\\t\\t\\t\\n        //Timeline looks like: [2, 9, 0, 0, 6, 9, 0, 0, 10, 0, 0]\\n        \\n        if timeline[0] == 0: return -1\\n        start = 0; end = timeline[0]; times = 1\\n        \\n        while end < T:\\n            maxpos, maxval = max(enumerate(timeline[start:end+1]), key=lambda x: x[1])\\n            if maxval > end:\\n                end = maxval\\n                start = maxpos\\n                times += 1\\n            else:\\n                return -1\\n        return times",
                "solutionTags": [
                    "Python"
                ],
                "code": "Create a Timeline list, the index is each second of starting time, value is the largest end time can be reached at this second. Search the maximum of each starting-ending interval till the end or stay fixed. \\n```\\n        //input: [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T=10\\n\\t\\t\\n        maxlen = max([i[1] for i in clips])\\n        timeline = [0]*(maxlen+1)\\n        for clipstart, clipend in clips:\\n            timeline[clipstart] = max(timeline[clipstart], clipend)\\n\\t\\t\\t\\n        //Timeline looks like: [2, 9, 0, 0, 6, 9, 0, 0, 10, 0, 0]\\n        \\n        if timeline[0] == 0: return -1\\n        start = 0; end = timeline[0]; times = 1\\n        \\n        while end < T:\\n            maxpos, maxval = max(enumerate(timeline[start:end+1]), key=lambda x: x[1])\\n            if maxval > end:\\n                end = maxval\\n                start = maxpos\\n                times += 1\\n            else:\\n                return -1\\n        return times",
                "codeTag": "Unknown"
            },
            {
                "id": 275270,
                "title": "c-beat-100-100",
                "content": "```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        int cnt = 0, cur_end = 0, pre_end = -1;\\n        for(auto& v:clips){\\n            if(v[1] <= cur_end) continue;\\n            if(v[0] > cur_end) return -1;          \\n            if(v[0] > pre_end){\\n                pre_end = cur_end;\\n                cnt++;\\n            }\\n            cur_end = v[1];           \\n            if(cur_end >= T) return cnt;            \\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        int cnt = 0, cur_end = 0, pre_end = -1;\\n        for(auto& v:clips){\\n            if(v[1] <= cur_end) continue;\\n            if(v[0] > cur_end) return -1;          \\n            if(v[0] > pre_end){\\n                pre_end = cur_end;\\n                cnt++;\\n            }\\n            cur_end = v[1];           \\n            if(cur_end >= T) return cnt;            \\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1746819,
                "title": "easy-greedy-solution-c",
                "content": "![image](https://assets.leetcode.com/users/images/1fc7b07e-5d48-420a-9c57-dbfd58d71e4c_1644070483.8811798.jpeg)\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/bda1f9a9-eb8c-40f8-b33f-91c87a7ecc09_1644070483.9485135.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        int min=0, max=0, ans=0;\\n        \\n        while(max<time)\\n        {\\n            for(int i=0; i<clips.size(); i++)\\n            {\\n                int left=clips[i][0];\\n                int right=clips[i][1];\\n                \\n                if(left <= min && right> max)\\n                    max=right;\\n            }\\n            \\n            if(min==max)\\n                return -1;\\n            \\n            min=max;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        int min=0, max=0, ans=0;\\n        \\n        while(max<time)\\n        {\\n            for(int i=0; i<clips.size(); i++)\\n            {\\n                int left=clips[i][0];\\n                int right=clips[i][1];\\n                \\n                if(left <= min && right> max)\\n                    max=right;\\n            }\\n            \\n            if(min==max)\\n                return -1;\\n            \\n            min=max;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790479,
                "title": "javascript-solution-greedy-approach",
                "content": "```\\nvar videoStitching = function(clips, T) {\\n    const n = clips.length;\\n    \\n    clips.sort((a, b) => a[0] - b[0]);\\n    \\n    let stitching_start = 0;\\n    let stitching_end = 0;\\n    let videos_used = 0;\\n    let index = 0;\\n    \\n    while (stitching_start < T) {\\n        while (index < n && clips[index][0] <= stitching_start) { // find the longest video that starts before our stitching_start\\n            stitching_end = Math.max(stitching_end, clips[index][1]);\\n            index++;\\n        }\\n        if (stitching_start == stitching_end) return -1; // made no advancement\\n        \\n        videos_used++;\\n        stitching_start = stitching_end;\\n    }\\n    \\n    return videos_used;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar videoStitching = function(clips, T) {\\n    const n = clips.length;\\n    \\n    clips.sort((a, b) => a[0] - b[0]);\\n    \\n    let stitching_start = 0;\\n    let stitching_end = 0;\\n    let videos_used = 0;\\n    let index = 0;\\n    \\n    while (stitching_start < T) {\\n        while (index < n && clips[index][0] <= stitching_start) { // find the longest video that starts before our stitching_start\\n            stitching_end = Math.max(stitching_end, clips[index][1]);\\n            index++;\\n        }\\n        if (stitching_start == stitching_end) return -1; // made no advancement\\n        \\n        videos_used++;\\n        stitching_start = stitching_end;\\n    }\\n    \\n    return videos_used;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582535,
                "title": "c-greedy-solution-faster-than-100-100-less-memory",
                "content": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n      int S = 0;\\n        int end = 0;\\n        int count = 0;\\n        while(end<T){\\n        S= end;\\n        int temp = end;\\n        for(int i = 0;i<clips.size();i++){\\n            if(clips[i][0]<=S )\\n            end = max(end,clips[i][1]);\\n        }\\n        if(end == temp )\\n            return -1;\\n        cout<<end<<endl;\\n        count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n      int S = 0;\\n        int end = 0;\\n        int count = 0;\\n        while(end<T){\\n        S= end;\\n        int temp = end;\\n        for(int i = 0;i<clips.size();i++){\\n            if(clips[i][0]<=S )\\n            end = max(end,clips[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 392489,
                "title": "java-dp-no-magic-code",
                "content": "```\\n// dp[T] - holds the minimum number of clips required to get the T seconds clip length\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, T + 1); // fill with T + 1 to respect Math.min\\n        dp[0] = 0;\\n        for(int videoLen=1; videoLen <= T; videoLen++){\\n            for(int c=0; c < clips.length; c++){\\n                int clipStart = clips[c][0];\\n                int cliepEnd = clips[c][1];\\n                if(clipStart <= videoLen && cliepEnd >= videoLen){\\n                    dp[videoLen] = Math.min(dp[videoLen], 1 + dp[clipStart]);\\n                }\\n            }\\n        }\\n        return dp[T] == T+1 ? -1 : dp[T];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// dp[T] - holds the minimum number of clips required to get the T seconds clip length\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, T + 1); // fill with T + 1 to respect Math.min\\n        dp[0] = 0;\\n        for(int videoLen=1; videoLen <= T; videoLen++){\\n            for(int c=0; c < clips.length; c++){\\n                int clipStart = clips[c][0];\\n                int cliepEnd = clips[c][1];\\n                if(clipStart <= videoLen && cliepEnd >= videoLen){\\n                    dp[videoLen] = Math.min(dp[videoLen], 1 + dp[clipStart]);\\n                }\\n            }\\n        }\\n        return dp[T] == T+1 ? -1 : dp[T];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270909,
                "title": "easy-python-dp-solution",
                "content": "\\n```\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [T+1]*(T+1)\\n        dp[0] = 0\\n        \\n        for i in range(T+1):\\n            for clip in clips:\\n                if i>= clip[0] and i<=clip[1]:\\n                    dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if dp[i] == T+1:\\n                return -1\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [T+1]*(T+1)\\n        dp[0] = 0\\n        \\n        for i in range(T+1):\\n            for clip in clips:\\n                if i>= clip[0] and i<=clip[1]:\\n                    dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if dp[i] == T+1:\\n                return -1\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1650889,
                "title": "lessons-learned",
                "content": "**A problem that has many different approaches**. \\n\\n* **Bruteforce**: **Backtracking** approach by maintaining a clipCount and choose to pick a clip and don\\'t pick a clip. O(2^n) time ans O(n) space\\n* **Dp - non LIS (tricky in identifying dp parameters)**:\\n \\xA0* Defining the parameters of overlapping states is tricky here. \\n \\xA0* Initially, I used 1d dp[] caching on current video index. This is obviously wrong since there are 2 dynamic parameters \\'current clip index\\' and \\'previous clip end time\\'. **Always cache on dynamic parameters of the state**. Thus understood dp is 2d here.  \\n \\xA0* But then the code should be modified. The final answer shouldn\\'t be dp[0th clip][having 0 start time]. Instead should be dp[any clip][having 0 start time] due to the fact that there might be multiple source nodes (clips with 0 as start time). Thus a for loop in the final seems required.\\n \\xA0 * An good to note optimization here is\\xA0the current clip index is not a relevant parameter for dp. Only previous clip end time is enough. Thus reducing dp from 2d to 1d.\\nReason (not sure if this is the teal reason): at any current clip index, that index also happens to be neglected. At this time only previous clip end time is really valued. (Unclear, gotta redo)\\n* **Dp - LIS**: \\n \\xA0* O(n\\xB2) time and O(n) space. Maybe improved to O(nlogn) time using BS instead of linear search. Gotta check though.\\n * \\xA0[Reference](https://leetcode.com/problems/video-stitching/discuss/1265887/Java-LIS-DP-Solution)\\n* \\xA0**Greedy**: Most optimal. Similar to [min refuel stops](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/) \\n* \\xA0**BFS**: since requirement is shortest path, solvable via bfs\\n* \\xA0**Binary search on answer space**: Not sure, but I feel so.\\n\\n**Code**:\\n```\\n// Dp: Optimized version of bactracking - Pick Or Don\\'t pick\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int clipLength = clips.length;\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        System.out.println(Arrays.deepToString(clips));\\n        int[] dp = new int[101];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int index = 0;\\n        int prevClipEndTime = 0;\\n        int minimumClipsRequired = f(clips, time, dp, index, prevClipEndTime);\\n        return minimumClipsRequired;\\n    }\\n    \\n    private int f(int[][] clips, int targetTime, int[] dp, int index, int prevClipEndTime) {\\n        // BASE\\n        if (prevClipEndTime >= targetTime) return 0;\\n        if (index >= clips.length) return -1;\\n        if (prevClipEndTime < clips[index][0]) return -1;\\n        \\n        // CACHE OUT\\n        if (dp[prevClipEndTime] != Integer.MAX_VALUE) return dp[prevClipEndTime];\\n        \\n        // OPTIMAL SUBSTRUCTURE\\n        int min = Integer.MAX_VALUE;\\n        int val = f(clips, targetTime, dp, index + 1, clips[index][1]); // Pick clip\\n        if (val != -1) min = Math.min(min, val + 1);\\n        \\n        val = f(clips, targetTime, dp, index + 1, prevClipEndTime); // Dont pick clip\\n        if (val != -1) min = Math.min(min, val);\\n        \\n        // CACHE IN\\n        dp[prevClipEndTime] = min == Integer.MAX_VALUE ? -1 : min;\\n        \\n        // RETURN\\n        return dp[prevClipEndTime];\\n    }\\n}\\n/*\\n[[0,2],[2,6],[0,3],[6,9]]\\n9\\n*/\\n```\\n\\n```\\n// LIS\\nclass Solution {\\npublic int videoStitching(int[][] clips, int T) {\\n\\n    Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n    \\n    //Finding maximum end time\\n    int max_end=-1;\\n    for(int i=0;i<clips.length;i++){\\n        max_end = Math.max(max_end, clips[i][1]);\\n    }\\n    \\n    //if end time is Less than Target time we can\\'t cover\\n    if(max_end < T){\\n        return -1;\\n    }\\n    \\n    \\n    int dp[] = new int[clips.length];\\n    Arrays.fill(dp, clips.length+1);\\n    // As start time is always 0 so marking clips with start time 0 as 1 in dp table \\n    // which means this can be considered.\\n    for(int i=0;i<clips.length;i++){\\n        if(clips[i][0] == 0){\\n            dp[i] = 1;\\n        }\\n    }\\n    // More or less it is same as LIS only difference is we are merging the intervals and\\n\\t// looking for minimum instead of Maximum.\\n    // Example two clips [0,2] [1,4] => it can be joined if 2 >= 1 and 4 >=2\\n    // Example two clips [0,1] [4,5] => it can\\'t be joined as 1 is not >= 4\\n    \\n    for(int i=1;i<clips.length;i++){\\n        for(int j=0;j<i;j++){\\n            int a = clips[j][0];\\n            int b = clips[j][1];\\n            int c = clips[i][0];\\n            int d = clips[i][1];       \\n            if(b >= c && d>=b){\\n                dp[i] = Math.min(dp[i],dp[j]+1);\\n            }\\n        }\\n    }\\n    \\n    //To get the answer we see if target time is in bounds of clip and search for minimum.\\n        \\n    int ans=clips.length+1;\\n    for(int j= clips.length-1;j>=0;j--){\\n        int a = clips[j][0];\\n        int b = clips[j][1];\\n        if(T >= a && T<=b){\\n            ans = Math.min(ans,dp[j]);\\n        }\\n    }\\n    \\nreturn ans == clips.length+1 ? -1:ans;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Dp: Optimized version of bactracking - Pick Or Don\\'t pick\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int clipLength = clips.length;\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        System.out.println(Arrays.deepToString(clips));\\n        int[] dp = new int[101];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int index = 0;\\n        int prevClipEndTime = 0;\\n        int minimumClipsRequired = f(clips, time, dp, index, prevClipEndTime);\\n        return minimumClipsRequired;\\n    }\\n    \\n    private int f(int[][] clips, int targetTime, int[] dp, int index, int prevClipEndTime) {\\n        // BASE\\n        if (prevClipEndTime >= targetTime) return 0;\\n        if (index >= clips.length) return -1;\\n        if (prevClipEndTime < clips[index][0]) return -1;\\n        \\n        // CACHE OUT\\n        if (dp[prevClipEndTime] != Integer.MAX_VALUE) return dp[prevClipEndTime];\\n        \\n        // OPTIMAL SUBSTRUCTURE\\n        int min = Integer.MAX_VALUE;\\n        int val = f(clips, targetTime, dp, index + 1, clips[index][1]); // Pick clip\\n        if (val != -1) min = Math.min(min, val + 1);\\n        \\n        val = f(clips, targetTime, dp, index + 1, prevClipEndTime); // Dont pick clip\\n        if (val != -1) min = Math.min(min, val);\\n        \\n        // CACHE IN\\n        dp[prevClipEndTime] = min == Integer.MAX_VALUE ? -1 : min;\\n        \\n        // RETURN\\n        return dp[prevClipEndTime];\\n    }\\n}\\n/*\\n[[0,2],[2,6],[0,3],[6,9]]\\n9\\n*/\\n```\n```\\n// LIS\\nclass Solution {\\npublic int videoStitching(int[][] clips, int T) {\\n\\n    Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n    \\n    //Finding maximum end time\\n    int max_end=-1;\\n    for(int i=0;i<clips.length;i++){\\n        max_end = Math.max(max_end, clips[i][1]);\\n    }\\n    \\n    //if end time is Less than Target time we can\\'t cover\\n    if(max_end < T){\\n        return -1;\\n    }\\n    \\n    \\n    int dp[] = new int[clips.length];\\n    Arrays.fill(dp, clips.length+1);\\n    // As start time is always 0 so marking clips with start time 0 as 1 in dp table \\n    // which means this can be considered.\\n    for(int i=0;i<clips.length;i++){\\n        if(clips[i][0] == 0){\\n            dp[i] = 1;\\n        }\\n    }\\n    // More or less it is same as LIS only difference is we are merging the intervals and\\n\\t// looking for minimum instead of Maximum.\\n    // Example two clips [0,2] [1,4] => it can be joined if 2 >= 1 and 4 >=2\\n    // Example two clips [0,1] [4,5] => it can\\'t be joined as 1 is not >= 4\\n    \\n    for(int i=1;i<clips.length;i++){\\n        for(int j=0;j<i;j++){\\n            int a = clips[j][0];\\n            int b = clips[j][1];\\n            int c = clips[i][0];\\n            int d = clips[i][1];       \\n            if(b >= c && d>=b){\\n                dp[i] = Math.min(dp[i],dp[j]+1);\\n            }\\n        }\\n    }\\n    \\n    //To get the answer we see if target time is in bounds of clip and search for minimum.\\n        \\n    int ans=clips.length+1;\\n    for(int j= clips.length-1;j>=0;j--){\\n        int a = clips[j][0];\\n        int b = clips[j][1];\\n        if(T >= a && T<=b){\\n            ans = Math.min(ans,dp[j]);\\n        }\\n    }\\n    \\nreturn ans == clips.length+1 ? -1:ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272690,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        int st=0,end=0,ans=1;\\n        sort(clips.begin(),clips.end());\\n        for(int i=0;i<n;i++){\\n            if(st>=clips[i][0]){\\n                end=max(end,clips[i][1]);\\n            }\\n            else{\\n                if(end>=time)\\n                    return ans;\\n                if(end<clips[i][0])\\n                    return -1;\\n                i--;\\n                st=end;\\n                ans++;\\n            }\\n        }\\n        if(end<time)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        int st=0,end=0,ans=1;\\n        sort(clips.begin(),clips.end());\\n        for(int i=0;i<n;i++){\\n            if(st>=clips[i][0]){\\n                end=max(end,clips[i][1]);\\n            }\\n            else{\\n                if(end>=time)\\n                    return ans;\\n                if(end<clips[i][0])\\n                    return -1;\\n                i--;\\n                st=end;\\n                ans++;\\n            }\\n        }\\n        if(end<time)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117847,
                "title": "java-clean-o-n-greedy-solution-with-useful-comments",
                "content": "This problem is basically Leetcode 45. Jump Game II but construct the array (lastUntil in the solution here) by ourselves. Before you solving this problem, I strongly recommand to get familiar with these \"prototype\" questions or revisit the solutions.\\n\\n* [55. Jump Game](https://leetcode.com/problems/jump-game/discuss/1117827/Java-clean-O(N)-time-O(1)-space-Greedy-Solution-oror-with-detailed-comments)\\n* [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/discuss/1117791/Java-O(1)-space-Greedy-Solution-oror-with-detailed-comments)\\n\\nOr we may check a maybe slightly harder question:\\n* [1326. Minimum Number of Taps to Open to Water a Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/1117822/Java-clean-O(n)-Greedy-Solution-oror-with-detailed-comments)\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if (T == 0) return 0;\\n        \\n        /* \\n        The array lastUntil is defined as follows: \\n        \\n        lastUntil[i] = j means assuming time [0: i-1] has been covered by some clips, \\n        j is the \"furthest\" time stamp s.t. we may add 1 more clip and cover time[i : j]  \\n        \\n        */\\n        int[] lastUntil = new int[T+1];\\n        Arrays.fill(lastUntil, -1);\\n        \\n        for (int[] clip : clips) {\\n            int start = clip[0], end = clip[1];\\n            if (start > T) continue;\\n            \\n            lastUntil[start] = Math.max(lastUntil[start], Math.min(end, T));\\n        }\\n        \\n        // far : the \"furthest\" time stamp we can cover with c clips\\n        // initially we have 1 clip, covering the time [0, lastUntil[0]]\\n        int far = lastUntil[0];\\n        int c = 1;\\n        \\n        if (far == T) return 1;\\n        \\n        // find \"furthest\" time stamp we can cover with c+1 clips\\n        int next = 0;\\n        \\n        for (int i = 0; i <= T; i++) {\\n            if (i > far) return -1;\\n            \\n            next = Math.max(next, lastUntil[i]);\\n            if (next >= T) return c+1;\\n            \\n            if (i == far) {\\n                far = next;\\n                c++;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if (T == 0) return 0;\\n        \\n        /* \\n        The array lastUntil is defined as follows: \\n        \\n        lastUntil[i] = j means assuming time [0: i-1] has been covered by some clips, \\n        j is the \"furthest\" time stamp s.t. we may add 1 more clip and cover time[i : j]  \\n        \\n        */\\n        int[] lastUntil = new int[T+1];\\n        Arrays.fill(lastUntil, -1);\\n        \\n        for (int[] clip : clips) {\\n            int start = clip[0], end = clip[1];\\n            if (start > T) continue;\\n            \\n            lastUntil[start] = Math.max(lastUntil[start], Math.min(end, T));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1065994,
                "title": "one-test-case-is-wrong",
                "content": "When the input clips is  [[2,4]] and T is 0 or 1.\\nwho know why the expected result is 0?\\nShould not the expected value be -1? \\nIt can be trigered by code\\n```\\n   \\n   public static int videoStitching(int[][] clips, int T) {\\n   if (clips == null || clips.length == 0) return -1;\\n    int N = clips.length;\\n    Arrays.sort(clips, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\tif (T==0) return 0; //  With this line, it is accepted. But result should be -1 meaning no solution, or result>=1 meaning the minimum clips number.  0 does not make any sense. \\n    if (0 < clips[0][0]) return -1; \\n    int result = 0;\\n    int l = 0, r = 0;\\n    for (int i = 0; i < clips.length; l = r, result++) {\\n      for (; i < clips.length && clips[i][0] <= l; i++) {\\n        r = Math.max(r, clips[i][1]);\\n      }\\n      if (r == l && r < T) return -1;\\n      if (r >= T) return ++result;\\n    }\\n    return r < T ? -1 : result;\\n  }\\n```\\n\\nIf clips is [[0,0]], and T is 0.\\nThe right expected should be 1, not 0. Right?",
                "solutionTags": [],
                "code": "```\\n   \\n   public static int videoStitching(int[][] clips, int T) {\\n   if (clips == null || clips.length == 0) return -1;\\n    int N = clips.length;\\n    Arrays.sort(clips, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\tif (T==0) return 0; //  With this line, it is accepted. But result should be -1 meaning no solution, or result>=1 meaning the minimum clips number.  0 does not make any sense. \\n    if (0 < clips[0][0]) return -1; \\n    int result = 0;\\n    int l = 0, r = 0;\\n    for (int i = 0; i < clips.length; l = r, result++) {\\n      for (; i < clips.length && clips[i][0] <= l; i++) {\\n        r = Math.max(r, clips[i][1]);\\n      }\\n      if (r == l && r < T) return -1;\\n      if (r >= T) return ++result;\\n    }\\n    return r < T ? -1 : result;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915884,
                "title": "python-top-down-and-bottom-up-dp",
                "content": "DP is not the fastest approach since this problem can be approached greedily.  But this is a good practice problem for DP.  \\n\\n**Top Down DP:**\\nStart with 2 pointers, (i) at 0 and (j) at T.\\nAt each stage consider taking a video clip.  \\nIf we take a video clip [3, 7] for example.  \\nThen we now have 1 clip and two new **subproblems** [i, 3] and [7, T].  \\nEach time we take a clip, split the range [i, j] into subproblems until i >= j in which case 0 additional clips are needed.  \\nThe final result will be the sum of the minimum number of clips to cover each subproblem.  \\n\\n**Note:** The clip does not need to be in the middle of [i,j].  It could be clip [i-1, j+1] and cover the entire window[i,j].\\nOr it could only partially overlap with [i,j] for instance [i=5, j=9] and clip = [3, 7] or [8, 10].\\n\\n<br>\\n\\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\n\\t\\tbest = float(\\'inf\\')\\n\\t\\tfor s,e in clips:\\n\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(e, j))\\n\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s))\\n\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s) + helper(e, j))\\n\\n\\t\\treturn best\\n\\n\\tclips = helper(0, T)\\n\\treturn clips if clips != float(\\'inf\\') else -1\\n```\\n\\n<br>\\n\\n**Bottom Up DP:**\\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\tdp = [[0 for _ in range(T+1)] for _ in range(T+1)]\\n\\n\\tfor i in range(T, -1, -1):\\n\\t\\tfor j in range(i, T+1):\\n\\n\\t\\t\\tif i >= j:\\n\\t\\t\\t\\tdp[i][j] = 0\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tbest = float(\\'inf\\')\\n\\t\\t\\tfor s,e in clips:\\n\\t\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[e][j])\\n\\t\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s])\\n\\t\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s] + dp[e][j])\\n\\n\\t\\t\\tdp[i][j] = best\\n\\n\\treturn dp[0][T] if dp[0][T] != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\n\\t\\tbest = float(\\'inf\\')\\n\\t\\tfor s,e in clips:\\n\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(e, j))\\n\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s))\\n\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s) + helper(e, j))\\n\\n\\t\\treturn best\\n\\n\\tclips = helper(0, T)\\n\\treturn clips if clips != float(\\'inf\\') else -1\\n```\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\tdp = [[0 for _ in range(T+1)] for _ in range(T+1)]\\n\\n\\tfor i in range(T, -1, -1):\\n\\t\\tfor j in range(i, T+1):\\n\\n\\t\\t\\tif i >= j:\\n\\t\\t\\t\\tdp[i][j] = 0\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tbest = float(\\'inf\\')\\n\\t\\t\\tfor s,e in clips:\\n\\t\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[e][j])\\n\\t\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s])\\n\\t\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s] + dp[e][j])\\n\\n\\t\\t\\tdp[i][j] = best\\n\\n\\treturn dp[0][T] if dp[0][T] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 857124,
                "title": "simple-knapsack-variant-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[105][105];\\n    long long solve(int cur,int index,vector<vector<int>>&clips,int T){\\n        if(cur>=T){\\n            return 0;\\n        }\\n        if(index>=clips.size()){\\n            return INT_MAX;\\n        }\\n        if(cur<clips[index][0]){\\n            return INT_MAX;\\n        }\\n        if(dp[cur][index]!=-1){\\n            return dp[cur][index];\\n        }\\n        long long op1 =solve(clips[index][1],index+1,clips,T)+1;\\n        long long op2 =solve(cur,index+1,clips,T);\\n        return dp[cur][index]=min(op1,op2);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end());\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,0,clips,T);\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[105][105];\\n    long long solve(int cur,int index,vector<vector<int>>&clips,int T){\\n        if(cur>=T){\\n            return 0;\\n        }\\n        if(index>=clips.size()){\\n            return INT_MAX;\\n        }\\n        if(cur<clips[index][0]){\\n            return INT_MAX;\\n        }\\n        if(dp[cur][index]!=-1){\\n            return dp[cur][index];\\n        }\\n        long long op1 =solve(clips[index][1],index+1,clips,T)+1;\\n        long long op2 =solve(cur,index+1,clips,T);\\n        return dp[cur][index]=min(op1,op2);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end());\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,0,clips,T);\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386731,
                "title": "java-dp-o-n-t-100-fast-solution",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n\\t\\t//dp[i] stores  eding time of the activity that start before or at ithe activity and has latest ending time.\\n        for(int[] clip: clips){\\n            if(clip[0]<=T)dp[clip[0]] = Math.max( dp[clip[0]], clip[1]);\\n        }\\n        \\n        for(int i=1;i<=T;i++){\\n            dp[i] = Math.max(dp[i-1], dp[i]);    \\n        }\\n        \\n        int i=0;\\n        int count = 0;\\n        while(i<T){\\n            if(dp[i]==i)break;\\n            count +=1;\\n            i = dp[i];\\n        }\\n        return i>=T?count:-1;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n\\t\\t//dp[i] stores  eding time of the activity that start before or at ithe activity and has latest ending time.\\n        for(int[] clip: clips){\\n            if(clip[0]<=T)dp[clip[0]] = Math.max( dp[clip[0]], clip[1]);\\n        }\\n        \\n        for(int i=1;i<=T;i++){\\n            dp[i] = Math.max(dp[i-1], dp[i]);    \\n        }\\n        \\n        int i=0;\\n        int count = 0;\\n        while(i<T){\\n            if(dp[i]==i)break;\\n            count +=1;\\n            i = dp[i];\\n        }\\n        return i>=T?count:-1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282413,
                "title": "java-greedy-solution-with-picture-explanation",
                "content": "![image](https://assets.leetcode.com/users/billlipeng/image_1556350273.png)\\n\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t// sort the array \\n        Arrays.sort(clips, (o1, o2) -> {\\n            if(o1[0] < o2[0]) return -1;\\n            if(o1[0] > o2[0]) return 1;\\n            return 0;\\n        });\\n        \\n\\t\\tint curEnd = -1; //  current end\\n        int potenEnd = 0; // potiential end\\n        int count = 0; // result\\n        for(int[] c : clips) {\\n\\t\\t\\n\\t\\t\\t// if potential end reaches T, then break and return count; ----> picture 1\\n\\t\\t\\t// if c[0] >  potential end, the task is impossible, return -1 -----> picture 2\\n            if(potenEnd >= T || c[0] > potenEnd) break;\\n            \\n            if(c[0] > curEnd) {\\n\\t\\t\\t\\t// in red circle in picture 3, we should pick one more clip, and update current end\\n                count++;\\n                curEnd = potenEnd;\\n            }\\n\\t\\t\\t// update potential end;\\n            potenEnd = Math.max(potenEnd, c[1]);\\n        }\\n        return potenEnd >= T ? count : -1;  \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t// sort the array \\n        Arrays.sort(clips, (o1, o2) -> {\\n            if(o1[0] < o2[0]) return -1;\\n            if(o1[0] > o2[0]) return 1;\\n            return 0;\\n        });\\n        \\n\\t\\tint curEnd = -1; //  current end\\n        int potenEnd = 0; // potiential end\\n        int count = 0; // result\\n        for(int[] c : clips) {\\n\\t\\t\\n\\t\\t\\t// if potential end reaches T, then break and return count; ----> picture 1\\n\\t\\t\\t// if c[0] >  potential end, the task is impossible, return -1 -----> picture 2\\n            if(potenEnd >= T || c[0] > potenEnd) break;\\n            \\n            if(c[0] > curEnd) {\\n\\t\\t\\t\\t// in red circle in picture 3, we should pick one more clip, and update current end\\n                count++;\\n                curEnd = potenEnd;\\n            }\\n\\t\\t\\t// update potential end;\\n            potenEnd = Math.max(potenEnd, c[1]);\\n        }\\n        return potenEnd >= T ? count : -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859346,
                "title": "easy-memoization-approach-c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[104][104];\\n    int solve(int i, vector<vector<int>>& clips, int mx, int time){\\n        if(mx >= time) return 0;\\n        if(i >= clips.size()){\\n            return INT_MAX;\\n        }\\n        if(dp[i][mx] != -1) return dp[i][mx];\\n        if(clips[i][0] <= mx){\\n            int temp = solve(i+1,clips,max(mx,clips[i][1]),time);\\n            return dp[i][mx] = min(temp == INT_MAX ? INT_MAX : temp+1 , solve(i+1,clips,mx,time));\\n        }\\n        return dp[i][mx] = INT_MAX;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        sort(clips.begin(),clips.end());\\n        if(clips[0][0] != 0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,clips,0,time);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[104][104];\\n    int solve(int i, vector<vector<int>>& clips, int mx, int time){\\n        if(mx >= time) return 0;\\n        if(i >= clips.size()){\\n            return INT_MAX;\\n        }\\n        if(dp[i][mx] != -1) return dp[i][mx];\\n        if(clips[i][0] <= mx){\\n            int temp = solve(i+1,clips,max(mx,clips[i][1]),time);\\n            return dp[i][mx] = min(temp == INT_MAX ? INT_MAX : temp+1 , solve(i+1,clips,mx,time));\\n        }\\n        return dp[i][mx] = INT_MAX;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        sort(clips.begin(),clips.end());\\n        if(clips[0][0] != 0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,clips,0,time);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690596,
                "title": "easy-c-o-n-time-t-c-o-time-s-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just keep the track of maximum time that can be reached from a particular starting point of time.\\n\\nNow, just take the prefix maximum value of time that can be reached till ith index. Now we will start from intial point of time and check the maximum time that can be reached from all the time stamps till that position(the maximum value is already stored in the dp) , if the value is greater than the current time then we will increase the answer count otherwise will break the loop and return the value -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + time)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(time)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<int>dp(time+1,0);\\n        for(int i=0; i<n ;i++)\\n        {\\n            if(clips[i][0] > time)\\n                continue;\\n            dp[clips[i][0]] = max(dp[clips[i][0]],min(clips[i][1],time));\\n        }\\n        for(int i = 1;i<=time;i++)\\n            dp[i] = max(dp[i-1],dp[i]);\\n        int id = 0,ans = 0;\\n        while(id<time)\\n        {\\n            ans++;\\n            if(dp[id] <= id)\\n                return -1;\\n            id = dp[id];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<int>dp(time+1,0);\\n        for(int i=0; i<n ;i++)\\n        {\\n            if(clips[i][0] > time)\\n                continue;\\n            dp[clips[i][0]] = max(dp[clips[i][0]],min(clips[i][1],time));\\n        }\\n        for(int i = 1;i<=time;i++)\\n            dp[i] = max(dp[i-1],dp[i]);\\n        int id = 0,ans = 0;\\n        while(id<time)\\n        {\\n            ans++;\\n            if(dp[id] <= id)\\n                return -1;\\n            id = dp[id];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604726,
                "title": "c-memoized-solution-beats-100-similar-problem-added-different-than-others",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is clear from the description that we can sort the pairs, this will not gonna cahnge the result. And after checking example we can say that every new coming index should have opening time <= closing time of current index.\\n\\n **Important :** here why the every fu**ing solution is dying to use prev as a value instead of prev as an index unlike in other questions,, this is becuase we have to compulsorily add the index with {0,x} so they are parsing the value of prev==0 to ensure that first value taken is zero. You can check that method in other posts, I am doing question with the same approach as many questions ask.\\n\\n   if you dont want to change your method\\n you can use a for loop and parse the prev as prev == clips[i][1] where i is the index such that clip[i][0] == 0;\\n\\nSimilar question : [1626. Best Team With No Conflicts](https://leetcode.com/problems/best-team-with-no-conflicts/)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int solve(int ind, int prev, vector<vector<int>>&dp, vector<vector<int>>& clips, int time){\\n        if(ind == clips.size()){\\n            if(clips[prev][1] >= time)return 0;\\n            return 1e9;\\n        }\\n        if(clips[prev][1] >= time)return 0;\\n        if(dp[ind][prev] != -1)return dp[ind][prev];\\n\\n        int take = 1e9;\\n        if(clips[ind][0] <= clips[prev][1]){\\n            take = 1+solve(ind + 1, ind, dp, clips, time);\\n        }\\n        int notTake = solve(ind + 1, prev, dp, clips, time);\\n        return dp[ind][prev] = min(take, notTake);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n + 1, -1));\\n        sort(clips.begin(), clips.end());\\n        int mini = 1e9;\\n        for(int i =0; i <n ;i++){\\n            // cout<<clips[i][0] <<\" \"<<clips[i][1]<<endl;\\n            if(clips[i][0]==0)\\n                mini =  min(mini, 1 + solve(i + 1, i, dp, clips, time));\\n        }\\n        if(mini == 1e9)return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int solve(int ind, int prev, vector<vector<int>>&dp, vector<vector<int>>& clips, int time){\\n        if(ind == clips.size()){\\n            if(clips[prev][1] >= time)return 0;\\n            return 1e9;\\n        }\\n        if(clips[prev][1] >= time)return 0;\\n        if(dp[ind][prev] != -1)return dp[ind][prev];\\n\\n        int take = 1e9;\\n        if(clips[ind][0] <= clips[prev][1]){\\n            take = 1+solve(ind + 1, ind, dp, clips, time);\\n        }\\n        int notTake = solve(ind + 1, prev, dp, clips, time);\\n        return dp[ind][prev] = min(take, notTake);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n + 1, -1));\\n        sort(clips.begin(), clips.end());\\n        int mini = 1e9;\\n        for(int i =0; i <n ;i++){\\n            // cout<<clips[i][0] <<\" \"<<clips[i][1]<<endl;\\n            if(clips[i][0]==0)\\n                mini =  min(mini, 1 + solve(i + 1, i, dp, clips, time));\\n        }\\n        if(mini == 1e9)return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665151,
                "title": "c-commented-explanation-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* Approach : Greedy */\\n    \\n    /*\\n    \\n    Observation (1):\\n    \\n    For similar starting point , we will pick that one which has the \\n\\tmaximum range , [a,b] , [a,d]. If (b>d) we will pick the interval [a,b] for \\n\\tsure as it will cover the longest distance towards the right.\\n    \\n    Observation (2):\\n    \\n    Now what we will do , when we reach the end of the choosen interval \\n\\t[a,b]. See, if (b==time) , then we are able to reach our destination so\\n\\treturn the total number of intervals we used so far. Else , we start \\n\\tsearching an interval , which has its starting point <= b and has the \\n\\tmaximum covering towards the right .\\n    \\n    */\\n    \\n    /*\\n    \\n    T.C : O(N + time)\\n    S.C : O(time)\\n    \\n    */\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        vector<int>dp(time+1,-1);\\n        \\n        for(int i=0;i<clips.size();i++){\\n            \\n            int left = min(clips[i][0],time);\\n            int right = min(clips[i][1],time);\\n            \\n            dp[left] = max(dp[left] , right);\\n            \\n        }\\n        \\n        int currmax = dp[0];\\n        \\n        int nextmax = -1;\\n        \\n        int jumps = 1;\\n        \\n        if(dp[0]==time) return 1;\\n        \\n        for(int i=0;i<=time;i++){\\n            \\n            nextmax = max(nextmax,dp[i]);\\n            \\n            if(currmax==i){\\n                \\n                currmax = nextmax;\\n                jumps++;\\n                \\n            }\\n            \\n            if(currmax == time){\\n                \\n                return jumps;\\n                \\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* Approach : Greedy */\\n    \\n    /*\\n    \\n    Observation (1):\\n    \\n    For similar starting point , we will pick that one which has the \\n\\tmaximum range , [a,b] , [a,d]. If (b>d) we will pick the interval [a,b] for \\n\\tsure as it will cover the longest distance towards the right.\\n    \\n    Observation (2):\\n    \\n    Now what we will do , when we reach the end of the choosen interval \\n\\t[a,b]. See, if (b==time) , then we are able to reach our destination so\\n\\treturn the total number of intervals we used so far. Else , we start \\n\\tsearching an interval , which has its starting point <= b and has the \\n\\tmaximum covering towards the right .\\n    \\n    */\\n    \\n    /*\\n    \\n    T.C : O(N + time)\\n    S.C : O(time)\\n    \\n    */\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        vector<int>dp(time+1,-1);\\n        \\n        for(int i=0;i<clips.size();i++){\\n            \\n            int left = min(clips[i][0],time);\\n            int right = min(clips[i][1],time);\\n            \\n            dp[left] = max(dp[left] , right);\\n            \\n        }\\n        \\n        int currmax = dp[0];\\n        \\n        int nextmax = -1;\\n        \\n        int jumps = 1;\\n        \\n        if(dp[0]==time) return 1;\\n        \\n        for(int i=0;i<=time;i++){\\n            \\n            nextmax = max(nextmax,dp[i]);\\n            \\n            if(currmax==i){\\n                \\n                currmax = nextmax;\\n                jumps++;\\n                \\n            }\\n            \\n            if(currmax == time){\\n                \\n                return jumps;\\n                \\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420715,
                "title": "c-easy-solution-recursion-memoization-dynamic-programming",
                "content": "```\\n//Recursion\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end()); \\n        return solve( clips , time ,clips.size()); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size, int dp[101][101]){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        if ( dp[time][size]!=-1) return dp[time][size]; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1,dp); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1,dp); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return dp[time][size]=ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end());\\n        int dp[101][101]; \\n        memset(dp, -1 , sizeof(dp)); \\n        return solve( clips , time ,clips.size(),dp);\\n    }\\n};\\n// Dynamic Programming + Space Optimization \\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recursion\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end()); \\n        return solve( clips , time ,clips.size()); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size, int dp[101][101]){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        if ( dp[time][size]!=-1) return dp[time][size]; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1,dp); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1,dp); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return dp[time][size]=ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end());\\n        int dp[101][101]; \\n        memset(dp, -1 , sizeof(dp)); \\n        return solve( clips , time ,clips.size(),dp);\\n    }\\n};\\n// Dynamic Programming + Space Optimization \\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283242,
                "title": "using-greedy-approach-without-sorting",
                "content": "Tried solving this problem using the concept of minimum number of jumps required to reach a target used in [Jump Game II](https://leetcode.com/problems/jump-game-ii/).\\nSteps: \\n1. Initialise an array of maximum size 100, with inital value of each element as INT_MIN.\\n2. From the range array, store the maximum distance that can be covered from each starting postion.\\n3. Now try to find out the minimum number of steps required to reach given distance, else return -1.\\n\\n```\\n    int findCount(vector<int> dist, int time){\\n        int count=0;\\n        int right=0,left=0;\\n        while(right<time){\\n            if(right<left)\\n                return -1;\\n            int next=0;\\n            for(int i=left;i<=right;i++){\\n                next=max(next,dist[i]);   //update the next maximum rechable distance\\n            }\\n            left=right+1;\\n            right=next;\\n            count++;                      //Increase the counter once a range is completely covered\\n        }\\n        return count;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> dist(100,INT_MIN);\\n        for(int i=0;i<clips.size();i++){\\n            dist[clips[i][0]]=max(dist[clips[i][0]],clips[i][1]);\\n        }\\n        return findCount(dist, time);\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    int findCount(vector<int> dist, int time){\\n        int count=0;\\n        int right=0,left=0;\\n        while(right<time){\\n            if(right<left)\\n                return -1;\\n            int next=0;\\n            for(int i=left;i<=right;i++){\\n                next=max(next,dist[i]);   //update the next maximum rechable distance\\n            }\\n            left=right+1;\\n            right=next;\\n            count++;                      //Increase the counter once a range is completely covered\\n        }\\n        return count;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> dist(100,INT_MIN);\\n        for(int i=0;i<clips.size();i++){\\n            dist[clips[i][0]]=max(dist[clips[i][0]],clips[i][1]);\\n        }\\n        return findCount(dist, time);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176584,
                "title": "two-problems-one-solution-java-explanation",
                "content": "**1024. Video Stitching**\\n```\\n[0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n```\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            \\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            total++;\\n        }\\n        \\n        \\n        return total;\\n    }\\n}\\n```\\n\\n**1326. Minimum Number of Taps to Open to Water a Garden**\\n```\\n\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<n) {\\n         \\n            for(int i=0; i<ranges.length; i++) {\\n                int left = i - ranges[i];\\n                int right = i + ranges[i];\\n                \\n                if(left<=min && max<right) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            \\n            total++;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n[0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            \\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            total++;\\n        }\\n        \\n        \\n        return total;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<n) {\\n         \\n            for(int i=0; i<ranges.length; i++) {\\n                int left = i - ranges[i];\\n                int right = i + ranges[i];\\n                \\n                if(left<=min && max<right) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            \\n            total++;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424243,
                "title": "c-faster-than-100-constant-space-greedy",
                "content": "##### **Greedy Choice** : Choose the interval which has the smallest starting time and longest duration and add it to the final answer\\n```\\nbool comp(const vector<int> &a, const vector<int> &b)\\n{\\n    if(a[0] == b[0])\\n        return (a[1] - a[0]) > (b[1] - b[0]);\\n    \\n    return a[0] < b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int maxtime = 0, tc = 0, i = 0;\\n        \\n        while(i < clips.size() and maxtime < time)\\n        {\\n            if(clips[i][0] > maxtime)\\n                return -1;\\n            \\n            int currmax = 0;\\n            \\n            for( ; i < clips.size() ; i++)\\n            {\\n                if(clips[i][0] <= maxtime)\\n                    currmax = max(currmax, clips[i][1]);\\n                else\\n                    break;\\n            }\\n            \\n            tc++;\\n            maxtime = currmax;\\n        }\\n        if(i >= clips.size() and maxtime < time)\\n            return -1;\\n        \\n        return tc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nbool comp(const vector<int> &a, const vector<int> &b)\\n{\\n    if(a[0] == b[0])\\n        return (a[1] - a[0]) > (b[1] - b[0]);\\n    \\n    return a[0] < b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int maxtime = 0, tc = 0, i = 0;\\n        \\n        while(i < clips.size() and maxtime < time)\\n        {\\n            if(clips[i][0] > maxtime)\\n                return -1;\\n            \\n            int currmax = 0;\\n            \\n            for( ; i < clips.size() ; i++)\\n            {\\n                if(clips[i][0] <= maxtime)\\n                    currmax = max(currmax, clips[i][1]);\\n                else\\n                    break;\\n            }\\n            \\n            tc++;\\n            maxtime = currmax;\\n        }\\n        if(i >= clips.size() and maxtime < time)\\n            return -1;\\n        \\n        return tc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230255,
                "title": "java-solution-priority-queue-and-stack-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        if(time == 0)\\n            return 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] == b[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int[] c:clips)\\n            q.add(c);\\n        Stack<int[]> s = new Stack<>();\\n        int end=0;\\n        if(q.peek()[0] != 0)\\n            return -1;\\n        while(!q.isEmpty() && end < time){\\n            int[] lp = null;\\n            while(s.size() != 0 && s.peek()[1] < q.peek()[1] && s.peek()[1] >= q.peek()[0]) lp = s.pop();\\n            if(lp != null)\\n                s.add(lp);\\n            if(s.size() == 0 || s.peek()[1] >= q.peek()[0])\\n                s.add(q.poll());\\n            else return -1;\\n            end = s.peek()[1];\\n            while(!q.isEmpty() && q.peek()[1] <= s.peek()[1]) q.poll();\\n        }\\n        return end >= time?s.size():-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        if(time == 0)\\n            return 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] == b[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int[] c:clips)\\n            q.add(c);\\n        Stack<int[]> s = new Stack<>();\\n        int end=0;\\n        if(q.peek()[0] != 0)\\n            return -1;\\n        while(!q.isEmpty() && end < time){\\n            int[] lp = null;\\n            while(s.size() != 0 && s.peek()[1] < q.peek()[1] && s.peek()[1] >= q.peek()[0]) lp = s.pop();\\n            if(lp != null)\\n                s.add(lp);\\n            if(s.size() == 0 || s.peek()[1] >= q.peek()[0])\\n                s.add(q.poll());\\n            else return -1;\\n            end = s.peek()[1];\\n            while(!q.isEmpty() && q.peek()[1] <= s.peek()[1]) q.poll();\\n        }\\n        return end >= time?s.size():-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222700,
                "title": "1ms-100-faster-dp-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips,(a,b)-> a[0]-b[0]);\\n        int dp[]=new int[T+1];\\n        Arrays.fill(dp,clips.length+2);\\n        dp[0]=0;\\n        for(int clip[] : clips){\\n            for(int j=clip[0];j<=clip[1]&&j<=T;j++)\\n                dp[j]=Math.min(dp[j],1+dp[clip[0]]);\\n        }\\n        return dp[T]>=clips.length+2 ? -1 : dp[T];\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips,(a,b)-> a[0]-b[0]);\\n        int dp[]=new int[T+1];\\n        Arrays.fill(dp,clips.length+2);\\n        dp[0]=0;\\n        for(int clip[] : clips){\\n            for(int j=clip[0];j<=clip[1]&&j<=T;j++)\\n                dp[j]=Math.min(dp[j],1+dp[clip[0]]);\\n        }\\n        return dp[T]>=clips.length+2 ? -1 : dp[T];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125417,
                "title": "sort-the-clips-and-one-pass-99-speed",
                "content": "Runtime: 20 ms, faster than 99.79% of Python3 online submissions for Video Stitching.\\nMemory Usage: 14.1 MB, less than 97.52% of Python3 online submissions for Video Stitching.\\n```\\nclass Solution:\\n    def videoStitching(self, clips, T: int) -> int:\\n        if T == 0:\\n            return 0\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] <= 0:\\n            len_clips = len(clips)\\n            lst = [clips[0]]\\n            idx = 1\\n            while lst[-1][1] < T and idx < len_clips:\\n                start, end = clips[idx]\\n                if start <= lst[-1][1] < end:\\n                    if len(lst) > 1 and start <= lst[-2][1]:\\n                        lst.pop()\\n                    lst.append(clips[idx])\\n                idx += 1\\n            if lst[-1][1] >= T:\\n                return len(lst)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips, T: int) -> int:\\n        if T == 0:\\n            return 0\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] <= 0:\\n            len_clips = len(clips)\\n            lst = [clips[0]]\\n            idx = 1\\n            while lst[-1][1] < T and idx < len_clips:\\n                start, end = clips[idx]\\n                if start <= lst[-1][1] < end:\\n                    if len(lst) > 1 and start <= lst[-2][1]:\\n                        lst.pop()\\n                    lst.append(clips[idx])\\n                idx += 1\\n            if lst[-1][1] >= T:\\n                return len(lst)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986021,
                "title": "c-100-faster-greedy-approach-short-code",
                "content": "For the current time stamp, choose the clip which falls within the range and has the greatest end point. If no such clip exists, solution does not exist.\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int s =0;\\n        int n = clips.size();\\n        int ans=0;\\n        while(s <T){\\n            int md = s;\\n            for(int i=0; i<n; i++){\\n                if(clips[i][0] <= s && clips[i][1] > md){\\n                    md = max(md, clips[i][1]);\\n                }\\n            }\\n            if(md == s) return -1;\\n            s = md;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int s =0;\\n        int n = clips.size();\\n        int ans=0;\\n        while(s <T){\\n            int md = s;\\n            for(int i=0; i<n; i++){\\n                if(clips[i][0] <= s && clips[i][1] > md){\\n                    md = max(md, clips[i][1]);\\n                }\\n            }\\n            if(md == s) return -1;\\n            s = md;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827352,
                "title": "java-dp-oms-100-time-and-space-o-1-space-o-n-t-time",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr  = new int[101];\\n//       Store  maximum number we can reach from given start point \\n        for(int i=0;i<clips.length;i++){\\n            arr[clips[i][0]]=Math.max(arr[clips[i][0]],clips[i][1]);\\n        }\\n//         find the maximum point we can reach until the given point\\n//         if max point we can reach from 1 is 9 and maximum point we can reach from 2 is 6 then       \\n//        update maximum point reached by 2 to 9\\n        for(int i=1;i<T+1;i++){\\n            arr[i]=Math.max(arr[i],arr[i-1]);\\n        }\\n        int steps=0;\\n//         current point\\n        int start=0;\\n        while(true){\\n//             get the maximum point for this start\\n            int lastNum=arr[start];\\n//             if this condition is true it means that all intervals starting before this point including current\\n//             start point can only reach a point which is less than or equal to current start point, so we can not \\n//            go beyond current start point ==> return -1  \\n            if(lastNum<=start)\\n                return -1;\\n            start=lastNum;\\n            steps++;\\n//             if you have reached a point which is greater than the T return steps\\n            if(lastNum>=T)\\n                return steps;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr  = new int[101];\\n//       Store  maximum number we can reach from given start point \\n        for(int i=0;i<clips.length;i++){\\n            arr[clips[i][0]]=Math.max(arr[clips[i][0]],clips[i][1]);\\n        }\\n//         find the maximum point we can reach until the given point\\n//         if max point we can reach from 1 is 9 and maximum point we can reach from 2 is 6 then       \\n//        update maximum point reached by 2 to 9\\n        for(int i=1;i<T+1;i++){\\n            arr[i]=Math.max(arr[i],arr[i-1]);\\n        }\\n        int steps=0;\\n//         current point\\n        int start=0;\\n        while(true){\\n//             get the maximum point for this start\\n            int lastNum=arr[start];\\n//             if this condition is true it means that all intervals starting before this point including current\\n//             start point can only reach a point which is less than or equal to current start point, so we can not \\n//            go beyond current start point ==> return -1  \\n            if(lastNum<=start)\\n                return -1;\\n            start=lastNum;\\n            steps++;\\n//             if you have reached a point which is greater than the T return steps\\n            if(lastNum>=T)\\n                return steps;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502376,
                "title": "readable-solution-to-sort-clips-by-start-o-n-logn-time",
                "content": "Steps:\\n1. Sort all clips by starting time.\\n2. Scan through sorted clips in order:\\n   1. Mark the ending time of current clip as max reachable time `maxReach`;\\n   2. Find all clips which overlap with current clip, and find the max reachable time of those clips `currentMaxReach`:\\n      - If we can reach further, i.e., `currentMaxReach > maxReach`, improve `maxReach` and count 1 more clip needed;\\n      - Otherwise, we can\\'t progress further to cover entire `[0,T]`.  \\n\\n```cpp\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n      sort(clips.begin(), clips.end()); // sort clips by start\\n      \\n      int i = 0; // clips index\\n      int maxReach = 0; // max time reachable by clips\\n      int cnt = 0; // number of clips needed\\n      \\n      while (maxReach < T) {\\n        int currentMaxReach = 0;\\n        while (i < clips.size() && clips[i][0] <= maxReach)\\n          currentMaxReach = max(currentMaxReach, clips[i++][1]);\\n        \\n        if (currentMaxReach <= maxReach) return -1; // can\\'t reach further\\n        maxReach = currentMaxReach;\\n        cnt++; // need an additional clip to reach new maxReach        \\n      }\\n      \\n      return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n      sort(clips.begin(), clips.end()); // sort clips by start\\n      \\n      int i = 0; // clips index\\n      int maxReach = 0; // max time reachable by clips\\n      int cnt = 0; // number of clips needed\\n      \\n      while (maxReach < T) {\\n        int currentMaxReach = 0;\\n        while (i < clips.size() && clips[i][0] <= maxReach)\\n          currentMaxReach = max(currentMaxReach, clips[i++][1]);\\n        \\n        if (currentMaxReach <= maxReach) return -1; // can\\'t reach further\\n        maxReach = currentMaxReach;\\n        cnt++; // need an additional clip to reach new maxReach        \\n      }\\n      \\n      return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501432,
                "title": "python-greedy-solution-beat-90-base-on-start",
                "content": "n: number of clips, t: interver to fill\\nTime complexity :  O(nlogn+nt)? \\nSpace Complexity : O(t)\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [0] + [float(\\'inf\\')] * T\\n        s_clip = sorted(clips, key=lambda interval: interval[0]) #sorted by start line\\n        reachable = 0\\n        for clip in s_clip:\\n            if clip[0] > T: break\\n            if reachable < clip[0]: return -1\\n            for i in range(clip[0], min(clip[1]+1, T+1)):\\n                dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if reachable < clip[1]: reachable = clip[1]\\n        return dp[T] if dp[T] != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [0] + [float(\\'inf\\')] * T\\n        s_clip = sorted(clips, key=lambda interval: interval[0]) #sorted by start line\\n        reachable = 0\\n        for clip in s_clip:\\n            if clip[0] > T: break\\n            if reachable < clip[0]: return -1\\n            for i in range(clip[0], min(clip[1]+1, T+1)):\\n                dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if reachable < clip[1]: reachable = clip[1]\\n        return dp[T] if dp[T] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443591,
                "title": "greedy-algorithm-0-ms",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Video Stitching.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Video Stitching.\\n\\n```cpp\\n// Greedy Algorithm\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        // sort intervals by the end\\n        auto comp = [](auto& left, auto& right) { return left[1] < right[1]; };\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int pos = clips.size() - 1;\\n        int ret = 0;\\n        while (pos >= 0 && T > 0) {            \\n            // greedy: find the left-most interval including T\\n            int min_left = INT_MAX;\\n            while (pos >= 0 && clips[pos][1] >= T) {\\n                if (clips[pos][0] <= T) // skip intervals on the right of T\\n                    min_left = min(min_left, clips[pos][0]);\\n                --pos;\\n            }\\n            \\n            if (min_left == INT_MAX) break;\\n            T = min_left;\\n            ++ret;\\n        }\\n        return T == 0 ? ret : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n// Greedy Algorithm\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        // sort intervals by the end\\n        auto comp = [](auto& left, auto& right) { return left[1] < right[1]; };\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int pos = clips.size() - 1;\\n        int ret = 0;\\n        while (pos >= 0 && T > 0) {            \\n            // greedy: find the left-most interval including T\\n            int min_left = INT_MAX;\\n            while (pos >= 0 && clips[pos][1] >= T) {\\n                if (clips[pos][0] <= T) // skip intervals on the right of T\\n                    min_left = min(min_left, clips[pos][0]);\\n                --pos;\\n            }\\n            \\n            if (min_left == INT_MAX) break;\\n            T = min_left;\\n            ++ret;\\n        }\\n        return T == 0 ? ret : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349446,
                "title": "c-memoization-beats-100-time-and-93-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int util(int T, vector< vector<int> > &clips, int idx) {\\n        if(idx < 0 && T != 0) return 1 << 30;\\n        if(T == 0) return 0;\\n        if(dp[idx][T]) return dp[idx][T];\\n\\t\\t\\n        int ans = 1<<30;\\n        for(int i = idx; i >= 0; i--) {\\n            if(clips[i][1] >= T) {\\n                ans = min(ans, 1 + util(clips[i][0], clips, i - 1));\\n            }\\n        }\\n        return dp[idx][T] = ans;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[1] < b[1];\\n        });\\n        int ans = util(T, clips, clips.size()-1);\\n        return (ans == (1<<30)) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int util(int T, vector< vector<int> > &clips, int idx) {\\n        if(idx < 0 && T != 0) return 1 << 30;\\n        if(T == 0) return 0;\\n        if(dp[idx][T]) return dp[idx][T];\\n\\t\\t\\n        int ans = 1<<30;\\n        for(int i = idx; i >= 0; i--) {\\n            if(clips[i][1] >= T) {\\n                ans = min(ans, 1 + util(clips[i][0], clips, i - 1));\\n            }\\n        }\\n        return dp[idx][T] = ans;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[1] < b[1];\\n        });\\n        int ans = util(T, clips, clips.size()-1);\\n        return (ans == (1<<30)) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280814,
                "title": "straight-forward-dp-solution",
                "content": "We are looking to cover the interval [0, T].\\nSo DP state is the best solution for interval [i, j].\\nOur solution is dp[0][T];\\nWe calculate dp[i][j] when we iterate through all the clips and try to solve left from the beginning of the clip and right from the end of the clip.\\n\\n```\\n    vector<vector<int> > dp;\\n    vector<vector<int> > clips;\\n    int T;\\n\\n    int solve(int from, int to) {\\n       from = max(from, 0);\\n       to = min(to, T);\\n       if (from >= to) return 0;\\n       int &res = dp[from][to];\\n       if (res != -1) return res;\\n       res = INT_MAX;\\n       for (int i = 0; i < clips.size(); ++i) {\\n          int left = solve(from, clips[i][0]);\\n          if (left == INT_MAX) {\\n             continue;\\n          }\\n          int right = solve(clips[i][1], to);\\n          if (right == INT_MAX) {\\n             continue;\\n          }\\n          res = min(res, 1 + left + right);\\n       }\\n       return res;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        this->clips = clips;\\n        this->T = T;\\n        dp.resize(T + 1, vector<int>(T + 1, -1));\\n        int res = solve(0, T);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int> > dp;\\n    vector<vector<int> > clips;\\n    int T;\\n\\n    int solve(int from, int to) {\\n       from = max(from, 0);\\n       to = min(to, T);\\n       if (from >= to) return 0;\\n       int &res = dp[from][to];\\n       if (res != -1) return res;\\n       res = INT_MAX;\\n       for (int i = 0; i < clips.size(); ++i) {\\n          int left = solve(from, clips[i][0]);\\n          if (left == INT_MAX) {\\n             continue;\\n          }\\n          int right = solve(clips[i][1], to);\\n          if (right == INT_MAX) {\\n             continue;\\n          }\\n          res = min(res, 1 + left + right);\\n       }\\n       return res;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        this->clips = clips;\\n        this->T = T;\\n        dp.resize(T + 1, vector<int>(T + 1, -1));\\n        int res = solve(0, T);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270676,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] clip: clips) {\\n            if (!map.containsKey(clip[0])) {\\n                map.put(clip[0], new LinkedList<Integer>());\\n            }\\n            map.get(clip[0]).add(clip[1]);\\n        }\\n        if (!map.containsKey(0)) {\\n            return -1;\\n        } else {\\n            dp[0] = 0;\\n        }\\n        for(int i = 0; i <= T; i++) {\\n            if (map.containsKey(i)) {\\n                for(int value: map.get(i)) {\\n                    if (value > T) value = T;\\n                    for(int k = i+1; k <= value; k++)\\n                        dp[k] = Math.min(dp[k], dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[T] != Integer.MAX_VALUE? dp[T]: -1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] clip: clips) {\\n            if (!map.containsKey(clip[0])) {\\n                map.put(clip[0], new LinkedList<Integer>());\\n            }\\n            map.get(clip[0]).add(clip[1]);\\n        }\\n        if (!map.containsKey(0)) {\\n            return -1;\\n        } else {\\n            dp[0] = 0;\\n        }\\n        for(int i = 0; i <= T; i++) {\\n            if (map.containsKey(i)) {\\n                for(int value: map.get(i)) {\\n                    if (value > T) value = T;\\n                    for(int k = i+1; k <= value; k++)\\n                        dp[k] = Math.min(dp[k], dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[T] != Integer.MAX_VALUE? dp[T]: -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270634,
                "title": "c-o-n-t-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int prebound2 = 0, prebound1 = 0, newbound = 0, res = 0;\\n        vector<int> clip(T + 1, 0);\\n        for(auto i : clips)\\n            if(i[0] <= T)\\n            clip[i[0]] = max(clip[i[0]], i[1]);\\n        while(prebound2 < T){\\n            for(int i = prebound1; i <= prebound2; ++i)\\n                if(clip[i] > newbound) newbound = clip[i];\\n            if(newbound == prebound2) return -1;\\n            prebound1 = prebound2;\\n            prebound2 = newbound;\\n            ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int prebound2 = 0, prebound1 = 0, newbound = 0, res = 0;\\n        vector<int> clip(T + 1, 0);\\n        for(auto i : clips)\\n            if(i[0] <= T)\\n            clip[i[0]] = max(clip[i[0]], i[1]);\\n        while(prebound2 < T){\\n            for(int i = prebound1; i <= prebound2; ++i)\\n                if(clip[i] > newbound) newbound = clip[i];\\n            if(newbound == prebound2) return -1;\\n            prebound1 = prebound2;\\n            prebound2 = newbound;\\n            ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270192,
                "title": "python-dp-solution",
                "content": "dp[i][t] = minimum number of clips needed with length i and target t\\n\\nbase cases:\\ndp[i][0] = 1\\n\\nfor each clips start time c0\\n\\tdp[i][t] = min(dp[i-1][c0] + 1, dp[i][t])\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(clips)\\n        clips.sort(key=lambda c: (c[0]))\\n        dp = [[float(\\'inf\\') for _ in range(T + 1)] for _ in range(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = 1\\n        for i in range(1, n + 1):\\n            c = clips[i-1]\\n            for t in range(0, T + 1):\\n                dp[i][t] = dp[i-1][t]\\n                if c[0] <= t <= c[1]:\\n                    if c[0] == 0:\\n                        dp[i][t] = 1\\n                    else:\\n                        dp[i][t] = min(dp[i-1][c[0]] + 1, dp[i][t])\\n        if dp[-1][-1] == float(\\'inf\\'):\\n            return -1\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(clips)\\n        clips.sort(key=lambda c: (c[0]))\\n        dp = [[float(\\'inf\\') for _ in range(T + 1)] for _ in range(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = 1\\n        for i in range(1, n + 1):\\n            c = clips[i-1]\\n            for t in range(0, T + 1):\\n                dp[i][t] = dp[i-1][t]\\n                if c[0] <= t <= c[1]:\\n                    if c[0] == 0:\\n                        dp[i][t] = 1\\n                    else:\\n                        dp[i][t] = min(dp[i-1][c[0]] + 1, dp[i][t])\\n        if dp[-1][-1] == float(\\'inf\\'):\\n            return -1\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270127,
                "title": "java-sorting-greedy-1ms",
                "content": "Greedy solution - we sort clips based on start time. Then finding max end time that we can achieve keeping start time before the prev end time. \\n\\nO(nlogn) time - sorting nlogn, plus linear time for scanning the array (every element visited once)\\nO(1) space - only state variables\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        Comparator<int[]> comp = new Comparator<int[]>() {\\n           public int compare(int[] ar1, int[] ar2) {\\n            return ar1[0] - ar2[0];    \\n           }\\n        };\\n        //sort clips based on the start time\\n        Arrays.sort(clips, comp);\\n        \\n        int res = 0;\\n        //state variables\\n        int min = 0, max = 0, i = 0;\\n        while ( i < clips.length ) {\\n            //checking if we have a gap - if prev end doesn\\'t ends before next start\\n            if (clips[i][0] > max)\\n                return -1;\\n            //rewinding forward to find the max end that has the start before the prev end\\n            int curMax = max;            \\n            while (i < clips.length && clips[i][0] <= max) {\\n                curMax = Math.max(curMax, clips[i++][1]);\\n            }\\n            //save new max end, increment the number of clips\\n            max = curMax;            \\n            res++;\\n            //check if we reach the target\\n            if (max >= T)\\n                return res;\\n        }        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        Comparator<int[]> comp = new Comparator<int[]>() {\\n           public int compare(int[] ar1, int[] ar2) {\\n            return ar1[0] - ar2[0];    \\n           }\\n        };\\n        //sort clips based on the start time\\n        Arrays.sort(clips, comp);\\n        \\n        int res = 0;\\n        //state variables\\n        int min = 0, max = 0, i = 0;\\n        while ( i < clips.length ) {\\n            //checking if we have a gap - if prev end doesn\\'t ends before next start\\n            if (clips[i][0] > max)\\n                return -1;\\n            //rewinding forward to find the max end that has the start before the prev end\\n            int curMax = max;            \\n            while (i < clips.length && clips[i][0] <= max) {\\n                curMax = Math.max(curMax, clips[i++][1]);\\n            }\\n            //save new max end, increment the number of clips\\n            max = curMax;            \\n            res++;\\n            //check if we reach the target\\n            if (max >= T)\\n                return res;\\n        }        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270004,
                "title": "leetcode-weekly-contest-131-screen-record",
                "content": "https://www.youtube.com/watch?v=bcrB6aN1pjk&feature=youtu.be\\n\\n```\\n5019. Video Stitching:\\n- O(nlogn + n*t)\\n- O(nlogn + n) sort + scan\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        \\n         // t indicates the coverage time of selected videos([0, t]), and next_t indicates the latest time that we can cover after adding a video.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Since the current coverage time is [0, t], the interval of the next video [x, y] we need to find must satisfy x <= t.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // In all videos[x_i, y_i] that meet the criteria, obviously the video with the latest end time will be better.\\n        int n = clips.size(), ret = 0, t = 0, next_t = 0;\\n        for (int i = 0; i < n && t < T; i++) {\\n            if (clips[i][0] > t) {\\n                t = next_t;\\n                ++ret;\\n            }\\n            \\n            if (clips[i][0] > next_t) {\\n                break;\\n            }\\n            \\n            next_t = max(next_t, clips[i][1]);\\n        }\\n        \\n        if (t < T) {\\n            t = next_t;\\n            ++ret;\\n        }\\n        return t < T ? -1 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n5019. Video Stitching:\\n- O(nlogn + n*t)\\n- O(nlogn + n) sort + scan\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        \\n         // t indicates the coverage time of selected videos([0, t]), and next_t indicates the latest time that we can cover after adding a video.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Since the current coverage time is [0, t], the interval of the next video [x, y] we need to find must satisfy x <= t.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // In all videos[x_i, y_i] that meet the criteria, obviously the video with the latest end time will be better.\\n        int n = clips.size(), ret = 0, t = 0, next_t = 0;\\n        for (int i = 0; i < n && t < T; i++) {\\n            if (clips[i][0] > t) {\\n                t = next_t;\\n                ++ret;\\n            }\\n            \\n            if (clips[i][0] > next_t) {\\n                break;\\n            }\\n            \\n            next_t = max(next_t, clips[i][1]);\\n        }\\n        \\n        if (t < T) {\\n            t = next_t;\\n            ++ret;\\n        }\\n        return t < T ? -1 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063132,
                "title": "",
                "content": "# Intuition\\n\\u0416\\u0430\\u0434\\u043D\\u044B\\u0439 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\n\\n# Approach\\n\\u0420\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F \\u043E\\u0442\\u0431\\u043E\\u0440\\u043E\\u043C \\u043D\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0435 \\u043B\\u0443\\u0447\\u0448\\u0435\\u0433\\u043E\\n\\n# Complexity\\n- Time complexity:\\n- O(n*log(n))\\n\\n\\n- Space complexity:\\n\\u0434\\u043E\\u043F\\u043E\\u043B\\u043D\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u0430\\u044F \\u043F\\u0430\\u043C\\u044F\\u0442\\u044C O(1)\\n\\n# Code\\n```\\nfunc videoStitching(clips [][]int, time int) int {\\n\\t// \\u0421\\u043E\\u0440\\u0442\\u0438\\u0440\\u0443\\u044E \\u0432\\u0441\\u0435 \\u043A\\u043B\\u0438\\u043F\\u044B \\u043F\\u043E \\u0432\\u043E\\u0437\\u0440\\u0430\\u0441\\u0442\\u0430\\u043D\\u0438\\u044E \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043A\\u043B\\u0438\\u043F\\u0430.\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif len(clips) == 1 &&\\n\\t\\tclips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsort.Slice(clips, func(i, j int) bool {\\n\\t\\tif clips[i][0] < clips[j][0] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif clips[i][0] == clips[j][0] {\\n\\t\\t\\treturn clips[i][1] > clips[j][1]\\n\\t\\t}\\n\\n\\t\\treturn false\\n\\t})\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif clips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// \\u041E\\u0442\\u0432\\u0435\\u0442 \\u043D\\u0430 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0443: \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u044B\\u0445 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0434\\u043B\\u044F\\n\\t// \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u044F \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 [0, time]\\n\\tminCount := 1\\n\\t// \\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u043D\\u0430 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0430\\u043A\\u043E\\u043F\\u043B\\u0435\\u043D\\u043D\\u0430\\u044F \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432\\n\\tmaxLasted := clips[0][1]\\n\\tfromClip := 0 // \\u043A\\u043B\\u0438\\u043F, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C\\u0441\\u044F \\u043F\\u0435\\u0440\\u0435\\u0431\\u0438\\u0440\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F\\n\\n\\tif maxLasted >= time {\\n\\t\\treturn minCount\\n\\t}\\n\\n\\tfor {\\n\\t\\tbestClipId := -1\\n\\t\\tmaxLastedPrev := -1\\n\\t\\t// \\u0414\\u043B\\u044F \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 \\u0438\\u0449\\u0435\\u0442\\u0441\\u044F \\u043B\\u0443\\u0447\\u0448\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434\\u0430\\n\\t\\t// \\u0432 \\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0430\\u0445 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B \\u043A\\u043B\\u0438\\u043F\\u0430 fromClip\\n\\t\\tfor i := fromClip; i < len(clips); i++ {\\n\\t\\t\\tif clips[i][0] <= clips[fromClip][1] &&\\n\\t\\t\\t\\tmaxLasted < clips[i][1] {\\n\\t\\t\\t\\tmaxLastedPrev = maxLasted\\n\\n\\t\\t\\t\\tmaxLasted = clips[i][1]\\n\\n\\t\\t\\t\\tbestClipId = i\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\t\\tif maxLasted >= time {\\n\\t\\t\\t\\tminCount++\\n\\t\\t\\t\\treturn minCount\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0448\\u043B\\u0438 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 clips[fromClip],\\n\\t\\t\\t// \\u0442\\u043E \\u0434\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0435 \\u0438\\u0449\\u0435\\u043C\\n\\t\\t\\tif clips[i][0] > clips[fromClip][1] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\tif maxLasted >= time {\\n\\t\\t\\tminCount++\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0435\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434 \\u043D\\u0435 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0438\\u043B\\u0441\\u044F, \\u0442\\u043E \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043D\\u0435\\u0442\\n\\t\\tif maxLastedPrev == -1 {\\n\\t\\t\\tminCount = -1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F \\u0432 \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u0438, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u043B\\u0451\\u043D \\u043F\\u0440\\u044B\\u0436\\u043E\\u043A\\n\\t\\t// \\u0441\\u043C\\u0435\\u0449\\u0430\\u0435\\u0442\\u0441\\u044F \\u043D\\u0430 \\u0442\\u043E\\u0442, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043F\\u0440\\u0438\\u0437\\u043D\\u0430\\u043D \\u0441\\u0430\\u043C\\u044B\\u043C \\u043B\\u0443\\u0447\\u0448\\u0438\\u043C\\n\\t\\tfromClip = bestClipId\\n\\t\\tminCount++\\n\\t}\\n\\n\\treturn minCount\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc videoStitching(clips [][]int, time int) int {\\n\\t// \\u0421\\u043E\\u0440\\u0442\\u0438\\u0440\\u0443\\u044E \\u0432\\u0441\\u0435 \\u043A\\u043B\\u0438\\u043F\\u044B \\u043F\\u043E \\u0432\\u043E\\u0437\\u0440\\u0430\\u0441\\u0442\\u0430\\u043D\\u0438\\u044E \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043A\\u043B\\u0438\\u043F\\u0430.\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif len(clips) == 1 &&\\n\\t\\tclips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsort.Slice(clips, func(i, j int) bool {\\n\\t\\tif clips[i][0] < clips[j][0] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif clips[i][0] == clips[j][0] {\\n\\t\\t\\treturn clips[i][1] > clips[j][1]\\n\\t\\t}\\n\\n\\t\\treturn false\\n\\t})\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif clips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// \\u041E\\u0442\\u0432\\u0435\\u0442 \\u043D\\u0430 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0443: \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u044B\\u0445 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0434\\u043B\\u044F\\n\\t// \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u044F \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 [0, time]\\n\\tminCount := 1\\n\\t// \\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u043D\\u0430 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0430\\u043A\\u043E\\u043F\\u043B\\u0435\\u043D\\u043D\\u0430\\u044F \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432\\n\\tmaxLasted := clips[0][1]\\n\\tfromClip := 0 // \\u043A\\u043B\\u0438\\u043F, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C\\u0441\\u044F \\u043F\\u0435\\u0440\\u0435\\u0431\\u0438\\u0440\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F\\n\\n\\tif maxLasted >= time {\\n\\t\\treturn minCount\\n\\t}\\n\\n\\tfor {\\n\\t\\tbestClipId := -1\\n\\t\\tmaxLastedPrev := -1\\n\\t\\t// \\u0414\\u043B\\u044F \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 \\u0438\\u0449\\u0435\\u0442\\u0441\\u044F \\u043B\\u0443\\u0447\\u0448\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434\\u0430\\n\\t\\t// \\u0432 \\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0430\\u0445 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B \\u043A\\u043B\\u0438\\u043F\\u0430 fromClip\\n\\t\\tfor i := fromClip; i < len(clips); i++ {\\n\\t\\t\\tif clips[i][0] <= clips[fromClip][1] &&\\n\\t\\t\\t\\tmaxLasted < clips[i][1] {\\n\\t\\t\\t\\tmaxLastedPrev = maxLasted\\n\\n\\t\\t\\t\\tmaxLasted = clips[i][1]\\n\\n\\t\\t\\t\\tbestClipId = i\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\t\\tif maxLasted >= time {\\n\\t\\t\\t\\tminCount++\\n\\t\\t\\t\\treturn minCount\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0448\\u043B\\u0438 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 clips[fromClip],\\n\\t\\t\\t// \\u0442\\u043E \\u0434\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0435 \\u0438\\u0449\\u0435\\u043C\\n\\t\\t\\tif clips[i][0] > clips[fromClip][1] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\tif maxLasted >= time {\\n\\t\\t\\tminCount++\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0435\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434 \\u043D\\u0435 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0438\\u043B\\u0441\\u044F, \\u0442\\u043E \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043D\\u0435\\u0442\\n\\t\\tif maxLastedPrev == -1 {\\n\\t\\t\\tminCount = -1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F \\u0432 \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u0438, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u043B\\u0451\\u043D \\u043F\\u0440\\u044B\\u0436\\u043E\\u043A\\n\\t\\t// \\u0441\\u043C\\u0435\\u0449\\u0430\\u0435\\u0442\\u0441\\u044F \\u043D\\u0430 \\u0442\\u043E\\u0442, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043F\\u0440\\u0438\\u0437\\u043D\\u0430\\u043D \\u0441\\u0430\\u043C\\u044B\\u043C \\u043B\\u0443\\u0447\\u0448\\u0438\\u043C\\n\\t\\tfromClip = bestClipId\\n\\t\\tminCount++\\n\\t}\\n\\n\\treturn minCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983759,
                "title": "with-similar-problems",
                "content": "# Code\\n``` java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        int n = clips.length;\\n        int curEnd = 0, farCanReach = 0, total = 0;\\n        int i=0;\\n        while(curEnd < time) {\\n            total++;\\n            while(i<n && curEnd >= clips[i][0]) {\\n                farCanReach = Math.max(farCanReach, clips[i++][1]);\\n            }\\n            if(farCanReach == curEnd) {\\n                return -1;\\n            }\\n            curEnd = farCanReach;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        int n = clips.length;\\n        int curEnd = 0, farCanReach = 0, total = 0;\\n        int i=0;\\n        while(curEnd < time) {\\n            total++;\\n            while(i<n && curEnd >= clips[i][0]) {\\n                farCanReach = Math.max(farCanReach, clips[i++][1]);\\n            }\\n            if(farCanReach == curEnd) {\\n                return -1;\\n            }\\n            curEnd = farCanReach;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551128,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int videoStitching(vector<vector<int>>& clips, int time) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    sort(std::begin(clips), std::end(clips));\\n\\n    int i = 0;\\n    while (farthest < time) {\\n      while (i < clips.size() && clips[i][0] <= end)\\n        farthest = max(farthest, clips[i++][1]);\\n      if (end == farthest)\\n        return -1;\\n      ++ans;\\n      end = farthest;\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        stack = [[0,0]]\\n        for c in sorted(clips, key=lambda c: c[0]):\\n            while len(stack) > 1 and stack[-2][1] >= c[0] and stack[-1][1] < c[1]:\\n                stack.pop()\\n            if stack[-1][1] < c[0]: break\\n            if c[1] >= time: return len(stack)\\n            stack.append(c)\\n        return -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            min = max;\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int videoStitching(vector<vector<int>>& clips, int time) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    sort(std::begin(clips), std::end(clips));\\n\\n    int i = 0;\\n    while (farthest < time) {\\n      while (i < clips.size() && clips[i][0] <= end)\\n        farthest = max(farthest, clips[i++][1]);\\n      if (end == farthest)\\n        return -1;\\n      ++ans;\\n      end = farthest;\\n    }\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        stack = [[0,0]]\\n        for c in sorted(clips, key=lambda c: c[0]):\\n            while len(stack) > 1 and stack[-2][1] >= c[0] and stack[-1][1] < c[1]:\\n                stack.pop()\\n            if stack[-1][1] < c[0]: break\\n            if c[1] >= time: return len(stack)\\n            stack.append(c)\\n        return -1\\n```\n```Java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            min = max;\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326289,
                "title": "python-greedy-with-sorting-comprehensive-explanation",
                "content": "# Intuition\\n\\nThe problem is to stitch video clips in a way that the resulting video covers the entire desired time, and we should use as few clips as possible. To achieve this, we need to select clips that start at or before the current end time and extend the video as far as possible.\\n\\n# Algorithm\\n1. Sort the input clips based on their start times.\\n2. Initialize num_clips to 0, current_end_time to 0, and i to 0.\\n3. While i is less than the number of clips:\\n    a. If clips[i][0] is greater than current_end_time, return -1.\\n    b. Initialize max_end_time to current_end_time.\\n    c. While i is less than the number of clips and clips[i][0] is less than or equal to current_end_time:\\n        - i. Update max_end_time to the maximum of max_end_time and clips[i][1].\\n        - ii. Increment i.\\nd. Increment num_clips.\\ne. Update current_end_time to max_end_time.\\nf. If current_end_time is greater than or equal to time, return num_clips.\\n4. Return -1, as the video cannot be stitched to cover the entire desired time.\\n\\n# Complexity\\n - Time complexity: $O(n \\\\cdot log(n))$, where $n$ is the number of clips. The sorting step has a time complexity of $O(n \\\\cdot log(n))$, and the rest of the algorithm takes\\n\\n- Space complexity: $O(1)$, since we only use a constant amount of additional space to store variables like num_clips, current_end_time, and max_end_time.\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key=lambda x: x[0])  \\n\\n        num_clips = 0\\n        current_end_time = 0\\n        i = 0\\n        \\n        while i < len(clips):\\n            if clips[i][0] > current_end_time:\\n                return -1\\n            \\n            max_end_time = current_end_time\\n            while i < len(clips) and clips[i][0] <= current_end_time:\\n                max_end_time = max(max_end_time, clips[i][1])\\n                i += 1\\n                \\n            num_clips += 1\\n            current_end_time = max_end_time\\n            \\n            if current_end_time >= time:\\n                return num_clips\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key=lambda x: x[0])  \\n\\n        num_clips = 0\\n        current_end_time = 0\\n        i = 0\\n        \\n        while i < len(clips):\\n            if clips[i][0] > current_end_time:\\n                return -1\\n            \\n            max_end_time = current_end_time\\n            while i < len(clips) and clips[i][0] <= current_end_time:\\n                max_end_time = max(max_end_time, clips[i][1])\\n                i += 1\\n                \\n            num_clips += 1\\n            current_end_time = max_end_time\\n            \\n            if current_end_time >= time:\\n                return num_clips\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157894,
                "title": "greedy-o-1-space-beats-100-time",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKind of a level order traversal, being greedy on the end of each clip merge which should be the higest value possible.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) : because of the sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        sort(clips.begin(),clips.end());\\n        int numofclips=1;\\n        int end=0;\\n        for(int i=0; i<n;){\\n            int newend=end;\\n            while(i<n && clips[i][0]<=end) newend=max(newend,clips[i++][1]);\\n            if(newend>=time) return numofclips;\\n            if(newend==end) return -1;\\n            end=newend;\\n            numofclips++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        sort(clips.begin(),clips.end());\\n        int numofclips=1;\\n        int end=0;\\n        for(int i=0; i<n;){\\n            int newend=end;\\n            while(i<n && clips[i][0]<=end) newend=max(newend,clips[i++][1]);\\n            if(newend>=time) return numofclips;\\n            if(newend==end) return -1;\\n            end=newend;\\n            numofclips++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128979,
                "title": "kotlin-without-sorting",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun videoStitching(clips: Array<IntArray>, time: Int): Int {\\n        val cTime = mutableMapOf<Int, Int>()\\n\\n        for ((s, e) in clips) {\\n            val clip = cTime[s]\\n            if (clip != null) cTime[s] = max(clip, e)\\n            else cTime[s] = e\\n        }\\n\\n        var result = 0\\n        var i = 0\\n\\n        while (i < time) {\\n            val possPicks = cTime.filter { (k ,v) -> i in k until v }\\n            if (possPicks.isEmpty()) return -1\\n            var j = 0\\n            possPicks.forEach { (_, v) -> if (v - i > j) j = v - i }\\n            i += j\\n            result++\\n        }\\n        return result\\n    }\\n}\\n```\\n![Screen Shot 2023-02-02 at 00.17.46.png](https://assets.leetcode.com/users/images/dfc3354d-86c7-40d4-a69f-13b31b80d7a8_1675287834.3006735.png)",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun videoStitching(clips: Array<IntArray>, time: Int): Int {\\n        val cTime = mutableMapOf<Int, Int>()\\n\\n        for ((s, e) in clips) {\\n            val clip = cTime[s]\\n            if (clip != null) cTime[s] = max(clip, e)\\n            else cTime[s] = e\\n        }\\n\\n        var result = 0\\n        var i = 0\\n\\n        while (i < time) {\\n            val possPicks = cTime.filter { (k ,v) -> i in k until v }\\n            if (possPicks.isEmpty()) return -1\\n            var j = 0\\n            possPicks.forEach { (_, v) -> if (v - i > j) j = v - i }\\n            i += j\\n            result++\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861994,
                "title": "c-dp-memoization-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\nvector<int>dp;\\nint solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n{\\n    if(T<=last_end)\\n        return 0;\\n    if(idx>=clips.size() )\\n        return 100;\\n    if(dp[last_end]!=-1)\\n        return dp[last_end];\\n     if(clips[idx][0]<=last_end)\\n    {\\n        return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n    }\\n    else\\n    {\\n        return dp[last_end]=100;\\n    }\\n       \\n}\\nint videoStitching(vector<vector<int>>& clips, int T)\\n{\\n    dp.resize(T+1,-1);\\n    sort(clips.begin(),clips.end());\\n    int p=solve(clips,T,0,0);\\n    if(p>=100)\\n        return -1;\\n    else\\n        return p;\\n}\\n};\\nif you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\nvector<int>dp;\\nint solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n{\\n    if(T<=last_end)\\n        return 0;\\n    if(idx>=clips.size() )\\n        return 100;\\n    if(dp[last_end]!=-1)\\n        return dp[last_end];\\n     if(clips[idx][0]<=last_end)\\n    {\\n        return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2843131,
                "title": "cpp-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long dp[101][101];\\n    long helper(int i, int prev, vector<vector<int>>&clips, int time){\\n        if(i==clips.size()){\\n            if(time<=prev){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        long pick=1e9;\\n        if(clips[i][0]<=prev){\\n            pick=1+helper(i+1,clips[i][1],clips,time);\\n        }\\n        long notpick=helper(i+1,prev,clips,time);\\n        return dp[i][prev]=min(pick,notpick);\\n    }\\n    long videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        long ans=helper(0,0,clips,time);\\n        if(ans>=1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[101][101];\\n    long helper(int i, int prev, vector<vector<int>>&clips, int time){\\n        if(i==clips.size()){\\n            if(time<=prev){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        long pick=1e9;\\n        if(clips[i][0]<=prev){\\n            pick=1+helper(i+1,clips[i][1],clips,time);\\n        }\\n        long notpick=helper(i+1,prev,clips,time);\\n        return dp[i][prev]=min(pick,notpick);\\n    }\\n    long videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        long ans=helper(0,0,clips,time);\\n        if(ans>=1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744314,
                "title": "0-1-knapsack-model",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& a, int time,int ind,int prev){\\n        if(ind == a.size()){\\n            if(prev >= time){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        int ans = 1e9;\\n        int ans1 = fun(a,time,ind+1,prev);\\n        ans = min(ans,ans1);\\n        if(a[ind][0] <= prev){\\n            int ans2 = 1+fun(a,time,ind+1,a[ind][1]);\\n            ans = min(ans,ans2);\\n        }\\n        return ans;\\n    }\\n    int videoStitching(vector<vector<int>>& a, int time) {\\n        sort(a.begin(),a.end());\\n        int ans = fun(a,time,0,0);\\n        if(ans == 1e9){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& a, int time,int ind,int prev){\\n        if(ind == a.size()){\\n            if(prev >= time){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        int ans = 1e9;\\n        int ans1 = fun(a,time,ind+1,prev);\\n        ans = min(ans,ans1);\\n        if(a[ind][0] <= prev){\\n            int ans2 = 1+fun(a,time,ind+1,a[ind][1]);\\n            ans = min(ans,ans2);\\n        }\\n        return ans;\\n    }\\n    int videoStitching(vector<vector<int>>& a, int time) {\\n        sort(a.begin(),a.end());\\n        int ans = fun(a,time,0,0);\\n        if(ans == 1e9){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736168,
                "title": "python-greedy",
                "content": "This one\\'s a real twist to the classic interval problem(s).\\nThe resolution structure remains the same for the most part, with 2 key steps:\\n* **Sorting the intervals by start ASC, [end DESC]**\\n* **Iterating through the intervals once**, keeping track of (at least) the last interval or part of it (be it the start and end of such interval, or just the end, etc).\\n\\n[I\\'m not gonna leave a full explanation but just the key cases and some considerations for the later presented code, which I tried my best to make self-explanatory. Also, there is some redundancy in it for the sake of clarity]\\n\\n-------------------\\n\\nThe first difference here is that the \"last interval\" is not going to be a definitive part of our solution. It can actually be replaced by another interval later in the iteration.\\n\\nConsider this case. Suppose you currently have a greedy solution like:\\n`solutionIntervals = [ [0,2], [1,5] ]` and you\\'re considering `[2,9]`. \\nThen `[1,5]` must be discarded in favour of `[2,9]`.\\nNow, notice you only need to keep track of the last one and the second-to-last one, for example:\\nYour clips are\\n`[ [0,4], [2,5], [3,6], [4,9] ]`\\nThen your iterations will be something like\\n0.`[0,4]` must be part of the answer\\n1.`[2,5]` contains [4, 5] which we hadn\\'t seen before so include `[2,5]` as candidate. `solutionIntervals = [ [0,4], [2,5] ]`\\n2.`[3,6]` starts before 4 and includes [5, 6], which `[2,5]` doesn\\'t. So we must discard `[2,5]` in favour of `[3,6]` to obtain [0, 6]. `solutionIntervals = [ [0,4], [3,6] ]`\\n3.`[4,9]` starts at 4, and includes [6, 9] which `[3,6]` doesn\\'t. So replace `[3,6]` by `[4,9]`. `solutionIntervals = [ [0,4], [4,9] ]`\\n\\nI know I actually owe a mathematical proof to why everything before the last element in `solutionIntervals` is a definitive part of the answer (that is an invariant of this algorithm btw), I guess it could be proven by contradiction. Do interviewers care about this? I don\\'t know for sure.\\n\\nAside from this case, all you need to do is add the current interval if it adds some bit of the video we hadn\\'t seen before (ie if end > currentEnd)\\n\\n--------------------\\n\\nThat being said, the following algorithm is of **O(NlogN)** time complexity, and **O(N)** space complexity, and it could be improved to **O(1)** (space).\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Sort the clips by start time \\n\\t\\t\\t\\tclips.sort(key=lambda x: (x[0], -x[1]))\\n\\n\\t\\t\\t\\ttotal = 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# This is a list where all of the intervals are a definitive part of our solution, except possibly the last one.\\n\\t\\t\\t\\t# This makes our code O(N) in memory, but we could actually make it O(1).\\n\\t\\t\\t\\t# I\\'ll leave that as homework for the reader(?)\\n\\t\\t\\t\\tintervals = [clips[0]]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# The first interval must always be considered. If there exists a solution at all, it is a definitive part of it.\\n\\t\\t\\t\\tcurrStart = clips[0][0]\\n\\t\\t\\t\\tcurrEnd = clips[0][1]\\n\\n\\t\\t\\t\\t# Minimum start time out of all clips is > 0 ? Forget it, the event has not been fully recorded\\n\\t\\t\\t\\tif currStart > 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t# The first clip begins at 0 and \\n\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tfor start, end in clips[1:]:\\n\\t\\t\\t\\t\\t# eg suppose you have intervals: [ [0,2], [1,9] ] and you consider [3, 4]. It must be discarded\\n\\t\\t\\t\\t\\tif end < currEnd:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\t# If there is only one interval in the list, then you cannot replace it.\\n\\t\\t\\t\\t\\tif len(intervals) == 1:\\n\\t\\t\\t\\t\\t\\t# Default case where you have missing bits of the video\\n\\t\\t\\t\\t\\t\\tif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# This is the case where you replace an interval.\\n\\t\\t\\t\\t\\t\\tif start <= intervals[-2][1] and end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tintervals.pop()\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Missing bits of the video again\\n\\t\\t\\t\\t\\t\\telif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# We know we\\'re not missing anything from the video and we\\'re including parts we hadn\\'t seen before\\n\\t\\t\\t\\t\\t\\telif end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\t# if for some reason we reach the end of the video, stop the iteration there\\n\\t\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t# return -1 if we haven\\'t actually reached the end of the video\\n\\t\\t\\t\\treturn len(intervals) if currEnd >= time else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "This one\\'s a real twist to the classic interval problem(s).\\nThe resolution structure remains the same for the most part, with 2 key steps:\\n* **Sorting the intervals by start ASC, [end DESC]**\\n* **Iterating through the intervals once**, keeping track of (at least) the last interval or part of it (be it the start and end of such interval, or just the end, etc).\\n\\n[I\\'m not gonna leave a full explanation but just the key cases and some considerations for the later presented code, which I tried my best to make self-explanatory. Also, there is some redundancy in it for the sake of clarity]\\n\\n-------------------\\n\\nThe first difference here is that the \"last interval\" is not going to be a definitive part of our solution. It can actually be replaced by another interval later in the iteration.\\n\\nConsider this case. Suppose you currently have a greedy solution like:\\n`solutionIntervals = [ [0,2], [1,5] ]` and you\\'re considering `[2,9]`. \\nThen `[1,5]` must be discarded in favour of `[2,9]`.\\nNow, notice you only need to keep track of the last one and the second-to-last one, for example:\\nYour clips are\\n`[ [0,4], [2,5], [3,6], [4,9] ]`\\nThen your iterations will be something like\\n0.`[0,4]` must be part of the answer\\n1.`[2,5]` contains [4, 5] which we hadn\\'t seen before so include `[2,5]` as candidate. `solutionIntervals = [ [0,4], [2,5] ]`\\n2.`[3,6]` starts before 4 and includes [5, 6], which `[2,5]` doesn\\'t. So we must discard `[2,5]` in favour of `[3,6]` to obtain [0, 6]. `solutionIntervals = [ [0,4], [3,6] ]`\\n3.`[4,9]` starts at 4, and includes [6, 9] which `[3,6]` doesn\\'t. So replace `[3,6]` by `[4,9]`. `solutionIntervals = [ [0,4], [4,9] ]`\\n\\nI know I actually owe a mathematical proof to why everything before the last element in `solutionIntervals` is a definitive part of the answer (that is an invariant of this algorithm btw), I guess it could be proven by contradiction. Do interviewers care about this? I don\\'t know for sure.\\n\\nAside from this case, all you need to do is add the current interval if it adds some bit of the video we hadn\\'t seen before (ie if end > currentEnd)\\n\\n--------------------\\n\\nThat being said, the following algorithm is of **O(NlogN)** time complexity, and **O(N)** space complexity, and it could be improved to **O(1)** (space).\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Sort the clips by start time \\n\\t\\t\\t\\tclips.sort(key=lambda x: (x[0], -x[1]))\\n\\n\\t\\t\\t\\ttotal = 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# This is a list where all of the intervals are a definitive part of our solution, except possibly the last one.\\n\\t\\t\\t\\t# This makes our code O(N) in memory, but we could actually make it O(1).\\n\\t\\t\\t\\t# I\\'ll leave that as homework for the reader(?)\\n\\t\\t\\t\\tintervals = [clips[0]]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# The first interval must always be considered. If there exists a solution at all, it is a definitive part of it.\\n\\t\\t\\t\\tcurrStart = clips[0][0]\\n\\t\\t\\t\\tcurrEnd = clips[0][1]\\n\\n\\t\\t\\t\\t# Minimum start time out of all clips is > 0 ? Forget it, the event has not been fully recorded\\n\\t\\t\\t\\tif currStart > 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t# The first clip begins at 0 and \\n\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tfor start, end in clips[1:]:\\n\\t\\t\\t\\t\\t# eg suppose you have intervals: [ [0,2], [1,9] ] and you consider [3, 4]. It must be discarded\\n\\t\\t\\t\\t\\tif end < currEnd:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\t# If there is only one interval in the list, then you cannot replace it.\\n\\t\\t\\t\\t\\tif len(intervals) == 1:\\n\\t\\t\\t\\t\\t\\t# Default case where you have missing bits of the video\\n\\t\\t\\t\\t\\t\\tif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# This is the case where you replace an interval.\\n\\t\\t\\t\\t\\t\\tif start <= intervals[-2][1] and end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tintervals.pop()\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Missing bits of the video again\\n\\t\\t\\t\\t\\t\\telif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# We know we\\'re not missing anything from the video and we\\'re including parts we hadn\\'t seen before\\n\\t\\t\\t\\t\\t\\telif end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\t# if for some reason we reach the end of the video, stop the iteration there\\n\\t\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t# return -1 if we haven\\'t actually reached the end of the video\\n\\t\\t\\t\\treturn len(intervals) if currEnd >= time else -1",
                "codeTag": "Java"
            },
            {
                "id": 2538961,
                "title": "javascript-greedy",
                "content": "```\\nvar videoStitching = function(clips, time) {\\n    clips.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return b[1] - a[1];\\n        }\\n        else {\\n            return a[0] - b[0];\\n        }\\n    });\\n    //console.log(clips);\\n    if (clips[0][0] !== 0) {\\n        return -1;//no clip starts from 0\\n    }\\n    let currEnd = 0;\\n    let taken = 0;\\n    let nextEnd = 0;\\n\\n    let i = 0;\\n    while (i < clips.length && clips[i][0] <= currEnd) {\\n        while (i < clips.length && clips[i][0] <= currEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n\\n        taken++;\\n        currEnd = nextEnd;\\n        if (currEnd >= time) {\\n            return taken;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nvar videoStitching = function(clips, time) {\\n    clips.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return b[1] - a[1];\\n        }\\n        else {\\n            return a[0] - b[0];\\n        }\\n    });\\n    //console.log(clips);\\n    if (clips[0][0] !== 0) {\\n        return -1;//no clip starts from 0\\n    }\\n    let currEnd = 0;\\n    let taken = 0;\\n    let nextEnd = 0;\\n\\n    let i = 0;\\n    while (i < clips.length && clips[i][0] <= currEnd) {\\n        while (i < clips.length && clips[i][0] <= currEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n\\n        taken++;\\n        currEnd = nextEnd;\\n        if (currEnd >= time) {\\n            return taken;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509349,
                "title": "c-merging-overlapping-intervals",
                "content": "This problem is similiar to merge intervals problem. \\nFor each interaval that we can reach, we check for the maximum right end we can reach. Once we finish all those interavals which can be traversed, we update start. Start is a variable that tells us whether or not we can traverse current interval. \\n\\n**Break :** If while traversing the intervals, our end time(ie the max we can go in the right) becomes greater than required time, we return count. And if the end does not change, then that means our loop is stuck. So we can not move further thus we return -1 \\n\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end());\\n        int i = 0, count=0, start = 0, end = 0;\\n        while(i<clips.size()){\\n            bool flag = false;\\n            while(i<clips.size() and clips[i][0]<=start){\\n                end = max(end,clips[i][1]);\\n                i++;\\n                flag = true;\\n            }\\n            count++;\\n            start = end;\\n            if(end>=time) return count;\\n            if(!flag) return -1;\\n        }\\n        if(end>=time) return count;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end());\\n        int i = 0, count=0, start = 0, end = 0;\\n        while(i<clips.size()){\\n            bool flag = false;\\n            while(i<clips.size() and clips[i][0]<=start){\\n                end = max(end,clips[i][1]);\\n                i++;\\n                flag = true;\\n            }\\n            count++;\\n            start = end;\\n            if(end>=time) return count;\\n            if(!flag) return -1;\\n        }\\n        if(end>=time) return count;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443812,
                "title": "c-dp-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(int ind, int st, int time, vector<vector<int>>& clips, vector<vector<int>> &dp)\\n    {\\n        if(st>=time)\\n        {\\n            return 0;\\n        }\\n        if(ind==clips.size())\\n        {\\n            if(st>=time)\\n            {\\n                return 0;\\n            }else\\n            {\\n                return 1e9;\\n            }\\n        }\\n        if(dp[ind][st]!=-1)\\n        {\\n            return dp[ind][st];\\n        }\\n        if(clips[ind][0]<=st)\\n        {\\n            return dp[ind][st] = min(1 + func(ind+1, clips[ind][1], time, clips, dp), func(ind+1, st, time, clips, dp));\\n        }\\n        \\n        return 1e9;   \\n        \\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(), clips.end());\\n        vector<vector<int>> dp(clips.size(), vector<int> (time+1, -1));\\n        int ans = func(0, 0, time, clips, dp);\\n        if(ans>=1e9)\\n        {\\n            return -1;\\n        }else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int ind, int st, int time, vector<vector<int>>& clips, vector<vector<int>> &dp)\\n    {\\n        if(st>=time)\\n        {\\n            return 0;\\n        }\\n        if(ind==clips.size())\\n        {\\n            if(st>=time)\\n            {\\n                return 0;\\n            }else\\n            {\\n                return 1e9;\\n            }\\n        }\\n        if(dp[ind][st]!=-1)\\n        {\\n            return dp[ind][st];\\n        }\\n        if(clips[ind][0]<=st)\\n        {\\n            return dp[ind][st] = min(1 + func(ind+1, clips[ind][1], time, clips, dp), func(ind+1, st, time, clips, dp));\\n        }\\n        \\n        return 1e9;   \\n        \\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(), clips.end());\\n        vector<vector<int>> dp(clips.size(), vector<int> (time+1, -1));\\n        int ans = func(0, 0, time, clips, dp);\\n        if(ans>=1e9)\\n        {\\n            return -1;\\n        }else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421299,
                "title": "using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(begin(clips),end(clips));\\n        int i=0,c=0,cur=0,nx=0;\\n        if(clips[0][0]!=0) return -1;\\n        while(i<clips.size()){\\n            int t=i;\\n            while(i<clips.size() && clips[i][0]<=cur){\\n                nx=max(nx,clips[i][1]);\\n                i++;\\n            }\\n            if(t==i) return -1;\\n            cur=nx;\\n            c++;\\n            if(cur>=time)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(begin(clips),end(clips));\\n        int i=0,c=0,cur=0,nx=0;\\n        if(clips[0][0]!=0) return -1;\\n        while(i<clips.size()){\\n            int t=i;\\n            while(i<clips.size() && clips[i][0]<=cur){\\n                nx=max(nx,clips[i][1]);\\n                i++;\\n            }\\n            if(t==i) return -1;\\n            cur=nx;\\n            c++;\\n            if(cur>=time)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315898,
                "title": "clear-explanation-with-and-without-sorting",
                "content": "#### Solution-1: Sorting the clips array\\n\\n```\\npublic int videoStitching(int[][] clips, int time) {                \\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        int start = 0, end = 0;\\n        int count = 0, startIndex = 0;\\n\\n        while (start < time) {\\n            while (startIndex < clips.length && clips[startIndex][0] <= start) {\\n                end = Math.max(end, clips[startIndex][1]);\\n                startIndex++;\\n            }\\n            if (start == end) {\\n                return -1;\\n            } else {\\n                start = end;\\n                count++;    \\n            }            \\n        }\\n        return count;\\n    }\\n```\\n\\n1. Sort the given clips array in increasing order of start times. If start times are equal then sort the array in increasing order of end times.\\n2. Traverse the sorted clips array from index = 0. \\n3. For every start time, identify the max end time that is possible. \\n4. Once we get a max end time for a start time. Increment count by 1.\\n5. Continue step-2 until out start >= time.\\n6. Return count\\n\\n\\n#### Without changing the order of the clips array\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] map = new int[time + 1];\\n        Arrays.fill(map, -1);\\n        int count = 0, endTime = time, maxEndTime = 0;\\n\\n        // building map\\n\\t\\tfor (int i = 0; i < clips.length; i++) {\\n            int start = clips[i][0], end = clips[i][1];\\n            if (start >= time) {\\n                continue;\\n            }\\n            map[start] = Math.max(map[start], end);\\n            maxEndTime = Math.max(map[start], maxEndTime);\\n        }\\n\\t\\t\\n\\t\\t// for endtime try to get the min start time as possible.\\n        int prevEndTime = endTime;\\n        while (endTime > 0) {\\n            for (int i = 0; i < map.length; i++) {\\n                if (map[i] >= endTime) {\\n                    count++;\\n                    prevEndTime = endTime;\\n                    endTime = i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// There is no change in end time which represents that there is an interval miss\\n            if (prevEndTime == endTime) {\\n                return -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n1. We maintain a map whose index represent start and map[index] represent max end. \\n2. After building the map, we follow a greedy approach to reach the end time from the minimum start index as possible. Ex: (3, 10), (5, 10). We want to choose (3,10) as it covers more intervals than (5, 10).",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] clips, int time) {                \\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        int start = 0, end = 0;\\n        int count = 0, startIndex = 0;\\n\\n        while (start < time) {\\n            while (startIndex < clips.length && clips[startIndex][0] <= start) {\\n                end = Math.max(end, clips[startIndex][1]);\\n                startIndex++;\\n            }\\n            if (start == end) {\\n                return -1;\\n            } else {\\n                start = end;\\n                count++;    \\n            }            \\n        }\\n        return count;\\n    }\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] map = new int[time + 1];\\n        Arrays.fill(map, -1);\\n        int count = 0, endTime = time, maxEndTime = 0;\\n\\n        // building map\\n\\t\\tfor (int i = 0; i < clips.length; i++) {\\n            int start = clips[i][0], end = clips[i][1];\\n            if (start >= time) {\\n                continue;\\n            }\\n            map[start] = Math.max(map[start], end);\\n            maxEndTime = Math.max(map[start], maxEndTime);\\n        }\\n\\t\\t\\n\\t\\t// for endtime try to get the min start time as possible.\\n        int prevEndTime = endTime;\\n        while (endTime > 0) {\\n            for (int i = 0; i < map.length; i++) {\\n                if (map[i] >= endTime) {\\n                    count++;\\n                    prevEndTime = endTime;\\n                    endTime = i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// There is no change in end time which represents that there is an interval miss\\n            if (prevEndTime == endTime) {\\n                return -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313212,
                "title": "reuse-jump-game-2",
                "content": "```\\n/*\\n\\n    a clip [si, ei] covers the range from si to ei, \\n    means if we are at the timestamp si, we can go till ei, using this one single clip.\\n    \\n    means we are allowed to take a jump of ei - si from si\\n    so for every clip [si, ei] consturct an array , such that a[si] = max(a[si], ei - si);\\n    \\n    and now apply jump game 2 on this array\\n    \\n    clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\\n    \\n    for the above test case, the array will be\\n    \\n    [2, 8, 0, 0, 2, 4, 0, 0, 2, 0, 0]\\n*/\\nclass Solution {\\npublic:\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> a(time + 1, 0);\\n        for(auto e : clips) {\\n            int start = e[0], end = e[1];\\n            if(start < a.size()) a[start] = max(a[start], end - start);\\n        }\\n        \\n        int jumps = 0, cur_max = 0, next_max = 0;\\n        \\n        for(int i = 0; i < a.size(); i++) {\\n            if(i > next_max) return -1;\\n            next_max = max(next_max, i + a[i]);\\n            if(i == cur_max) {\\n                cur_max = next_max;\\n                if(i != a.size() - 1) jumps++;\\n            }\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    a clip [si, ei] covers the range from si to ei, \\n    means if we are at the timestamp si, we can go till ei, using this one single clip.\\n    \\n    means we are allowed to take a jump of ei - si from si\\n    so for every clip [si, ei] consturct an array , such that a[si] = max(a[si], ei - si);\\n    \\n    and now apply jump game 2 on this array\\n    \\n    clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\\n    \\n    for the above test case, the array will be\\n    \\n    [2, 8, 0, 0, 2, 4, 0, 0, 2, 0, 0]\\n*/\\nclass Solution {\\npublic:\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> a(time + 1, 0);\\n        for(auto e : clips) {\\n            int start = e[0], end = e[1];\\n            if(start < a.size()) a[start] = max(a[start], end - start);\\n        }\\n        \\n        int jumps = 0, cur_max = 0, next_max = 0;\\n        \\n        for(int i = 0; i < a.size(); i++) {\\n            if(i > next_max) return -1;\\n            next_max = max(next_max, i + a[i]);\\n            if(i == cur_max) {\\n                cur_max = next_max;\\n                if(i != a.size() - 1) jumps++;\\n            }\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212162,
                "title": "java-o-nlogn-with-detailed-explanation-no-dp-bs",
                "content": "```\\npublic int videoStitching(int[][] clips, int time) {\\n        // Sort the array by the start and then sort by the end\\n        Arrays.sort(clips, (a, b) -> \\n                    {\\n                        int result = Integer.compare(a[0], b[0]);\\n                        \\n                        if (result == 0)\\n                        {\\n                            return Integer.compare(a[1], b[1]);\\n                        }\\n                        \\n                        return result;\\n                    });\\n        \\n        // The algorithm:\\n        // We iterate through the sorted array of clips\\n        // and try to find the best candidates for stitching.\\n        // Every time we find a candidate we increase counter.\\n        int[] current = clips[0];\\n        int counter = 1;\\n        \\n        // Edge case when there is no clip starting with 0\\n        if (current[0] != 0)\\n        {\\n            return -1;\\n        }\\n        \\n        for (int i = 1; i < clips.length; i++)\\n        {\\n            // Edge case when the match length is less than \\n            // total duration of clips.\\n            if (current[1] >= time)\\n            {\\n                return counter;\\n            }\\n\\n            // If there are two clips with the same start time\\n            // we use the next one because it has end time further away \\n            // (because the array ordered by the end time in ascending order)\\n            if (clips[i][0] == current[0])\\n            {\\n                current = clips[i];\\n                continue;\\n            }\\n            \\n            // If there is a gap between clips then we can\\'t form the whole match\\n            // and return -1\\n            if (clips[i][0] > current[1])\\n                return -1;\\n            \\n            // In this case the next clip in the array\\n            // is completely covered by current clip\\n            if (current[1] >= clips[i][1])\\n                continue;\\n\\n            // Here we try to find the best candidate for current clip.\\n            // It will be the one whose end is further away and start is within\\n            // current clip so that we can stitch them together\\n            int[] best = clips[i];\\n            int j = i + 1;\\n            while (j < clips.length && clips[j][0] <= current[1])\\n            {\\n                if (clips[j][1] > best[1])\\n                {\\n                    best = clips[j];\\n                    i = j;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // Every time we find the best stitching candidate we increase the counter\\n            // and move to the next iteration\\n            counter++;\\n            current = best;\\n        }\\n        \\n        // Edge case when there are not enough clips to stitch the whole match\\n        if (current[1] < time)\\n            return -1;\\n        \\n        return counter;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int videoStitching(int[][] clips, int time) {\\n        // Sort the array by the start and then sort by the end\\n        Arrays.sort(clips, (a, b) -> \\n                    {\\n                        int result = Integer.compare(a[0], b[0]);\\n                        \\n                        if (result == 0)\\n                        {\\n                            return Integer.compare(a[1], b[1]);\\n                        }\\n                        \\n                        return result;\\n                    });\\n        \\n        // The algorithm:\\n        // We iterate through the sorted array of clips\\n        // and try to find the best candidates for stitching.\\n        // Every time we find a candidate we increase counter.\\n        int[] current = clips[0];\\n        int counter = 1;\\n        \\n        // Edge case when there is no clip starting with 0\\n        if (current[0] != 0)\\n        {\\n            return -1;\\n        }\\n        \\n        for (int i = 1; i < clips.length; i++)\\n        {\\n            // Edge case when the match length is less than \\n            // total duration of clips.\\n            if (current[1] >= time)\\n            {\\n                return counter;\\n            }\\n\\n            // If there are two clips with the same start time\\n            // we use the next one because it has end time further away \\n            // (because the array ordered by the end time in ascending order)\\n            if (clips[i][0] == current[0])\\n            {\\n                current = clips[i];\\n                continue;\\n            }\\n            \\n            // If there is a gap between clips then we can\\'t form the whole match\\n            // and return -1\\n            if (clips[i][0] > current[1])\\n                return -1;\\n            \\n            // In this case the next clip in the array\\n            // is completely covered by current clip\\n            if (current[1] >= clips[i][1])\\n                continue;\\n\\n            // Here we try to find the best candidate for current clip.\\n            // It will be the one whose end is further away and start is within\\n            // current clip so that we can stitch them together\\n            int[] best = clips[i];\\n            int j = i + 1;\\n            while (j < clips.length && clips[j][0] <= current[1])\\n            {\\n                if (clips[j][1] > best[1])\\n                {\\n                    best = clips[j];\\n                    i = j;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // Every time we find the best stitching candidate we increase the counter\\n            // and move to the next iteration\\n            counter++;\\n            current = best;\\n        }\\n        \\n        // Edge case when there are not enough clips to stitch the whole match\\n        if (current[1] < time)\\n            return -1;\\n        \\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2194956,
                "title": "greedy-java-explanation",
                "content": "1. Sort the clip by start time\\n2. Initially `start` time is `0`.\\n3. Get the `maximum end time` until you do not see a overlap with `start` time. (`while` loop 2)\\n4. What you are trying to do here is, with overlap from the previous start time or clip, what is the maximum end point you can reach. When there is no overlap with previous clip, 2nd while loop ends.\\n5. At any given point in time, if the start and end meets, then end point is stuck, hence there is no solution. (`return -1`).\\n6. otherwise, you found the minimum clip until the end, now we can start searching for the clip from the end point, which means map `end to start`.\\n7. count the clip.\\n8. repeat from `step 2`.\\n\\n*If i try to generalize it, minimum number of operations/steps or whatever entity to cover entire data structure,\\nwe can basically use this technique to solve the problem*\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        int start = 0, end = 0, index = 0;\\n        while (start < time) {\\n            while (index < clips.length && clips[index][0] <= start) {\\n                end = Math.max(end, clips[index][1]);\\n                index++;\\n            }\\n            if (start == end) return -1;\\n            start = end;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        int start = 0, end = 0, index = 0;\\n        while (start < time) {\\n            while (index < clips.length && clips[index][0] <= start) {\\n                end = Math.max(end, clips[index][1]);\\n                index++;\\n            }\\n            if (start == end) return -1;\\n            start = end;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106637,
                "title": "python-greedy-sorting",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if time == 0: \\n            return 0\\n        \\n\\t\\t# this can be simplified as  clips.sort(key = lambda x : (x[0])), we only care about start\\n        clips.sort(key = lambda x : (x[0], -x[1]))\\n\\n        ans = 0\\n        cur_end, next_end = 0, 0\\n        i, n = 0, len(clips)\\n        \\n        while i < n and clips[i][0] <=  cur_end:\\n            \\n            # greedy choose next clip\\n            while i < n and clips[i][0] <= cur_end:\\n                next_end = max(next_end, clips[i][1])\\n                i += 1\\n                \\n            \\n            # found one, update cur end\\n            ans += 1\\n            cur_end = next_end\\n            if cur_end >= time:\\n                return ans\\n            \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if time == 0: \\n            return 0\\n        \\n\\t\\t# this can be simplified as  clips.sort(key = lambda x : (x[0])), we only care about start\\n        clips.sort(key = lambda x : (x[0], -x[1]))\\n\\n        ans = 0\\n        cur_end, next_end = 0, 0\\n        i, n = 0, len(clips)\\n        \\n        while i < n and clips[i][0] <=  cur_end:\\n            \\n            # greedy choose next clip\\n            while i < n and clips[i][0] <= cur_end:\\n                next_end = max(next_end, clips[i][1])\\n                i += 1\\n                \\n            \\n            # found one, update cur end\\n            ans += 1\\n            cur_end = next_end\\n            if cur_end >= time:\\n                return ans\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088521,
                "title": "java-easy-o-nlogn-with-explanation",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //initially sort clips so that all clips with common starting point appear together\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        //initially maxReachable clip time is zero\\n        //and count of clips is zero\\n        int maxReachable = 0;\\n        int count = 0;\\n        //i is index for traversing over clips\\n        int i = 0;\\n        \\n        //loop until condition met\\n        while(maxReachable < time) {\\n            //locally we don\\'t know max where we will reach\\n            //so mark -1\\n            int localMaxReachable = -1;\\n            //while i is in range\\n            //go through clips with starting point less than maxReachable time \\n            //because these clips are reachable\\n            while(i<clips.length && clips[i][0] <= maxReachable) {\\n                //find the max reachable point from all these clips\\n                localMaxReachable = Math.max(localMaxReachable, clips[i][1]);\\n                i++;\\n            }\\n            //if after all this we still cannot reach further than current reachable\\n            //then we are stuck and therefore return -1\\n            if(localMaxReachable <= maxReachable)   return -1;\\n            \\n            //otherwise, new maxReachable should be changed\\n            maxReachable = localMaxReachable;\\n            //and we will increase count of clips needed\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //initially sort clips so that all clips with common starting point appear together\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        //initially maxReachable clip time is zero\\n        //and count of clips is zero\\n        int maxReachable = 0;\\n        int count = 0;\\n        //i is index for traversing over clips\\n        int i = 0;\\n        \\n        //loop until condition met\\n        while(maxReachable < time) {\\n            //locally we don\\'t know max where we will reach\\n            //so mark -1\\n            int localMaxReachable = -1;\\n            //while i is in range\\n            //go through clips with starting point less than maxReachable time \\n            //because these clips are reachable\\n            while(i<clips.length && clips[i][0] <= maxReachable) {\\n                //find the max reachable point from all these clips\\n                localMaxReachable = Math.max(localMaxReachable, clips[i][1]);\\n                i++;\\n            }\\n            //if after all this we still cannot reach further than current reachable\\n            //then we are stuck and therefore return -1\\n            if(localMaxReachable <= maxReachable)   return -1;\\n            \\n            //otherwise, new maxReachable should be changed\\n            maxReachable = localMaxReachable;\\n            //and we will increase count of clips needed\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080624,
                "title": "c-short-clear-recursive-memoization",
                "content": "**Recursive Approach**\\n```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vector<vector<int>>& clips, int time, int prev, int idx){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;   // ending time not reachable\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1);\\n        }\\n        \\n        return min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        int prev = 0;\\n        int start = 0;\\n        \\n        int minimumClips = helper(clips, time, prev, start);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\\n\\n**Memoization**\\n```\\nusing vv_t = vector<vector<int>>;\\n\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vv_t& clips, int time, int prev, int idx, vv_t& dp){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;  // ending time not reachable\\n        }\\n        \\n        // we are taking min(prev, time) because clips ending time may exceeds the expected given time and it is considered valid\\n        //example: [[0,4],[2,8]] time = 5\\n        // output: 2\\n        \\n        if(dp[idx][min(prev, time)] != -1){\\n            return dp[idx][prev];\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1, dp);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1, dp);\\n        }\\n         \\n        return dp[idx][min(prev, time)] = min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        constexpr int INF = INT_MAX-1;\\n        int n = clips.size();\\n        int prev = 0;\\n        int start = 0;\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        \\n        vv_t dp(n+1, vector<int>(time+1, -1));\\n        \\n        int minimumClips = helper(clips, time, prev, start, dp);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\\n\\n\\n**Tabulation**\\n```\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vector<vector<int>>& clips, int time, int prev, int idx){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;   // ending time not reachable\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1);\\n        }\\n        \\n        return min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        int prev = 0;\\n        int start = 0;\\n        \\n        int minimumClips = helper(clips, time, prev, start);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\n```\\nusing vv_t = vector<vector<int>>;\\n\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vv_t& clips, int time, int prev, int idx, vv_t& dp){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;  // ending time not reachable\\n        }\\n        \\n        // we are taking min(prev, time) because clips ending time may exceeds the expected given time and it is considered valid\\n        //example: [[0,4],[2,8]] time = 5\\n        // output: 2\\n        \\n        if(dp[idx][min(prev, time)] != -1){\\n            return dp[idx][prev];\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1, dp);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1, dp);\\n        }\\n         \\n        return dp[idx][min(prev, time)] = min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        constexpr int INF = INT_MAX-1;\\n        int n = clips.size();\\n        int prev = 0;\\n        int start = 0;\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        \\n        vv_t dp(n+1, vector<int>(time+1, -1));\\n        \\n        int minimumClips = helper(clips, time, prev, start, dp);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598548,
                "title": "greedy-java",
                "content": "[LC1326](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/1598562/greedy-java)\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(T == 0) return 0;\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int start = clips[i][0], end = clips[i][1];\\n            if(start > T) continue;\\n            dp[start] = Math.max(dp[start], Math.min(end, T));\\n        }\\n        \\n        int next = 0;\\n        int furthest = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i <= T; i++){\\n            next = Math.max(next, dp[i]);\\n            if(i == furthest){\\n                furthest = next;\\n                count++;\\n                if(furthest >= T){\\n                    return count;\\n                }\\n            }\\n        }\\n        return furthest >= T? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(T == 0) return 0;\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int start = clips[i][0], end = clips[i][1];\\n            if(start > T) continue;\\n            dp[start] = Math.max(dp[start], Math.min(end, T));\\n        }\\n        \\n        int next = 0;\\n        int furthest = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i <= T; i++){\\n            next = Math.max(next, dp[i]);\\n            if(i == furthest){\\n                furthest = next;\\n                count++;\\n                if(furthest >= T){\\n                    return count;\\n                }\\n            }\\n        }\\n        return furthest >= T? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505429,
                "title": "c-faster-than-100-time-o-n-space-o-1",
                "content": "we can change the problem to [Jump Game](https://leetcode.com/problems/jump-game-ii/), because it only has 100 clips\\nTime: O(n)\\nSpace: O(1)\\n```\\nint ans = 0, n = clips.size(), stop = 0, nextstop = 0;\\nint dp[101] = {0};\\nfor(int i = 0; i < n; i++){\\n\\tdp[clips[i][0]] = max(dp[clips[i][0]], clips[i][1]);\\n}\\nint i;\\nfor(i = 0; i <= stop && i < time; i++){\\n\\tnextstop = max(nextstop, dp[i]);\\n\\tif(stop == i){\\n\\t\\tans++;\\n\\t\\tstop = nextstop;\\n\\t}\\n}\\nreturn stop >= time? ans: -1;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint ans = 0, n = clips.size(), stop = 0, nextstop = 0;\\nint dp[101] = {0};\\nfor(int i = 0; i < n; i++){\\n\\tdp[clips[i][0]] = max(dp[clips[i][0]], clips[i][1]);\\n}\\nint i;\\nfor(i = 0; i <= stop && i < time; i++){\\n\\tnextstop = max(nextstop, dp[i]);\\n\\tif(stop == i){\\n\\t\\tans++;\\n\\t\\tstop = nextstop;\\n\\t}\\n}\\nreturn stop >= time? ans: -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500050,
                "title": "python-greedy-sort-o-n-o-nlogn-with-explanation",
                "content": "The first idea that come to my mind is to cover as much interval as possible, which is the intuition of sorting the clips array by:\\n1. increasing start time, which allows us to detect void intervals (like [1,3], then [5,7], 4 is not covered, then we can simply return -1)\\n2. decreasing ending time if the start times are the same, which allows maximizing the interval size (like [1,8] comes before [1,2], we use [1,8])\\n\\nAfter that, we can go with a one-pass solution:\\n1. We use the very first item in the array, which should cover 0 as the starttime, then as far as possible for the endtime\\n2. Then we can ignore all intervals with the same starttime. (This idea can be further improved in the code)\\n3. A tricky part comes, like if we have [0,4] in our hand, we should choose [4,7] favor than [2,6], and [4,5], because [4,7] has farther endtime then both, while the starttime is either smaller or equal to the previous endtime (in the code: last_right variable).\\n4. We continue until either we reach a farther endtime than our target, or we come to the end of the array and the target is yet not covered.\\n5. Then we can write our own code, and be careful for the edge cases.\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if not clips:\\n            return -1\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] != 0:\\n            return -1\\n        cur_left, cur_right = clips[0][0], clips[0][1]\\n        i = count = 0\\n        while cur_right < time:\\n            if i == len(clips):\\n                return -1\\n            while i < len(clips) and clips[i][0] == cur_left:\\n                i += 1\\n            last_right = cur_right\\n            while i < len(clips) and last_right >= clips[i][0]:\\n                cur_right = max(cur_right, clips[i][1])\\n                i += 1\\n            if i < len(clips) and clips[i][0] > cur_right:\\n                return -1\\n            count += 1\\n            cur_left = clips[i-1][0]\\n        return count+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if not clips:\\n            return -1\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] != 0:\\n            return -1\\n        cur_left, cur_right = clips[0][0], clips[0][1]\\n        i = count = 0\\n        while cur_right < time:\\n            if i == len(clips):\\n                return -1\\n            while i < len(clips) and clips[i][0] == cur_left:\\n                i += 1\\n            last_right = cur_right\\n            while i < len(clips) and last_right >= clips[i][0]:\\n                cur_right = max(cur_right, clips[i][1])\\n                i += 1\\n            if i < len(clips) and clips[i][0] > cur_right:\\n                return -1\\n            count += 1\\n            cur_left = clips[i-1][0]\\n        return count+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479233,
                "title": "c-greedy-solution",
                "content": "Please Upvote if you like the Solution!\\n\\n     int videoStitching(vector<vector<int>>& clips, int time)\\n     {\\n        int start=0;\\n        int end=0;\\n        int count=0;\\n        \\n        while(end<time)\\n        {\\n            for(int i=0;i<clips.size();i++)\\n            {\\n                if(clips[i][0]<=start && clips[i][1]>end)\\n                {\\n                    end=clips[i][1];\\n                }\\n            }\\n            if(start==end)\\n                return -1;\\n            start=end;\\n            count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "Please Upvote if you like the Solution!\\n\\n     int videoStitching(vector<vector<int>>& clips, int time)\\n     {\\n        int start=0;\\n        int end=0;\\n        int count=0;\\n        \\n        while(end<time)\\n        {\\n            for(int i=0;i<clips.size();i++)\\n            {\\n                if(clips[i][0]<=start && clips[i][1]>end)\\n                {\\n                    end=clips[i][1];\\n                }\\n            }\\n            if(start==end)\\n                return -1;\\n            start=end;\\n            count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1475038,
                "title": "java-0ms-commented",
                "content": "This ran initially in 0ms. When I added the comments it slowed down a bit.\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        List<Integer> startend = new ArrayList<> (time + 1);\\n        // create a list (can create an array) that holds the maximum end time for each start time\\n        for (int i = 0; i <= time; i++) {\\n            startend.add(-1);\\n        }\\n        // store the maximum end time for each start time. \\n        for (int[] clip : clips) {\\n            // might have time = 5 and clip[0] = 8. This will cause an error. The if statement avoids it\\n            if (clip[0] > time) continue;\\n            int tempend = Math.min(time, clip[1]);\\n            startend.set(clip[0], Math.max(startend.get(clip[0]), tempend)); \\n        }\\n        // for a complete clip we need to start from 0\\n        int start = 0;\\n        int end = startend.get(0);\\n        // if we didn\\'t find previously any clip that starts from 0 we return -1; we can\\'t complete the clip\\n        if (end == -1) return -1;\\n        // otherwise, we found 1 clip that can be useful. so we start counting from 1\\n        int count = 1;\\n        // we repeat the pattern until we reach the end time\\n        while (end < time) {\\n            // we need to find a clip (after start) that ends after end.\\n            int max = end;\\n            for (int i = start + 1; i <= end; i++){\\n                if (startend.get(i) > max) max = startend.get(i);\\n            }\\n            // if we didn\\'t find a clip that ends after our end, we are stuck and can\\'t continue\\n            if (max == end) return -1;\\n            // otherwise we need to start searching from where we used to end till the newly found end (max)\\n            start = end;\\n            end = max;\\n            // if we succeeded to find a new end, then we stiched another clip and we can increase our count\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        List<Integer> startend = new ArrayList<> (time + 1);\\n        // create a list (can create an array) that holds the maximum end time for each start time\\n        for (int i = 0; i <= time; i++) {\\n            startend.add(-1);\\n        }\\n        // store the maximum end time for each start time. \\n        for (int[] clip : clips) {\\n            // might have time = 5 and clip[0] = 8. This will cause an error. The if statement avoids it\\n            if (clip[0] > time) continue;\\n            int tempend = Math.min(time, clip[1]);\\n            startend.set(clip[0], Math.max(startend.get(clip[0]), tempend)); \\n        }\\n        // for a complete clip we need to start from 0\\n        int start = 0;\\n        int end = startend.get(0);\\n        // if we didn\\'t find previously any clip that starts from 0 we return -1; we can\\'t complete the clip\\n        if (end == -1) return -1;\\n        // otherwise, we found 1 clip that can be useful. so we start counting from 1\\n        int count = 1;\\n        // we repeat the pattern until we reach the end time\\n        while (end < time) {\\n            // we need to find a clip (after start) that ends after end.\\n            int max = end;\\n            for (int i = start + 1; i <= end; i++){\\n                if (startend.get(i) > max) max = startend.get(i);\\n            }\\n            // if we didn\\'t find a clip that ends after our end, we are stuck and can\\'t continue\\n            if (max == end) return -1;\\n            // otherwise we need to start searching from where we used to end till the newly found end (max)\\n            start = end;\\n            end = max;\\n            // if we succeeded to find a new end, then we stiched another clip and we can increase our count\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430859,
                "title": "java-is-sorting-really-needed",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int currentEnd = 0, lastStart = 0, res = 0;\\n        while (currentEnd < time) {\\n            for (int i = 0; i < clips.length; i++) {\\n                if (clips[i][0] <= lastStart)\\n                    currentEnd = Math.max(currentEnd, clips[i][1]);\\n            }\\n            \\n            if (currentEnd == lastStart)\\n                return -1;\\n            \\n            lastStart = currentEnd;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int currentEnd = 0, lastStart = 0, res = 0;\\n        while (currentEnd < time) {\\n            for (int i = 0; i < clips.length; i++) {\\n                if (clips[i][0] <= lastStart)\\n                    currentEnd = Math.max(currentEnd, clips[i][1]);\\n            }\\n            \\n            if (currentEnd == lastStart)\\n                return -1;\\n            \\n            lastStart = currentEnd;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409409,
                "title": "python3-neat-implementation",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        \\n        clips.sort(key = lambda x:x[1], reverse = True)\\n        clips.sort(key = lambda x:x[0])\\n        if clips[0][0] > 0: return -1  \\n        count = 0\\n        \\n        # take first clip\\n        curr_farthest = clips[0][1]\\n        curr_clip = 0  \\n        count += 1\\n        \\n        while curr_farthest < time:\\n            \\n            next_farthest = -1\\n            i = curr_clip\\n            \\n            while i < len(clips) and clips[i][0] <= curr_farthest :\\n                next_farthest = max(next_farthest, clips[i][1])\\n                i += 1\\n                \\n            if next_farthest <= curr_farthest: return -1\\n            \\n            curr_farthest = next_farthest\\n            curr_clip = i\\n            count += 1\\n            \\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        \\n        clips.sort(key = lambda x:x[1], reverse = True)\\n        clips.sort(key = lambda x:x[0])\\n        if clips[0][0] > 0: return -1  \\n        count = 0\\n        \\n        # take first clip\\n        curr_farthest = clips[0][1]\\n        curr_clip = 0  \\n        count += 1\\n        \\n        while curr_farthest < time:\\n            \\n            next_farthest = -1\\n            i = curr_clip\\n            \\n            while i < len(clips) and clips[i][0] <= curr_farthest :\\n                next_farthest = max(next_farthest, clips[i][1])\\n                i += 1\\n                \\n            if next_farthest <= curr_farthest: return -1\\n            \\n            curr_farthest = next_farthest\\n            curr_clip = i\\n            count += 1\\n            \\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367857,
                "title": "explanation-fo-dp-solution",
                "content": "`dp[i]` is the minimum number of intervals required to reach  `time = i`\\nIn English, the dp array is answering the question : What is the fewest number of clips I can use so that my result includes events at `time  = i`?\\n\\nIf we have three clips `[[1,5], [1,10], [1, 100]]` - it\\'s obvious which one we should choose right? We should choose the one with the biggest range `[1-100]` because we want the fewest clips. This logic is what this DP solution is trying to do. For every `time = i`, we go through every clip and try to choose the best clip for that time. In previous example, the best clip range for `time = 1` is `[1,100]`. \\n\\n**Example:**\\nLet\\'s say we added another clip [50, 60], and we now have `[[1,5], [1,10],  [50,60], [1,100]]`. When we get to `time = 50`, we would first try `[50,60]` before `[1, 100]`. \\n\\nUsing our equation, `dp[i] = Math.min(dp[i], dp[start] + 1)`, `dp[50]=Math.min(100, 51)`, resulting in `dp[50] = 51`. How do we interpret this? Because we haven\\'t seen any other clip that covers `time=50`, we must assume the worst case, which is all other clips before this one only cover 1 second.\\n\\nWhen we arrive to clip `[1, 100]`, we see that this clip covers `time = 50`, we can potentially reuse this range to minimize our clips that we assumed in the worst case previously. We know this covers `time = 50` because of `if(i >= start && i <= end)`. Since we can reuse this range, we can choose between the minimum of how many clips it takes to make the start of this range and the current `time = i`\\n\\n```\\nclass Solution {\\n   public int videoStitching(int[][] clips, int T) {\\n    int[] dp = new int[T+ 1];\\n    Arrays.fill(dp, T+1);\\n    dp[0] = 0;\\n     \\n    for(int i = 1; i <= T; i++) {\\n      for(int[] c : clips) {\\n        int start = c[0];\\n        int end = c[1];\\n        if(i >= start && i <= end) { // Time at `i` is within clip range\\n          /*\\n          dp[start] covers dp[i] in this if statement\\n          If this clip starting here can cover dp[i], we want to check\\n          if it is better than a previous clip that covered i\\n          */\\n          dp[i] = Math.min(dp[i], dp[start] + 1);\\n        }\\n      }\\n    }\\n   if(dp[T] == T+1) return -1;\\n    return dp[T];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int videoStitching(int[][] clips, int T) {\\n    int[] dp = new int[T+ 1];\\n    Arrays.fill(dp, T+1);\\n    dp[0] = 0;\\n     \\n    for(int i = 1; i <= T; i++) {\\n      for(int[] c : clips) {\\n        int start = c[0];\\n        int end = c[1];\\n        if(i >= start && i <= end) { // Time at `i` is within clip range\\n          /*\\n          dp[start] covers dp[i] in this if statement\\n          If this clip starting here can cover dp[i], we want to check\\n          if it is better than a previous clip that covered i\\n          */\\n          dp[i] = Math.min(dp[i], dp[start] + 1);\\n        }\\n      }\\n    }\\n   if(dp[T] == T+1) return -1;\\n    return dp[T];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357550,
                "title": "c-o-n-log-n-sort-greedy",
                "content": "```\\n\\tint videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0];\\n        });\\n        int curr=0;\\n        int i=0;\\n        int n=clips.size();\\n        int ans=0;\\n        while(i<n){\\n            int best=-1;\\n            while(i<n && clips[i][0]<=curr){\\n                if(best==-1 ||\\xA0clips[i][1]>clips[best][1]){\\n                    best=i;\\n                }\\n                i++;\\n            }\\n            if(best==-1){\\n                return curr>=time?ans:-1;\\n            }else{\\n                ans++;\\n                curr=clips[best][1];\\n                if(curr>=time){\\n                    return ans;\\n                }\\n            }   \\n        }\\n        return curr>=time?ans:-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0];\\n        });\\n        int curr=0;\\n        int i=0;\\n        int n=clips.size();\\n        int ans=0;\\n        while(i<n){\\n            int best=-1;\\n            while(i<n && clips[i][0]<=curr){\\n                if(best==-1 ||\\xA0clips[i][1]>clips[best][1]){\\n                    best=i;\\n                }\\n                i++;\\n            }\\n            if(best==-1){\\n                return curr>=time?ans:-1;\\n            }else{\\n                ans++;\\n                curr=clips[best][1];\\n                if(curr>=time){\\n                    return ans;\\n                }\\n            }   \\n        }\\n        return curr>=time?ans:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314525,
                "title": "c-o-n-2-100-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n       int ans=0,cur_min=0;\\n       while(cur_min<time){\\n             int cur_max=INT_MIN;\\n             for(int i=0; i<clips.size(); i++){\\n                 if(clips[i][0]<=cur_min)cur_max=max(cur_max,clips[i][1]);\\n             }\\n           if(cur_max==INT_MIN || cur_max==cur_min)return -1;\\n           ans++;\\n           cur_min=cur_max;\\n       }\\n       return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n       int ans=0,cur_min=0;\\n       while(cur_min<time){\\n             int cur_max=INT_MIN;\\n             for(int i=0; i<clips.size(); i++){\\n                 if(clips[i][0]<=cur_min)cur_max=max(cur_max,clips[i][1]);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1205476,
                "title": "test-case-55-seems-wrong",
                "content": "```\\n\\nInput: [[2,4]]\\n0\\nOutput: -1\\nExpected: 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nInput: [[2,4]]\\n0\\nOutput: -1\\nExpected: 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157480,
                "title": "c-solution-gready-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end(), [] (vector<int>& p, vector<int>& q) {\\n            return p[0] <  q[0];\\n        });\\n        int ans = 0;\\n        int start = 0;\\n        int j = 0;\\n        while(start < T) {\\n            int max_right = start;\\n            while(j < n && clips[j][0] <= start) {\\n                max_right = max(max_right, clips[j][1]);\\n                j++;\\n            }\\n            if(max_right <= start) {\\n                return -1;\\n            }\\n            start = max_right;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end(), [] (vector<int>& p, vector<int>& q) {\\n            return p[0] <  q[0];\\n        });\\n        int ans = 0;\\n        int start = 0;\\n        int j = 0;\\n        while(start < T) {\\n            int max_right = start;\\n            while(j < n && clips[j][0] <= start) {\\n                max_right = max(max_right, clips[j][1]);\\n                j++;\\n            }\\n            if(max_right <= start) {\\n                return -1;\\n            }\\n            start = max_right;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103376,
                "title": "concise-java-greedy-and-swift-dp",
                "content": "Java using greedy algorithm because it turns out in this particular case the local optimals amounts to global optimal:\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, (a,b)-> a[0]-b[0]);\\n        int minCount=0;\\n        for (int i=0, beg=0, end=0; beg<T; beg=end,++minCount) {\\n            for (; i<clips.length && clips[i][0]<=beg; ++i) end=Math.max(end, clips[i][1]);\\n            if (beg==end) return -1;\\n        }\\n        return minCount;\\n    }\\n}\\n```\\nSwift DP approach, slower but it is an algorithm that is generalized and could be used where greedy does not yield global optimal:\\n```\\nclass Solution {\\n    func videoStitching(_ clips: [[Int]], _ T: Int) -> Int {\\n        // dp[0..T] where dp[t]=mininum_intervals_needed_to_reach_t\\n        var dp:[Int]=Array(repeating:T+1,count:T+1)\\n        dp[0]=0\\n        if T==0 {return T}\\n        //where adds a filter to allow early termination, if t-1 is not reachable, so must be t\\n        for t in 1...T where dp[t-1]<T+1 { \\n            for clip in clips {\\n                if clip[0]<=t && t<=clip[1] {\\n                    dp[t]=min(dp[t], dp[clip[0]]+1)\\n                }\\n            }\\n        }\\n        return dp[T]==T+1 ? -1: dp[T]\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, (a,b)-> a[0]-b[0]);\\n        int minCount=0;\\n        for (int i=0, beg=0, end=0; beg<T; beg=end,++minCount) {\\n            for (; i<clips.length && clips[i][0]<=beg; ++i) end=Math.max(end, clips[i][1]);\\n            if (beg==end) return -1;\\n        }\\n        return minCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func videoStitching(_ clips: [[Int]], _ T: Int) -> Int {\\n        // dp[0..T] where dp[t]=mininum_intervals_needed_to_reach_t\\n        var dp:[Int]=Array(repeating:T+1,count:T+1)\\n        dp[0]=0\\n        if T==0 {return T}\\n        //where adds a filter to allow early termination, if t-1 is not reachable, so must be t\\n        for t in 1...T where dp[t-1]<T+1 { \\n            for clip in clips {\\n                if clip[0]<=t && t<=clip[1] {\\n                    dp[t]=min(dp[t], dp[clip[0]]+1)\\n                }\\n            }\\n        }\\n        return dp[T]==T+1 ? -1: dp[T]\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072551,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> jumps(T+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clips[i][0]>T)continue;\\n            jumps[clips[i][0]] = max(jumps[clips[i][0]],clips[i][1]);\\n        }\\n        int cur = 0, back_up = -1, cnt =0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(cur<i)return -1;\\n            back_up = max(back_up, jumps[i]);\\n            if( cur == i && i!=T)\\n            {\\n                cur = back_up;\\n                back_up = -1;\\n                cnt++;\\n            }\\n        }\\n        return (cur<T?-1:cnt);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> jumps(T+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clips[i][0]>T)continue;\\n            jumps[clips[i][0]] = max(jumps[clips[i][0]],clips[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1056299,
                "title": "c-memo",
                "content": "```\\nint INF=1000;\\nclass Solution {\\npublic:\\n    vector<vector<int>>clip;\\n    vector<vector<vector<int>>>dp;\\n    int get(int i,int s,int l)\\n    {\\n        if(i>=clip.size())\\n            return INF;\\n        if(clip[i][0]>s)\\n            return INF;\\n        if(clip[i][0]<=s && clip[i][1]>=l)\\n            return 1;\\n        if(dp[i][s][l]!=-1)\\n            return dp[i][s][l];\\n        int res;\\n        res=min(1+get(i+1,clip[i][1],l),get(i+1,s,l));\\n        return dp[i][s][l]=res;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(),clips.end());\\n        clip=clips;\\n        if(T==0)\\n            return 0;\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp.resize(clips.size(),vector<vector<int>>(T+1,vector<int>(T+1,-1)));\\n        int res=get(0,0,T);\\n        return res>=INF?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint INF=1000;\\nclass Solution {\\npublic:\\n    vector<vector<int>>clip;\\n    vector<vector<vector<int>>>dp;\\n    int get(int i,int s,int l)\\n    {\\n        if(i>=clip.size())\\n            return INF;\\n        if(clip[i][0]>s)\\n            return INF;\\n        if(clip[i][0]<=s && clip[i][1]>=l)\\n            return 1;\\n        if(dp[i][s][l]!=-1)\\n            return dp[i][s][l];\\n        int res;\\n        res=min(1+get(i+1,clip[i][1],l),get(i+1,s,l));\\n        return dp[i][s][l]=res;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(),clips.end());\\n        clip=clips;\\n        if(T==0)\\n            return 0;\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp.resize(clips.size(),vector<vector<int>>(T+1,vector<int>(T+1,-1)));\\n        int res=get(0,0,T);\\n        return res>=INF?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015164,
                "title": "ugly-greedy-solution-but-it-is-fast",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        if T==0:\\n            return 0\\n        last = 0\\n        cnt=1\\n        first = 0\\n        i=0\\n        while i< len(clips):\\n            \\n            if clips[i][0]==first:\\n                last = clips[i][1]\\n                if last >=T:\\n                    return cnt\\n            elif clips[i][0]>first:      \\n                cnt+=1\\n                if clips[i][0]>last:\\n                    return -1\\n                else:\\n                    temp = last\\n                    while i<len(clips) and clips[i][0]<=temp:\\n                        last = max(last, clips[i][1])\\n                        if last>=T:\\n                            return cnt\\n                        i+=1\\n                    \\n                    if i == len(clips):\\n                        if T>last:\\n                            return -1\\n                        return cnt\\n                    first = clips[i][0]\\n            i+=1\\n        if clips[-1][1]== T:\\n            return cnt+1\\n        if T>last:\\n            return -1\\n        return cnt",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        if T==0:\\n            return 0\\n        last = 0\\n        cnt=1\\n        first = 0\\n        i=0\\n        while i< len(clips):\\n            \\n            if clips[i][0]==first:\\n                last = clips[i][1]\\n                if last >=T:\\n                    return cnt\\n            elif clips[i][0]>first:      \\n                cnt+=1\\n                if clips[i][0]>last:\\n                    return -1\\n                else:\\n                    temp = last\\n                    while i<len(clips) and clips[i][0]<=temp:\\n                        last = max(last, clips[i][1])\\n                        if last>=T:\\n                            return cnt\\n                        i+=1\\n                    \\n                    if i == len(clips):\\n                        if T>last:\\n                            return -1\\n                        return cnt\\n                    first = clips[i][0]\\n            i+=1\\n        if clips[-1][1]== T:\\n            return cnt+1\\n        if T>last:\\n            return -1\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 963483,
                "title": "idea",
                "content": "- \"we can cut a clip\" means for an interval, we can use any parts of it. \\n-  we don\\'t care how to cut it, we care how it could help us cover the range ```0..T```\\n- Given the requirement, we need to make sure each number in ```0,1,2,...,T``` will be covered.\\n- we would like to check them one by one: \\n\\t- so, why not check ```0``` first, then ```1```, then ```2```, ... ?\\n- Therefore, we may need to sort the clips (intervals) so that they are better corresponding to the order of from ```0``` to ```T```\\n\\n- Lets start. **Now we firstly need to cover** ```0```. How to cover it? For intervals represented as ```[a,b]```, every interval satisfying ```a<=0<=b``` should be considered.\\n- Okay, so maybe after checking, we find ```many``` intervals they all satisfy ```a<=0<=b```, what to do with them?\\n- We would think: why not just choose the interval with greatest ```b``` ? (greedy)\\n- The followings will be natural:\\n\\t- ok we have chosen the one with greatest ```b```. **We have covered** ```0```, but also looks like by the way we have also covered every number between ```0..b```\\n\\t- we don\\'t need to think about cover ```1..b``` anymore\\n\\t- **next step we just need to think about how to cover** ```b```\\n- What do we do?\\n\\t- We repeat the above method to find intervals satisfying ```a_new<=b<=b_new```\\n\\t- so on so forth!\\n\\t- Until we get a **new** ```b``` such that ```b>=T```,\\n\\t- we\\'re done.\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        \\n        t = 0\\n        curmax = -1\\n        res = 0\\n        \\n        for clip in clips:\\n            if clip[0] <= t:\\n                curmax = max(curmax, clip[1])\\n            else:\\n                t = curmax\\n                res += 1\\n                if t < clip[0]:\\n                    return -1\\n                else:\\n                    curmax = clip[1]\\n            if curmax >= T:\\n                return res + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```0..T```\n```0,1,2,...,T```\n```0```\n```1```\n```2```\n```0```\n```T```\n```0```\n```[a,b]```\n```a<=0<=b```\n```many```\n```a<=0<=b```\n```b```\n```b```\n```0```\n```0..b```\n```1..b```\n```b```\n```a_new<=b<=b_new```\n```b```\n```b>=T```\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        \\n        t = 0\\n        curmax = -1\\n        res = 0\\n        \\n        for clip in clips:\\n            if clip[0] <= t:\\n                curmax = max(curmax, clip[1])\\n            else:\\n                t = curmax\\n                res += 1\\n                if t < clip[0]:\\n                    return -1\\n                else:\\n                    curmax = clip[1]\\n            if curmax >= T:\\n                return res + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957420,
                "title": "java-accepted-greedy-0ms",
                "content": "**GREEDY APPROACH** \\n\\nFirst sort the array so that we skip un - necessary comparisons\\nStarting from start=0,  we try and go till start=T, and at each time try to reach the furthest distance , so that we minimise the number of intervals.\\nThe core idea is quite similar to *jump game* question where we have to reach the end in minimum jumps.\\n\\n```\\n\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int count =0;\\n        int start=0;\\n        int i=0;\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        \\n        while(start<T)\\n        {\\n            int max = -1 ;\\n            boolean exist =false;\\n            for(;i<clips.length && start>=clips[i][0];i++)\\n            {\\n            //  System.out.println(Arrays.toString(clips[i]));\\n                if(max < clips[i][1])\\n                {\\n                    max=clips[i][1];\\n                    exist=true;\\n                }\\n                \\n            }\\n         //   System.out.println(max);\\n           \\n            if(!exist)\\n                return -1;\\n            count++;\\n            start =  max;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int count =0;\\n        int start=0;\\n        int i=0;\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        \\n        while(start<T)\\n        {\\n            int max = -1 ;\\n            boolean exist =false;\\n            for(;i<clips.length && start>=clips[i][0];i++)\\n            {\\n            //  System.out.println(Arrays.toString(clips[i]));\\n                if(max < clips[i][1])\\n                {\\n                    max=clips[i][1];\\n                    exist=true;\\n                }\\n                \\n            }\\n         //   System.out.println(max);\\n           \\n            if(!exist)\\n                return -1;\\n            count++;\\n            start =  max;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923972,
                "title": "python3-commented-faster-than-95-51",
                "content": "*Runtime: 28 ms, faster than 95.51% of Python3 online submissions for Video Stitching.\\nMemory Usage: 14.3 MB, less than 100.00% of Python3 online submissions for Video Stitching.*\\n\\n```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], target: int) -> int:\\n        if not clips:\\n            return -1\\n        # sort by earliest start and furtest end\\n        sorted_clips = sorted(clips, key=lambda clip: (clip[0], -clip[1]))\\n        # currently covered\\n        covered_left, covered_right = sorted_clips[0]\\n        # special case 0 not covered?\\n        if not covered_left <= 0 <= covered_right:\\n            return -1\\n        # keep track of the clips used\\n        min_clips = 1\\n        # explore the rest of the clips\\n        i = 1\\n        while i < len(sorted_clips):\\n            # check if we are done covering the target\\n            if target <= covered_right:\\n                return min_clips\\n            # check if the coverage is continuos\\n            left, right = sorted_clips[i]\\n            if not left <= covered_right:\\n                return -1\\n            # greedy choose the furthest each time\\n            while i < len(sorted_clips) and sorted_clips[i][0] <= covered_right:\\n                right = max(right, sorted_clips[i][1])\\n                i += 1\\n            # update covered interval\\n            covered_right = right\\n            min_clips += 1\\n            i += 1\\n        # we used all the clips but the target is still out of range?\\n        if not target <= right:\\n            return -1\\n        return min_clips\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], target: int) -> int:\\n        if not clips:\\n            return -1\\n        # sort by earliest start and furtest end\\n        sorted_clips = sorted(clips, key=lambda clip: (clip[0], -clip[1]))\\n        # currently covered\\n        covered_left, covered_right = sorted_clips[0]\\n        # special case 0 not covered?\\n        if not covered_left <= 0 <= covered_right:\\n            return -1\\n        # keep track of the clips used\\n        min_clips = 1\\n        # explore the rest of the clips\\n        i = 1\\n        while i < len(sorted_clips):\\n            # check if we are done covering the target\\n            if target <= covered_right:\\n                return min_clips\\n            # check if the coverage is continuos\\n            left, right = sorted_clips[i]\\n            if not left <= covered_right:\\n                return -1\\n            # greedy choose the furthest each time\\n            while i < len(sorted_clips) and sorted_clips[i][0] <= covered_right:\\n                right = max(right, sorted_clips[i][1])\\n                i += 1\\n            # update covered interval\\n            covered_right = right\\n            min_clips += 1\\n            i += 1\\n        # we used all the clips but the target is still out of range?\\n        if not target <= right:\\n            return -1\\n        return min_clips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921334,
                "title": "simple-greedy-problem-java-combine-two-problems",
                "content": "There are two problems which are identical, It has same logic and approch. Both problems solved with Greedy.\\n1024. Video Stitching\\n1326. Minimum Number of Taps to Open to Water a Garden\\n\\n```\\n/*  [0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n*/\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int min =0;\\n        int max =0;\\n        int total = 0;\\n        \\n        while(max<T) {             //Maximum value is crossing the total time\\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && max<right) {    \\n                    max = right;\\n                }\\n            }\\n            if(min == max) {    //If solution could not be possibele.\\n                return -1;\\n            }\\n            min = max;  //Setting min to max for next incoming clip\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\\n1326. Minimum Number of Taps to Open to Water a Garden \\nFor this problem, please see a picture in describe, they have described very well to give visual impact.\\n```\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        int idx = 0;\\n        \\n        while(max<n) {                //  If maximum value is crossing the nober of taps\\n            for(int i=idx; i<ranges.length; i++) {\\n                if(i-ranges[i]<=min && max<i+ranges[i]){\\n                    max= i + ranges[i];   //Setting Maximum from the ranges\\n                    idx = i;\\n                }\\n            }\\n            if(min == max) return -1;   //Suppose there is no solution possible\\n            min = max;                  // Setting Minimum to start a new range\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\\nPlease upvote if you like.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n/*  [0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n*/\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int min =0;\\n        int max =0;\\n        int total = 0;\\n        \\n        while(max<T) {             //Maximum value is crossing the total time\\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && max<right) {    \\n                    max = right;\\n                }\\n            }\\n            if(min == max) {    //If solution could not be possibele.\\n                return -1;\\n            }\\n            min = max;  //Setting min to max for next incoming clip\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        int idx = 0;\\n        \\n        while(max<n) {                //  If maximum value is crossing the nober of taps\\n            for(int i=idx; i<ranges.length; i++) {\\n                if(i-ranges[i]<=min && max<i+ranges[i]){\\n                    max= i + ranges[i];   //Setting Maximum from the ranges\\n                    idx = i;\\n                }\\n            }\\n            if(min == max) return -1;   //Suppose there is no solution possible\\n            min = max;                  // Setting Minimum to start a new range\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907548,
                "title": "o-n-no-sorting-based-on-jump-game",
                "content": "This problem is actually same with jump game.\\nFirst we build jump distance array:\\n```\\n        //for every position befor T, we find the max distance from this position\\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n```\\n\\nThen, we compute like jump game \\nbtw, jump game is actually a BFS pattern problem.\\nSo, for every step, we try to gain the max distance we can jump.\\nIf we arrive current max distance, we update the max distance by max, and res+=1;\\n\\n```\\n        int max = 0, res = 0, curMax = 0;\\n\\t\\t\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nThe complete code is :\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t//part one: build the step-distance 1-D array\\n        int[] maxEnd = new int[T];                \\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n        \\n\\t\\t//part two: solve it likes jump game \\n        int max = 0, res = 0, curMax = 0;\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```\\nThe time complexity is O(n)",
                "solutionTags": [],
                "code": "```\\n        //for every position befor T, we find the max distance from this position\\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n```\n```\\n        int max = 0, res = 0, curMax = 0;\\n\\t\\t\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t//part one: build the step-distance 1-D array\\n        int[] maxEnd = new int[T];                \\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n        \\n\\t\\t//part two: solve it likes jump game \\n        int max = 0, res = 0, curMax = 0;\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896344,
                "title": "java-dp-solution-with-explanation",
                "content": "Take reference of this example to understand:\\n```\\nint[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n```\\n\\n1. Sort the clips by start time.\\n2. \"normalise the input\". This means if there is any interval after sorting with same start time then pick the one with highest end time, like in above example if we have ``[0,1], [0,2], [0,3], [0,4]`` then it is obvious that if we pick ``[0,4] `` then it will contribute to min length.\\n3. As a part of normalisation also check if there is an interval which fully merges in the interval just retrieved above, then ignore it. For instance we had interval ``[0,4]`` now adding ``[2,4]`` will not contribute to anything so do not add it in out normalised list.\\n4. Now After running above 3 steps my list will only contain \\n\\n```\\n0,4\\n2,6\\n4,7\\n6,9\\n```\\n\\nNow convert this question to https://leetcode.com/problems/jump-game-ii/ and solve it using a DP array where dp[i] denotes min number of steps required to reach i\\n\\nNow my jump array will be as below:\\n``[4,0,6,0,7,0,9,0,0]``\\n\\nThis means that I can move from index 0 to index 4 or I can move from index 2 to index 6.\\n\\nfor my dp i am using two loops. I fix my first loop and move the second loop till max index defined in value of first loop and ask myself a simple question.\\n\\nWhat is the min steps required to move to index j from index i.\\n\\n```\\npackage com.practice.queue;\\n\\nimport java.util.*;\\n\\n//https://leetcode.com/problems/video-stitching/\\npublic class VideoStitching {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(clips == null || clips.length <=0) {\\n            return -1;\\n        }\\n        Arrays.sort(clips, (a, b) -> Integer.compare(a[0], b[0]));\\n        if(clips[clips.length - 1][1] < T) {\\n            return  -1;\\n        }\\n        List<int[]> list = new ArrayList<>();\\n        list.add(clips[0]);\\n        for(int i=1;i<clips.length;i++) {\\n            int start = clips[i][0];\\n            int end = clips[i][1];\\n\\n            int prevStart = list.get(list.size() - 1)[0];\\n            int prevEnd = list.get(list.size() - 1)[1];\\n\\n            if(prevStart == start) {\\n                if(end > prevEnd) {\\n                    list.remove(list.size() - 1);\\n                    list.add(clips[i]);\\n                }\\n                continue;\\n            }\\n            if (start <= prevEnd && end <= prevEnd) {\\n                continue;\\n            }\\n            list.add(clips[i]);\\n        }\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        int[] jump = new int[T + 1];\\n        Arrays.fill(jump, 0);\\n        for(int[] current: list) {\\n            if(current[0] >= T) {\\n                continue;\\n            }\\n            jump[current[0]] = current[1];\\n        }\\n\\n        for(int i=0;i<T;i++) {\\n            if(jump[i] == 0) {\\n                continue;\\n            }\\n            int j = i + 1;\\n            for(;j <= jump[i] && j <= T;j++) {\\n                dp[j] = Math.min(dp[j], 1 + dp[i]);\\n            }\\n\\n        }\\n        for(int i=0;i<=T;i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                return -1;\\n            }\\n        }\\n        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];\\n    }\\n\\n    public static void main(String args[]) {\\n        VideoStitching videoStitching =  new VideoStitching();\\n        int[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n\\n        videoStitching.videoStitching(arr, 9);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n```\n```\\n0,4\\n2,6\\n4,7\\n6,9\\n```\n```\\npackage com.practice.queue;\\n\\nimport java.util.*;\\n\\n//https://leetcode.com/problems/video-stitching/\\npublic class VideoStitching {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(clips == null || clips.length <=0) {\\n            return -1;\\n        }\\n        Arrays.sort(clips, (a, b) -> Integer.compare(a[0], b[0]));\\n        if(clips[clips.length - 1][1] < T) {\\n            return  -1;\\n        }\\n        List<int[]> list = new ArrayList<>();\\n        list.add(clips[0]);\\n        for(int i=1;i<clips.length;i++) {\\n            int start = clips[i][0];\\n            int end = clips[i][1];\\n\\n            int prevStart = list.get(list.size() - 1)[0];\\n            int prevEnd = list.get(list.size() - 1)[1];\\n\\n            if(prevStart == start) {\\n                if(end > prevEnd) {\\n                    list.remove(list.size() - 1);\\n                    list.add(clips[i]);\\n                }\\n                continue;\\n            }\\n            if (start <= prevEnd && end <= prevEnd) {\\n                continue;\\n            }\\n            list.add(clips[i]);\\n        }\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        int[] jump = new int[T + 1];\\n        Arrays.fill(jump, 0);\\n        for(int[] current: list) {\\n            if(current[0] >= T) {\\n                continue;\\n            }\\n            jump[current[0]] = current[1];\\n        }\\n\\n        for(int i=0;i<T;i++) {\\n            if(jump[i] == 0) {\\n                continue;\\n            }\\n            int j = i + 1;\\n            for(;j <= jump[i] && j <= T;j++) {\\n                dp[j] = Math.min(dp[j], 1 + dp[i]);\\n            }\\n\\n        }\\n        for(int i=0;i<=T;i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                return -1;\\n            }\\n        }\\n        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];\\n    }\\n\\n    public static void main(String args[]) {\\n        VideoStitching videoStitching =  new VideoStitching();\\n        int[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n\\n        videoStitching.videoStitching(arr, 9);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866265,
                "title": "confused-why-dp-at-all-if-you-already-sort-them-first",
                "content": "Both the question and the hints indicate that we should consider DP, which is what many people including myself have tried. In these DP solutions we sort the input clips first by their starting point, and then apply DP. However once they are sorted, why apply DP (O(TN)) instead of simply go through the sorted list (O(N))?\\n\\nMy solution with sorting but not DP (faster than ~90%, but not the point)\\n```\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if (T == 0) {\\n            return 0;\\n        }\\n                \\n        std::sort(clips.begin(), clips.end(), [](const std::vector<int> &lhs, const std::vector<int> &rhs){\\n           if (lhs[0] != rhs[0]) {\\n               return lhs[0] < rhs[0];\\n           } else {\\n               return lhs[1] > rhs[1];\\n           }\\n        });\\n        \\n\\t\\t// The max value that we can reach so far.\\n        int max_seen = 0;\\n\\t\\t// The previous max_seen, from which we try to determine the current candiate interval.\\n        int start_point = 0;\\n\\t\\t// Number of interval needed to reconstruct the video.\\n        int interval_count = 0; \\n\\t\\t\\n\\t\\t// Instead of DP, simply go through all the clips in one pass.\\n        for (const std::vector<int> &clip : clips) {\\n            if (clip[1] <= max_seen) {\\n                continue;\\n            } else if (max_seen < clip[0]) {\\n                return -1;\\n            }\\n            \\n            if (clip[0] > start_point) {\\n                // Part of the current clip is not covered by the previous interval, \\n\\t\\t\\t\\t// so start a new candidate interval.\\n                start_point = max_seen;\\n                 ++interval_count;\\n            } \\n\\n            if (clip[1] >= T) {\\n                return ++interval_count;\\n            }\\n            max_seen = clip[1];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if (T == 0) {\\n            return 0;\\n        }\\n                \\n        std::sort(clips.begin(), clips.end(), [](const std::vector<int> &lhs, const std::vector<int> &rhs){\\n           if (lhs[0] != rhs[0]) {\\n               return lhs[0] < rhs[0];\\n           } else {\\n               return lhs[1] > rhs[1];\\n           }\\n        });\\n        \\n\\t\\t// The max value that we can reach so far.\\n        int max_seen = 0;\\n\\t\\t// The previous max_seen, from which we try to determine the current candiate interval.\\n        int start_point = 0;\\n\\t\\t// Number of interval needed to reconstruct the video.\\n        int interval_count = 0; \\n\\t\\t\\n\\t\\t// Instead of DP, simply go through all the clips in one pass.\\n        for (const std::vector<int> &clip : clips) {\\n            if (clip[1] <= max_seen) {\\n                continue;\\n            } else if (max_seen < clip[0]) {\\n                return -1;\\n            }\\n            \\n            if (clip[0] > start_point) {\\n                // Part of the current clip is not covered by the previous interval, \\n\\t\\t\\t\\t// so start a new candidate interval.\\n                start_point = max_seen;\\n                 ++interval_count;\\n            } \\n\\n            if (clip[1] >= T) {\\n                return ++interval_count;\\n            }\\n            max_seen = clip[1];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847705,
                "title": "c-knapsack-and-dfs-dp-approaches-explained",
                "content": "For the **Knapsack** idea, at a starting time, for the given clip, you have 2 options; you can either select the clip or choose to not select it. The time should also be part of DP state, because  our decision might change if we have encountered the clip at a different time.\\n**Time Complexity: O(N * T)**\\n\\nFor the **DFS** idea, ```dp(i)``` represents the number of clips you further need given that you have selected the clip ```i```. So, run a dfs checking for all possible options from ```i+1```. \\n**Time Complexity: O(N^2)**\\n\\nSince, in both the cases, its easier only when the clips are ordered according to their starting time, we sort them.\\n```\\nDFS DP\\nint memo[100];\\nint dp(int i,vector<vector<int>>& arr, int time,int T)\\n{\\n\\tif(time>=T)\\n\\t\\treturn 0;\\n\\telse if(i>=arr.size())\\n\\t\\treturn 1000;\\n\\telse if(memo[i]!=-1)\\n\\t\\treturn memo[i];\\n\\telse\\n\\t{\\n\\t\\tint q=1000;\\n\\t\\tfor(int j=i+1;j<arr.size()&&time>=arr[j][0];++j)\\n\\t\\t\\tq=min(q,1+dp(j,arr,max(time,arr[j][1]),T));\\n\\t\\treturn memo[i]=q;\\n\\t}\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) \\n{\\n\\tsort(clips.begin(),clips.end());\\n\\tmemset(memo,-1,sizeof(memo));\\n\\tint ret=1000;\\n\\tfor(int i=0;i<clips.size();++i)\\n\\t\\tif(clips[i][0]==0)\\n\\t\\t\\tret=min(ret,1+dp(i,clips,clips[i][1],T));\\n\\treturn ret<1000?ret:-1;\\n}\\n\\n\\t```\\nKnapsack DP\\n\\nvector<vector<int>> memo;\\nint dp(int i,int t,vector<vector<int>>& clips,int T)\\n{\\n\\tif(i>=clips.size())\\n\\t{\\n\\t\\tif(t>=T)\\n\\t\\t\\treturn 0;\\n\\t\\telse return 101;\\n\\t}\\n\\tif(memo[i][t]!=-1)\\n\\t\\treturn memo[i][t];\\n\\tint not_taken=dp(i+1,t,clips,T);\\n\\tint taken=101;\\n\\tif(clips[i][0]<=t)\\n\\t\\ttaken=1+dp(i+1,max(t,clips[i][1]),clips,T);\\n\\treturn memo[i][t]=min(taken,not_taken);\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(),clips.end());\\n\\tmemo.resize(clips.size(),vector<int>(100+1,-1));\\n\\tint val=dp(0,0,clips,T);\\n\\treturn val<=clips.size()?val:-1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp(i)```\n```i```\n```i+1```\n```\\nDFS DP\\nint memo[100];\\nint dp(int i,vector<vector<int>>& arr, int time,int T)\\n{\\n\\tif(time>=T)\\n\\t\\treturn 0;\\n\\telse if(i>=arr.size())\\n\\t\\treturn 1000;\\n\\telse if(memo[i]!=-1)\\n\\t\\treturn memo[i];\\n\\telse\\n\\t{\\n\\t\\tint q=1000;\\n\\t\\tfor(int j=i+1;j<arr.size()&&time>=arr[j][0];++j)\\n\\t\\t\\tq=min(q,1+dp(j,arr,max(time,arr[j][1]),T));\\n\\t\\treturn memo[i]=q;\\n\\t}\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) \\n{\\n\\tsort(clips.begin(),clips.end());\\n\\tmemset(memo,-1,sizeof(memo));\\n\\tint ret=1000;\\n\\tfor(int i=0;i<clips.size();++i)\\n\\t\\tif(clips[i][0]==0)\\n\\t\\t\\tret=min(ret,1+dp(i,clips,clips[i][1],T));\\n\\treturn ret<1000?ret:-1;\\n}\\n\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 833691,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        if(clips.size() == 0)\\n            return -1;\\n        \\n        sort(clips.begin(), clips.end(), \\n            [&](vector<int> &a, vector<int> &b)\\n            {\\n                return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n            });\\n        \\n        \\n\\n        int idx = 0;\\n        for(int i = 0; i < clips.size(); i++){\\n            if(clips[i][0] != clips[idx][0])\\n                swap(clips[++idx], clips[i]);\\n        }\\n\\n        clips.resize(1 + idx);\\n        \\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        vector<int> frag(T + 1, INT_MAX);\\n        for(int i = 0; i <= clips[0][1] && i <= T; i++)\\n            frag[i] = 1;\\n\\n        for(int i = 1; i < clips.size() && clips[i][0] < T; i++) \\n        {\\n            if(frag[clips[i][0]] == INT_MAX)\\n                return -1;\\n            else {\\n                int cnt = frag[clips[i][0]];\\n                for(int j = clips[i][0]; j <= clips[i][1] && j <= T; j++)\\n                    frag[j] = min(frag[j], cnt + 1);\\n            }\\n        }\\n        \\n        return frag.back() == INT_MAX ? -1 : frag.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        if(clips.size() == 0)\\n            return -1;\\n        \\n        sort(clips.begin(), clips.end(), \\n            [&](vector<int> &a, vector<int> &b)\\n            {\\n                return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n            });\\n        \\n        \\n\\n        int idx = 0;\\n        for(int i = 0; i < clips.size(); i++){\\n            if(clips[i][0] != clips[idx][0])\\n                swap(clips[++idx], clips[i]);\\n        }\\n\\n        clips.resize(1 + idx);\\n        \\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        vector<int> frag(T + 1, INT_MAX);\\n        for(int i = 0; i <= clips[0][1] && i <= T; i++)\\n            frag[i] = 1;\\n\\n        for(int i = 1; i < clips.size() && clips[i][0] < T; i++) \\n        {\\n            if(frag[clips[i][0]] == INT_MAX)\\n                return -1;\\n            else {\\n                int cnt = frag[clips[i][0]];\\n                for(int j = clips[i][0]; j <= clips[i][1] && j <= T; j++)\\n                    frag[j] = min(frag[j], cnt + 1);\\n            }\\n        }\\n        \\n        return frag.back() == INT_MAX ? -1 : frag.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833273,
                "title": "top-down-and-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        memo = []\\n        for i in range(T+1):\\n            memo.append([-1 for _ in range(T+1)])\\n            \\n        def dp(left, right):\\n            # print(left, right)\\n            if left >= right:\\n                return 0\\n            if memo[left][right] != -1:\\n                return memo[left][right]\\n\\n            ret = float(\"inf\")\\n            for cleft, cright in clips:\\n                if cleft <= left and cright <= left or cleft >= right and cright >= right:\\n                    continue\\n                ret = min(ret, 1 + dp(left, cleft) + dp(cright, right))\\n            memo[left][right] = ret\\n            return ret\\n        \\n        ret = dp(0, T)\\n        return ret if ret != float(\"inf\") else -1\\n```\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort(key = lambda x: (x[0], x[1]))\\n        memo = []\\n        for left in range(T+1):\\n            memo.append([float(\"inf\") for _ in range(T+1)])\\n            for right in range(T+1):\\n                if left >= right:\\n                    memo[left][right] = 0 \\n            \\n        for l in range(1, T+2):\\n            for left in range(T+1):\\n                right = left + l - 1\\n                # print(left, right)\\n                if right > T:\\n                    break\\n                for cleft, cright in clips:\\n                    if cleft <= left and cright <= left:\\n                        continue\\n                    if cleft >= right and cright >= right:\\n                        break\\n                    p1 = memo[left][cleft]\\n                    p2 = memo[cright][right] if cright <= right else 0\\n                    memo[left][right] = min(memo[left][right], 1 + p1 + p2)\\n        return memo[0][T] if memo[0][T] != float(\"inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        memo = []\\n        for i in range(T+1):\\n            memo.append([-1 for _ in range(T+1)])\\n            \\n        def dp(left, right):\\n            # print(left, right)\\n            if left >= right:\\n                return 0\\n            if memo[left][right] != -1:\\n                return memo[left][right]\\n\\n            ret = float(\"inf\")\\n            for cleft, cright in clips:\\n                if cleft <= left and cright <= left or cleft >= right and cright >= right:\\n                    continue\\n                ret = min(ret, 1 + dp(left, cleft) + dp(cright, right))\\n            memo[left][right] = ret\\n            return ret\\n        \\n        ret = dp(0, T)\\n        return ret if ret != float(\"inf\") else -1\\n```\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort(key = lambda x: (x[0], x[1]))\\n        memo = []\\n        for left in range(T+1):\\n            memo.append([float(\"inf\") for _ in range(T+1)])\\n            for right in range(T+1):\\n                if left >= right:\\n                    memo[left][right] = 0 \\n            \\n        for l in range(1, T+2):\\n            for left in range(T+1):\\n                right = left + l - 1\\n                # print(left, right)\\n                if right > T:\\n                    break\\n                for cleft, cright in clips:\\n                    if cleft <= left and cright <= left:\\n                        continue\\n                    if cleft >= right and cright >= right:\\n                        break\\n                    p1 = memo[left][cleft]\\n                    p2 = memo[cright][right] if cright <= right else 0\\n                    memo[left][right] = min(memo[left][right], 1 + p1 + p2)\\n        return memo[0][T] if memo[0][T] != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821273,
                "title": "dp-explained-beats-92-c",
                "content": "\\n> Approach \\n1. You might have figured out we need a travesal scheme.\\n2. Also you would have thought to order the clips in increasing order of `{start, end}` time\\n2. For travesal, did you think of some kind of `BFS`?\\n3. You are correct, we attempt this problem by a similar approach. \\n4. Since we have sorted things will be easy \\n5. We try to combine the `clip[i] {st, en}` with `clip[j] {beg, fin} ` , where `j > i and j < n` only when \\n\\ta. when the ovelapp is partial, i.e `clip[j]` should not be completly inside `clip[i]`.\\n\\tb. We come up with following formula for merging \\n\\tc. `(st < beg && beg <= en && en < fin)`\\n\\t\\n6. While merging we store the minimimum (merged) for each clip\\n\\n\\n> Algorithm \\n\\n```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end());\\n        \\n        vector<int> minFromHere(n, 2*T);\\n\\t\\t// a high value \\n        int ans = 2*T;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// starting and ending time \\n            int st = clips[i][0];\\n            int en = clips[i][1];\\n            \\n            if(st == 0) {\\n\\t\\t\\t\\t// first clip\\n                minFromHere[i] = 1;\\n            }\\n            \\n            if(en >= T) {\\n\\t\\t\\t\\t// last clip update ans \\n                ans = min(ans, minFromHere[i]);\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all the intermediate clips \\n            for(int j=i+1; j<n; j++) {\\n\\t\\t\\t\\t// starting and ending time\\n                int beg = clips[j][0];\\n                int fin = clips[j][1];\\n                    \\n                if(st < beg && beg <= en && en < fin) {\\n\\t\\t\\t\\t\\t// valid clip \\n                    minFromHere[j] = min(minFromHere[j], minFromHere[i] + 1);\\n                }\\n            }\\n        }\\n        \\n        return (ans == 2*T? -1: ans);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end());\\n        \\n        vector<int> minFromHere(n, 2*T);\\n\\t\\t// a high value \\n        int ans = 2*T;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// starting and ending time \\n            int st = clips[i][0];\\n            int en = clips[i][1];\\n            \\n            if(st == 0) {\\n\\t\\t\\t\\t// first clip\\n                minFromHere[i] = 1;\\n            }\\n            \\n            if(en >= T) {\\n\\t\\t\\t\\t// last clip update ans \\n                ans = min(ans, minFromHere[i]);\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all the intermediate clips \\n            for(int j=i+1; j<n; j++) {\\n\\t\\t\\t\\t// starting and ending time\\n                int beg = clips[j][0];\\n                int fin = clips[j][1];\\n                    \\n                if(st < beg && beg <= en && en < fin) {\\n\\t\\t\\t\\t\\t// valid clip \\n                    minFromHere[j] = min(minFromHere[j], minFromHere[i] + 1);\\n                }\\n            }\\n        }\\n        \\n        return (ans == 2*T? -1: ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789021,
                "title": "super-easy-java-solution-0ms-100-better",
                "content": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        int min = 0;\\n        int max = 0;\\n        int count = 0;\\n        \\n        while(max<T)\\n        {\\n            for(int i=0;i<clips.length;i++)\\n            {\\n                int left = clips[i][0];\\n                int right = clips[i][1];\\n                \\n                if(left<=min && right>max)\\n                {\\n                    max = right;\\n                }\\n               \\n            }\\n             if(min==max) return -1;\\n                min=max;\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        int min = 0;\\n        int max = 0;\\n        int count = 0;\\n        \\n        while(max<T)\\n        {\\n            for(int i=0;i<clips.length;i++)\\n            {\\n                int left = clips[i][0];\\n                int right = clips[i][1];\\n                \\n                if(left<=min && right>max)\\n                {\\n                    max = right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 733035,
                "title": "python-simple-using-1-d-dp-o-t-len-clips",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp=[float(\"inf\")]*(T+1)\\n        dp[0]=0\\n        for i in range(1,T+1):\\n            for x in clips:\\n                if x[1]>=i>x[0]:\\n                    dp[i]=min(dp[i],dp[x[0]]+1)\\n        if dp[T]==float(\"inf\"):\\n            return -1\\n        return dp[T]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp=[float(\"inf\")]*(T+1)\\n        dp[0]=0\\n        for i in range(1,T+1):\\n            for x in clips:\\n                if x[1]>=i>x[0]:\\n                    dp[i]=min(dp[i],dp[x[0]]+1)\\n        if dp[T]==float(\"inf\"):\\n            return -1\\n        return dp[T]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 541302,
                "title": "simple-c-sorting-method",
                "content": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(), clips.end());\\n\\n\\tint cnt = 1;\\n\\tint curr = 0, next = INT_MIN;\\n\\n\\tfor (vector<int>& val : clips) {\\n\\t\\tif (val[0] <= curr) next = max(next, val[1]);\\n\\t\\telse if (val[0] > next) return -1;\\n\\t\\telse {\\n\\t\\t\\t++cnt;\\n\\t\\t\\tcurr = next;\\n\\t\\t\\tnext = max(next, val[1]);\\n\\t\\t}\\n\\n\\t\\tif (next >= T) return cnt;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(), clips.end());\\n\\n\\tint cnt = 1;\\n\\tint curr = 0, next = INT_MIN;\\n\\n\\tfor (vector<int>& val : clips) {\\n\\t\\tif (val[0] <= curr) next = max(next, val[1]);\\n\\t\\telse if (val[0] > next) return -1;\\n\\t\\telse {\\n\\t\\t\\t++cnt;\\n\\t\\t\\tcurr = next;\\n\\t\\t\\tnext = max(next, val[1]);\\n\\t\\t}\\n\\n\\t\\tif (next >= T) return cnt;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526433,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> intervals(T + 1, 0);  \\n        for (auto &clip : clips) {\\n            if (clip[0] <= T) {\\n                intervals[clip[0]] = min(T, max(intervals[clip[0]], clip[1]));\\n            }\\n        }\\n        int p0 = -1, p1 = intervals[0], cnt = 1;\\n        for (int i = 1; i <= T && p1 >= i; i++) {\\n            if (intervals[i] > p1) {\\n                if (i <= p0) p1 = intervals[i];\\n                else {\\n                    p0 = p1;\\n                    p1 = intervals[i];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return p1 >= T ? cnt : -1;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> intervals(T + 1, 0);  \\n        for (auto &clip : clips) {\\n            if (clip[0] <= T) {\\n                intervals[clip[0]] = min(T, max(intervals[clip[0]], clip[1]));\\n            }\\n        }\\n        int p0 = -1, p1 = intervals[0], cnt = 1;\\n        for (int i = 1; i <= T && p1 >= i; i++) {\\n            if (intervals[i] > p1) {\\n                if (i <= p0) p1 = intervals[i];\\n                else {\\n                    p0 = p1;\\n                    p1 = intervals[i];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return p1 >= T ? cnt : -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496820,
                "title": "java-priorityqueue-solution-in-1ms",
                "content": "```\\npublic int videoStitching(int[][] clips, int T) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tfor (int[] clip : clips) pq.offer(clip);\\n\\tint res = 0;\\n\\tint end = 0;\\n\\twhile (!pq.isEmpty() && end < T) {\\n\\t\\tif (pq.peek()[0] > end) return -1;\\n\\t\\tint nextEnd = 0;\\n\\t\\twhile (!pq.isEmpty() && pq.peek()[0] <= end) {\\n\\t\\t\\tnextEnd = Math.max(nextEnd, pq.poll()[1]);\\n\\t\\t}\\n\\t\\tend = nextEnd;\\n\\t\\tres++;\\n\\t}\\n\\treturn end >= T ? res : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] clips, int T) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tfor (int[] clip : clips) pq.offer(clip);\\n\\tint res = 0;\\n\\tint end = 0;\\n\\twhile (!pq.isEmpty() && end < T) {\\n\\t\\tif (pq.peek()[0] > end) return -1;\\n\\t\\tint nextEnd = 0;\\n\\t\\twhile (!pq.isEmpty() && pq.peek()[0] <= end) {\\n\\t\\t\\tnextEnd = Math.max(nextEnd, pq.poll()[1]);\\n\\t\\t}\\n\\t\\tend = nextEnd;\\n\\t\\tres++;\\n\\t}\\n\\treturn end >= T ? res : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486056,
                "title": "without-sort-space-o-1-time-worst-o-n-2-average-o-n-m",
                "content": "This solution uses no DP and beats 100% LC runtime.\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int max = 0;\\n        int start = 0, j = 0, i;\\n        while(start < T) {\\n            i = 0;\\n            while(i < clips.length) {\\n                if(start >= clips[i][0] && max < clips[i][1])\\n                    max = clips[i][1];\\n                i++;\\n            }\\n            if(start == max) return -1;\\n            j++;\\n            start = max;\\n        }\\n        return j < clips.length + 1 ? j : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int max = 0;\\n        int start = 0, j = 0, i;\\n        while(start < T) {\\n            i = 0;\\n            while(i < clips.length) {\\n                if(start >= clips[i][0] && max < clips[i][1])\\n                    max = clips[i][1];\\n                i++;\\n            }\\n            if(start == max) return -1;\\n            j++;\\n            start = max;\\n        }\\n        return j < clips.length + 1 ? j : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484775,
                "title": "easy-solution-using-greedy-and-dp-in-java",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int n=clips.length;\\n        Arrays.sort(clips,(a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n        int[] dp=new int[n];\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp[0]=1;\\n        if(clips[0][1]==T)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0)\\n                dp[i]=n+1;\\n            for(int j=0;j<i;j++)\\n            {\\n             if(clips[i][1]>clips[j][1] && clips[i][0]<=clips[j][1])\\n             {\\n                 dp[i]=Math.min(dp[i],dp[j]+1);\\n             }\\n            }\\n            if(clips[i][1]>=T)\\n            {\\n                if(dp[i]==n+1)\\n                    continue;\\n                else\\n                    return dp[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nSimilar Question:https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int n=clips.length;\\n        Arrays.sort(clips,(a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n        int[] dp=new int[n];\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp[0]=1;\\n        if(clips[0][1]==T)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0)\\n                dp[i]=n+1;\\n            for(int j=0;j<i;j++)\\n            {\\n             if(clips[i][1]>clips[j][1] && clips[i][0]<=clips[j][1])\\n             {\\n                 dp[i]=Math.min(dp[i],dp[j]+1);\\n             }\\n            }\\n            if(clips[i][1]>=T)\\n            {\\n                if(dp[i]==n+1)\\n                    continue;\\n                else\\n                    return dp[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436077,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        unordered_map<int,vector<int>> map;\\n        for(auto clip : clips){\\n            map[clip[0]].push_back(clip[1]);\\n        }\\n        queue<int> q;\\n        vector<bool> visited(T+1, false);\\n        q.push(0);\\n        int num = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr==T){\\n                    return num;\\n                }\\n                for(int j : map[curr]){\\n                    for(int k = 0; k<=j; k++){\\n                        if(visited[k]==false){\\n                            visited[k] = true;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n            }\\n            num++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        unordered_map<int,vector<int>> map;\\n        for(auto clip : clips){\\n            map[clip[0]].push_back(clip[1]);\\n        }\\n        queue<int> q;\\n        vector<bool> visited(T+1, false);\\n        q.push(0);\\n        int num = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr==T){\\n                    return num;\\n                }\\n                for(int j : map[curr]){\\n                    for(int k = 0; k<=j; k++){\\n                        if(visited[k]==false){\\n                            visited[k] = true;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n            }\\n            num++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398684,
                "title": "java-solution-has-clearly-explanation-time-o-nlogn-space-o-1",
                "content": "``` Problem is finding minimum of merging clips to make a clip: [0, T]\\n1. First clips must start from zero.\\n2. If next clips doesn\\'t overlap with current merged clip or overlap but they have endTime shorted than endTime of current merged clip, return -1.\\n3. If they have multiple overlap, only merge with an overlap which have longest endTime.\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        if (clips.length == 0) return -1;\\n        Arrays.sort(clips, (a, b) -> (a[0] - b[0]));\\n        if (clips[0][0] > 0) return -1; // because clips doesn\\'t start from zero;\\n        \\n        int[] lastClip = new int[]{0, 0};\\n        int count = 0, i = 0;\\n        while(i < clips.length && lastClip[1] < T) {\\n            \\n            int[] nextClip = null;\\n            int maxEnd = 0;\\n            while(i < clips.length && isOverlap(lastClip, clips[i])) {\\n                if (maxEnd < clips[i][1]) {\\n                    maxEnd = clips[i][1];\\n                    nextClip = clips[i];\\n                }\\n                i++;\\n            }\\n            \\n            \\n            if (nextClip == null || nextClip[1] <= lastClip[1]) return -1;\\n            // because the length of clips couldn\\'t increase, so They never have endTime >= T\\n            \\n            lastClip[1] = nextClip[1];\\n            count++;\\n        }\\n        \\n        return lastClip[1] >= T ? count : -1;\\n    }\\n    \\n    private boolean isOverlap(int[] clip1, int[] clip2) {\\n        return clip1[1] >= clip2[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` Problem is finding minimum of merging clips to make a clip: [0, T]\\n1. First clips must start from zero.\\n2. If next clips doesn\\'t overlap with current merged clip or overlap but they have endTime shorted than endTime of current merged clip, return -1.\\n3. If they have multiple overlap, only merge with an overlap which have longest endTime.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395401,
                "title": "0ms-faster-than-100-o-n-c-simple-traversal-of-array-once-o-1-storage",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[1] < b[1];\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        int n = clips.size();\\n        int val = T;\\n        int check = T;\\n        int steps = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (i >= 0 && clips[i][1] >= val)\\n            {\\n                check = min(check, clips[i][0]);\\n                if (check == 0)\\n                    return steps + 1;\\n                i--;\\n            }\\n            steps++;\\n            if (check == val)\\n                return -1;\\n            val = check;\\n            check = val;\\n            i++;\\n        }\\n        if (val != 0)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[1] < b[1];\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        int n = clips.size();\\n        int val = T;\\n        int check = T;\\n        int steps = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (i >= 0 && clips[i][1] >= val)\\n            {\\n                check = min(check, clips[i][0]);\\n                if (check == 0)\\n                    return steps + 1;\\n                i--;\\n            }\\n            steps++;\\n            if (check == val)\\n                return -1;\\n            val = check;\\n            check = val;\\n            i++;\\n        }\\n        if (val != 0)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370350,
                "title": "python-o-n-greedy-solution-75-runtime-100-memory",
                "content": "Not sure why this got tagged as DP - while I\\'m sure DP is a valid approach, a greedy approach seems far more intuitive.\\n\\nSort in increasing order by start time, then in decreasing order by end time.\\n\\nPick the first clip, then move to the right until you find the largest end time for the next clip whose start time is <= that of your previous clip. Repeat until you hit T (return number of clips used) or exceed the array bounds (return -1).\\n\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort(key=lambda x:(x[0],-x[1]))\\n        # If lowest time isn\\'t 0, we cannot cover the event\\n        if clips[0][0]>0: return -1\\n        ans = 1\\n        end = clips[0][1]\\n        use = 0\\n        while end < T:\\n            i = use+1\\n            tmp = end\\n            if clips[i][0]>end: return -1\\n            while i < len(clips) and clips[i][0]<=end:\\n                if clips[i][1]>tmp:\\n                    tmp = clips[i][1]\\n                    use = i\\n                i += 1\\n            end = tmp\\n            ans += 1\\n            if i>=len(clips) and end<T: return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort(key=lambda x:(x[0],-x[1]))\\n        # If lowest time isn\\'t 0, we cannot cover the event\\n        if clips[0][0]>0: return -1\\n        ans = 1\\n        end = clips[0][1]\\n        use = 0\\n        while end < T:\\n            i = use+1\\n            tmp = end\\n            if clips[i][0]>end: return -1\\n            while i < len(clips) and clips[i][0]<=end:\\n                if clips[i][1]>tmp:\\n                    tmp = clips[i][1]\\n                    use = i\\n                i += 1\\n            end = tmp\\n            ans += 1\\n            if i>=len(clips) and end<T: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312543,
                "title": "c-dp-solution-4ms-no-sorting",
                "content": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int dp[205];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<clips.size();i++){\\n            if(dp[clips[i][0]]<clips[i][1]) dp[clips[i][0]] = clips[i][1];\\n        }\\n        for(int i=1;i<205;i++){\\n            dp[i] = max(dp[i],dp[i-1]);\\n        }\\n        int i=0,ans=0;\\n        while(i<T ){\\n            if(dp[i]<=i){\\n                ans=-1;\\n                break;\\n            }\\n            i = dp[i];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int dp[205];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<clips.size();i++){\\n            if(dp[clips[i][0]]<clips[i][1]) dp[clips[i][0]] = clips[i][1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 307135,
                "title": "java-solution-using-buckets-no-sorting-o-n",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        List<int[]>[] buckets = new ArrayList[101];\\n        for(int[] clip : clips) {\\n            if(buckets[clip[0]] == null) buckets[clip[0]] = new ArrayList<>();\\n            buckets[clip[0]].add(clip);\\n        }\\n        int start = 0, end = 0;\\n        int res = 0;\\n        while(end < T) {\\n            int next = end;\\n            for(int i = start; i <= end; i++) {\\n                List<int[]> bucket = buckets[i];\\n                if(bucket == null) continue;\\n                for(int[] clip : bucket) {\\n                    if(clip[1] > next) {\\n                        next = clip[1];\\n                        start = clip[0];\\n                    }\\n                }\\n            }\\n            if(next == end) return -1;\\n            end = next;\\n            res++;\\n            //System.out.println(start + \" \" + end);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        List<int[]>[] buckets = new ArrayList[101];\\n        for(int[] clip : clips) {\\n            if(buckets[clip[0]] == null) buckets[clip[0]] = new ArrayList<>();\\n            buckets[clip[0]].add(clip);\\n        }\\n        int start = 0, end = 0;\\n        int res = 0;\\n        while(end < T) {\\n            int next = end;\\n            for(int i = start; i <= end; i++) {\\n                List<int[]> bucket = buckets[i];\\n                if(bucket == null) continue;\\n                for(int[] clip : bucket) {\\n                    if(clip[1] > next) {\\n                        next = clip[1];\\n                        start = clip[0];\\n                    }\\n                }\\n            }\\n            if(next == end) return -1;\\n            end = next;\\n            res++;\\n            //System.out.println(start + \" \" + end);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304932,
                "title": "c-greedy-0ms-with-explanation",
                "content": "```\\n1. sort the clips by starting value, if with the same starting value, sort by ending value.\\n    same idea can apply to many interval questions.\\n2. every time pick a node, whose starting point is no larger than your current starting value.\\n    Among them, choose the one with largest ending point.\\n3. last round\\'s ending point will be the starting point next round.\\n4. if current search cannot reach a suitable node, fail\\n    if cuurent ending point is no less than T, succeed\\n```\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t/* sort first, which make complexity to be O(N*logN) */\\n        sort(clips.begin(),clips.end(),[](auto &i1, auto &i2){\\n           if(i1[0] == i2[0]) return i1[1] < i2[1];\\n            else return i1[0] < i2[0];});\\n        \\n        int idx = 0,cnt = 0,head = 0,longest_end = -1, end_idx = -1;\\n        while(idx < clips.size()){\\n            for(;idx < clips.size();idx++){\\n\\t\\t\\t\\t/* choose largest ending point among the nodes whose starting point is no larger than head */\\n                if(clips[idx][0] <= head){\\n                    if(clips[idx][1] > longest_end)\\n                        longest_end = clips[idx][1], end_idx = idx;\\n                }\\n                else\\n                    break;\\n            }\\n            cnt++;\\n            if(longest_end >= T)   // found node can END the requirement, succeed. \\n                return cnt;\\n            else if(end_idx == -1) // find nothing in this round, fail\\n                return -1;\\n            head = longest_end;\\n            end_idx = -1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. sort the clips by starting value, if with the same starting value, sort by ending value.\\n    same idea can apply to many interval questions.\\n2. every time pick a node, whose starting point is no larger than your current starting value.\\n    Among them, choose the one with largest ending point.\\n3. last round\\'s ending point will be the starting point next round.\\n4. if current search cannot reach a suitable node, fail\\n    if cuurent ending point is no less than T, succeed\\n```\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t/* sort first, which make complexity to be O(N*logN) */\\n        sort(clips.begin(),clips.end(),[](auto &i1, auto &i2){\\n           if(i1[0] == i2[0]) return i1[1] < i2[1];\\n            else return i1[0] < i2[0];});\\n        \\n        int idx = 0,cnt = 0,head = 0,longest_end = -1, end_idx = -1;\\n        while(idx < clips.size()){\\n            for(;idx < clips.size();idx++){\\n\\t\\t\\t\\t/* choose largest ending point among the nodes whose starting point is no larger than head */\\n                if(clips[idx][0] <= head){\\n                    if(clips[idx][1] > longest_end)\\n                        longest_end = clips[idx][1], end_idx = idx;\\n                }\\n                else\\n                    break;\\n            }\\n            cnt++;\\n            if(longest_end >= T)   // found node can END the requirement, succeed. \\n                return cnt;\\n            else if(end_idx == -1) // find nothing in this round, fail\\n                return -1;\\n            head = longest_end;\\n            end_idx = -1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303094,
                "title": "easy-short-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n        clips.sort(key=lambda x:x[0])\\n        start = ending = count = i = 0\\n        \\n        while i < len(clips):\\n\\t\\t    # find the latest time that can be covered by adding one segment\\n            while (i < len(clips)) and (clips[i][0] <= start) :\\n                ending = max(ending, clips[i][1])    \\n                i += 1\\n            count += 1    #added a segment\\n            if ending >= T:    # we are done\\n                return count\\n            if ending == start:    # we couldn\\'t move forward in time, and haven\\'t reached T\\n                return -1\\n            start = ending    # prepare for adding another segment \\n        \\n\\t\\t# there is no valid solution if after going through all segments, we haven\\'t reached T\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n        clips.sort(key=lambda x:x[0])\\n        start = ending = count = i = 0\\n        \\n        while i < len(clips):\\n\\t\\t    # find the latest time that can be covered by adding one segment\\n            while (i < len(clips)) and (clips[i][0] <= start) :\\n                ending = max(ending, clips[i][1])    \\n                i += 1\\n            count += 1    #added a segment\\n            if ending >= T:    # we are done\\n                return count\\n            if ending == start:    # we couldn\\'t move forward in time, and haven\\'t reached T\\n                return -1\\n            start = ending    # prepare for adding another segment \\n        \\n\\t\\t# there is no valid solution if after going through all segments, we haven\\'t reached T\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301910,
                "title": "c-greedy-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]<b[0]) return true;\\n            if(a[0]==b[0] && a[1]<b[1]) return true;\\n            else return false;\\n        });\\n        if(clips[0][0]!=0) return -1;\\n        int count = 0;\\n        int num = 0;\\n        int i = 0;\\n        for(i=0; i<clips.size();) {\\n            int maxR = INT_MIN;\\n            while((i<clips.size()) && (clips[i][0]<=num)) {\\n                maxR = max(maxR,clips[i][1]);\\n                i++;\\n            }\\n            num = maxR;\\n            count++;\\n            if(num>=T) break;\\n            else if(i>=clips.size() || num==INT_MIN) return -1;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]<b[0]) return true;\\n            if(a[0]==b[0] && a[1]<b[1]) return true;\\n            else return false;\\n        });\\n        if(clips[0][0]!=0) return -1;\\n        int count = 0;\\n        int num = 0;\\n        int i = 0;\\n        for(i=0; i<clips.size();) {\\n            int maxR = INT_MIN;\\n            while((i<clips.size()) && (clips[i][0]<=num)) {\\n                maxR = max(maxR,clips[i][1]);\\n                i++;\\n            }\\n            num = maxR;\\n            count++;\\n            if(num>=T) break;\\n            else if(i>=clips.size() || num==INT_MIN) return -1;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296262,
                "title": "easy-to-understand-c-greedy-algo",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if(T == 0)\\n            return 0;\\n        \\n        // running time is N*LOG(N) + N\\n        \\n        // sort clips from starting point, and if starting points are equal, \\n        // then by shortest to longest\\n        \\n        std::sort(clips.begin(), clips.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            int lhsLen = lhs[1] - lhs[0];\\n            int rhsLen = rhs[1] - rhs[0];\\n            if(lhs[0] == rhs[0])\\n                return lhsLen < rhsLen;\\n            return lhs[0] < rhs[0];\\n        });\\n        \\n        // we need to have SOME clip starting at 0\\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        // ordered from left to right, largest to smallest\\n        int numClips = 0;\\n        int n = (int)clips.size();\\n        \\n        // marker represents the furthest point we can reach in a clip\\n        // \\n        // example:\\n        //\\n        // [0 1]\\n        // [0, 1, 2, 3]  <-- marker will become 3, now search all clips with start <= 3\\n        //          [3, 4]\\n        //          [3, 4, 5]\\n        //       [2, 3, 4, 5, 6, 7] <-- marker will become 7\\n        //\\n        //      this continues until marker is at or past T.\\n        //      \\n        \\n        int marker = 0;\\n        int i = 0;\\n        \\n        // greedy algorithm: trying to reach T as quickly as possible.\\n        \\n        while(i < n) {\\n            \\n            // determine which clip will get us out the furthest\\n            \\n            int best = -1;\\n            while(i < n && clips[i][0] <= marker) {\\n                if(clips[i][1] > best)\\n                    best = clips[i][1];\\n                i++;\\n            }\\n            \\n            marker = best;            \\n            numClips++;\\n            \\n            if(marker >= T)\\n                break;\\n            \\n            if(i >= n || best == -1)\\n                return -1;\\n        }\\n        \\n        return numClips;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if(T == 0)\\n            return 0;\\n        \\n        // running time is N*LOG(N) + N\\n        \\n        // sort clips from starting point, and if starting points are equal, \\n        // then by shortest to longest\\n        \\n        std::sort(clips.begin(), clips.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            int lhsLen = lhs[1] - lhs[0];\\n            int rhsLen = rhs[1] - rhs[0];\\n            if(lhs[0] == rhs[0])\\n                return lhsLen < rhsLen;\\n            return lhs[0] < rhs[0];\\n        });\\n        \\n        // we need to have SOME clip starting at 0\\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        // ordered from left to right, largest to smallest\\n        int numClips = 0;\\n        int n = (int)clips.size();\\n        \\n        // marker represents the furthest point we can reach in a clip\\n        // \\n        // example:\\n        //\\n        // [0 1]\\n        // [0, 1, 2, 3]  <-- marker will become 3, now search all clips with start <= 3\\n        //          [3, 4]\\n        //          [3, 4, 5]\\n        //       [2, 3, 4, 5, 6, 7] <-- marker will become 7\\n        //\\n        //      this continues until marker is at or past T.\\n        //      \\n        \\n        int marker = 0;\\n        int i = 0;\\n        \\n        // greedy algorithm: trying to reach T as quickly as possible.\\n        \\n        while(i < n) {\\n            \\n            // determine which clip will get us out the furthest\\n            \\n            int best = -1;\\n            while(i < n && clips[i][0] <= marker) {\\n                if(clips[i][1] > best)\\n                    best = clips[i][1];\\n                i++;\\n            }\\n            \\n            marker = best;            \\n            numClips++;\\n            \\n            if(marker >= T)\\n                break;\\n            \\n            if(i >= n || best == -1)\\n                return -1;\\n        }\\n        \\n        return numClips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281761,
                "title": "python-dp-solution-with-explanation",
                "content": "1. Sort the input clips and initialize dp list of size T+1 with each element as -1\\n2. Iterate ```i``` over clips until exhausted or dp[T+1] has a value other than -1\\n3. If ```clips[i][0]``` is 0 then to get to any point up to ```clips[i][1]``` is at most 1 step\\n4. Otherwise if ```clips[i][0]``` is -1 that means there is a gap and we cannot get to T\\n5. Finally, min steps to get to anywhere between ```clips[i][0]``` and ```clips[i][1]``` is min of min steps to get to ```dp[clips[i][0]] + 1``` or the previously seen min\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort()\\n    \\n        if clips[0][0] != 0:\\n            return -1\\n        if T == 0:\\n            return 1\\n    \\n        dp = [-1] * (T+1)\\n        \\n        i = 0\\n        while i < len(clips) and dp[T] == -1:\\n            start, end = clips[i][0], clips[i][1]\\n            if start == 0:\\n                for j in range(start, min(end+1, T+1)):\\n                    dp[j] = 1\\n            elif dp[start] == -1:\\n                return -1\\n            else:\\n                for j in range(start, min(end+1, T+1)):\\n                    if dp[j] == -1:\\n                        dp[j] = dp[start] + 1\\n                    else:\\n                        dp[j] = min(dp[j], dp[start] + 1)\\n            i += 1\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```i```\n```clips[i][0]```\n```clips[i][1]```\n```clips[i][0]```\n```clips[i][0]```\n```clips[i][1]```\n```dp[clips[i][0]] + 1```\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort()\\n    \\n        if clips[0][0] != 0:\\n            return -1\\n        if T == 0:\\n            return 1\\n    \\n        dp = [-1] * (T+1)\\n        \\n        i = 0\\n        while i < len(clips) and dp[T] == -1:\\n            start, end = clips[i][0], clips[i][1]\\n            if start == 0:\\n                for j in range(start, min(end+1, T+1)):\\n                    dp[j] = 1\\n            elif dp[start] == -1:\\n                return -1\\n            else:\\n                for j in range(start, min(end+1, T+1)):\\n                    if dp[j] == -1:\\n                        dp[j] = dp[start] + 1\\n                    else:\\n                        dp[j] = min(dp[j], dp[start] + 1)\\n            i += 1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280516,
                "title": "o-n-log-n-c-solution",
                "content": "The sorting is O(n log n). Although there are two nested while loops every element is actually touched once - and so the loops are O(n).\\n\\n```\\npublic class Solution \\n{\\n    public int VideoStitching(int[][] clips, int T) \\n    {\\n        int N = clips.GetLength(0);\\n        clips = clips.OrderBy(a => a[0]).ToArray();\\n        \\n        int s = 0, e = 0;\\n        int k = 0;\\n        int count = 0;\\n        while (k < N && e < T)\\n        {\\n            int max = e;\\n            int ns=-1, ne=-1;\\n            while(k < N && clips[k][0] <= e)\\n            {\\n                if (clips[k][1] > max)\\n                {\\n                    ns = clips[k][0];\\n                    ne = clips[k][1];\\n                    max = ne;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            if (ns == -1) // could use ne == -1 as well\\n                break;\\n            \\n            s = ns;\\n            e = ne;\\n            count++;\\n        }\\n        \\n        return e>=T ? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int VideoStitching(int[][] clips, int T) \\n    {\\n        int N = clips.GetLength(0);\\n        clips = clips.OrderBy(a => a[0]).ToArray();\\n        \\n        int s = 0, e = 0;\\n        int k = 0;\\n        int count = 0;\\n        while (k < N && e < T)\\n        {\\n            int max = e;\\n            int ns=-1, ne=-1;\\n            while(k < N && clips[k][0] <= e)\\n            {\\n                if (clips[k][1] > max)\\n                {\\n                    ns = clips[k][0];\\n                    ne = clips[k][1];\\n                    max = ne;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            if (ns == -1) // could use ne == -1 as well\\n                break;\\n            \\n            s = ns;\\n            e = ne;\\n            count++;\\n        }\\n        \\n        return e>=T ? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274649,
                "title": "theoretical-explanation-o-n-log-n",
                "content": "Sort the intervals by start and end. This is important for ensuring that we cover all the gaps.\\n\\n`clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10`\\nbecomes\\n`clips = [[0,2],[1,5],[1,9],[4,6],[5,9],[8,10]]`\\n\\nDefine some assumptions\\n* We define mininum required clips as `m`. (m >= 1)\\n* The first `m-1` clips are finalized and will never be modified. \\n* The `m`th clip can be modified.\\n* The `m` clips will always form a continuous interval, where the clips overlap. If this assumption is false, the algorithm must terminate immediately.\\n* Define the finalized interval  `I1 = [0, E1]`, which covers all the start values of `m` clips using the combined intervals of the first `m - 1` clips. `(E1 >= start for each (start, end))`.   \\n* Define the entire visible interval as `I2 = [0, E2]`, which covers all the end values of the first `m` clips using the combined intervals of `m` clips `(E2 >= end for each (start, end))`. If the entire visible interval covers [0, T], we are done.\\n* E1 <= E2 because `m-1` clips will always cover less than `m` clips\\n* Initially, E1 = 0, E2 = 0, m = 1.\\n\\nWe notice a few things for a new interval [start, end]:\\n1. If start is outside `I2` (start > E2), there is a gap between E2 and end that isn\\'t covered. The algorithm should terminate and return -1 because any future clip will have a start value >= start (the list is sorted by start) and will never be able to cover the gap.\\n2. If start value is outside `I1` and within `I2` (E1 < start <= E2), we need to increment `m` by 1 because we can\\'t replce the `m`th clip and still maintain that `I2` is continuous and the clips are overlapping. If we tried to replace the `m`th clip, we would have two intervals [0,E1] and [start,end] that do not overlap (overlap requires that start <= E1, but in this case start > E1) and this is an invalid configuration.\\n3. If start is within `I1` (start <= E1), we can replace the `m`th clip with the new interval if it is able to expand `I2` (the entire visible interval). This is because `I2` is still continuous and the clips overlap.\\n4. If end >= T, `I2` covers [0, T] and we can finalize the `m`th clip because we have covered the entire interval. \\n \\nWe can try to run this algorithm manually using the example data:\\nInitially, finalized interval `I1` is [0,0], entire interval `I2` is [0,0]. \\n`clips = [[0,2],[1,5],[1,9],[4,6],[5,9],[8,10]], T = 10`.\\n1. For interval [0,2], finalized interval is [0,0], entire interval is [0,2], m = 1. (cover with [0,2])\\n2. For interval [1,5], finalized interval is [0,2], entire interval is [0,5], m = 2  (cover with [0,2],[1,5], can\\'t replace 1st clip so we add a 2nd clip)\\n3. For interval [1,9], finalized interval is [0,2], entire interval is [0,9], m = 2 (cover with [0,2],[1,9], replace 2nd clip)\\n4. For interval [4,6], finalized interval is [0,9], entire interval is [0,9], m = 3 (cover with [0,2],[1,9],[4,6], can\\'t replace 2nd clip so we add a 3rd clip)\\n5. For interval [5,9], finalized interval is [0,9], entire interval is [0,9], m = 3 (cover with [0,2],[1,9],[4,6], don\\'t replace 3rd clip because [5,9] doesn\\'t expand possibly reachable interval)\\n6. For interval [8,10], finalized interval is [0,9], entire interval is [0,10], m = 3 (cover with [0,2],[1,9],[8,10], replace 3rd clip. Terminate here and return 3 because end = 10 and end >= T)\\n\\nCode in Python:\\n```\\ne1 = 0 # finalized interval (0, e1)   \\ne2 = 0 # entire visible interval (0, e2)\\nm = 1\\nfor (start, end) in sorted(clips):\\n\\tif start > e2: # there is a gap between e2 and start\\n\\t\\tbreak\\n\\telif start > e1: # e1 < start <= e2\\n\\t\\te1 = e2  # expand finalized interval to include mth clip\\n\\t\\tm += 1 # can\\'t replace mth clip, add another clip\\n\\t\\t\\n\\te2 = max(e2, end) # expand entire visible interval\\n\\tif e2 >= T: # entire visible interval covered [0, T]\\n\\t\\treturn m\\n\\nreturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ne1 = 0 # finalized interval (0, e1)   \\ne2 = 0 # entire visible interval (0, e2)\\nm = 1\\nfor (start, end) in sorted(clips):\\n\\tif start > e2: # there is a gap between e2 and start\\n\\t\\tbreak\\n\\telif start > e1: # e1 < start <= e2\\n\\t\\te1 = e2  # expand finalized interval to include mth clip\\n\\t\\tm += 1 # can\\'t replace mth clip, add another clip\\n\\t\\t\\n\\te2 = max(e2, end) # expand entire visible interval\\n\\tif e2 >= T: # entire visible interval covered [0, T]\\n\\t\\treturn m\\n\\nreturn -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273263,
                "title": "java-o-n-solution",
                "content": "``` \\npublic int videoStitching(int[][] clips, int T) {\\n        if(T==0) return 0;\\n        int ans = 0, max = 0, i;\\n        int[] tmp= new int[101];\\n        for(int[] clip:clips) tmp[clip[0]] = Math.max(tmp[clip[0]], clip[1]);\\n        int index = tmp[0];\\n        for(i=0; i <= index; i++){\\n            max = Math.max(tmp[i], max);\\n            if(i == index){\\n                ans++;\\n                if(index==max || i>=T) break;\\n                index = max;\\n            } \\n        }\\n        return i>=T?ans:-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic int videoStitching(int[][] clips, int T) {\\n        if(T==0) return 0;\\n        int ans = 0, max = 0, i;\\n        int[] tmp= new int[101];\\n        for(int[] clip:clips) tmp[clip[0]] = Math.max(tmp[clip[0]], clip[1]);\\n        int index = tmp[0];\\n        for(i=0; i <= index; i++){\\n            max = Math.max(tmp[i], max);\\n            if(i == index){\\n                ans++;\\n                if(index==max || i>=T) break;\\n                index = max;\\n            } \\n        }\\n        return i>=T?ans:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271973,
                "title": "java-o-nlogn-with-clear-explanation",
                "content": "**This problem can be thought of as follows**: Imagine clips as a buses going from a point x1 to point x2. Then the stitching task in this case translates into finding the minimum number of bus-change to reach the destination.\\n\\nSo, the greedy approach is as follows - from any point take a bus that takes you furthest. This works because we can get down at any intermediate point to catch next suitable bus. \\n- sort the buses schedules according to the start position.\\n- Create a `checkpoint` at the furthest point we can reach from `0` i.e. starting position. \\n- Next suitable bus is the one which has its `start` to the left of this checkpoint and takes us furthest\\n- create a checkpoint here and repeat the steps.\\n\\nThe code is as follows:\\n\\n```\\nclass Solution {\\n    \\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, new Comparator<int[]>(){\\n            // ...a...b...\\n            @Override\\n            public int compare(int[] b, int[] a){\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int stitches=0, reach=0, checkpoint=0, i=0, j=0;\\n        \\n\\t\\t// while the destination (T) is not reached\\n        for(i = 0; i < clips.length && checkpoint < T; stitches++ ){\\n            if(clips[i][0] <= checkpoint){\\n\\t\\t\\t\\t// how far can we reach? from left of prev checkpoint\\n                for(j=i; j < clips.length && clips[j][0] <= checkpoint; j++){\\n                    reach = clips[j][1] > reach ? clips[j][1] : reach;\\n                }\\n                checkpoint = reach;\\n                i = j;\\n            } else {\\n                // if the start is beyond the previous checkpoint, the task becomes impossible\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// return the count if the destination is reached\\n        return (checkpoint < T) ? -1 : stitches;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, new Comparator<int[]>(){\\n            // ...a...b...\\n            @Override\\n            public int compare(int[] b, int[] a){\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int stitches=0, reach=0, checkpoint=0, i=0, j=0;\\n        \\n\\t\\t// while the destination (T) is not reached\\n        for(i = 0; i < clips.length && checkpoint < T; stitches++ ){\\n            if(clips[i][0] <= checkpoint){\\n\\t\\t\\t\\t// how far can we reach? from left of prev checkpoint\\n                for(j=i; j < clips.length && clips[j][0] <= checkpoint; j++){\\n                    reach = clips[j][1] > reach ? clips[j][1] : reach;\\n                }\\n                checkpoint = reach;\\n                i = j;\\n            } else {\\n                // if the start is beyond the previous checkpoint, the task becomes impossible\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// return the count if the destination is reached\\n        return (checkpoint < T) ? -1 : stitches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271296,
                "title": "java-o-nlogn-solution",
                "content": "```\\n\\n\\t1. Sort intervals based on start\\n\\t2. keep track of max and previous max, if a new interval overlaps with the previous interval, update the max. \\n\\t3. Increase the previous max and count only if new interval does not overlap with the last chosen interval. This means we are replacing the last chosen interval with the current one.\\n\\teg:: [0,5] [1,8] [1,9] T=9 \\n\\tAfter [0,5] max=5, pmax=0  \\n\\tAfter [1,8] max=8, pmax=5 \\n\\tAfter [1,9] max=9, pmax=5. Replaced [1,8] with [1,9]\\n\\n```\\n\\tpublic int videoStitching(int[][] clips, int T) {\\n\\n\\t\\tArrays.sort(clips, (a,b)->a[0]-b[0]);\\n\\t\\tint count=0;\\n\\t\\tint pmax = -1;\\n\\t\\tint max = 0;\\n\\t\\tint index=0;\\n\\t\\twhile(max<T && index<clips.length){\\n\\t\\t\\tif(clips[index][0]<=max && clips[index][1]>=max){\\n\\t\\t\\t\\tif(clips[index][0]>pmax){\\n\\t\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t\\t pmax=max;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmax=clips[index][1];\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\tif(max<T) return -1;\\n\\t\\treturn count;\\n\\t}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\t1. Sort intervals based on start\\n\\t2. keep track of max and previous max, if a new interval overlaps with the previous interval, update the max. \\n\\t3. Increase the previous max and count only if new interval does not overlap with the last chosen interval. This means we are replacing the last chosen interval with the current one.\\n\\teg:: [0,5] [1,8] [1,9] T=9 \\n\\tAfter [0,5] max=5, pmax=0  \\n\\tAfter [1,8] max=8, pmax=5 \\n\\tAfter [1,9] max=9, pmax=5. Replaced [1,8] with [1,9]\\n\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270834,
                "title": "java-solution",
                "content": "**Idea**\\nAfter sorting, keep choosing clips that can push `maxEnd` as much as possible without causing gaps (i.e. the incoming clips should start before `currEnd`. `currEnd` denotes the last known `maxEnd`). \\n\\n```\\npublic int videoStitching(int[][] c, int T) {\\n        Arrays.sort(c, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] c1, int[] c2){\\n               return c1[0]-c2[0];\\n           } \\n        });\\n        \\n        int currEnd = 0, maxEnd = 0, count = 0, i = 0;\\n        while(i < c.length){\\n            if(c[i][0] > currEnd)\\n                return -1;\\n            while(i < c.length && c[i][0] <= currEnd){\\n                maxEnd = Math.max(maxEnd, c[i][1]);\\n                i++;\\n            }\\n            ++count;\\n            currEnd = maxEnd;\\n            if(currEnd >= T)\\n                return count;\\n        }\\n        return currEnd < T ? -1 : count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] c, int T) {\\n        Arrays.sort(c, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] c1, int[] c2){\\n               return c1[0]-c2[0];\\n           } \\n        });\\n        \\n        int currEnd = 0, maxEnd = 0, count = 0, i = 0;\\n        while(i < c.length){\\n            if(c[i][0] > currEnd)\\n                return -1;\\n            while(i < c.length && c[i][0] <= currEnd){\\n                maxEnd = Math.max(maxEnd, c[i][1]);\\n                i++;\\n            }\\n            ++count;\\n            currEnd = maxEnd;\\n            if(currEnd >= T)\\n                return count;\\n        }\\n        return currEnd < T ? -1 : count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270198,
                "title": "dp-c",
                "content": "\\u8FD9\\u662Fcontest130\\u7684\\u538B\\u8F74\\u9898\\u3002\\n\\u8981\\u60F3\\u5168\\u8986\\u76D6\\uFF0C\\u5219\\u80AF\\u5B9A\\u662F\\u96C6\\u5408\\u4E4B\\u95F4\\u6709\\u4EA4\\u96C6\\u3002\\n\\u56E0\\u6B64\\u6211\\u4EEC\\u5148\\u6309\\u7167\\u5934\\u6392\\u5E8F\\uFF0C\\u7136\\u540E\\u9488\\u5BF9\\u6BCF\\u4E00\\u4E2A\\u533A\\u95F4\\uFF0C\\u57FA\\u4E8E\\u5B83\\u524D\\u9762\\u7684\\u5408\\u9002\\u533A\\u95F4\\u5F97\\u5230\\u81EA\\u5DF1\\u7684\\u6700\\u4F18\\u89E3\\u3002\\n``` \\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> dp(clips.size(),INT_MAX);\\n        auto cmp=[](vector<int> &a, vector<int> &b){\\n            return a[0]<b[0];\\n        };\\n        sort(clips.begin(),clips.end(),cmp);\\n        if(clips[0][0]!=0) return -1;\\n        for(int i=0;i<clips.size();i++){\\n            if(clips[i][0]==0) \\n                dp[i]=1;\\n        }\\n        for(int i=0;i<clips.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(dp[j]!=INT_MAX && clips[j][1]>=clips[i][0]){\\n                    dp[i]=min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<clips.size();i++){ \\n            if(clips[i][1]>=T) // \\u53EA\\u904D\\u5386\\u8FD9\\u4E9B\\u96C6\\u5408\\u6765\\u5F97\\u5230\\u5168\\u5C40\\u6700\\u4F18\\u89E3\\n                res=min(res,dp[i]);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> dp(clips.size(),INT_MAX);\\n        auto cmp=[](vector<int> &a, vector<int> &b){\\n            return a[0]<b[0];\\n        };\\n        sort(clips.begin(),clips.end(),cmp);\\n        if(clips[0][0]!=0) return -1;\\n        for(int i=0;i<clips.size();i++){\\n            if(clips[i][0]==0) \\n                dp[i]=1;\\n        }\\n        for(int i=0;i<clips.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(dp[j]!=INT_MAX && clips[j][1]>=clips[i][0]){\\n                    dp[i]=min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<clips.size();i++){ \\n            if(clips[i][1]>=T) // \\u53EA\\u904D\\u5386\\u8FD9\\u4E9B\\u96C6\\u5408\\u6765\\u5F97\\u5230\\u5168\\u5C40\\u6700\\u4F18\\u89E3\\n                res=min(res,dp[i]);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270082,
                "title": "python-dp",
                "content": "* We can sort the videos according to their end time. So the last video\\'s start time is equal or larger than T, the last video will not be included. That is DP[i][j] = DP[i][j - 1]\\n* If the last video\\'s start time is smaller than T, We need to look at it\\'s end time. If it\\'s end time is larger than T, we will make a new time clips[i - 1][1] (endtime) as new T if we include the last video. Otherwise we just ignore the last video. That is DP[i][j] = min(DP[i - 1][j], DP[i - 1][clips[i - 1][1]] + 1)\\n*  If the last video\\'s end time is smaller than T, there is no way we can get the time span [0, T] covered, since the clips are sorted by their ending times. So DP[i][j] = inf\\n\\nBelow is the code implementation\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        \\'\\'\\'\\n        DP[i][T] = DP[i - 1][T] if T <= clips[i - 1][0]\\n        else\\n        DP[i][T] = DP[i - 1][clips[i - 1][0]] + 1 or DP[i - 1][T] whichever is smaller\\n        \\n        \\'\\'\\'\\n        clips = sorted(clips, key = lambda x:x[::-1])\\n        n = len(clips)\\n        inf = float(\\'inf\\')\\n        DP = [[inf for j in range(T + 1)] for i in range(n + 1)]\\n        \\n        DP[0][0] = 0\\n        \\n        for i in range(1, n + 1):\\n            DP[i][0] = 0\\n        for j in range(1, T + 1):\\n            DP[0][j] = inf\\n            \\n        for i in range(1, n + 1):\\n            for j in range(1, T + 1):\\n                if clips[i - 1][0] >= j:\\n                    DP[i][j] = DP[i - 1][j]\\n                else:\\n                    if j <= clips[i - 1][1]: #now only need to cover to clips[i - 1][0] if clips[i] is included\\n                        DP[i][j] = min(DP[i - 1][clips[i - 1][0]] + 1, DP[i - 1][j])\\n                    else: #\\n                        DP[i][j] = inf\\n        return DP[n][T] if DP[n][T] < inf else -1\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        \\'\\'\\'\\n        DP[i][T] = DP[i - 1][T] if T <= clips[i - 1][0]\\n        else\\n        DP[i][T] = DP[i - 1][clips[i - 1][0]] + 1 or DP[i - 1][T] whichever is smaller\\n        \\n        \\'\\'\\'\\n        clips = sorted(clips, key = lambda x:x[::-1])\\n        n = len(clips)\\n        inf = float(\\'inf\\')\\n        DP = [[inf for j in range(T + 1)] for i in range(n + 1)]\\n        \\n        DP[0][0] = 0\\n        \\n        for i in range(1, n + 1):\\n            DP[i][0] = 0\\n        for j in range(1, T + 1):\\n            DP[0][j] = inf\\n            \\n        for i in range(1, n + 1):\\n            for j in range(1, T + 1):\\n                if clips[i - 1][0] >= j:\\n                    DP[i][j] = DP[i - 1][j]\\n                else:\\n                    if j <= clips[i - 1][1]: #now only need to cover to clips[i - 1][0] if clips[i] is included\\n                        DP[i][j] = min(DP[i - 1][clips[i - 1][0]] + 1, DP[i - 1][j])\\n                    else: #\\n                        DP[i][j] = inf\\n        return DP[n][T] if DP[n][T] < inf else -1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270032,
                "title": "java-o-n-t-solution-same-to-jump-game-ii",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        for (int[] clip: clips) {\\n            if (clip[0] < T + 1)\\n                dp[clip[0]] = Math.max(dp[clip[0]], Math.min(clip[1], T));\\n        }\\n        int jump = 0;\\n        int nextmax = 0;\\n        int curmax = dp[0];\\n        for (int i = 0; i < T + 1; i++) {\\n            nextmax = Math.max(nextmax, dp[i]);\\n            if (i == curmax || i == T) {\\n                \\n                jump++;\\n                if (nextmax == i) {\\n                    return i == T ? jump : -1;\\n                }\\n                curmax = nextmax;\\n            }\\n        }\\n        return jump;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        for (int[] clip: clips) {\\n            if (clip[0] < T + 1)\\n                dp[clip[0]] = Math.max(dp[clip[0]], Math.min(clip[1], T));\\n        }\\n        int jump = 0;\\n        int nextmax = 0;\\n        int curmax = dp[0];\\n        for (int i = 0; i < T + 1; i++) {\\n            nextmax = Math.max(nextmax, dp[i]);\\n            if (i == curmax || i == T) {\\n                \\n                jump++;\\n                if (nextmax == i) {\\n                    return i == T ? jump : -1;\\n                }\\n                curmax = nextmax;\\n            }\\n        }\\n        return jump;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269990,
                "title": "greedy-approach-o-n-log-n",
                "content": "This problem is similar to  <a href=\"https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/\"> Activity selection problem </a>\\n\\nThe idea consists in choose the maximum end interval given a start of video.\\n* For example:  If I\\'m at minute <code>5</code> of the video and I have the following intervals <code>[3-6], [7-10], [4-9] </code>. I will choose <code>[4-9]</code> because that contains number <code>5</code> and have the maximum end of video. (<code> [7-10] </code> not contains the minute <code>5</code>). \\n* Then you will update the start time, and repeat the proccess until you get a <code>start time >=T</code>\\n\\n\\n**C++**\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint maxend =-1;\\n\\t\\t\\t\\tfor(int i=0;i<clips.size();i++){\\n\\t\\t\\t\\t\\tint end= clips[i][1];\\n\\t\\t\\t\\t\\tif(end>maxend &&  clips[i][0]<=start && end>start){\\n\\t\\t\\t\\t\\t\\tmaxend=end;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tstart=maxend;\\n\\t\\t\\t\\tif(start>=T)return count; //goal\\n\\t\\t\\t\\tif(start==-1)return -1; // its not possible improve start time\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\t\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^2) where n is the lengh of clips\\n\\nIt\\'s possible improve the solution in O(n*log(n)) if you sort the array by the start of video. Then find in constant time (two pointers) given a start time <code>(S)</code>, an interval with maximum end where their start is greater or equal than <code>S</code>\\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tvector<pair<int,int> >v;\\t\\n\\t\\t\\tfor(int i=0;i<clips.size();i++)\\n\\t\\t\\t\\tv.push_back(make_pair(clips[i][0],clips[i][1]));\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tint start=0;           \\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<v.size(); ){\\n\\t\\t\\t\\tif(v[i].first>start)return -1;// there are no video that contains start\\n\\t\\t\\t\\tint maxend=-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i<v.size()  && v[i].first<=start){\\n\\t\\t\\t\\t\\tmaxend=max(maxend,v[i].second);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif(maxend>=T)return count;\\n\\t\\t\\t\\tif(maxend<=start)return -1;//no increase start\\n\\t\\t\\t\\tstart=maxend;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\t\\n</code>\\n\\n<b>Complexity time </b>\\n* O(nlog(n)) where n is the lengh of clips",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint maxend =-1;\\n\\t\\t\\t\\tfor(int i=0;i<clips.size();i++){\\n\\t\\t\\t\\t\\tint end= clips[i][1];\\n\\t\\t\\t\\t\\tif(end>maxend &&  clips[i][0]<=start && end>start){\\n\\t\\t\\t\\t\\t\\tmaxend=end;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4102040,
                "title": "c-implementation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing similar approach to merging intervals\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWithout using DP, we can actually take the maximum possible length we can receive (provided the mini and maxi (initialised with 0)).\\n# Complexity\\n- Time complexity: O(n*n) worst case but n <- (1,100) so feasible\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int count = 0;\\n        int mini=0;\\n        int maxi=0;\\n        while(maxi<time){\\n            for(int i=0;i<clips.size();i++){\\n                int start=clips[i][0];\\n                int end=clips[i][1];\\n                if(start<=mini && end>=maxi){\\n                    maxi=end;\\n                }\\n            }\\n            if(mini==maxi) return -1;\\n            mini=maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int count = 0;\\n        int mini=0;\\n        int maxi=0;\\n        while(maxi<time){\\n            for(int i=0;i<clips.size();i++){\\n                int start=clips[i][0];\\n                int end=clips[i][1];\\n                if(start<=mini && end>=maxi){\\n                    maxi=end;\\n                }\\n            }\\n            if(mini==maxi) return -1;\\n            mini=maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086427,
                "title": "ruby-solution-with-sorting-explained-100-67",
                "content": "# Intuition\\nSort the clips, then iterated through them.  Add a new clip whenever necessary, and return -1 if there\\'s a missing gap.  Return the number of clips once you get to time.\\n\\n# Approach\\n1. Sort the clips.\\n2. Initialize curr_end (the ending time of the last clip), total (number of clips used), and i at 0.\\n3. Iterate through the rest of the clips.\\n    - If the next clip doesn\\'t intersect with curr_end, it\\'s impossible to cover the full interval, so return -1.\\n    - Otherwise, look through all clips that could be merged with the current one and choose the one with the latest ending time.  (Since the clips are sorted, you can increment i and won\\'t need to check those clips again.)  Add 1 to total.\\n4. At the end, return the total number of clips you\\'ve used if you cover the full interval, -1 otherwise.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef video_stitching(clips, time)\\n    clips.sort!\\n    curr_end = 0\\n    total = 0\\n    i = 0\\n\\n    until i == clips.length || curr_end >= time\\n        return -1 if clips[i][0] > curr_end\\n        max = clips[0][1]\\n\\n        if i != clips.length && clips[i][0] <= curr_end\\n            until i == clips.length || clips[i][0] > curr_end\\n                max = clips[i][1] if clips[i][1] > max\\n                i += 1\\n            end\\n        else\\n            i += 1\\n        end\\n        \\n        total += 1\\n        curr_end = max\\n    end\\n\\n    curr_end >= time ? total : -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef video_stitching(clips, time)\\n    clips.sort!\\n    curr_end = 0\\n    total = 0\\n    i = 0\\n\\n    until i == clips.length || curr_end >= time\\n        return -1 if clips[i][0] > curr_end\\n        max = clips[0][1]\\n\\n        if i != clips.length && clips[i][0] <= curr_end\\n            until i == clips.length || clips[i][0] > curr_end\\n                max = clips[i][1] if clips[i][1] > max\\n                i += 1\\n            end\\n        else\\n            i += 1\\n        end\\n        \\n        total += 1\\n        curr_end = max\\n    end\\n\\n    curr_end >= time ? total : -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4002006,
                "title": "python3-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        # sort clips by start time\\n        clips.sort(key=lambda x : x[0])\\n\\n        # if we don\\'t have a clip starting at time 0, the problem is impossible\\n        if clips[0][0] != 0:\\n            return -1\\n\\n        # memoization\\n        cache = {} # clip index : min number of steps it takes to get to the end\\n\\n        # dfs portion\\n        def dfs(clip_index):\\n\\n            # avoid repeated work\\n            if clip_index in cache:\\n                return cache[clip_index]\\n            \\n            # base case, we found a clip that reaches the end\\n            if clips[clip_index][1] >= time:\\n                cache[clip_index] = 1\\n                return 1\\n            \\n            # dfs future clips\\n            res = float(\\'inf\\')\\n            for i in range(clip_index + 1, len(clips)):\\n\\n                curr_clip = clips[clip_index]\\n                next_clip = clips[i]\\n\\n                # ensure that we are actually going forward and that the end of the current clip and the start of the next clip are connected\\n                if next_clip[0] > curr_clip[0] and next_clip[0] <= curr_clip[1] and next_clip[1] > curr_clip[1]:\\n                    res = min(res, 1 + dfs(i))\\n\\n            cache[clip_index] = res\\n            return res\\n        \\n        # find the best clip to start with -> [0, greatest end time]\\n        start_index = 0\\n        for i in range(1, len(clips)):\\n            if clips[i][0] != 0:\\n                break\\n            if clips[i][1] > clips[start_index][1]:\\n                start_index = i\\n        \\n        # call dfs\\n        res = dfs(start_index)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        # sort clips by start time\\n        clips.sort(key=lambda x : x[0])\\n\\n        # if we don\\'t have a clip starting at time 0, the problem is impossible\\n        if clips[0][0] != 0:\\n            return -1\\n\\n        # memoization\\n        cache = {} # clip index : min number of steps it takes to get to the end\\n\\n        # dfs portion\\n        def dfs(clip_index):\\n\\n            # avoid repeated work\\n            if clip_index in cache:\\n                return cache[clip_index]\\n            \\n            # base case, we found a clip that reaches the end\\n            if clips[clip_index][1] >= time:\\n                cache[clip_index] = 1\\n                return 1\\n            \\n            # dfs future clips\\n            res = float(\\'inf\\')\\n            for i in range(clip_index + 1, len(clips)):\\n\\n                curr_clip = clips[clip_index]\\n                next_clip = clips[i]\\n\\n                # ensure that we are actually going forward and that the end of the current clip and the start of the next clip are connected\\n                if next_clip[0] > curr_clip[0] and next_clip[0] <= curr_clip[1] and next_clip[1] > curr_clip[1]:\\n                    res = min(res, 1 + dfs(i))\\n\\n            cache[clip_index] = res\\n            return res\\n        \\n        # find the best clip to start with -> [0, greatest end time]\\n        start_index = 0\\n        for i in range(1, len(clips)):\\n            if clips[i][0] != 0:\\n                break\\n            if clips[i][1] > clips[start_index][1]:\\n                start_index = i\\n        \\n        # call dfs\\n        res = dfs(start_index)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989957,
                "title": "java-greedy-o-n-time-complexity-0ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] dp = new int[time+1];\\n\\n        for(int i=0; i<clips.length; i++) {\\n            int left = clips[i][0];\\n            int right = clips[i][1];\\n\\n            if(left > time) left = time;\\n            if(right > time) right = time;\\n\\n            if(right > dp[left]) dp[left] = right;\\n        }\\n        \\n        int max = -1;\\n        int pos = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<=time; i++) {\\n            if(i > pos) return -1;\\n\\n            max = Math.max(max, dp[i]);\\n\\n            if(i == pos) {\\n                count++;\\n                pos = max;\\n            }\\n\\n            if(pos >= time) break;\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] dp = new int[time+1];\\n\\n        for(int i=0; i<clips.length; i++) {\\n            int left = clips[i][0];\\n            int right = clips[i][1];\\n\\n            if(left > time) left = time;\\n            if(right > time) right = time;\\n\\n            if(right > dp[left]) dp[left] = right;\\n        }\\n        \\n        int max = -1;\\n        int pos = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<=time; i++) {\\n            if(i > pos) return -1;\\n\\n            max = Math.max(max, dp[i]);\\n\\n            if(i == pos) {\\n                count++;\\n                pos = max;\\n            }\\n\\n            if(pos >= time) break;\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989910,
                "title": "dp-with-memoization-to-return-the-paths-as-well-not-just-min-values",
                "content": "# Intuition\\nMost of the programs just use track the min number. In most real world problems we need the actual clips as well.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key = lambda x: x[0])\\n        cache = {}\\n        rv = float(\\'inf\\')\\n        for i in range(len(clips)):\\n            if clips[i][0] == 0:\\n                x = self.stitch(clips, time, i, cache)\\n                if len(x) > 0:\\n                    rv = min(rv, len(x))\\n            else:\\n                break \\n        return rv if rv < float(\\'inf\\') else -1\\n    \\n    def stitch(self, clips, target, index, cache):\\n        if index in cache:\\n            return cache[index]\\n        current = clips[index]\\n        if current[0] <= target <= current[1]:\\n            return [current]\\n        glb_min = []\\n        for nxti in range(index+1, len(clips)):\\n            nxt = clips[nxti]\\n            if nxt[0] > current[1]:\\n                #If the next index beginning is greater than current end:\\n                break\\n            elif current[0] <= nxt[0] <= current[1] and nxt[1] > current[1]:\\n                # If there is beginning intercept and next end > current end\\n                valr = self.stitch(clips, target, nxti, cache)\\n                val = [i for i in valr]\\n                if len(val) > 0:\\n                    val.append(current)\\n                if len(val) > 0:\\n                    if len(glb_min) == 0:\\n                        glb_min = val\\n                    else:\\n                        glb_min = val if len(val) < len(glb_min) else glb_min\\n        cache[index] = glb_min\\n        return glb_min\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key = lambda x: x[0])\\n        cache = {}\\n        rv = float(\\'inf\\')\\n        for i in range(len(clips)):\\n            if clips[i][0] == 0:\\n                x = self.stitch(clips, time, i, cache)\\n                if len(x) > 0:\\n                    rv = min(rv, len(x))\\n            else:\\n                break \\n        return rv if rv < float(\\'inf\\') else -1\\n    \\n    def stitch(self, clips, target, index, cache):\\n        if index in cache:\\n            return cache[index]\\n        current = clips[index]\\n        if current[0] <= target <= current[1]:\\n            return [current]\\n        glb_min = []\\n        for nxti in range(index+1, len(clips)):\\n            nxt = clips[nxti]\\n            if nxt[0] > current[1]:\\n                #If the next index beginning is greater than current end:\\n                break\\n            elif current[0] <= nxt[0] <= current[1] and nxt[1] > current[1]:\\n                # If there is beginning intercept and next end > current end\\n                valr = self.stitch(clips, target, nxti, cache)\\n                val = [i for i in valr]\\n                if len(val) > 0:\\n                    val.append(current)\\n                if len(val) > 0:\\n                    if len(glb_min) == 0:\\n                        glb_min = val\\n                    else:\\n                        glb_min = val if len(val) < len(glb_min) else glb_min\\n        cache[index] = glb_min\\n        return glb_min\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989601,
                "title": "greedy-soln-0ms",
                "content": "```\\nclass Pair implements Comparable<Pair>{\\n    int s,e;\\n    Pair(int s,int e){\\n        this.s=s;this.e=e;\\n    }\\n    @Override\\n    public int compareTo(Pair that){\\n        return this.s-that.s;\\n    }\\n}\\nclass Solution {\\n    public int videoStitching(int[][] ar, int time) {\\n        int n=ar.length;\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<ar.length;i++){\\n            li.add(new Pair(ar[i][0],ar[i][1]));\\n        }\\n        Collections.sort(li);\\n        if(li.get(0).s!=0)return -1;\\n        int i=0;\\n        int prev=li.get(i).e;\\n                while(i<n && li.get(i).s==0){\\n                    prev=Math.max(prev,li.get(i).e);\\n                    i++;\\n                }\\n        int ans=1;\\n        if(prev>=time)return ans;\\n        while(i<n){\\n            int j=i;\\n            if(li.get(j).s<=prev){\\n                int max=li.get(i).e;\\n                while(j<n && li.get(j).s<=prev){\\n                    max=Math.max(max,li.get(j).e);\\n                    j++;\\n                }\\n                ans++;\\n                prev=max;\\n                if(max>=time)return ans;\\n            }\\n            if(i!=j)i=j;\\n            else return -1;\\n        }\\n        if(prev<time)return -1;\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Pair implements Comparable<Pair>{\\n    int s,e;\\n    Pair(int s,int e){\\n        this.s=s;this.e=e;\\n    }\\n    @Override\\n    public int compareTo(Pair that){\\n        return this.s-that.s;\\n    }\\n}\\nclass Solution {\\n    public int videoStitching(int[][] ar, int time) {\\n        int n=ar.length;\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<ar.length;i++){\\n            li.add(new Pair(ar[i][0],ar[i][1]));\\n        }\\n        Collections.sort(li);\\n        if(li.get(0).s!=0)return -1;\\n        int i=0;\\n        int prev=li.get(i).e;\\n                while(i<n && li.get(i).s==0){\\n                    prev=Math.max(prev,li.get(i).e);\\n                    i++;\\n                }\\n        int ans=1;\\n        if(prev>=time)return ans;\\n        while(i<n){\\n            int j=i;\\n            if(li.get(j).s<=prev){\\n                int max=li.get(i).e;\\n                while(j<n && li.get(j).s<=prev){\\n                    max=Math.max(max,li.get(j).e);\\n                    j++;\\n                }\\n                ans++;\\n                prev=max;\\n                if(max>=time)return ans;\\n            }\\n            if(i!=j)i=j;\\n            else return -1;\\n        }\\n        if(prev<time)return -1;\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3985573,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        int currend,nextend,ans;\\n        currend=0;\\n        nextend=0;\\n        ans=0;\\n\\n        vector<int> v(101);\\n\\n        for(int i=0;i<clips.size();i++)\\n        {\\n            v[clips[i][0]]=max(v[clips[i][0]],clips[i][1]);\\n        }\\n\\n        //for(int i=0;i<time+1;i++)\\n        //{\\n        //    cout<<v[i]<<\" \";\\n        //}\\n\\n        for(int i=0;i<=time;i++)\\n        {\\n            if(i>nextend)\\n            {\\n                return -1;\\n            }\\n\\n            if(i>currend)\\n            {\\n                ans++;\\n                currend=nextend;\\n            }\\n\\n            nextend=max(nextend,v[i]);\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        int currend,nextend,ans;\\n        currend=0;\\n        nextend=0;\\n        ans=0;\\n\\n        vector<int> v(101);\\n\\n        for(int i=0;i<clips.size();i++)\\n        {\\n            v[clips[i][0]]=max(v[clips[i][0]],clips[i][1]);\\n        }\\n\\n        //for(int i=0;i<time+1;i++)\\n        //{\\n        //    cout<<v[i]<<\" \";\\n        //}\\n\\n        for(int i=0;i<=time;i++)\\n        {\\n            if(i>nextend)\\n            {\\n                return -1;\\n            }\\n\\n            if(i>currend)\\n            {\\n                ans++;\\n                currend=nextend;\\n            }\\n\\n            nextend=max(nextend,v[i]);\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3985472,
                "title": "easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        //DP[I]  min clips to make time of i value film\\n        vector<int> maxi(105,-1);\\n        sort(clips.begin(),clips.end());\\n        for(auto i:clips)\\n        {\\n            int l=i[0];\\n            int r=i[1];\\n            for(int i=l;i<=r;i++)\\n            {\\n                maxi[i]=max(maxi[i],r);\\n            }\\n        }\\n        int cnt=0;\\n        int t=0;\\n        while(t<time)\\n        {\\n            int nexT=maxi[t];\\n            if(nexT==-1 || nexT==t)\\n                return -1;\\n            t=nexT;\\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        //DP[I]  min clips to make time of i value film\\n        vector<int> maxi(105,-1);\\n        sort(clips.begin(),clips.end());\\n        for(auto i:clips)\\n        {\\n            int l=i[0];\\n            int r=i[1];\\n            for(int i=l;i<=r;i++)\\n            {\\n                maxi[i]=max(maxi[i],r);\\n            }\\n        }\\n        int cnt=0;\\n        int t=0;\\n        while(t<time)\\n        {\\n            int nexT=maxi[t];\\n            if(nexT==-1 || nexT==t)\\n                return -1;\\n            t=nexT;\\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984319,
                "title": "c-dp-take-nottake",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int en,vector<vector<int>>& clips,int time)\\n    {\\n        if(idx>=clips.size())\\n        {\\n            if(en>=time)\\n            return 0;\\n            return INT_MAX-1;\\n        }\\n        if(dp[idx][en]!=-1)\\n        return dp[idx][en];\\n        int tak = INT_MAX;\\n        if(clips[idx][0]<=en && clips[idx][1]>=en)\\n        {\\n            tak = 1+solve(idx+1,max(en,clips[idx][1]),clips,time);\\n        }\\n        int notTak = solve(idx+1,en,clips,time);\\n        return dp[idx][en] = min(tak,notTak);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        int ans = solve(0,0,clips,time);\\n        return ans==INT_MAX-1?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int en,vector<vector<int>>& clips,int time)\\n    {\\n        if(idx>=clips.size())\\n        {\\n            if(en>=time)\\n            return 0;\\n            return INT_MAX-1;\\n        }\\n        if(dp[idx][en]!=-1)\\n        return dp[idx][en];\\n        int tak = INT_MAX;\\n        if(clips[idx][0]<=en && clips[idx][1]>=en)\\n        {\\n            tak = 1+solve(idx+1,max(en,clips[idx][1]),clips,time);\\n        }\\n        int notTak = solve(idx+1,en,clips,time);\\n        return dp[idx][en] = min(tak,notTak);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        int ans = solve(0,0,clips,time);\\n        return ans==INT_MAX-1?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984043,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nint cmp(const void*a,const void*b){\\n    int *aa=*(int**)a;\\n    int *bb=*(int**)b;\\n    \\n    if(aa[0]==bb[0]) return aa[1]-bb[1];\\n    return aa[0]-bb[0];\\n}\\nint videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }else if(left==clips[idx][0] && right>=clips[idx][1]){\\n            clips[idx][1]=right;\\n            continue;\\n        }else if(left>=clips[idx][0] && right<=clips[idx][1]){\\n            continue;\\n        }else if(left<clips[idx][0]&&right>clips[idx][1]){\\n            while(idx!=-1 && left<clips[idx][0]&&right>clips[idx][1]){\\n                idx--;\\n            }\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n        else if(left<=clips[idx][1] && right>clips[idx][1]){\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n    \\n    }\\n    if(clips[idx][1]<time) return -1;\\n    return  idx+1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void*a,const void*b){\\n    int *aa=*(int**)a;\\n    int *bb=*(int**)b;\\n    \\n    if(aa[0]==bb[0]) return aa[1]-bb[1];\\n    return aa[0]-bb[0];\\n}\\nint videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }else if(left==clips[idx][0] && right>=clips[idx][1]){\\n            clips[idx][1]=right;\\n            continue;\\n        }else if(left>=clips[idx][0] && right<=clips[idx][1]){\\n            continue;\\n        }else if(left<clips[idx][0]&&right>clips[idx][1]){\\n            while(idx!=-1 && left<clips[idx][0]&&right>clips[idx][1]){\\n                idx--;\\n            }\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n        else if(left<=clips[idx][1] && right>clips[idx][1]){\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n    \\n    }\\n    if(clips[idx][1]<time) return -1;\\n    return  idx+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983941,
                "title": "greedy-beats-100-no-sorting",
                "content": "# Intuition\\nThis is a similar problem to Jump Game 2. At each point store the maximum value we can go to and then you can copy paste the template for finding the minimum count.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> start(101,0);\\n        for(auto clip:clips){\\n            int a=clip[0];\\n            int b=clip[1];\\n            start[a]=max(start[a],b);\\n        }\\n        \\n        int end = 0, farCanReach = 0, cnt = 0;\\n        \\n        for (int i = 0;end < time; end = farCanReach) {\\n            cnt++;\\n            \\n            while (i < start.size() && i <= end) {\\n                farCanReach = max(farCanReach, start[i++]);\\n            }\\n            \\n            if (end == farCanReach) return -1; // if the farCanReach isn\\'t updated then we cannot move further from it and never got to end\\n        }\\n        \\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> start(101,0);\\n        for(auto clip:clips){\\n            int a=clip[0];\\n            int b=clip[1];\\n            start[a]=max(start[a],b);\\n        }\\n        \\n        int end = 0, farCanReach = 0, cnt = 0;\\n        \\n        for (int i = 0;end < time; end = farCanReach) {\\n            cnt++;\\n            \\n            while (i < start.size() && i <= end) {\\n                farCanReach = max(farCanReach, start[i++]);\\n            }\\n            \\n            if (end == farCanReach) return -1; // if the farCanReach isn\\'t updated then we cannot move further from it and never got to end\\n        }\\n        \\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954064,
                "title": "c-easy-clean-code-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tt(int i,vector<vector<int>> &c,int t,vector<int> &dp,int p)\\n    {\\n       if(i>=c.size()) return INT_MAX;\\n       if(c[i][1]>=t) return 1;\\n       if(dp[i]!=-1) return dp[i];\\n\\n       int s=INT_MAX;\\n       for(int j=i+1;j<c.size();j++)\\n       if(c[j][0]<=p)\\n       s=min(s,tt(j,c,t,dp,c[j][1]));\\n\\n       if(s!=INT_MAX)\\n       return dp[i]=s+1;\\n       return dp[i]=s;\\n    }\\n    int videoStitching(vector<vector<int>>& c, int t) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),ans=INT_MAX;\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++)\\n         if(c[i][0]==0)\\n         ans=min(ans,tt(i,c,t,dp,c[i][1]));\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n![cat.png](https://assets.leetcode.com/users/images/35cf7558-fbac-4042-a81d-39cfdfe578e5_1692876425.0175996.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tt(int i,vector<vector<int>> &c,int t,vector<int> &dp,int p)\\n    {\\n       if(i>=c.size()) return INT_MAX;\\n       if(c[i][1]>=t) return 1;\\n       if(dp[i]!=-1) return dp[i];\\n\\n       int s=INT_MAX;\\n       for(int j=i+1;j<c.size();j++)\\n       if(c[j][0]<=p)\\n       s=min(s,tt(j,c,t,dp,c[j][1]));\\n\\n       if(s!=INT_MAX)\\n       return dp[i]=s+1;\\n       return dp[i]=s;\\n    }\\n    int videoStitching(vector<vector<int>>& c, int t) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),ans=INT_MAX;\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++)\\n         if(c[i][0]==0)\\n         ans=min(ans,tt(i,c,t,dp,c[i][1]));\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948907,
                "title": "java-100-no-dp-simple-greedy-approach-tc-o-n",
                "content": "# Intuition\\nSo the intuition is from a time what maxTime I can cover directly without any new Interval. Now if I want to increase MaxReach Time. I have to search from current time to maxReact Time, where can I go directly in one go and so on untill we reach maxReach becomes time.\\n\\n# Approach\\nJust dry run it you will understand\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] end = new int[time + 1];\\n        for(int i = 0; i < clips.length; i++){\\n            int left = clips[i][0];\\n            if(left > time){\\n                continue;\\n            }\\n            int right = Math.min(time, clips[i][1]);\\n            int maxRight = Math.max(right, end[left]);\\n            end[left] = maxRight;\\n        }\\n\\n        int maxReach = end[0];\\n        int cnt = 1;\\n        int st = 0;\\n        while(maxReach < time){\\n            if(st > maxReach){\\n                cnt = -1;\\n                break;\\n            }\\n            cnt++; int newReach = st;\\n            while(st <= maxReach){\\n                newReach = Math.max(newReach, end[st]);\\n                st++;\\n            }\\n            maxReach = newReach;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] end = new int[time + 1];\\n        for(int i = 0; i < clips.length; i++){\\n            int left = clips[i][0];\\n            if(left > time){\\n                continue;\\n            }\\n            int right = Math.min(time, clips[i][1]);\\n            int maxRight = Math.max(right, end[left]);\\n            end[left] = maxRight;\\n        }\\n\\n        int maxReach = end[0];\\n        int cnt = 1;\\n        int st = 0;\\n        while(maxReach < time){\\n            if(st > maxReach){\\n                cnt = -1;\\n                break;\\n            }\\n            cnt++; int newReach = st;\\n            while(st <= maxReach){\\n                newReach = Math.max(newReach, end[st]);\\n                st++;\\n            }\\n            maxReach = newReach;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873668,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n      n,i = len(clips),1\\n      clips.sort(key = lambda x : (x[0] , -x[1])) \\n      ans = [clips[0]]\\n      # pruning the original array \\n      while i < n:\\n        if clips[i][0] != ans[-1][0] : \\n          ans.append(clips[i]) \\n        while i < n and (clips[i][0] == ans[-1][0] or clips[i][1] <= ans[-1][1] ): i += 1 \\n      dp = [-1 for _ in range(len(ans) + 1)]\\n      def f(i):\\n        if i < n and ans[i][1] >= time : return 1 \\n        if dp[i] != -1 : return dp[i]\\n        best = 123456 \\n        for j in range(i+1,len(ans)):\\n          x = ans[i][1] \\n          if x < ans[j][1] and x >= ans[j][0] : \\n            best = min(best , 1 + f(j)) \\n        dp[i] = best \\n        return best \\n      value = f(0)\\n      print(ans)\\n      if value == 123456 or ans[0][0] != 0 : return -1 \\n      return value\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n      n,i = len(clips),1\\n      clips.sort(key = lambda x : (x[0] , -x[1])) \\n      ans = [clips[0]]\\n      # pruning the original array \\n      while i < n:\\n        if clips[i][0] != ans[-1][0] : \\n          ans.append(clips[i]) \\n        while i < n and (clips[i][0] == ans[-1][0] or clips[i][1] <= ans[-1][1] ): i += 1 \\n      dp = [-1 for _ in range(len(ans) + 1)]\\n      def f(i):\\n        if i < n and ans[i][1] >= time : return 1 \\n        if dp[i] != -1 : return dp[i]\\n        best = 123456 \\n        for j in range(i+1,len(ans)):\\n          x = ans[i][1] \\n          if x < ans[j][1] and x >= ans[j][0] : \\n            best = min(best , 1 + f(j)) \\n        dp[i] = best \\n        return best \\n      value = f(0)\\n      print(ans)\\n      if value == 123456 or ans[0][0] != 0 : return -1 \\n      return value\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869700,
                "title": "c-greedy-approach-beats-100-of-c-solutions",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int largest = 0, prev = -1, cnt = 0;\\n        sort(clips.begin(), clips.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0];\\n        });\\n        for (const vector<int>& c : clips) {\\n            if (c[0] > largest) return -1;\\n            if (c[1] <= largest) continue;\\n            if (prev == -1 || c[0] > prev) {\\n                prev = largest;\\n                ++ cnt;\\n            }\\n            largest = c[1];\\n            if (c[1] >= time) break;\\n        }\\n        if (largest < time) return -1;\\n        return cnt;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int largest = 0, prev = -1, cnt = 0;\\n        sort(clips.begin(), clips.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0];\\n        });\\n        for (const vector<int>& c : clips) {\\n            if (c[0] > largest) return -1;\\n            if (c[1] <= largest) continue;\\n            if (prev == -1 || c[0] > prev) {\\n                prev = largest;\\n                ++ cnt;\\n            }\\n            largest = c[1];\\n            if (c[1] >= time) break;\\n        }\\n        if (largest < time) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869339,
                "title": "reduce-to-jump-game-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReduce the problem to https://leetcode.com/problems/jump-game-ii/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Convert the input to the Jump Game II problem\\n    * Map all the clips to a timeline by start time (which is essentially a counting sort)\\n    * Store max end time at each index\\n* Solve it greedily by maintaining current and max reach (end time)\\n\\n# Complexity\\n- Time complexity: $$O(max(M, N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhere M is `clips.len()` and N is `time`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn video_stitching(clips: Vec<Vec<i32>>, time: i32) -> i32 {\\n        let timeline = clips.into_iter().fold(vec![0; time as usize], |mut acc, v| {\\n            let i = v[0] as usize;\\n            if i < acc.len() { acc[i] = acc[i].max(v[1] as usize); }\\n            acc\\n        });\\n\\n        let mut cur_reach = 0;\\n        let mut max_reach = 0;\\n        let mut ans = 0;\\n        for (start, end) in timeline.into_iter().enumerate() {\\n            max_reach = max_reach.max(end);\\n\\n            if start > cur_reach { return -1; }\\n            if start == cur_reach {\\n                ans += 1;\\n                cur_reach = max_reach;\\n            }\\n        }\\n\\n        if cur_reach >= time as usize { ans } else { -1 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn video_stitching(clips: Vec<Vec<i32>>, time: i32) -> i32 {\\n        let timeline = clips.into_iter().fold(vec![0; time as usize], |mut acc, v| {\\n            let i = v[0] as usize;\\n            if i < acc.len() { acc[i] = acc[i].max(v[1] as usize); }\\n            acc\\n        });\\n\\n        let mut cur_reach = 0;\\n        let mut max_reach = 0;\\n        let mut ans = 0;\\n        for (start, end) in timeline.into_iter().enumerate() {\\n            max_reach = max_reach.max(end);\\n\\n            if start > cur_reach { return -1; }\\n            if start == cur_reach {\\n                ans += 1;\\n                cur_reach = max_reach;\\n            }\\n        }\\n\\n        if cur_reach >= time as usize { ans } else { -1 }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866627,
                "title": "100-faster-for-beginner-to-advance-learner",
                "content": "\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int maxLength=0, minLength= 0, total = 0;\\n        while(maxLength<time){\\n            for(int i=0;i<clips.length;i++) {\\n                int l = clips[i][0];\\n                int r = clips[i][1];\\n                if(l<=minLength && r>maxLength)\\n                    maxLength = r;\\n            }\\n            if(minLength == maxLength)\\n                return -1;\\n            minLength = maxLength;\\n            total ++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int maxLength=0, minLength= 0, total = 0;\\n        while(maxLength<time){\\n            for(int i=0;i<clips.length;i++) {\\n                int l = clips[i][0];\\n                int r = clips[i][1];\\n                if(l<=minLength && r>maxLength)\\n                    maxLength = r;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573370,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1966622,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1569473,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2038518,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2011402,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2006991,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1698492,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1670067,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1631316,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "question_content": "<p>Given a weighted undirected connected graph with <code>n</code>&nbsp;vertices numbered from <code>0</code> to <code>n - 1</code>,&nbsp;and an array <code>edges</code>&nbsp;where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, weight<sub>i</sub>]</code> represents a bidirectional and weighted edge between nodes&nbsp;<code>a<sub>i</sub></code>&nbsp;and <code>b<sub>i</sub></code>. A minimum spanning tree (MST) is a subset of the graph&#39;s edges that connects all vertices without cycles&nbsp;and with the minimum possible total edge weight.</p>\n\n<p>Find <em>all the critical and pseudo-critical edges in the given graph&#39;s minimum spanning tree (MST)</em>. An MST edge whose deletion from the graph would cause the MST weight to increase is called a&nbsp;<em>critical edge</em>. On&nbsp;the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.</p>\n\n<p>Note that you can return the indices of the edges in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/04/ex1.png\" style=\"width: 259px; height: 262px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n<strong>Output:</strong> [[0,1],[2,3,4,5]]\n<strong>Explanation:</strong> The figure above describes the graph.\nThe following figure shows all the possible MSTs:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/04/msts.png\" style=\"width: 540px; height: 553px;\" />\nNotice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.\nThe edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/04/ex2.png\" style=\"width: 247px; height: 253px;\" /></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n<strong>Output:</strong> [[],[0,1,2,3]]\n<strong>Explanation:</strong> We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li>All pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 697761,
                "title": "c-solution-enumerating-edges-with-explanation",
                "content": "We use the standard MST algorithm as a baseline, and denote the total MST weight as `origin_mst`.\\nTo generate critical and pseudo-critical lists, we enumerate each edge:\\n1. If deleting the edge and re-calculating the mst again makes mst total weight increase (or can\\'t form mst), then the edge goes into critical list.\\n2. If we force adding the edge to the mst (by first adding the edge to the mst edge set and run the standard MST algorithm for the rest of the edges), and find that the mst doesn\\'t change, then the edge goes into pseudo-critical list. (This is because if an edge can be in any mst, we can always add it to the edge set first, without changing the final mst total weight).\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697750,
                "title": "java-simple-solution-based-on-finding-mst",
                "content": "First, we find the cost of the MST using all edges.\\n\\nAn edge is critical iff all MSTs without this edge will have larger costs than the min cost. An edge is pseudo-critical if no matter we use  or do not use this edge, we can always find an MST with the min cost.\\n\\n```\\nclass UnionFind{\\n    final int[] parents;\\n    int count;\\n    \\n    public UnionFind(int n){\\n        this.parents = new int[n];\\n        reset();\\n    }\\n    \\n    public void reset(){\\n        for(int i =0;i<parents.length;i++){\\n            parents[i] = i;\\n        }\\n        count = parents.length;\\n    }\\n    \\n    public int find(int i){\\n        int parent = parents[i];\\n        if(parent == i){\\n            return i;\\n        }else{\\n            int root = find(parent);\\n            parents[i] = root;\\n            return root;\\n        }\\n    }\\n    \\n    public boolean union(int i, int j){\\n        int r1 = find(i);\\n        int r2 = find(j);\\n        if(r1 != r2){\\n            count--;\\n            parents[r1] = r2;\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n       \\n        List<Integer>criticals = new ArrayList<>();\\n        List<Integer> pseduos = new ArrayList<>();\\n        \\n        Map<int[], Integer> map = new HashMap<>();\\n        for(int i =0;i<edges.length;i++){\\n            map.put(edges[i], i);\\n        }\\n        \\n        Arrays.sort(edges, (e1, e2)->Integer.compare(e1[2], e2[2]));\\n        int minCost = buildMST(n, edges, null, null);\\n        \\n        for(int i =0;i<edges.length;i++){\\n            int[] edge = edges[i];\\n            int index = map.get(edge);\\n            int costWithout = buildMST(n, edges, null, edge);\\n            if(costWithout > minCost){\\n                criticals.add(index);\\n            }else{\\n                int costWith = buildMST(n, edges, edge, null);\\n                if(costWith == minCost){\\n                    pseduos.add(index);\\n                }\\n            }\\n            \\n        }\\n        \\n        return Arrays.asList(criticals, pseduos);\\n    }\\n    \\n    private int buildMST(int n, int[][] edges, int[] pick, int[] skip){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        if(pick != null){\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(int[] edge : edges){\\n            if(edge != skip && uf.union(edge[0], edge[1])){\\n                cost += edge[2];\\n            }\\n        }\\n        return uf.count == 1? cost : Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind{\\n    final int[] parents;\\n    int count;\\n    \\n    public UnionFind(int n){\\n        this.parents = new int[n];\\n        reset();\\n    }\\n    \\n    public void reset(){\\n        for(int i =0;i<parents.length;i++){\\n            parents[i] = i;\\n        }\\n        count = parents.length;\\n    }\\n    \\n    public int find(int i){\\n        int parent = parents[i];\\n        if(parent == i){\\n            return i;\\n        }else{\\n            int root = find(parent);\\n            parents[i] = root;\\n            return root;\\n        }\\n    }\\n    \\n    public boolean union(int i, int j){\\n        int r1 = find(i);\\n        int r2 = find(j);\\n        if(r1 != r2){\\n            count--;\\n            parents[r1] = r2;\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n       \\n        List<Integer>criticals = new ArrayList<>();\\n        List<Integer> pseduos = new ArrayList<>();\\n        \\n        Map<int[], Integer> map = new HashMap<>();\\n        for(int i =0;i<edges.length;i++){\\n            map.put(edges[i], i);\\n        }\\n        \\n        Arrays.sort(edges, (e1, e2)->Integer.compare(e1[2], e2[2]));\\n        int minCost = buildMST(n, edges, null, null);\\n        \\n        for(int i =0;i<edges.length;i++){\\n            int[] edge = edges[i];\\n            int index = map.get(edge);\\n            int costWithout = buildMST(n, edges, null, edge);\\n            if(costWithout > minCost){\\n                criticals.add(index);\\n            }else{\\n                int costWith = buildMST(n, edges, edge, null);\\n                if(costWith == minCost){\\n                    pseduos.add(index);\\n                }\\n            }\\n            \\n        }\\n        \\n        return Arrays.asList(criticals, pseduos);\\n    }\\n    \\n    private int buildMST(int n, int[][] edges, int[] pick, int[] skip){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        if(pick != null){\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(int[] edge : edges){\\n            if(edge != skip && uf.union(edge[0], edge[1])){\\n                cost += edge[2];\\n            }\\n        }\\n        return uf.count == 1? cost : Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698311,
                "title": "python-unionfind-kruskal-solution-with-detail-explanation-from-o-e-2-to-o-eloge",
                "content": "**Background**\\n\\nThe Kruskal\\u2019s algorithm finds the minimum cost spanning tree using a greedy approach: it first sorts all edges, which takes `O(ELogE)` time. After sorting, it iterates through all edges and apply Union-Find algorithm. \\n\\nThe Union-Find by Rank and Path Compression  takes `O(alpha(V) * E)`, where `alpha(V)` is the inverse of the Ackermann function and can be considered constant.\\n\\n<br />\\n\\n**Explaination - O(E^2) Solution**\\n\\nFrom the Background section, we know that the bottleneck for Kruskal\\'s algorithm is really the sorting part. If all edges are already sorted, we can find the MST with any subset of nodes in `O(E)` time.\\n\\nWe can take the following steps to solve this problem:\\n\\n1. Sort all the edges in non-decreasing order of their weight.\\n2. Run Kruskal\\u2019s algorithm to find the total weight of the MST (i.e. `base`).\\n3. Iterate through each edge and find the weight of MST if we excludes this edge (i.e. `wgt_excl`).\\n4. If `wgt_excl != base`, this edge is a critical edge.\\n5. If `wgt_excl == base`, this edge is either pseudo-critical (MST may or may not include this edge), or redundant (MST cannot include this edge). Let\\'s find the MST\\'s total weights if we do include this edge (i.e. `wgt_incl`). If `wgt_incl` is larger than `base`, then this edge is redundant; otherwise, this edge is pseudo-critial.\\n\\nThe time complexity is `O(E^2)`, because we do sorting once (`O(ElogE)`) and calculating MST `2E` times (`O(E^2)`) .\\n\\n<br />\\n\\n**Explaination - O(ElogE) Solution**\\n\\nIn the previous algorithm, we calculated MST for `2E` times. This takes a lot of time and is not necessary. Instead, we can populate the list of critical edges and pesudo-critical edges when we calculates the MST. In this way, we only need to calculate the MST once.\\n\\nI will list the general thoughts below, but please see code comments for more details.\\n\\nFirst of all, we sort all edges in the same way as we did in the Kruskal\\u2019s algorithm.\\n\\nThen, for a given weight, we check all its corresponding edges. For edge `(u, v)`, if it connects two already connected groups, it is redundant (neither critical nor pesudo-critical); otherwise, we put `(u, v)`\\'s group parents `(pu, pv)` in `seen`.\\n\\nIf there is more than one edge that connects union group `pu` and `pv`, then all `seen[pu, pv]` are pesudo-critical. If not, we check if the edges in `seen[pu, pv]` forms any cycles. For the edges not forming cycles, we mark them as critical, and mark the others as pesudo-critical.\\n\\nTo identify cycles in a graph, we can refer to the solution of [1192. Critical Connections in a Network](https://leetcode.com/problems/critical-connections-in-a-network/).\\n\\n\\n<br />\\n\\n**O(E^2) Solution**\\n```Python\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```\\n\\n\\n\\n**O(ElogE) Solution**\\n```Python\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    \\n        # reference: LC 1192\\n        def dfs(curr, level, parent):\\n            levels[curr] = level\\n            for child, i in graph[curr]:\\n                if child == parent:\\n                    continue\\n                elif levels[child] == -1:\\n                    levels[curr] = min(levels[curr], dfs(child, level + 1, curr))\\n                else:\\n                    levels[curr] = min(levels[curr], levels[child])\\n                if levels[child] >= level + 1 and i not in p_cri:\\n                    cri.add(i)\\n            return levels[curr]\\n        \\n        # init critical and pseudo-critical edge set\\n        cri, p_cri = set(), set()\\n        \\n        # use dic to store all edges associated with a given weight\\n        dic = collections.defaultdict(list)\\n        for i, (u, v, w) in enumerate(edges):\\n            dic[w].append([u, v, i])\\n        \\n        # define union find et\\n        union_set = UnionFindSet(n)\\n        \\n        # iterate through all weights in ascending order\\n        for w in sorted(dic):\\n                \\n            # seen[(pu, pv)] contains all edges connecting pu and pv,\\n            # where pu and pv are the parent nodes of their corresponding groups\\n            seen = collections.defaultdict(set)\\n            # populate seen\\n            for u, v, i in dic[w]:\\n                pu, pv = union_set.find(u), union_set.find(v)\\n                # skip the edge that creates cycle\\n                if pu == pv:\\n                    continue\\n                seen[min(pu, pv), max(pu, pv)].add(i) # edge i connects pu and pv\\n            \\n            # w_edges contains all weight-w edges we may add to MST\\n            w_edges, graph = [], collections.defaultdict(list)\\n            for pu, pv in seen:\\n                # more than 1 edge can connect pu and pv\\n                # these edges are pseudo-critical\\n                if len(seen[pu, pv]) > 1:\\n                    p_cri |= seen[pu, pv]\\n                # construct graph for weight w \\n                edge_idx = seen[pu, pv].pop()\\n                graph[pu].append((pv, edge_idx))\\n                graph[pv].append((pu, edge_idx))\\n                w_edges.append((pu, pv, edge_idx))\\n                # union pu and pv groups\\n                union_set.union(pu, pv)\\n            \\n            # run dfs to mark all critical w_edges\\n            levels = [-1] * n\\n            for u, v, i in w_edges:\\n                if levels[u] == -1:\\n                    dfs(u, 0, -1)\\n            # the edges in w_edges cycles are pseudo-critical\\n            for u, v, i in w_edges:\\n                if i not in cri:\\n                    p_cri.add(i)\\n        \\n        return [cri, p_cri]\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```\n```Python\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    \\n        # reference: LC 1192\\n        def dfs(curr, level, parent):\\n            levels[curr] = level\\n            for child, i in graph[curr]:\\n                if child == parent:\\n                    continue\\n                elif levels[child] == -1:\\n                    levels[curr] = min(levels[curr], dfs(child, level + 1, curr))\\n                else:\\n                    levels[curr] = min(levels[curr], levels[child])\\n                if levels[child] >= level + 1 and i not in p_cri:\\n                    cri.add(i)\\n            return levels[curr]\\n        \\n        # init critical and pseudo-critical edge set\\n        cri, p_cri = set(), set()\\n        \\n        # use dic to store all edges associated with a given weight\\n        dic = collections.defaultdict(list)\\n        for i, (u, v, w) in enumerate(edges):\\n            dic[w].append([u, v, i])\\n        \\n        # define union find et\\n        union_set = UnionFindSet(n)\\n        \\n        # iterate through all weights in ascending order\\n        for w in sorted(dic):\\n                \\n            # seen[(pu, pv)] contains all edges connecting pu and pv,\\n            # where pu and pv are the parent nodes of their corresponding groups\\n            seen = collections.defaultdict(set)\\n            # populate seen\\n            for u, v, i in dic[w]:\\n                pu, pv = union_set.find(u), union_set.find(v)\\n                # skip the edge that creates cycle\\n                if pu == pv:\\n                    continue\\n                seen[min(pu, pv), max(pu, pv)].add(i) # edge i connects pu and pv\\n            \\n            # w_edges contains all weight-w edges we may add to MST\\n            w_edges, graph = [], collections.defaultdict(list)\\n            for pu, pv in seen:\\n                # more than 1 edge can connect pu and pv\\n                # these edges are pseudo-critical\\n                if len(seen[pu, pv]) > 1:\\n                    p_cri |= seen[pu, pv]\\n                # construct graph for weight w \\n                edge_idx = seen[pu, pv].pop()\\n                graph[pu].append((pv, edge_idx))\\n                graph[pv].append((pu, edge_idx))\\n                w_edges.append((pu, pv, edge_idx))\\n                # union pu and pv groups\\n                union_set.union(pu, pv)\\n            \\n            # run dfs to mark all critical w_edges\\n            levels = [-1] * n\\n            for u, v, i in w_edges:\\n                if levels[u] == -1:\\n                    dfs(u, 0, -1)\\n            # the edges in w_edges cycles are pseudo-critical\\n            for u, v, i in w_edges:\\n                if i not in cri:\\n                    p_cri.add(i)\\n        \\n        return [cri, p_cri]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929059,
                "title": "beats-100-js-ts-java-c-c-python-python3-kotlin",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n\\n```C++ []\\nclass UnionFind {\\npublic: \\n    vector<int> parent; \\n    UnionFind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i; \\n    }\\n    \\n    int findParent(int p) {\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]); \\n    }\\n    \\n    void Union(int u , int v) {\\n        int pu = findParent(u) , pv = findParent(v); \\n        parent[pu] = pv;\\n    }    \\n};\\n\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>&a , vector<int>&b) {\\n        return a[2] < b[2]; \\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical ,  pscritical ;\\n        //1\\n        for(int i=0;i<edges.size();i++)\\n            edges[i].push_back(i); \\n        \\n        //2 \\n        sort(edges.begin() , edges.end() , cmp) ;\\n        \\n        int mstwt = findMST(n,edges,-1,-1); //3\\n        for(int i=0;i<edges.size();i++){\\n            if(mstwt< findMST(n,edges,i,-1)) //5\\n                critical.push_back(edges[i][3]); \\n            else if(mstwt == findMST(n,edges,-1,i))  //6\\n                pscritical.push_back(edges[i][3]);\\n        }\\n        return {critical , pscritical};         \\n    }\\n    \\nprivate:\\n    int findMST(int &n ,  vector<vector<int>>& edges , int block , int e) {\\n        UnionFind uf(n); \\n        int weight = 0 ;\\n        if(e != -1) {\\n            weight += edges[e][2]; \\n            uf.Union(edges[e][0] , edges[e][1]); \\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(i == block) \\n                continue; \\n            if(uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) //4\\n                continue; \\n            uf.Union(edges[i][0] , edges[i][1]); \\n            weight += edges[i][2]; \\n        }\\n        \\n        //Check if all vertices are included then only it is MST. \\n        for(int i=0;i<n;i++){\\n            if(uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }    \\n        \\n        return weight; \\n    }\\n    \\n};\\n```\\n```Typescript []\\nfunction findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\\n    let copyEdges=[...edges];\\n    \\n    let mst=findMst(n,copyEdges,[],[]);\\n    let critical:number[]=[];\\n    let pseudoCritical:number[]=[];\\n    \\n    for(let i =0;i<edges.length;i++)\\n        {\\n         \\n            let delMst=findMst(n,copyEdges,[],edges[i]);\\n            \\n            if(delMst!=mst){\\n                critical.push(i);\\n                continue;   \\n            }\\n            let forceMst=findMst(n,copyEdges,edges[i],[]);\\n            \\n            if(forceMst==mst)\\n                pseudoCritical.push(i);\\n    \\n        }\\n    return [critical,pseudoCritical];\\n\\n};\\n\\nfunction filterRow(rowNum:number, arr:number[][]): number[][]{\\n    let copy:number[][]=[];\\n    \\n    for(let i=0;i<arr.length;i++)\\n        if(i!=rowNum)\\n            copy.push(arr[i]);\\n    \\n    return copy;\\n    \\n    \\n}\\n\\nfunction findMst(n:number, edges: number[][],forceEdge:number[],deleteEdge:number[]):  number {\\n    \\n   edges.sort((a,b)=>a[2]-b[2]);\\n\\n   const parent= Array(n);\\n   const rank=Array(n).fill(0);\\n    \\n   for(let i=0;i<n;i++)\\n      parent[i]=i;\\n   \\n    \\n\\n    \\n   let mst:number=0;\\n   let numEdges:number=0;\\n   \\n    \\n   if(forceEdge.length!=0)\\n       {\\n          let edge=forceEdge;\\n           let v1=edge[0];\\n           let v2=edge[1];\\n           let weight=edge[2];\\n           \\n           if(findParent(v1,parent)!=findParent(v2,parent))\\n               {\\n                   numEdges++;\\n                   mst+=weight;\\n                     \\n                   union(v1,v2,rank,parent);\\n                \\n               }\\n       }\\n    \\n    \\n   for(let i=0;i<edges.length;i++)\\n       { \\n           \\n           \\n           \\n           let edge=edges[i];\\n           let v1=edge[0];\\n           let v2=edge[1];\\n           let weight=edge[2];\\n           \\n           if(deleteEdge.length!=0 && v1==deleteEdge[0] && v2==deleteEdge[1])\\n               continue;\\n           \\n           \\n           if(findParent(v1,parent)!=findParent(v2,parent))\\n               {\\n                   numEdges++;\\n                   mst+=weight;\\n                   union(v1,v2,rank,parent);\\n                  \\n               }\\n           \\n           if(numEdges==n-1)\\n               break;\\n          \\n       }\\n    \\n    return mst;\\n    \\n}\\n\\nfunction findParent(vertex: number, parent: number[]): number{\\n    if(parent[vertex]==vertex)\\n        return vertex;\\n    \\n    return parent[vertex]=findParent(parent[vertex],parent);\\n    \\n    \\n}\\n\\n\\nfunction union(v1:number, v2:number, rank:number[], parent:number[] ): void {\\n    v1=findParent(v1,parent);\\n    v2=findParent(v2,parent);\\n    \\n    if(rank[v1]>rank[v2])\\n        {\\n            parent[v2]=v1;\\n        }\\n    else if(rank[v2]>rank[v1])\\n        parent[v1]=v2;\\n    else{\\n        parent[v2]=v1;\\n        rank[v1]++;\\n    }\\n}\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass UnionFind {\\n    private int[] parent;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    public int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    public void union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            edge = Arrays.copyOf(edge, edge.length + 1);\\n            edge[3] = i;\\n            edges[i] = edge;\\n        }\\n        \\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.add(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.add(edges[i][3]);\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(critical);\\n        result.add(pseudoCritical);\\n        return result;\\n    }\\n\\n    private int findMST(int n, int[][] edges, int block, int e) {\\n        UnionFind uf = new UnionFind(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.union(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.union(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return Integer.MAX_VALUE;\\n        }\\n\\n        return weight;\\n    }\\n}\\n```\\n```Python []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find_parent(self, p):\\n        if self.parent[p] == p:\\n            return p\\n        self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    @staticmethod\\n    def cmp(a, b):\\n        return a[2] < b[2]\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i in range(len(edges)):\\n            edges[i].append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        \\n        mstwt = self.find_MST(n, edges, -1, -1)\\n        \\n        for i in range(len(edges)):\\n            if mstwt < self.find_MST(n, edges, i, -1):\\n                critical.append(edges[i][3])\\n            elif mstwt == self.find_MST(n, edges, -1, i):\\n                pseudo_critical.append(edges[i][3])\\n        \\n        return [critical, pseudo_critical]\\n    \\n    def find_MST(self, n, edges, block, e):\\n        uf = UnionFind(n)\\n        weight = 0\\n        \\n        if e != -1:\\n            weight += edges[e][2]\\n            uf.union(edges[e][0], edges[e][1])\\n        \\n        for i in range(len(edges)):\\n            if i == block:\\n                continue\\n            if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                continue\\n            uf.union(edges[i][0], edges[i][1])\\n            weight += edges[i][2]\\n        \\n        for i in range(n):\\n            if uf.find_parent(i) != uf.find_parent(0):\\n                return float(\\'inf\\')\\n        \\n        return weight\\n```\\n```Python3 []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find_parent(self, p):\\n        if self.parent[p] == p:\\n            return p\\n        self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def cmp(a, b):\\n            return a[2] < b[2]\\n        \\n        critical, pseudo_critical = [], []\\n        \\n        for i in range(len(edges)):\\n            edges[i].append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        \\n        mst_wt = self.find_mst(n, edges, -1, -1)\\n        \\n        for i in range(len(edges)):\\n            if mst_wt < self.find_mst(n, edges, i, -1):\\n                critical.append(edges[i][3])\\n            elif mst_wt == self.find_mst(n, edges, -1, i):\\n                pseudo_critical.append(edges[i][3])\\n        \\n        return [critical, pseudo_critical]\\n    \\n    def find_mst(self, n, edges, block, e):\\n        uf = UnionFind(n)\\n        weight = 0\\n        \\n        if e != -1:\\n            weight += edges[e][2]\\n            uf.union(edges[e][0], edges[e][1])\\n        \\n        for i in range(len(edges)):\\n            if i == block:\\n                continue\\n            if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                continue\\n            uf.union(edges[i][0], edges[i][1])\\n            weight += edges[i][2]\\n        \\n        for i in range(n):\\n            if uf.find_parent(i) != uf.find_parent(0):\\n                return float(\\'inf\\')\\n        \\n        return weight\\n```\\n```C# []\\npublic class Solution {\\n    public class Edge{\\n        public int id{get;set;}\\n        public int from{get;set;}\\n        public int to{get;set;}\\n        public int cost{get;set;}\\n    }\\n    class DSU{\\n        int[] par, sz;\\n        public int componentCount;\\n        public DSU(int n){\\n            par = new int[n];\\n            componentCount = n;\\n            sz = new int[n];\\n            for(int i = 0; i < n;i++){\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        public int FindParent(int u){\\n            if(par[u] == u) return u;\\n            int p = FindParent(par[u]);\\n            par[u] = p;\\n            return p;\\n        }\\n        public bool IsSameComponent(int u , int v) => FindParent(u) == FindParent(v);\\n        public void Join(int u,int v){\\n            u = FindParent(u);\\n            v = FindParent(v);\\n            if(u == v) return;\\n            if(sz[u] < sz[v]) (u,v) = (v,u);\\n            par[v] = u;\\n            sz[u]+=sz[v];\\n            componentCount--;\\n        }\\n    }\\n    int kruskal(PriorityQueue<Edge,int> edges, int nodes,Edge taken = null){\\n        int res = 0;\\n        DSU dsu = new DSU(nodes);\\n        if(taken != null){\\n            dsu.Join(taken.from, taken.to);\\n            res += taken.cost;\\n        }\\n        while(dsu.componentCount > 1 && edges.Count > 0){\\n            var e = edges.Dequeue();\\n            if(dsu.IsSameComponent(e.from, e.to)) continue;\\n            dsu.Join(e.from, e.to);\\n            res += e.cost;\\n        }\\n        if(dsu.componentCount > 1) return Int32.MaxValue;\\n        return res;\\n    }\\n    public PriorityQueue<Edge,int> GetEdges(int[][] edges,int skipedIdx = -1){\\n        PriorityQueue<Edge,int> edgesPq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0;i < edges.Length;i++){\\n            if(i == skipedIdx) continue;\\n            edgesPq.Enqueue(new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]},edges[i][2]);\\n        }\\n        return edgesPq;\\n    }\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost =  kruskal(GetEdges(edges),n);\\n        List<IList<int>> res = new List<IList<int>>(){new List<int>(),new List<int>()};\\n        for(int i = 0; i < edges.Length;i++){\\n            int curCost = kruskal(GetEdges(edges,i),n);\\n            if(curCost > mstCost) res[0].Add(i);\\n            else{\\n                Edge taken = new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]};\\n                curCost = kruskal(GetEdges(edges),n,taken);\\n                if(curCost == mstCost)res[1].Add(i);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n```Javascript []\\nclass UnionFind {\\n    constructor(n) {\\n        this.parents = [];\\n        for(let i = 0; i < n; i++) {\\n            this.parents.push(i);\\n        }\\n        this.count = n;\\n    }\\n\\n    find(index) {\\n        const parent = this.parents[index];\\n        if(parent === index) return index;\\n\\n        let root = this.find(parent);\\n        this.parents[index] = root;\\n        return root;\\n    }\\n\\n    union(index1, index2) {\\n        let p1 = this.find(index1);\\n        let p2 = this.find(index2);\\n\\n        if(p1 !== p2) {\\n            this.count--;\\n            this.parents[p1] = p2;\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let criticalEdges = [], psuedoCriticalEdges = [], map = new Map();\\n    \\n    edges.forEach((edge, i) => map.set(edge, i));\\n    \\n    edges.sort((a, b) => a[2] - b[2]);\\n    \\n    const buildMST = (pick, skip) => {\\n        let uf = new UnionFind(n), cost = 0;\\n        \\n        if(pick !== null) {\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(let edge of edges) {\\n            if(edge !== skip && uf.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER;\\n    };\\n    \\n    const minCost = buildMST(null, null);\\n    \\n    for(let edge of edges) {\\n        const index = map.get(edge);\\n        const costWithout = buildMST(null, edge);\\n        if(costWithout > minCost) {\\n            criticalEdges.push(index);\\n        } else {\\n            const costWith = buildMST(edge, null);\\n            if(costWith === minCost) psuedoCriticalEdges.push(index);\\n        }\\n    }\\n    \\n    return [criticalEdges, psuedoCriticalEdges];\\n};\\n```\\n```Kotlin []\\nimport kotlin.math.*\\nimport kotlin.comparisons.*\\n\\nclass Solution {\\n    data class Edge(\\n        val node1: Int,\\n        val node2: Int,\\n        val weight: Int,\\n        val number: Int\\n    )\\n    \\n    class UnionFind(val size: Int) {\\n        private val content: Array<Pair<Int, Int>> = Array(size) { it to 1 }\\n        \\n        fun union(first: Int, second: Int) {\\n            val firstRoot: Pair<Int, Int> = root(first)\\n            val secondRoot: Pair<Int, Int> = root(second)\\n            \\n            if (firstRoot.first != secondRoot.first) {\\n                // probably due to old kotlin version, this should work with lamda\\n                var higher: Pair<Int, Int> = maxOf(firstRoot, secondRoot, object: Comparator<Pair<Int, Int>> {\\n                    override fun compare(firstPair: Pair<Int, Int>, secondPair: Pair<Int, Int>): Int {\\n                        return firstPair.second - secondPair.second\\n                    }\\n                })\\n                \\n                higher = Pair(higher.first, higher.second + min(firstRoot.second, secondRoot.second))\\n                \\n                content[firstRoot.first] = higher\\n                content[secondRoot.first] = higher\\n            }\\n        }\\n        \\n        fun connected(first: Int, second: Int): Boolean {\\n            return root(first).first == root(second).first\\n        }\\n        \\n        fun root(node: Int): Pair<Int, Int> {\\n            var cur = node\\n            \\n            while (content[cur].first != cur) {\\n                content[cur] = content[content[cur].first]\\n                cur = content[cur].first\\n            }\\n            \\n            return content[cur]\\n        }\\n    }\\n    \\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\\n        val critical: MutableList<Int> = mutableListOf()\\n        val pseudo: MutableList<Int> = mutableListOf()\\n        \\n        val sortedEdges = edges.asSequence()\\n            .mapIndexed { index, edge -> \\n                Edge(edge[0], edge[1], edge[2], index) \\n            }\\n            .sortedBy { it.weight }\\n            .toList()\\n        \\n        val minWeight = findMSTWeight(n, sortedEdges)\\n        for (edge in sortedEdges) {   \\n            if (findMSTWeight(n, sortedEdges, blocked = edge) != minWeight) {\\n                critical.add(edge.number)\\n            } else if (findMSTWeight(n, sortedEdges, peeked = edge) == minWeight) {\\n                pseudo.add(edge.number)\\n            }\\n        }\\n        \\n        return listOf(critical, pseudo)\\n    }\\n    \\n    fun findMSTWeight(n: Int, edges: List<Edge>, blocked: Edge? = null, peeked: Edge? = null): Int {\\n        val union = UnionFind(n)\\n        var weight = 0;\\n        \\n        peeked?.let { \\n            union.union(it.node1, it.node2)\\n            weight += it.weight\\n        }\\n        \\n        for (edge in edges) {\\n            if (blocked?.number != edge.number && !union.connected(edge.node1, edge.node2)) {\\n                union.union(edge.node1, edge.node2)\\n                weight += edge.weight\\n            }\\n        }\\n        \\n        return weight\\n    }\\n}\\n```\\n\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "TypeScript",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass UnionFind {\\npublic: \\n    vector<int> parent; \\n    UnionFind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i; \\n    }\\n    \\n    int findParent(int p) {\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]); \\n    }\\n    \\n    void Union(int u , int v) {\\n        int pu = findParent(u) , pv = findParent(v); \\n        parent[pu] = pv;\\n    }    \\n};\\n\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>&a , vector<int>&b) {\\n        return a[2] < b[2]; \\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical ,  pscritical ;\\n        //1\\n        for(int i=0;i<edges.size();i++)\\n            edges[i].push_back(i); \\n        \\n        //2 \\n        sort(edges.begin() , edges.end() , cmp) ;\\n        \\n        int mstwt = findMST(n,edges,-1,-1); //3\\n        for(int i=0;i<edges.size();i++){\\n            if(mstwt< findMST(n,edges,i,-1)) //5\\n                critical.push_back(edges[i][3]); \\n            else if(mstwt == findMST(n,edges,-1,i))  //6\\n                pscritical.push_back(edges[i][3]);\\n        }\\n        return {critical , pscritical};         \\n    }\\n    \\nprivate:\\n    int findMST(int &n ,  vector<vector<int>>& edges , int block , int e) {\\n        UnionFind uf(n); \\n        int weight = 0 ;\\n        if(e != -1) {\\n            weight += edges[e][2]; \\n            uf.Union(edges[e][0] , edges[e][1]); \\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(i == block) \\n                continue; \\n            if(uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) //4\\n                continue; \\n            uf.Union(edges[i][0] , edges[i][1]); \\n            weight += edges[i][2]; \\n        }\\n        \\n        //Check if all vertices are included then only it is MST. \\n        for(int i=0;i<n;i++){\\n            if(uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }    \\n        \\n        return weight; \\n    }\\n    \\n};\\n```\n```Typescript []\\nfunction findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\\n    let copyEdges=[...edges];\\n    \\n    let mst=findMst(n,copyEdges,[],[]);\\n    let critical:number[]=[];\\n    let pseudoCritical:number[]=[];\\n    \\n    for(let i =0;i<edges.length;i++)\\n        {\\n         \\n            let delMst=findMst(n,copyEdges,[],edges[i]);\\n            \\n            if(delMst!=mst){\\n                critical.push(i);\\n                continue;   \\n            }\\n            let forceMst=findMst(n,copyEdges,edges[i],[]);\\n            \\n            if(forceMst==mst)\\n                pseudoCritical.push(i);\\n    \\n        }\\n    return [critical,pseudoCritical];\\n\\n};\\n\\nfunction filterRow(rowNum:number, arr:number[][]): number[][]{\\n    let copy:number[][]=[];\\n    \\n    for(let i=0;i<arr.length;i++)\\n        if(i!=rowNum)\\n            copy.push(arr[i]);\\n    \\n    return copy;\\n    \\n    \\n}\\n\\nfunction findMst(n:number, edges: number[][],forceEdge:number[],deleteEdge:number[]):  number {\\n    \\n   edges.sort((a,b)=>a[2]-b[2]);\\n\\n   const parent= Array(n);\\n   const rank=Array(n).fill(0);\\n    \\n   for(let i=0;i<n;i++)\\n      parent[i]=i;\\n   \\n    \\n\\n    \\n   let mst:number=0;\\n   let numEdges:number=0;\\n   \\n    \\n   if(forceEdge.length!=0)\\n       {\\n          let edge=forceEdge;\\n           let v1=edge[0];\\n           let v2=edge[1];\\n           let weight=edge[2];\\n           \\n           if(findParent(v1,parent)!=findParent(v2,parent))\\n               {\\n                   numEdges++;\\n                   mst+=weight;\\n                     \\n                   union(v1,v2,rank,parent);\\n                \\n               }\\n       }\\n    \\n    \\n   for(let i=0;i<edges.length;i++)\\n       { \\n           \\n           \\n           \\n           let edge=edges[i];\\n           let v1=edge[0];\\n           let v2=edge[1];\\n           let weight=edge[2];\\n           \\n           if(deleteEdge.length!=0 && v1==deleteEdge[0] && v2==deleteEdge[1])\\n               continue;\\n           \\n           \\n           if(findParent(v1,parent)!=findParent(v2,parent))\\n               {\\n                   numEdges++;\\n                   mst+=weight;\\n                   union(v1,v2,rank,parent);\\n                  \\n               }\\n           \\n           if(numEdges==n-1)\\n               break;\\n          \\n       }\\n    \\n    return mst;\\n    \\n}\\n\\nfunction findParent(vertex: number, parent: number[]): number{\\n    if(parent[vertex]==vertex)\\n        return vertex;\\n    \\n    return parent[vertex]=findParent(parent[vertex],parent);\\n    \\n    \\n}\\n\\n\\nfunction union(v1:number, v2:number, rank:number[], parent:number[] ): void {\\n    v1=findParent(v1,parent);\\n    v2=findParent(v2,parent);\\n    \\n    if(rank[v1]>rank[v2])\\n        {\\n            parent[v2]=v1;\\n        }\\n    else if(rank[v2]>rank[v1])\\n        parent[v1]=v2;\\n    else{\\n        parent[v2]=v1;\\n        rank[v1]++;\\n    }\\n}\\n```\n```Java []\\nimport java.util.*;\\n\\nclass UnionFind {\\n    private int[] parent;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    public int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    public void union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            edge = Arrays.copyOf(edge, edge.length + 1);\\n            edge[3] = i;\\n            edges[i] = edge;\\n        }\\n        \\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.add(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.add(edges[i][3]);\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(critical);\\n        result.add(pseudoCritical);\\n        return result;\\n    }\\n\\n    private int findMST(int n, int[][] edges, int block, int e) {\\n        UnionFind uf = new UnionFind(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.union(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.union(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return Integer.MAX_VALUE;\\n        }\\n\\n        return weight;\\n    }\\n}\\n```\n```Python []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find_parent(self, p):\\n        if self.parent[p] == p:\\n            return p\\n        self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    @staticmethod\\n    def cmp(a, b):\\n        return a[2] < b[2]\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i in range(len(edges)):\\n            edges[i].append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        \\n        mstwt = self.find_MST(n, edges, -1, -1)\\n        \\n        for i in range(len(edges)):\\n            if mstwt < self.find_MST(n, edges, i, -1):\\n                critical.append(edges[i][3])\\n            elif mstwt == self.find_MST(n, edges, -1, i):\\n                pseudo_critical.append(edges[i][3])\\n        \\n        return [critical, pseudo_critical]\\n    \\n    def find_MST(self, n, edges, block, e):\\n        uf = UnionFind(n)\\n        weight = 0\\n        \\n        if e != -1:\\n            weight += edges[e][2]\\n            uf.union(edges[e][0], edges[e][1])\\n        \\n        for i in range(len(edges)):\\n            if i == block:\\n                continue\\n            if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                continue\\n            uf.union(edges[i][0], edges[i][1])\\n            weight += edges[i][2]\\n        \\n        for i in range(n):\\n            if uf.find_parent(i) != uf.find_parent(0):\\n                return float(\\'inf\\')\\n        \\n        return weight\\n```\n```Python3 []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    \\n    def find_parent(self, p):\\n        if self.parent[p] == p:\\n            return p\\n        self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def cmp(a, b):\\n            return a[2] < b[2]\\n        \\n        critical, pseudo_critical = [], []\\n        \\n        for i in range(len(edges)):\\n            edges[i].append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        \\n        mst_wt = self.find_mst(n, edges, -1, -1)\\n        \\n        for i in range(len(edges)):\\n            if mst_wt < self.find_mst(n, edges, i, -1):\\n                critical.append(edges[i][3])\\n            elif mst_wt == self.find_mst(n, edges, -1, i):\\n                pseudo_critical.append(edges[i][3])\\n        \\n        return [critical, pseudo_critical]\\n    \\n    def find_mst(self, n, edges, block, e):\\n        uf = UnionFind(n)\\n        weight = 0\\n        \\n        if e != -1:\\n            weight += edges[e][2]\\n            uf.union(edges[e][0], edges[e][1])\\n        \\n        for i in range(len(edges)):\\n            if i == block:\\n                continue\\n            if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                continue\\n            uf.union(edges[i][0], edges[i][1])\\n            weight += edges[i][2]\\n        \\n        for i in range(n):\\n            if uf.find_parent(i) != uf.find_parent(0):\\n                return float(\\'inf\\')\\n        \\n        return weight\\n```\n```C# []\\npublic class Solution {\\n    public class Edge{\\n        public int id{get;set;}\\n        public int from{get;set;}\\n        public int to{get;set;}\\n        public int cost{get;set;}\\n    }\\n    class DSU{\\n        int[] par, sz;\\n        public int componentCount;\\n        public DSU(int n){\\n            par = new int[n];\\n            componentCount = n;\\n            sz = new int[n];\\n            for(int i = 0; i < n;i++){\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        public int FindParent(int u){\\n            if(par[u] == u) return u;\\n            int p = FindParent(par[u]);\\n            par[u] = p;\\n            return p;\\n        }\\n        public bool IsSameComponent(int u , int v) => FindParent(u) == FindParent(v);\\n        public void Join(int u,int v){\\n            u = FindParent(u);\\n            v = FindParent(v);\\n            if(u == v) return;\\n            if(sz[u] < sz[v]) (u,v) = (v,u);\\n            par[v] = u;\\n            sz[u]+=sz[v];\\n            componentCount--;\\n        }\\n    }\\n    int kruskal(PriorityQueue<Edge,int> edges, int nodes,Edge taken = null){\\n        int res = 0;\\n        DSU dsu = new DSU(nodes);\\n        if(taken != null){\\n            dsu.Join(taken.from, taken.to);\\n            res += taken.cost;\\n        }\\n        while(dsu.componentCount > 1 && edges.Count > 0){\\n            var e = edges.Dequeue();\\n            if(dsu.IsSameComponent(e.from, e.to)) continue;\\n            dsu.Join(e.from, e.to);\\n            res += e.cost;\\n        }\\n        if(dsu.componentCount > 1) return Int32.MaxValue;\\n        return res;\\n    }\\n    public PriorityQueue<Edge,int> GetEdges(int[][] edges,int skipedIdx = -1){\\n        PriorityQueue<Edge,int> edgesPq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0;i < edges.Length;i++){\\n            if(i == skipedIdx) continue;\\n            edgesPq.Enqueue(new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]},edges[i][2]);\\n        }\\n        return edgesPq;\\n    }\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost =  kruskal(GetEdges(edges),n);\\n        List<IList<int>> res = new List<IList<int>>(){new List<int>(),new List<int>()};\\n        for(int i = 0; i < edges.Length;i++){\\n            int curCost = kruskal(GetEdges(edges,i),n);\\n            if(curCost > mstCost) res[0].Add(i);\\n            else{\\n                Edge taken = new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]};\\n                curCost = kruskal(GetEdges(edges),n,taken);\\n                if(curCost == mstCost)res[1].Add(i);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```Javascript []\\nclass UnionFind {\\n    constructor(n) {\\n        this.parents = [];\\n        for(let i = 0; i < n; i++) {\\n            this.parents.push(i);\\n        }\\n        this.count = n;\\n    }\\n\\n    find(index) {\\n        const parent = this.parents[index];\\n        if(parent === index) return index;\\n\\n        let root = this.find(parent);\\n        this.parents[index] = root;\\n        return root;\\n    }\\n\\n    union(index1, index2) {\\n        let p1 = this.find(index1);\\n        let p2 = this.find(index2);\\n\\n        if(p1 !== p2) {\\n            this.count--;\\n            this.parents[p1] = p2;\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let criticalEdges = [], psuedoCriticalEdges = [], map = new Map();\\n    \\n    edges.forEach((edge, i) => map.set(edge, i));\\n    \\n    edges.sort((a, b) => a[2] - b[2]);\\n    \\n    const buildMST = (pick, skip) => {\\n        let uf = new UnionFind(n), cost = 0;\\n        \\n        if(pick !== null) {\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(let edge of edges) {\\n            if(edge !== skip && uf.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER;\\n    };\\n    \\n    const minCost = buildMST(null, null);\\n    \\n    for(let edge of edges) {\\n        const index = map.get(edge);\\n        const costWithout = buildMST(null, edge);\\n        if(costWithout > minCost) {\\n            criticalEdges.push(index);\\n        } else {\\n            const costWith = buildMST(edge, null);\\n            if(costWith === minCost) psuedoCriticalEdges.push(index);\\n        }\\n    }\\n    \\n    return [criticalEdges, psuedoCriticalEdges];\\n};\\n```\n```Kotlin []\\nimport kotlin.math.*\\nimport kotlin.comparisons.*\\n\\nclass Solution {\\n    data class Edge(\\n        val node1: Int,\\n        val node2: Int,\\n        val weight: Int,\\n        val number: Int\\n    )\\n    \\n    class UnionFind(val size: Int) {\\n        private val content: Array<Pair<Int, Int>> = Array(size) { it to 1 }\\n        \\n        fun union(first: Int, second: Int) {\\n            val firstRoot: Pair<Int, Int> = root(first)\\n            val secondRoot: Pair<Int, Int> = root(second)\\n            \\n            if (firstRoot.first != secondRoot.first) {\\n                // probably due to old kotlin version, this should work with lamda\\n                var higher: Pair<Int, Int> = maxOf(firstRoot, secondRoot, object: Comparator<Pair<Int, Int>> {\\n                    override fun compare(firstPair: Pair<Int, Int>, secondPair: Pair<Int, Int>): Int {\\n                        return firstPair.second - secondPair.second\\n                    }\\n                })\\n                \\n                higher = Pair(higher.first, higher.second + min(firstRoot.second, secondRoot.second))\\n                \\n                content[firstRoot.first] = higher\\n                content[secondRoot.first] = higher\\n            }\\n        }\\n        \\n        fun connected(first: Int, second: Int): Boolean {\\n            return root(first).first == root(second).first\\n        }\\n        \\n        fun root(node: Int): Pair<Int, Int> {\\n            var cur = node\\n            \\n            while (content[cur].first != cur) {\\n                content[cur] = content[content[cur].first]\\n                cur = content[cur].first\\n            }\\n            \\n            return content[cur]\\n        }\\n    }\\n    \\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\\n        val critical: MutableList<Int> = mutableListOf()\\n        val pseudo: MutableList<Int> = mutableListOf()\\n        \\n        val sortedEdges = edges.asSequence()\\n            .mapIndexed { index, edge -> \\n                Edge(edge[0], edge[1], edge[2], index) \\n            }\\n            .sortedBy { it.weight }\\n            .toList()\\n        \\n        val minWeight = findMSTWeight(n, sortedEdges)\\n        for (edge in sortedEdges) {   \\n            if (findMSTWeight(n, sortedEdges, blocked = edge) != minWeight) {\\n                critical.add(edge.number)\\n            } else if (findMSTWeight(n, sortedEdges, peeked = edge) == minWeight) {\\n                pseudo.add(edge.number)\\n            }\\n        }\\n        \\n        return listOf(critical, pseudo)\\n    }\\n    \\n    fun findMSTWeight(n: Int, edges: List<Edge>, blocked: Edge? = null, peeked: Edge? = null): Int {\\n        val union = UnionFind(n)\\n        var weight = 0;\\n        \\n        peeked?.let { \\n            union.union(it.node1, it.node2)\\n            weight += it.weight\\n        }\\n        \\n        for (edge in edges) {\\n            if (blocked?.number != edge.number && !union.connected(edge.node1, edge.node2)) {\\n                union.union(edge.node1, edge.node2)\\n                weight += edge.weight\\n            }\\n        }\\n        \\n        return weight\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698025,
                "title": "o-eloge-kruskal-tarjan",
                "content": "First we have some observations:\\n\\t1. Any edge with the minimum weight must belong to at least one MST\\n\\t2. In Kruskal algorithm, after processing those edges with the same minimum weight, the Union of vertices is independent of the choice of the edges, thus the rest part of the algorithm is unaffected\\n\\t3. The edges with minimum weight form a subgraph, and the bridges of it are critical edges, while the other are pseudo-critical edges\\n\\t4. Those ignored edges in Kruskal (with two ends already connected) are not critital or pseudo-critical\\nUsing these observations we have an algorithm:\\n\\t1. Sort and group edges by weight. In each step we process one group of edges\\n\\t2. Discard the edges whose ends are already connected\\n\\t3. Run Tarjan\\'s bridge finding algorithm on each connnected part of the subgraph. Add bridges to critical and the rest to pseudo-critical\\n\\t4. Use union-find to connect the edges\\' two ends.\\nSorting takes O(ElogE) time and Tarjan takes O(V\\'+E\\') time. Since we will only process any edge once and that after one step, the number of independent vertices shrinks by at least V\\'/2 (connected parts will be reduced to one vertice), the total time cost of Tarjan is O(V+E). Thus the overall time complexity is O(ElogE).\\nIn the contest, however, I used some brute-force method instead of union-find and tarjan to save coding time, but also get accepted thanks to the weak data cases. It\\'s possible to solve V,E~10^5 with the optimal algorithm.\\n```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges=[x+[i] for i,x in enumerate(edges)]\\n        ce,pce=set(),set()\\n        while any([e[0]!=e[1] for e in edges]):\\n            temp=min([e[2] for e in edges])\\n            s=[e for e in edges if e[2]==temp]\\n            for i in range(len(s)):\\n                temp2=[x[:] for x in s]\\n                for j in range(len(s)):\\n                    if i!=j:\\n                        f,t,w,id=temp2[j]\\n                        for e in temp2:\\n                            if e[0]==t:\\n                                e[0]=f\\n                            if e[1]==t:\\n                                e[1]=f\\n                if temp2[i][0]==temp2[i][1]:\\n                    pce.add(temp2[i][3])\\n                else:\\n                    ce.add(temp2[i][3])\\n            for f,t,w,i in s:\\n                for e in edges:\\n                    if e[0]==t:\\n                        e[0]=f\\n                    if e[1]==t:\\n                        e[1]=f\\n            edges=[e for e in edges if e[2]!=temp and e[0]!=e[1]]\\n        return [list(ce),list(pce)]\\n```\\nThe code above is O(E^3) or higher, and I may update it to optimal when I have time.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges=[x+[i] for i,x in enumerate(edges)]\\n        ce,pce=set(),set()\\n        while any([e[0]!=e[1] for e in edges]):\\n            temp=min([e[2] for e in edges])\\n            s=[e for e in edges if e[2]==temp]\\n            for i in range(len(s)):\\n                temp2=[x[:] for x in s]\\n                for j in range(len(s)):\\n                    if i!=j:\\n                        f,t,w,id=temp2[j]\\n                        for e in temp2:\\n                            if e[0]==t:\\n                                e[0]=f\\n                            if e[1]==t:\\n                                e[1]=f\\n                if temp2[i][0]==temp2[i][1]:\\n                    pce.add(temp2[i][3])\\n                else:\\n                    ce.add(temp2[i][3])\\n            for f,t,w,i in s:\\n                for e in edges:\\n                    if e[0]==t:\\n                        e[0]=f\\n                    if e[1]==t:\\n                        e[1]=f\\n            edges=[e for e in edges if e[2]!=temp and e[0]!=e[1]]\\n        return [list(ce),list(pce)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478180,
                "title": "python-mst-with-kruskal-s-algorithm-standard-code-clean-concise",
                "content": "**Idea**\\n- Firstly, run the MST algorithm to find the **total weight of Minimum Spanning Tree** of the graph.\\n- To find **if one edge is critical**, **delete that edge** and **re-run the MST** algorithm and see **if the weight of the new MST increases**.\\n- To find **if a non-critical edge is speudo-critical**, **include that edge** and **re-run the MST** algorithm and see **if the weight of the new MST the same**.\\n- Since we only **interactive with edges** of the MST, so **Kruskal\\'s Algorithm is a best fit** to solve this problem.\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [1] * n\\n\\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.rank[pu] < self.rank[pv]:\\n            self.parent[pu] = self.parent[pv]\\n        elif self.rank[pu] > self.rank[pv]:\\n            self.parent[pv] = self.parent[pu]\\n        else:\\n            self.rank[pu] += 1\\n            self.parent[pv] = pu\\n        return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = [[u, v, w, i] for i, [u, v, w] in enumerate(edges)]  # Add original indices of edge to edges array\\n        edges.sort(key=lambda x: x[2])  # Sort in increasing order of weight\\n\\n        # O(E)\\n        def kruskal(n, edges, bannedIdx, includeIdx):\\n            uf = UnionFind(n)\\n            totalWeight = 0\\n            if includeIdx != -1:\\n                u, v, w, _ = edges[includeIdx]\\n                uf.union(u, v)\\n                totalWeight += w\\n                n -= 1\\n\\n            for i, (u, v, weight, _) in enumerate(edges):\\n                if i == bannedIdx: continue\\n                if uf.union(u, v):\\n                    totalWeight += weight\\n                    n -= 1\\n                if n == 1: break  # A bit optimize since we found enough n-1 edges\\n            return math.inf if n > 1 else totalWeight\\n\\n        criticalEdges = []\\n        mstWeight = kruskal(n, edges, -1, -1)\\n        for i in range(len(edges)):  # O(E * E)\\n            totalWeight = kruskal(n, edges, i, -1)\\n            if totalWeight > mstWeight:  # the mst increasing -> ith edge is critical\\n                criticalEdges.append(edges[i][3])  # add original index\\n\\n        pseudoCriticalEdges = []\\n        for i in range(len(edges)):  # O(E * E)\\n            if edges[i][3] in criticalEdges: continue  # We only care non-critical edges\\n            totalWeight = kruskal(n, edges, -1, i)\\n            if totalWeight == mstWeight:  # the mst the same -> ith edge is pseudo-critical\\n                pseudoCriticalEdges.append(edges[i][3])  # add original index\\n\\n        return [criticalEdges, pseudoCriticalEdges]\\n```\\n**Complexity**\\n- Time: `O(E * E)`, where `V <= 100` is number of vertices, `E <= min(200, V*(V-1)/2)` is number of edges.\\n- Space: `O(E + V)`",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [1] * n\\n\\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.rank[pu] < self.rank[pv]:\\n            self.parent[pu] = self.parent[pv]\\n        elif self.rank[pu] > self.rank[pv]:\\n            self.parent[pv] = self.parent[pu]\\n        else:\\n            self.rank[pu] += 1\\n            self.parent[pv] = pu\\n        return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = [[u, v, w, i] for i, [u, v, w] in enumerate(edges)]  # Add original indices of edge to edges array\\n        edges.sort(key=lambda x: x[2])  # Sort in increasing order of weight\\n\\n        # O(E)\\n        def kruskal(n, edges, bannedIdx, includeIdx):\\n            uf = UnionFind(n)\\n            totalWeight = 0\\n            if includeIdx != -1:\\n                u, v, w, _ = edges[includeIdx]\\n                uf.union(u, v)\\n                totalWeight += w\\n                n -= 1\\n\\n            for i, (u, v, weight, _) in enumerate(edges):\\n                if i == bannedIdx: continue\\n                if uf.union(u, v):\\n                    totalWeight += weight\\n                    n -= 1\\n                if n == 1: break  # A bit optimize since we found enough n-1 edges\\n            return math.inf if n > 1 else totalWeight\\n\\n        criticalEdges = []\\n        mstWeight = kruskal(n, edges, -1, -1)\\n        for i in range(len(edges)):  # O(E * E)\\n            totalWeight = kruskal(n, edges, i, -1)\\n            if totalWeight > mstWeight:  # the mst increasing -> ith edge is critical\\n                criticalEdges.append(edges[i][3])  # add original index\\n\\n        pseudoCriticalEdges = []\\n        for i in range(len(edges)):  # O(E * E)\\n            if edges[i][3] in criticalEdges: continue  # We only care non-critical edges\\n            totalWeight = kruskal(n, edges, -1, i)\\n            if totalWeight == mstWeight:  # the mst the same -> ith edge is pseudo-critical\\n                pseudoCriticalEdges.append(edges[i][3])  # add original index\\n\\n        return [criticalEdges, pseudoCriticalEdges]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735619,
                "title": "c-dijkstra-s-minimax-path-algorithm",
                "content": "**Minimum Spanning Trees and Minimax Paths**\\n\\nThe path between any two nodes in a minimum spanning tree is a **minimax path**. That is, a path that minimizes the maximum weight of any of its edges (https://en.wikipedia.org/wiki/Widest_path_problem). \\n\\nHere is a proof:\\nhttps://stackoverflow.com/questions/43012559/how-to-prove-there-always-exists-a-minimax-path-completely-on-the-mst\\n\\nIt follows from similar logic to that used in the proof that:\\n* `e = (u, v, w)` is a *critical* edge if-and-only-if the cost of the minimax path from `u` to `v` that doesn\\'t use `e` is *greater than* `w`.\\n* `e = (u, v, w)` is a *pseudo-critical* edge if-and-only-if the cost of the minimax path from `u` to `v` that doesn\\'t use `e` is *equal to* `w`.\\n\\n**Algorithm**\\n\\nFor every edge `e = (u, v, w)`, we remove `e` from the graph and find the cost of the minimax path from `u` to `v`.\\n* If the cost if greater than `w`, then `e` is a critical edge.\\n* If the cost is equal to `w` then `e` is a pseudo-critical edge.\\n\\nYou can find minimax paths with a trivial modification to Dijkstra\\'s algorithm (and most other shortest-path algorithms).\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<pair<int, int>>> g(n);\\n        for (auto &e : edges) {\\n            int u = e[0], v = e[1], w = e[2];\\n            g[u].emplace_back(v, w);\\n            g[v].emplace_back(u, w);\\n        }\\n        vector<vector<int>> ans(2);\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto &e = edges[i];\\n            int u = e[0], v = e[1], w = e[2];\\n            int m = minimax(g, u, v);\\n            if (w < m) {\\n                ans[0].push_back(i);\\n            } else if (w == m) {\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    int minimax(vector<vector<pair<int, int>>> &g, int src, int dst) {\\n        vector<int> dist(g.size(), 1e9);\\n        priority_queue<pair<int, int>> pq;\\n        pq.emplace(dist[src] = 0, src);\\n        while (!pq.empty()) {\\n            auto [pri, u] = pq.top(); pq.pop();\\n            if (-pri > dist[u]) {\\n                continue;\\n            }\\n            for (auto &[v, w] : g[u]) {\\n                if (u == src && v == dst) {\\n                    continue;\\n                }\\n                if (dist[v] > max(dist[u], w)) {\\n                    dist[v] = max(dist[u], w);\\n                    pq.emplace(-dist[v], v);\\n                }\\n            }\\n        }\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<pair<int, int>>> g(n);\\n        for (auto &e : edges) {\\n            int u = e[0], v = e[1], w = e[2];\\n            g[u].emplace_back(v, w);\\n            g[v].emplace_back(u, w);\\n        }\\n        vector<vector<int>> ans(2);\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto &e = edges[i];\\n            int u = e[0], v = e[1], w = e[2];\\n            int m = minimax(g, u, v);\\n            if (w < m) {\\n                ans[0].push_back(i);\\n            } else if (w == m) {\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    int minimax(vector<vector<pair<int, int>>> &g, int src, int dst) {\\n        vector<int> dist(g.size(), 1e9);\\n        priority_queue<pair<int, int>> pq;\\n        pq.emplace(dist[src] = 0, src);\\n        while (!pq.empty()) {\\n            auto [pri, u] = pq.top(); pq.pop();\\n            if (-pri > dist[u]) {\\n                continue;\\n            }\\n            for (auto &[v, w] : g[u]) {\\n                if (u == src && v == dst) {\\n                    continue;\\n                }\\n                if (dist[v] > max(dist[u], w)) {\\n                    dist[v] = max(dist[u], w);\\n                    pq.emplace(-dist[v], v);\\n                }\\n            }\\n        }\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697912,
                "title": "python-unionfind-kruskal-check-double",
                "content": "Imagine getting all MSTs. That is very huge.\\nSo change the problem. If we have to use or don\\'t use a edge, can we make a MST?\\n\\nIf we do not use a edge and MST value is incresed, that edge is critical edge.\\nBecause we cannot create good MST without this edge. \\nIt means all good MST use this edge.\\nSo this edge is critical edge.\\n\\nIf we always use a edge and MST value is not changed, that edge is presudo-criticla edge. \\nBecause we can create good MST including this edge. \\nIt means at least one MST use this edge. So this edge is presudo-critical edge.\\n\\nThe time complextiy is `O(ElogE + E^2 + E^2)`.\\nUnion-Find time complexity is almost `O(N)`.\\n\\n```python\\nfrom typing import Dict, List\\nfrom collections import deque, defaultdict, OrderedDict, Counter\\nfrom heapq import heapify, heappush, heappop\\nfrom bisect import bisect_left, bisect_right\\nfrom functools import lru_cache\\nfrom itertools import combinations, permutations, groupby\\nfrom math import gcd\\nimport re\\nimport sys\\ninf = float(\\'inf\\')\\nsys.setrecursionlimit(10**9)\\nMOD = 10**9+7\\n\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n\\n    def find(self, a):\\n        if self.par[a] == a:\\n            return a\\n        self.par[a] = self.find(self.par[a])\\n        return self.par[a]\\n\\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        if a > b:\\n            a, b = b, a\\n        if a == b:\\n            return False\\n        self.par[b] = a\\n        return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # save the edge id\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n\\n        # Do not use this edge\\n        def find_mst_not_use_this_edge(not_use):\\n            unionFind = UnionFind(n)\\n            res = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == not_use:\\n                    continue\\n                if unionFind.union(u, v) == True:\\n                    res += w\\n\\n            return res if all(unionFind.find(i) == 0 for i in range(n)) else inf\\n\\n        # Need to use this edge\\n        def find_mst_need_use_this_edge(need_use):\\n            # use this edge first\\n            unionFind = UnionFind(n)\\n            res = edges[need_use][2]\\n            unionFind.union(edges[need_use][0], edges[need_use][1])\\n            # And then create mst\\n            for i, (u, v, w, _) in enumerate(edges):\\n\\t\\t\\t\\t# alread use this edge\\n                if i == need_use:\\n                    continue\\n                if unionFind.union(u, v) == True:\\n                    res += w\\n\\n            return res if all(unionFind.find(i) == 0 for i in range(n)) else inf\\n        # Normal MST value\\n        base = find_mst_not_use_this_edge(-1)\\n        cri = []\\n        p_cri = []\\n        for i in range(len(edges)):\\n            v = find_mst_not_use_this_edge(i)\\n            # If MST value is increased, it means all MST use this edge.\\n            if v != base:\\n                cri.append(edges[i][3])\\n            else:\\n                v = find_mst_need_use_this_edge(i)\\n                # If MST value is not changed, it means at least one MST which use this edge exists\\n                if v == base:\\n                    p_cri.append(edges[i][3])\\n\\n        return [cri, p_cri]\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom typing import Dict, List\\nfrom collections import deque, defaultdict, OrderedDict, Counter\\nfrom heapq import heapify, heappush, heappop\\nfrom bisect import bisect_left, bisect_right\\nfrom functools import lru_cache\\nfrom itertools import combinations, permutations, groupby\\nfrom math import gcd\\nimport re\\nimport sys\\ninf = float(\\'inf\\')\\nsys.setrecursionlimit(10**9)\\nMOD = 10**9+7\\n\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n\\n    def find(self, a):\\n        if self.par[a] == a:\\n            return a\\n        self.par[a] = self.find(self.par[a])\\n        return self.par[a]\\n\\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        if a > b:\\n            a, b = b, a\\n        if a == b:\\n            return False\\n        self.par[b] = a\\n        return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # save the edge id\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n\\n        # Do not use this edge\\n        def find_mst_not_use_this_edge(not_use):\\n            unionFind = UnionFind(n)\\n            res = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == not_use:\\n                    continue\\n                if unionFind.union(u, v) == True:\\n                    res += w\\n\\n            return res if all(unionFind.find(i) == 0 for i in range(n)) else inf\\n\\n        # Need to use this edge\\n        def find_mst_need_use_this_edge(need_use):\\n            # use this edge first\\n            unionFind = UnionFind(n)\\n            res = edges[need_use][2]\\n            unionFind.union(edges[need_use][0], edges[need_use][1])\\n            # And then create mst\\n            for i, (u, v, w, _) in enumerate(edges):\\n\\t\\t\\t\\t# alread use this edge\\n                if i == need_use:\\n                    continue\\n                if unionFind.union(u, v) == True:\\n                    res += w\\n\\n            return res if all(unionFind.find(i) == 0 for i in range(n)) else inf\\n        # Normal MST value\\n        base = find_mst_not_use_this_edge(-1)\\n        cri = []\\n        p_cri = []\\n        for i in range(len(edges)):\\n            v = find_mst_not_use_this_edge(i)\\n            # If MST value is increased, it means all MST use this edge.\\n            if v != base:\\n                cri.append(edges[i][3])\\n            else:\\n                v = find_mst_need_use_this_edge(i)\\n                # If MST value is not changed, it means at least one MST which use this edge exists\\n                if v == base:\\n                    p_cri.append(edges[i][3])\\n\\n        return [cri, p_cri]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929154,
                "title": "100-o-eloge-kruskal-s-algorithm-and-dfs",
                "content": "# Problem Understanding\\n\\nIn the problem \"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,\" we are presented with a weighted undirected connected graph consisting of `n` vertices, numbered from 0 to `n - 1`. The graph is described by an array `edges`, where each element `edges[i] = [ai, bi, weighti]` represents a bidirectional edge with a weight between nodes `ai` and `bi`. The primary objective is to identify and categorize edges within the minimum spanning tree (MST) of the graph.\\n\\n**The Task**\\n\\nOur task is twofold:\\n\\n1. **Critical Edges**: We need to identify the critical edges within the MST. A critical edge is an edge present in the MST such that removing it from the graph would lead to an increase in the overall weight of the MST.\\n\\n2. **Pseudo-Critical Edges**: Additionally, we aim to pinpoint pseudo-critical edges. A pseudo-critical edge is an edge that may appear in some of the MSTs but not necessarily in all of them.\\n\\nIn essence, our goal is to dissect the graph\\'s MST and classify edges into these two categories: critical and pseudo-critical. By addressing this problem, we gain insights into the intricacies of graph theory and optimization, as well as the significance of edge classifications within minimum spanning trees. This exercise enhances our understanding of these fundamental graph concepts and their application to real-world scenarios.\\n\\n---\\n\\n# Live Coding:\\nhttps://youtu.be/wkCHl9tpoyQ\\n\\n# Approach: Kruskal\\'s Algorithm and DFS\\n\\nWe\\'re tasked with finding both critical and pseudo-critical edges in a Minimum Spanning Tree (MST) of a given graph. To accomplish this, we employ a blend of two well-known algorithms:\\n- **Kruskal\\'s Algorithm** to determine the MST.\\n- **Depth-First Search (DFS)** to traverse and inspect the MST for edge classifications.\\n\\n## Key Components\\n\\n1. **Union-Find Structure**: A classic data structure to manage sets or components. It facilitates checking whether two nodes are in the same component and joining two components.\\n2. **Adjacency List**: A way of representing our graph, making it easier to traverse and inspect its edges and nodes.\\n\\n## Approach Steps\\n\\n### 1. Set the Stage:\\n   - Introduce the **Union-Find** data structure to help us decide if an edge can be safely added to the MST without forming a cycle.\\n   - Create an **Adjacency List** to represent our graph\\'s structure and relationships.\\n\\n### 2. Construct the MST:\\n   - Begin by arranging the edges based on their weights, ensuring we always consider the smallest edge first.\\n   - Proceed through these edges, and if adding an edge doesn\\'t form a cycle (verified using Union-Find), incorporate it into the MST.\\n\\n### 3. Traverse and Classify:\\n   - Use **DFS** to explore the MST. \\n   - As we traverse, we record the depth or \"level\" of each node.\\n   - Edges are then classified based on their significance to the structure and weight of the MST:\\n     - **Critical Edges**: Removing them results in a more massive MST.\\n     - **Pseudo-Critical Edges**: Edges that can be part of some MSTs but aren\\'t mandatory for the minimum weight.\\n\\n### 4. Conclude:\\n   - Once all edges have been inspected and classified, present them in two separate lists: one for critical edges and another for pseudo-critical ones.\\n\\n## Complexity Insights\\n\\n- **Time Complexity**: Two aspects majorly influence our solution\\'s speed:\\n  - **Sorting the edges**, costing $$O(E \\\\log E)$$ where $$E$$ is the number of edges.\\n  - **Union-Find operations**, taking $$O(E \\\\alpha(V))$$, where $$\\\\alpha(V)$$ is the inverse Ackermann function. This function grows very slowly, making this part almost linear in terms of time complexity.\\n  In essence, our algorithm roughly runs in $$O(E \\\\log E)$$.\\n\\n- **Space Complexity**: Our primary memory consumption sources are:\\n  - Storing the graph\\'s edges and nodes.\\n  - The Union-Find and adjacency list structures.\\n  As a result, our space needs are roughly $$O(E + V)$$, where $$E$$ is the number of edges, and $$V$$ is the number of vertices.\\n\\n---\\n\\nIn a nutshell, our approach combines classical graph algorithms and data structures to effectively classify edges in an MST, offering valuable insights into the graph\\'s structure and relationships.\\n\\n---\\n\\n# Performance:\\n\\n| Language  | Runtime   | Runtime Beats (%) | Memory   | Memory Beats (%) |\\n|-----------|-----------|-------------------|----------|------------------|\\n| Python3   | 72 ms     | 100%              | 16.7 MB  | 40.66%           |\\n\\n\\n\\n---\\n\\n# Code\\n``` Python []\\n# Step 1: Union-Find Data Structure\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        rootX, rootY = self.find(x), self.find(y)\\n        if rootX == rootY:\\n            return False\\n        if self.rank[rootX] > self.rank[rootY]:\\n            self.parent[rootY] = rootX\\n        else:\\n            self.parent[rootX] = rootY\\n            if self.rank[rootX] == self.rank[rootY]:\\n                self.rank[rootY] += 1\\n        return True\\n\\n# Step 2: Main Solution\\nclass Solution:\\n    # Main Method\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: [[int]]) -> [[int]]:\\n        \\n        # Step 3: Depth-First Search (DFS) Helper Function\\n        def dfs(node, depth, ancestor):\\n            levels[node] = depth\\n            for neighbor, edge_index in adjacency_list[node]:\\n                if neighbor == ancestor:\\n                    continue\\n                if levels[neighbor] == -1:\\n                    levels[node] = min(levels[node], dfs(neighbor, depth + 1, node))\\n                else:\\n                    levels[node] = min(levels[node], levels[neighbor])\\n                if levels[neighbor] >= depth + 1 and edge_index not in pseudo_critical:\\n                    critical.add(edge_index)\\n            return levels[node]\\n\\n        # Step 4: Initialize Sets\\n        critical, pseudo_critical = set(), set()\\n\\n        # Step 5: Grouping Edges By Weight\\n        weight_to_edges = {w: [] for w in {edge[2] for edge in edges}}\\n        for i, (u, v, w) in enumerate(edges):\\n            weight_to_edges[w].append([u, v, i])\\n        \\n        # Step 6: Using Union-Find\\n        union_find = UnionFind(n)\\n        \\n        # Step 7: Iterating Through Weights\\n        for weight in sorted(weight_to_edges):\\n            edge_lookup = defaultdict(set)\\n            \\n            for u, v, edge_index in weight_to_edges[weight]:\\n                rootU, rootV = union_find.find(u), union_find.find(v)\\n                \\n                if rootU != rootV:\\n                    union_pair = tuple(sorted((rootU, rootV)))\\n                    edge_lookup[union_pair].add(edge_index)\\n            \\n            mst_edges, adjacency_list = [], defaultdict(list)\\n            \\n            for (rootU, rootV), edge_indexes in edge_lookup.items():\\n                if len(edge_indexes) > 1:\\n                    pseudo_critical.update(edge_indexes)\\n                \\n                edge_idx = edge_indexes.pop()\\n                adjacency_list[rootU].append((rootV, edge_idx))\\n                adjacency_list[rootV].append((rootU, edge_idx))\\n                mst_edges.append((rootU, rootV, edge_idx))\\n                union_find.union(rootU, rootV)\\n            \\n            levels = [-1] * n\\n            \\n            for u, v, _ in mst_edges:\\n                if levels[u] == -1:\\n                    dfs(u, 0, -1)\\n            \\n            for _, _, edge_index in mst_edges:\\n                if edge_index not in critical:\\n                    pseudo_critical.add(edge_index)\\n\\n        # Step 8: Return Result\\n        return [list(critical), list(pseudo_critical)]\\n```\\n\\nThis problem beautifully showcases the application of Kruskal\\'s algorithm and depth-first search (DFS) to identify critical and pseudo-critical edges in a minimum spanning tree. Solving this problem provides a deep understanding of these graph algorithms and their practical use in real-world scenarios. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Graph",
                    "Minimum Spanning Tree"
                ],
                "code": "``` Python []\\n# Step 1: Union-Find Data Structure\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        rootX, rootY = self.find(x), self.find(y)\\n        if rootX == rootY:\\n            return False\\n        if self.rank[rootX] > self.rank[rootY]:\\n            self.parent[rootY] = rootX\\n        else:\\n            self.parent[rootX] = rootY\\n            if self.rank[rootX] == self.rank[rootY]:\\n                self.rank[rootY] += 1\\n        return True\\n\\n# Step 2: Main Solution\\nclass Solution:\\n    # Main Method\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: [[int]]) -> [[int]]:\\n        \\n        # Step 3: Depth-First Search (DFS) Helper Function\\n        def dfs(node, depth, ancestor):\\n            levels[node] = depth\\n            for neighbor, edge_index in adjacency_list[node]:\\n                if neighbor == ancestor:\\n                    continue\\n                if levels[neighbor] == -1:\\n                    levels[node] = min(levels[node], dfs(neighbor, depth + 1, node))\\n                else:\\n                    levels[node] = min(levels[node], levels[neighbor])\\n                if levels[neighbor] >= depth + 1 and edge_index not in pseudo_critical:\\n                    critical.add(edge_index)\\n            return levels[node]\\n\\n        # Step 4: Initialize Sets\\n        critical, pseudo_critical = set(), set()\\n\\n        # Step 5: Grouping Edges By Weight\\n        weight_to_edges = {w: [] for w in {edge[2] for edge in edges}}\\n        for i, (u, v, w) in enumerate(edges):\\n            weight_to_edges[w].append([u, v, i])\\n        \\n        # Step 6: Using Union-Find\\n        union_find = UnionFind(n)\\n        \\n        # Step 7: Iterating Through Weights\\n        for weight in sorted(weight_to_edges):\\n            edge_lookup = defaultdict(set)\\n            \\n            for u, v, edge_index in weight_to_edges[weight]:\\n                rootU, rootV = union_find.find(u), union_find.find(v)\\n                \\n                if rootU != rootV:\\n                    union_pair = tuple(sorted((rootU, rootV)))\\n                    edge_lookup[union_pair].add(edge_index)\\n            \\n            mst_edges, adjacency_list = [], defaultdict(list)\\n            \\n            for (rootU, rootV), edge_indexes in edge_lookup.items():\\n                if len(edge_indexes) > 1:\\n                    pseudo_critical.update(edge_indexes)\\n                \\n                edge_idx = edge_indexes.pop()\\n                adjacency_list[rootU].append((rootV, edge_idx))\\n                adjacency_list[rootV].append((rootU, edge_idx))\\n                mst_edges.append((rootU, rootV, edge_idx))\\n                union_find.union(rootU, rootV)\\n            \\n            levels = [-1] * n\\n            \\n            for u, v, _ in mst_edges:\\n                if levels[u] == -1:\\n                    dfs(u, 0, -1)\\n            \\n            for _, _, edge_index in mst_edges:\\n                if edge_index not in critical:\\n                    pseudo_critical.add(edge_index)\\n\\n        # Step 8: Return Result\\n        return [list(critical), list(pseudo_critical)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929349,
                "title": "detailed-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/u1-Xuvl2RoA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass UnionFind {\\n    private int[] parent;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    public int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    public void union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            edge = Arrays.copyOf(edge, edge.length + 1);\\n            edge[3] = i;\\n            edges[i] = edge;\\n        }\\n        \\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.add(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.add(edges[i][3]);\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(critical);\\n        result.add(pseudoCritical);\\n        return result;\\n    }\\n\\n    private int findMST(int n, int[][] edges, int block, int e) {\\n        UnionFind uf = new UnionFind(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.union(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.union(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return Integer.MAX_VALUE;\\n        }\\n\\n        return weight;\\n    }\\n}\\n```\\n\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent;\\n\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    void unionSets(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical;\\n        vector<int> pseudoCritical;\\n        \\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.push_back(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.push_back(edges[i][3]);\\n        }\\n\\n        vector<vector<int>> result;\\n        result.push_back(critical);\\n        result.push_back(pseudoCritical);\\n        return result;\\n    }\\n\\n    int findMST(int n, vector<vector<int>>& edges, int block, int e) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.unionSets(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.unionSets(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }\\n\\n        return weight;\\n    }\\n};\\n```\\n\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find_parent(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union_sets(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find_MST(graph, block, e):\\n            uf = UnionFind(n)\\n            weight = 0\\n            \\n            if e != -1:\\n                weight += edges[e][2]\\n                uf.union_sets(edges[e][0], edges[e][1])\\n            \\n            for i in range(len(edges)):\\n                if i == block:\\n                    continue\\n                \\n                if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                    continue\\n                \\n                uf.union_sets(edges[i][0], edges[i][1])\\n                weight += edges[i][2]\\n            \\n            for i in range(n):\\n                if uf.find_parent(i) != uf.find_parent(0):\\n                    return float(\\'inf\\')\\n            \\n            return weight\\n        \\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i, edge in enumerate(edges):\\n            edge.append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        mst_weight = find_MST(edges, -1, -1)\\n        \\n        for i, edge in enumerate(edges):\\n            if mst_weight < find_MST(edges, i, -1):\\n                critical.append(edge[3])\\n            elif mst_weight == find_MST(edges, -1, i):\\n                pseudo_critical.append(edge[3])\\n        \\n        return [critical, pseudo_critical]\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\n    private int[] parent;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    public int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    public void union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            edge = Arrays.copyOf(edge, edge.length + 1);\\n            edge[3] = i;\\n            edges[i] = edge;\\n        }\\n        \\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.add(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.add(edges[i][3]);\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(critical);\\n        result.add(pseudoCritical);\\n        return result;\\n    }\\n\\n    private int findMST(int n, int[][] edges, int block, int e) {\\n        UnionFind uf = new UnionFind(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.union(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.union(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return Integer.MAX_VALUE;\\n        }\\n\\n        return weight;\\n    }\\n}\\n```\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent;\\n\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n\\n    int findParent(int p) {\\n        return parent[p] == p ? p : (parent[p] = findParent(parent[p]));\\n    }\\n\\n    void unionSets(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical;\\n        vector<int> pseudoCritical;\\n        \\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n\\n        int mstwt = findMST(n, edges, -1, -1);\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (mstwt < findMST(n, edges, i, -1))\\n                critical.push_back(edges[i][3]);\\n            else if (mstwt == findMST(n, edges, -1, i))\\n                pseudoCritical.push_back(edges[i][3]);\\n        }\\n\\n        vector<vector<int>> result;\\n        result.push_back(critical);\\n        result.push_back(pseudoCritical);\\n        return result;\\n    }\\n\\n    int findMST(int n, vector<vector<int>>& edges, int block, int e) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n\\n        if (e != -1) {\\n            weight += edges[e][2];\\n            uf.unionSets(edges[e][0], edges[e][1]);\\n        }\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block)\\n                continue;\\n\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))\\n                continue;\\n\\n            uf.unionSets(edges[i][0], edges[i][1]);\\n            weight += edges[i][2];\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }\\n\\n        return weight;\\n    }\\n};\\n```\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find_parent(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union_sets(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find_MST(graph, block, e):\\n            uf = UnionFind(n)\\n            weight = 0\\n            \\n            if e != -1:\\n                weight += edges[e][2]\\n                uf.union_sets(edges[e][0], edges[e][1])\\n            \\n            for i in range(len(edges)):\\n                if i == block:\\n                    continue\\n                \\n                if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                    continue\\n                \\n                uf.union_sets(edges[i][0], edges[i][1])\\n                weight += edges[i][2]\\n            \\n            for i in range(n):\\n                if uf.find_parent(i) != uf.find_parent(0):\\n                    return float(\\'inf\\')\\n            \\n            return weight\\n        \\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i, edge in enumerate(edges):\\n            edge.append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        mst_weight = find_MST(edges, -1, -1)\\n        \\n        for i, edge in enumerate(edges):\\n            if mst_weight < find_MST(edges, i, -1):\\n                critical.append(edge[3])\\n            elif mst_weight == find_MST(edges, -1, i):\\n                pseudo_critical.append(edge[3])\\n        \\n        return [critical, pseudo_critical]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930993,
                "title": "c-dsu-good-use-of-concepts-day-19",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    void disjoint(int size){\\n        parent.resize(size+1);\\n        for(int i=0;i<=size;i++)\\n        parent[i]=(i);\\n    }\\n    int find(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    void merge(int u,int v){\\n        int ua = find(u);\\n        int ub = find(v);\\n        parent[ua] = ub;\\n    }\\n    int help1(vector<vector<int>>& e,int j,int n){\\n        disjoint(n+1);\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<e.size();i++){\\n            if(i==j)continue;\\n            v.push_back({e[i][2],{e[i][0],e[i][1]}});\\n        }\\n        sort(v.begin(),v.end());\\n        int mst_weight = 0;\\n        int edges = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto x = v[i];\\n            int u = find(x.second.first);\\n            int v = find(x.second.second);\\n            if(u!=v){\\n                edges++;\\n                mst_weight += x.first;\\n                merge(u,v);\\n            } \\n        }\\n        if(edges!=n-1)return INT_MAX;\\n        return mst_weight;\\n    }\\n    int help2(vector<vector<int>>& e,int j,int n){\\n        disjoint(n+1);\\n        int mst_weight = e[j][2];\\n        merge(e[j][1],e[j][0]);\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<e.size();i++){\\n            if(i==j)continue;\\n            v.push_back({e[i][2],{e[i][0],e[i][1]}});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            auto x = v[i];\\n            int u = find(x.second.first);\\n            int v = find(x.second.second);\\n            if(u!=v){\\n                mst_weight += x.first;\\n                merge(u,v);\\n            } \\n        }\\n        return mst_weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& e) {\\n        disjoint(n+1);\\n        int mst_weight = help1(e,-1,n);\\n        vector<vector<int>>ans;\\n        vector<int>v1,v2;\\n        for(int i=0;i<e.size();i++){\\n            int new_weight1 = help1(e,i,n);\\n            int new_weight2 = help2(e,i,n);\\n            if(new_weight1 > mst_weight){\\n                v1.push_back(i);\\n            }\\n           else if(new_weight2 == mst_weight){\\n                v2.push_back(i);\\n            }\\n        }\\n        ans.push_back(v1);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/45352c8f-4604-4f6e-bda0-eb904980ea7a_1692444615.6198385.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    void disjoint(int size){\\n        parent.resize(size+1);\\n        for(int i=0;i<=size;i++)\\n        parent[i]=(i);\\n    }\\n    int find(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    void merge(int u,int v){\\n        int ua = find(u);\\n        int ub = find(v);\\n        parent[ua] = ub;\\n    }\\n    int help1(vector<vector<int>>& e,int j,int n){\\n        disjoint(n+1);\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<e.size();i++){\\n            if(i==j)continue;\\n            v.push_back({e[i][2],{e[i][0],e[i][1]}});\\n        }\\n        sort(v.begin(),v.end());\\n        int mst_weight = 0;\\n        int edges = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto x = v[i];\\n            int u = find(x.second.first);\\n            int v = find(x.second.second);\\n            if(u!=v){\\n                edges++;\\n                mst_weight += x.first;\\n                merge(u,v);\\n            } \\n        }\\n        if(edges!=n-1)return INT_MAX;\\n        return mst_weight;\\n    }\\n    int help2(vector<vector<int>>& e,int j,int n){\\n        disjoint(n+1);\\n        int mst_weight = e[j][2];\\n        merge(e[j][1],e[j][0]);\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<e.size();i++){\\n            if(i==j)continue;\\n            v.push_back({e[i][2],{e[i][0],e[i][1]}});\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            auto x = v[i];\\n            int u = find(x.second.first);\\n            int v = find(x.second.second);\\n            if(u!=v){\\n                mst_weight += x.first;\\n                merge(u,v);\\n            } \\n        }\\n        return mst_weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& e) {\\n        disjoint(n+1);\\n        int mst_weight = help1(e,-1,n);\\n        vector<vector<int>>ans;\\n        vector<int>v1,v2;\\n        for(int i=0;i<e.size();i++){\\n            int new_weight1 = help1(e,i,n);\\n            int new_weight2 = help2(e,i,n);\\n            if(new_weight1 > mst_weight){\\n                v1.push_back(i);\\n            }\\n           else if(new_weight2 == mst_weight){\\n                v2.push_back(i);\\n            }\\n        }\\n        ans.push_back(v1);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411039,
                "title": "c-kruskal-algorithm-explained",
                "content": "```\\n1. Assign a value to each edge. That is what going to be printed. \\n2. To form a MST using Kruskals, sort edges according to their weights \\n3. Perform Kruskals. To detect Cycle use Union find.\\n4. If it dosen\\'t form a cycle include that edge. Since they are sorted, it is assured that we get the MST \\n5. Check for critical edges by removing each edge and finding the MST. If the new MST is greater than original MST it means that removing this edge increases the MST. Hence this is a critical edge \\n6. For checking pseudo critical edges, include this edge in MST formation. If new MST == original MST then this is a pseudo critcal edge. \\n\\n\\nclass UnionFind {\\npublic: \\n    vector<int> parent; \\n    UnionFind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i; \\n    }\\n    \\n    int findParent(int p) {\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]); \\n    }\\n    \\n    void Union(int u , int v) {\\n        int pu = findParent(u) , pv = findParent(v); \\n        parent[pu] = pv;\\n    }    \\n};\\n\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>&a , vector<int>&b) {\\n        return a[2] < b[2]; \\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical ,  pscritical ;\\n        //1\\n        for(int i=0;i<edges.size();i++)\\n            edges[i].push_back(i); \\n        \\n        //2 \\n        sort(edges.begin() , edges.end() , cmp) ;\\n        \\n        int mstwt = findMST(n,edges,-1,-1); //3\\n        for(int i=0;i<edges.size();i++){\\n            if(mstwt< findMST(n,edges,i,-1)) //5\\n                critical.push_back(edges[i][3]); \\n            else if(mstwt == findMST(n,edges,-1,i))  //6\\n                pscritical.push_back(edges[i][3]);\\n        }\\n        return {critical , pscritical};         \\n    }\\n    \\nprivate:\\n    int findMST(int &n ,  vector<vector<int>>& edges , int block , int e) {\\n        UnionFind uf(n); \\n        int weight = 0 ;\\n        if(e != -1) {\\n            weight += edges[e][2]; \\n            uf.Union(edges[e][0] , edges[e][1]); \\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(i == block) \\n                continue; \\n            if(uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) //4\\n                continue; \\n            uf.Union(edges[i][0] , edges[i][1]); \\n            weight += edges[i][2]; \\n        }\\n        \\n        //Check if all vertices are included then only it is MST. \\n        for(int i=0;i<n;i++){\\n            if(uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }    \\n        \\n        return weight; \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\n1. Assign a value to each edge. That is what going to be printed. \\n2. To form a MST using Kruskals, sort edges according to their weights \\n3. Perform Kruskals. To detect Cycle use Union find.\\n4. If it dosen\\'t form a cycle include that edge. Since they are sorted, it is assured that we get the MST \\n5. Check for critical edges by removing each edge and finding the MST. If the new MST is greater than original MST it means that removing this edge increases the MST. Hence this is a critical edge \\n6. For checking pseudo critical edges, include this edge in MST formation. If new MST == original MST then this is a pseudo critcal edge. \\n\\n\\nclass UnionFind {\\npublic: \\n    vector<int> parent; \\n    UnionFind(int n){\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i; \\n    }\\n    \\n    int findParent(int p) {\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]); \\n    }\\n    \\n    void Union(int u , int v) {\\n        int pu = findParent(u) , pv = findParent(v); \\n        parent[pu] = pv;\\n    }    \\n};\\n\\nclass Solution {\\npublic:    \\n    static bool cmp(vector<int>&a , vector<int>&b) {\\n        return a[2] < b[2]; \\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical ,  pscritical ;\\n        //1\\n        for(int i=0;i<edges.size();i++)\\n            edges[i].push_back(i); \\n        \\n        //2 \\n        sort(edges.begin() , edges.end() , cmp) ;\\n        \\n        int mstwt = findMST(n,edges,-1,-1); //3\\n        for(int i=0;i<edges.size();i++){\\n            if(mstwt< findMST(n,edges,i,-1)) //5\\n                critical.push_back(edges[i][3]); \\n            else if(mstwt == findMST(n,edges,-1,i))  //6\\n                pscritical.push_back(edges[i][3]);\\n        }\\n        return {critical , pscritical};         \\n    }\\n    \\nprivate:\\n    int findMST(int &n ,  vector<vector<int>>& edges , int block , int e) {\\n        UnionFind uf(n); \\n        int weight = 0 ;\\n        if(e != -1) {\\n            weight += edges[e][2]; \\n            uf.Union(edges[e][0] , edges[e][1]); \\n        }\\n        \\n        for(int i=0;i<edges.size();i++){\\n            if(i == block) \\n                continue; \\n            if(uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) //4\\n                continue; \\n            uf.Union(edges[i][0] , edges[i][1]); \\n            weight += edges[i][2]; \\n        }\\n        \\n        //Check if all vertices are included then only it is MST. \\n        for(int i=0;i<n;i++){\\n            if(uf.findParent(i) != uf.findParent(0))\\n                return INT_MAX;\\n        }    \\n        \\n        return weight; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698182,
                "title": "c-dijkstra-prim-s-algorithm-o-ev-2",
                "content": "```\\nstruct Edge{\\n    int idx, to, cost;\\n    Edge(int idx, int to, int cost) : idx(idx), to(to), cost(cost) {};\\n\\t// Operator is inverted to make priority_queue a min heap\\n    bool operator < (const Edge& other) const { return cost > other.cost; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<Edge>> adj(n);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].emplace_back(i, edges[i][1], edges[i][2]);\\n            adj[edges[i][1]].emplace_back(i, edges[i][0], edges[i][2]);\\n        }\\n        int mn = prim(adj, -1, 0, -1); // Cost of MST on original graph\\n        vector<vector<int>> ans(2);\\n        for(int i = 0; i < edges.size(); i++){\\n\\t\\t\\t// Does force-taking this edge increase the MST cost? -> neither critical nor pseudo-critical\\n            if(prim(adj, i, edges[i][0], -1) > mn) continue;\\n\\t\\t\\t// Does ignoring this edge increase the MST cost? -> critical if true, pseudo-critical if false\\n            if(prim(adj, -1, 0, i) > mn) ans[0].push_back(i);\\n            else ans[1].push_back(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int prim(vector<vector<Edge>>& adj, int startEdgeIdx, int startEdgeFrom, int ignoreEdgeIdx){\\n        int cnt = 0, total = 0;\\n        vector<bool> visited(adj.size());\\n        priority_queue<Edge> pq;\\n        pq.emplace(-1, startEdgeFrom, 0);\\n        while(pq.size()){\\n            auto [idx, to, cost] = pq.top();\\n            pq.pop();\\n            if(visited[to]) continue;\\n            visited[to] = true;\\n            cnt++;\\n            total += cost;\\n            if(cnt == adj.size()) break;\\n            for(auto edge : adj[to]){\\n                if(visited[edge.to] || edge.idx == ignoreEdgeIdx) continue;\\n\\t\\t\\t\\t// If it\\'s the start edge we assigned, we take the edge upfront and give it the highest priority by making it free\\n                if(edge.idx == startEdgeIdx){\\n                    total += edge.cost;\\n                    edge.cost = 0;\\n                }\\n                pq.push(edge);\\n            }\\n        }\\n        return cnt == adj.size() ? total : INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Edge{\\n    int idx, to, cost;\\n    Edge(int idx, int to, int cost) : idx(idx), to(to), cost(cost) {};\\n\\t// Operator is inverted to make priority_queue a min heap\\n    bool operator < (const Edge& other) const { return cost > other.cost; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<Edge>> adj(n);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].emplace_back(i, edges[i][1], edges[i][2]);\\n            adj[edges[i][1]].emplace_back(i, edges[i][0], edges[i][2]);\\n        }\\n        int mn = prim(adj, -1, 0, -1); // Cost of MST on original graph\\n        vector<vector<int>> ans(2);\\n        for(int i = 0; i < edges.size(); i++){\\n\\t\\t\\t// Does force-taking this edge increase the MST cost? -> neither critical nor pseudo-critical\\n            if(prim(adj, i, edges[i][0], -1) > mn) continue;\\n\\t\\t\\t// Does ignoring this edge increase the MST cost? -> critical if true, pseudo-critical if false\\n            if(prim(adj, -1, 0, i) > mn) ans[0].push_back(i);\\n            else ans[1].push_back(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int prim(vector<vector<Edge>>& adj, int startEdgeIdx, int startEdgeFrom, int ignoreEdgeIdx){\\n        int cnt = 0, total = 0;\\n        vector<bool> visited(adj.size());\\n        priority_queue<Edge> pq;\\n        pq.emplace(-1, startEdgeFrom, 0);\\n        while(pq.size()){\\n            auto [idx, to, cost] = pq.top();\\n            pq.pop();\\n            if(visited[to]) continue;\\n            visited[to] = true;\\n            cnt++;\\n            total += cost;\\n            if(cnt == adj.size()) break;\\n            for(auto edge : adj[to]){\\n                if(visited[edge.to] || edge.idx == ignoreEdgeIdx) continue;\\n\\t\\t\\t\\t// If it\\'s the start edge we assigned, we take the edge upfront and give it the highest priority by making it free\\n                if(edge.idx == startEdgeIdx){\\n                    total += edge.cost;\\n                    edge.cost = 0;\\n                }\\n                pq.push(edge);\\n            }\\n        }\\n        return cnt == adj.size() ? total : INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930480,
                "title": "quick-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478977,
                "title": "100-faster-o-ev-building-mst-once-is-enough",
                "content": "\\n Following 4 steps are required in algo.\\n \\n1. Create graph as adjacency matrix of `int[][][]` type and keep edge weight and indices in the matrix. Indices are kept so that we don\\'t loose track of indices while sorting edges in Kruskal\\'s algo\\n2. Create MST using Kruskal\\'s algo on our graph created in step 1. Store this tree in new adjacency list(variable `mst` in code) and also the set of edges Indices used to create MST(variable `mstSet`)\\n3. For each edge `(u,v)` not in MST, if there exist edge `(x,y)` in MST on path from u to v such that `cost(u,v) = cost(x,y)` then `u,v` is a psuedo critical edge\\n4. For each edge `(u,v)` in MST, if it is not a psuedo critical edge, then it\\'s a critical edge.\\n\\n\\nPlease check https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/14/Small14.pdf.\\nThere is proof of prim\\'s algo(also applicable for kruskal\\'s algo) in this pdf, which can help understand the validity of step 3 and step 4.\\n\\n**Intuition behind step 3**: Let\\'s say path from u to v is denoted by  `P(u,v)` in MST. For any two vertices `u` and `v` there exists one and only path  `P(u,v)` in MST because MST is one connected tree covering all n vertices with n-1 edges. Therefore, adding any edge  `(u,v)` not in MST to MST will create one cycle .  If `(x,y)` is in `P(u,v)` in MST such that `cost(u,v) = cost(x,y)`, and if we remove `(x,y)`  from MST and add `(u,v)` to MST, our cost of MST will remain same because we are deleting and adding same weight edge, and the cycle created by adding edge `(u,v)` to MST will break after we remove edge `x,y`, which will create new MST implying that edge `(u,v)` was psuedo critical.\\n\\n\\n**Intuition behind step 4**: All edges in MST except psuedo critical edges were the minimum edges that we found during our algo, if we try to delete it, then the total weight cost of MST will only increase because there is no edge of the same(if such exist, it could be psuedo-critical) or less weight in non-MST which could have been added during algo run.\\n\\nTime Complexity: \\nTime complexity of Kruskal = O(ELogE + ELogV)\\nTime complexity to find psuedo critical edges = O(E(E\\'+V)) where E\\' are no. of edges in MST. \\nWe are running `path` on MST which is tree, therefore E\\' = V-1\\nHence, Time complexity to find psuedo critical edges = O(EV)\\nTime complexity to find critical edges = O(E)\\n\\nTotal time complexity = O(EV)\\n\\n```\\nclass Solution {\\n\\tpublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\t\\tint[][][] g = new int[n][n][2]; //{w,ind}\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n\\t\\t\\tint[] e = edges[i];\\n\\t\\t\\tint f = e[0];\\n\\t\\t\\tint t = e[1];\\n\\t\\t\\tint w = e[2];\\n\\t\\t\\tg[f][t][0] = w;\\n\\t\\t\\tg[t][f][0] = w;\\n\\t\\t\\tg[f][t][1] = i;\\n\\t\\t\\tg[t][f][1] = i;\\n\\t\\t}\\n\\n\\t\\tList<Integer>[] mst = new List[n];\\n\\t\\tfor(int i = 0; i < n; i ++) {\\n\\t\\t\\tmst[i] = new LinkedList<>();\\n\\t\\t}\\n\\n\\t\\tboolean[] mstSet = new boolean[edges.length];\\n\\n        Arrays.sort(edges, (a,b) -> Integer.compare(a[2], b[2]));\\n        \\n        buildMST(n, edges, mstSet, mst, g);\\n\\t\\t\\n\\t\\tList<List<Integer>> ans = new ArrayList<>(2);\\n\\t\\tSet<Integer> pce = new HashSet<>();\\n\\t\\tList<Integer> ce = new LinkedList<>();\\n\\t\\t\\n\\t\\t// psuedo critical edges\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n            int f = edges[i][0], t = edges[i][1];\\n            int w = edges[i][2];\\n            int ind = g[f][t][1];\\n\\t\\t\\tif(!mstSet[ind]) {\\n                Set<Integer> cur = new HashSet<>();\\n\\t\\t\\t\\tboolean p = path(f, t, w, -1, mst, g, cur);\\n                if(p && cur.size() > 0) {\\n                    pce.addAll(cur);\\n                    pce.add(ind);\\n                }\\n\\t\\t\\t\\tif(!p) {\\n\\t\\t\\t\\t\\tSystem.out.println(\"Should not reach here\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\t// critical edges\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n            int f = edges[i][0], t = edges[i][1];\\n            int w = edges[i][2];\\n            int ind = g[f][t][1];\\n\\t\\t\\tif(mstSet[ind] && !pce.contains(ind)) {\\n\\t\\t\\t\\tce.add(ind);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tans.add(ce);\\n\\t\\tans.add(new LinkedList<>(pce));\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tboolean path(int f, int t, int w, int p, List<Integer>[] mst, int[][][] g, Set<Integer> ind) {\\n\\t\\tif(f == t) {\\n\\t\\t\\treturn true; \\n\\t\\t}\\n\\t\\tfor(int nbr: mst[f]) {\\n\\t\\t\\tif(p != nbr) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(path(nbr, t, w, f, mst, g, ind)) {\\n\\t\\t\\t\\t\\tif(g[f][nbr][0] == w) {\\n\\t\\t\\t\\t\\t\\tind.add(g[f][nbr][1]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n    \\n    private void buildMST(int n, int[][] edges, boolean[] mste, List<Integer>[] mstg, int[][][] g){\\n        int weight = 0; \\n        DisjointSet ds = new DisjointSet(n);\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            \\n            if (ds.union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n                int[] edge = edges[i];\\n                mstg[edge[0]].add(edge[1]);\\n                mstg[edge[1]].add(edge[0]);\\n                mste[g[edge[0]][edge[1]][1]] = true;\\n            }\\n        }\\n    }\\n}\\n\\n\\nclass DisjointSet {\\n    int[] parent;\\n    \\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int i) {\\n        return (i == parent[i]) ? i : (parent[i] = find(parent[i]));\\n    }\\n    \\n    public boolean union(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if (pu == pv) {\\n            return false;\\n        }\\n        parent[pu] = pv;\\n        return true;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4835adfa-b31c-41de-ba03-54ffca957375_1632319257.3089685.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\t\\tint[][][] g = new int[n][n][2]; //{w,ind}\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n\\t\\t\\tint[] e = edges[i];\\n\\t\\t\\tint f = e[0];\\n\\t\\t\\tint t = e[1];\\n\\t\\t\\tint w = e[2];\\n\\t\\t\\tg[f][t][0] = w;\\n\\t\\t\\tg[t][f][0] = w;\\n\\t\\t\\tg[f][t][1] = i;\\n\\t\\t\\tg[t][f][1] = i;\\n\\t\\t}\\n\\n\\t\\tList<Integer>[] mst = new List[n];\\n\\t\\tfor(int i = 0; i < n; i ++) {\\n\\t\\t\\tmst[i] = new LinkedList<>();\\n\\t\\t}\\n\\n\\t\\tboolean[] mstSet = new boolean[edges.length];\\n\\n        Arrays.sort(edges, (a,b) -> Integer.compare(a[2], b[2]));\\n        \\n        buildMST(n, edges, mstSet, mst, g);\\n\\t\\t\\n\\t\\tList<List<Integer>> ans = new ArrayList<>(2);\\n\\t\\tSet<Integer> pce = new HashSet<>();\\n\\t\\tList<Integer> ce = new LinkedList<>();\\n\\t\\t\\n\\t\\t// psuedo critical edges\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n            int f = edges[i][0], t = edges[i][1];\\n            int w = edges[i][2];\\n            int ind = g[f][t][1];\\n\\t\\t\\tif(!mstSet[ind]) {\\n                Set<Integer> cur = new HashSet<>();\\n\\t\\t\\t\\tboolean p = path(f, t, w, -1, mst, g, cur);\\n                if(p && cur.size() > 0) {\\n                    pce.addAll(cur);\\n                    pce.add(ind);\\n                }\\n\\t\\t\\t\\tif(!p) {\\n\\t\\t\\t\\t\\tSystem.out.println(\"Should not reach here\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\t\\t// critical edges\\n\\t\\tfor(int i = 0; i < edges.length; i ++) {\\n            int f = edges[i][0], t = edges[i][1];\\n            int w = edges[i][2];\\n            int ind = g[f][t][1];\\n\\t\\t\\tif(mstSet[ind] && !pce.contains(ind)) {\\n\\t\\t\\t\\tce.add(ind);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tans.add(ce);\\n\\t\\tans.add(new LinkedList<>(pce));\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tboolean path(int f, int t, int w, int p, List<Integer>[] mst, int[][][] g, Set<Integer> ind) {\\n\\t\\tif(f == t) {\\n\\t\\t\\treturn true; \\n\\t\\t}\\n\\t\\tfor(int nbr: mst[f]) {\\n\\t\\t\\tif(p != nbr) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(path(nbr, t, w, f, mst, g, ind)) {\\n\\t\\t\\t\\t\\tif(g[f][nbr][0] == w) {\\n\\t\\t\\t\\t\\t\\tind.add(g[f][nbr][1]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n    \\n    private void buildMST(int n, int[][] edges, boolean[] mste, List<Integer>[] mstg, int[][][] g){\\n        int weight = 0; \\n        DisjointSet ds = new DisjointSet(n);\\n        \\n        for (int i = 0; i < edges.length; i++) {\\n            \\n            if (ds.union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n                int[] edge = edges[i];\\n                mstg[edge[0]].add(edge[1]);\\n                mstg[edge[1]].add(edge[0]);\\n                mste[g[edge[0]][edge[1]][1]] = true;\\n            }\\n        }\\n    }\\n}\\n\\n\\nclass DisjointSet {\\n    int[] parent;\\n    \\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int i) {\\n        return (i == parent[i]) ? i : (parent[i] = find(parent[i]));\\n    }\\n    \\n    public boolean union(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if (pu == pv) {\\n            return false;\\n        }\\n        parent[pu] = pv;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929720,
                "title": "ex-amazon-explains-a-solution-with-python-and-java",
                "content": "# Solution Video\\nI have to take care of my kids all day. Usually I put a solution video for each question but today, it seems to be hard to create the video.\\n\\n### Please subscribe to my channel from here. I have 245 videos as of August 19th.\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nI have limited time today, so I solved this quesion with Python and Java. This is based on Python. Other might be different a bit.\\n\\n1. **Initialize UnionFind Class:**\\n   - Create a class named `UnionFind` to implement the Union-Find data structure.\\n   - Initialize the class with the `size` of elements. Initialize `parent` as a list of indices and set each element\\'s size to 1 and `max_size` to 1.\\n\\n2. **Define `find` Method:**\\n   - Implement the `find` method within the `UnionFind` class.\\n   - Given an element `x`, recursively find its root element and update its parent to the root.\\n   - Return the root element.\\n\\n3. **Define `union` Method:**\\n   - Implement the `union` method within the `UnionFind` class.\\n   - Given elements `x` and `y`, find their root elements.\\n   - If the roots are not the same, merge the smaller tree under the larger tree.\\n   - Update the parent and size accordingly, and track the maximum size.\\n\\n4. **Initialize Variables:**\\n   - Create a function named `findCriticalAndPseudoCriticalEdges` within the `Solution` class.\\n   - Create a copy of the `edges` list named `sorted_edges` and append the index to each edge.\\n   - Sort `sorted_edges` based on the edge weight using a lambda function.\\n\\n5. **Calculate Minimum Spanning Tree (MST) Weight:**\\n   - Initialize an instance of the `UnionFind` class as `union_find_standard`.\\n   - Initialize `minimum_spanning_tree_weight` as 0.\\n   - Iterate through each edge `(u, v, weight, _)` in `sorted_edges`.\\n     - If `union_find_standard.union(u, v)` connects the nodes, update `minimum_spanning_tree_weight` by adding the edge weight.\\n\\n6. **Find Critical and Pseudo-Critical Edges:**\\n   - Initialize two empty lists `critical_edges` and `pseudo_critical_edges`.\\n   - Iterate through each edge `(u, v, weight, i)` in `sorted_edges`.\\n     - Initialize a temporary `UnionFind` instance as `union_find_temp` and a temporary weight `temp_weight` as 0.\\n     - For each edge `(x, y, w_temp, j)` in `sorted_edges`, calculate the total weight `temp_weight` if the current edge is ignored.\\n     - Check if `union_find_temp.max_size` is less than `n` or `temp_weight` is greater than `minimum_spanning_tree_weight`.\\n       - If true, add `i` to `critical_edges` and continue.\\n     - Otherwise, initialize a new `UnionFind` instance as `union_find_force` and initialize `force_weight` as `weight`.\\n     - Perform union on `(u, v)` using `union_find_force` and iterate through all edges to calculate `force_weight` if the current edge is forced.\\n     - Check if `force_weight` is equal to `minimum_spanning_tree_weight`.\\n       - If true, add `i` to `pseudo_critical_edges`.\\n\\n7. **Return Result:**\\n   - Return a list containing `critical_edges` and `pseudo_critical_edges`.\\n\\nThe code aims to find critical and pseudo-critical edges in a graph\\'s minimum spanning tree (MST) using the Union-Find data structure. It sorts edges based on weight, calculates the MST weight, and checks for critical and pseudo-critical edges based on certain conditions.\\n\\n```python []\\nclass Solution:\\n\\n    class UnionFind:\\n        def __init__(self, size):\\n            self.parent = list(range(size))\\n            self.size = [1] * size\\n            self.max_size = 1\\n\\n        def find(self, x):\\n            if x != self.parent[x]:\\n                self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n\\n        def union(self, x, y):\\n            root_x = self.find(x)\\n            root_y = self.find(y)\\n            if root_x != root_y:\\n                if self.size[root_x] < self.size[root_y]:\\n                    root_x, root_y = root_y, root_x\\n                self.parent[root_y] = root_x\\n                self.size[root_x] += self.size[root_y]\\n                self.max_size = max(self.max_size, self.size[root_x])\\n                return True\\n            return False\\n\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        sorted_edges = [edge.copy() for edge in edges]\\n\\n        for i, edge in enumerate(sorted_edges):\\n            edge.append(i)\\n\\n        sorted_edges.sort(key=lambda x: x[2])\\n\\n        union_find_standard = self.UnionFind(n)\\n        minimum_spanning_tree_weight = 0\\n        for u, v, weight, _ in sorted_edges:\\n            if union_find_standard.union(u, v):\\n                minimum_spanning_tree_weight += weight\\n\\n        critical_edges = []\\n        pseudo_critical_edges = []\\n        for (u, v, weight, i) in sorted_edges:\\n            union_find_temp = self.UnionFind(n)\\n            temp_weight = 0\\n            for (x, y, w_temp, j) in sorted_edges:\\n                if i != j and union_find_temp.union(x, y):\\n                    temp_weight += w_temp\\n\\n            if union_find_temp.max_size < n or temp_weight > minimum_spanning_tree_weight:\\n                critical_edges.append(i)\\n                continue\\n\\n            union_find_force = self.UnionFind(n)\\n            force_weight = weight\\n            union_find_force.union(u, v)\\n            for (x, y, w_force, j) in sorted_edges:\\n                if i != j and union_find_force.union(x, y):\\n                    force_weight += w_force\\n\\n            if force_weight == minimum_spanning_tree_weight:\\n                pseudo_critical_edges.append(i)\\n\\n        return [critical_edges, pseudo_critical_edges]\\n```\\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int maxSize;\\n\\n        public UnionFind(int size) {\\n            this.parent = new int[size];\\n            this.size = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n                this.size[i] = 1;\\n            }\\n            this.maxSize = 1;\\n        }\\n\\n        public int find(int x) {\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (size[rootX] < size[rootY]) {\\n                    int temp = rootX;\\n                    rootX = rootY;\\n                    rootY = temp;\\n                }\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n                maxSize = Math.max(maxSize, size[rootX]);\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<int[]> sortedEdges = new ArrayList<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            sortedEdges.add(new int[]{edges[i][0], edges[i][1], edges[i][2], i});\\n        }\\n        Collections.sort(sortedEdges, Comparator.comparingInt(a -> a[2]));\\n\\n        UnionFind unionFindStandard = new UnionFind(n);\\n        int minimumSpanningTreeWeight = 0;\\n        for (int[] edge : sortedEdges) {\\n            if (unionFindStandard.union(edge[0], edge[1])) {\\n                minimumSpanningTreeWeight += edge[2];\\n            }\\n        }\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for (int[] edge : sortedEdges) {\\n            UnionFind unionFindTemp = new UnionFind(n);\\n            int tempWeight = 0;\\n            for (int[] tempEdge : sortedEdges) {\\n                if (edge[3] != tempEdge[3] && unionFindTemp.union(tempEdge[0], tempEdge[1])) {\\n                    tempWeight += tempEdge[2];\\n                }\\n            }\\n\\n            if (unionFindTemp.maxSize < n || tempWeight > minimumSpanningTreeWeight) {\\n                criticalEdges.add(edge[3]);\\n                continue;\\n            }\\n\\n            UnionFind unionFindForce = new UnionFind(n);\\n            int forceWeight = edge[2];\\n            unionFindForce.union(edge[0], edge[1]);\\n            for (int[] forceEdge : sortedEdges) {\\n                if (edge[3] != forceEdge[3] && unionFindForce.union(forceEdge[0], forceEdge[1])) {\\n                    forceWeight += forceEdge[2];\\n                }\\n            }\\n\\n            if (forceWeight == minimumSpanningTreeWeight) {\\n                pseudoCriticalEdges.add(edge[3]);\\n            }\\n        }\\n\\n        result.add(criticalEdges);\\n        result.add(pseudoCriticalEdges);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n\\n    class UnionFind:\\n        def __init__(self, size):\\n            self.parent = list(range(size))\\n            self.size = [1] * size\\n            self.max_size = 1\\n\\n        def find(self, x):\\n            if x != self.parent[x]:\\n                self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n\\n        def union(self, x, y):\\n            root_x = self.find(x)\\n            root_y = self.find(y)\\n            if root_x != root_y:\\n                if self.size[root_x] < self.size[root_y]:\\n                    root_x, root_y = root_y, root_x\\n                self.parent[root_y] = root_x\\n                self.size[root_x] += self.size[root_y]\\n                self.max_size = max(self.max_size, self.size[root_x])\\n                return True\\n            return False\\n\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        sorted_edges = [edge.copy() for edge in edges]\\n\\n        for i, edge in enumerate(sorted_edges):\\n            edge.append(i)\\n\\n        sorted_edges.sort(key=lambda x: x[2])\\n\\n        union_find_standard = self.UnionFind(n)\\n        minimum_spanning_tree_weight = 0\\n        for u, v, weight, _ in sorted_edges:\\n            if union_find_standard.union(u, v):\\n                minimum_spanning_tree_weight += weight\\n\\n        critical_edges = []\\n        pseudo_critical_edges = []\\n        for (u, v, weight, i) in sorted_edges:\\n            union_find_temp = self.UnionFind(n)\\n            temp_weight = 0\\n            for (x, y, w_temp, j) in sorted_edges:\\n                if i != j and union_find_temp.union(x, y):\\n                    temp_weight += w_temp\\n\\n            if union_find_temp.max_size < n or temp_weight > minimum_spanning_tree_weight:\\n                critical_edges.append(i)\\n                continue\\n\\n            union_find_force = self.UnionFind(n)\\n            force_weight = weight\\n            union_find_force.union(u, v)\\n            for (x, y, w_force, j) in sorted_edges:\\n                if i != j and union_find_force.union(x, y):\\n                    force_weight += w_force\\n\\n            if force_weight == minimum_spanning_tree_weight:\\n                pseudo_critical_edges.append(i)\\n\\n        return [critical_edges, pseudo_critical_edges]\\n```\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int maxSize;\\n\\n        public UnionFind(int size) {\\n            this.parent = new int[size];\\n            this.size = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n                this.size[i] = 1;\\n            }\\n            this.maxSize = 1;\\n        }\\n\\n        public int find(int x) {\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (size[rootX] < size[rootY]) {\\n                    int temp = rootX;\\n                    rootX = rootY;\\n                    rootY = temp;\\n                }\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n                maxSize = Math.max(maxSize, size[rootX]);\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<int[]> sortedEdges = new ArrayList<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            sortedEdges.add(new int[]{edges[i][0], edges[i][1], edges[i][2], i});\\n        }\\n        Collections.sort(sortedEdges, Comparator.comparingInt(a -> a[2]));\\n\\n        UnionFind unionFindStandard = new UnionFind(n);\\n        int minimumSpanningTreeWeight = 0;\\n        for (int[] edge : sortedEdges) {\\n            if (unionFindStandard.union(edge[0], edge[1])) {\\n                minimumSpanningTreeWeight += edge[2];\\n            }\\n        }\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for (int[] edge : sortedEdges) {\\n            UnionFind unionFindTemp = new UnionFind(n);\\n            int tempWeight = 0;\\n            for (int[] tempEdge : sortedEdges) {\\n                if (edge[3] != tempEdge[3] && unionFindTemp.union(tempEdge[0], tempEdge[1])) {\\n                    tempWeight += tempEdge[2];\\n                }\\n            }\\n\\n            if (unionFindTemp.maxSize < n || tempWeight > minimumSpanningTreeWeight) {\\n                criticalEdges.add(edge[3]);\\n                continue;\\n            }\\n\\n            UnionFind unionFindForce = new UnionFind(n);\\n            int forceWeight = edge[2];\\n            unionFindForce.union(edge[0], edge[1]);\\n            for (int[] forceEdge : sortedEdges) {\\n                if (edge[3] != forceEdge[3] && unionFindForce.union(forceEdge[0], forceEdge[1])) {\\n                    forceWeight += forceEdge[2];\\n                }\\n            }\\n\\n            if (forceWeight == minimumSpanningTreeWeight) {\\n                pseudoCriticalEdges.add(edge[3]);\\n            }\\n        }\\n\\n        result.add(criticalEdges);\\n        result.add(pseudoCriticalEdges);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929324,
                "title": "java-time-o-e-log-e-space-o-e-v-kruskal-s-explanation-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding both critical and pseudo-critical edges in a given weighted undirected connected graph\\'s minimum spanning tree (MST). A critical edge is an MST edge whose removal increases the MST weight, while a pseudo-critical edge can exist in some but not all MSTs. We can solve this problem by first building the MST using Kruskal\\'s algorithm and then identifying the critical and pseudo-critical edges based on certain conditions.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Construct the initial graph using the given edges, where `graph[from][to][0]` stores the edge weight and `graph[from][to][1]` stores the edge index.\\n2. Sort the edges in ascending order of their weights.\\n3. Build the MST using Kruskal\\'s algorithm while tracking the included edges using `mstEdgeSet`.\\n4. During the MST construction, store the minimum spanning tree\\'s structure in the `minimumSpanningTree` array.\\n5. For each edge not included in the MST, check if it is a pseudo-critical edge by verifying if there exists a path between its endpoints with the same weight as the edge being considered.\\n6. Identify the critical edges by examining the edges present in the MST but not classified as pseudo-critical.\\n7. Return the lists of critical and pseudo-critical edges.\\n\\n# Complexity\\n- Time complexity: O(E * log E) due to the sorting of edges and the MST construction. Here, E is the number of edges in the graph.\\n\\n- Space complexity: O(E + V) for the graph storage, where V is the number of vertices in the graph.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int[][][] graph = new int[n][n][2]; // {weight, index}\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            graph[from][to][0] = weight;\\n            graph[to][from][0] = weight;\\n            graph[from][to][1] = i;\\n            graph[to][from][1] = i;\\n        }\\n\\n        List<Integer>[] minimumSpanningTree = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            minimumSpanningTree[i] = new LinkedList<>();\\n        }\\n\\n        boolean[] mstEdgeSet = new boolean[edges.length];\\n\\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        buildMinimumSpanningTree(n, edges, mstEdgeSet, minimumSpanningTree, graph);\\n\\n        List<List<Integer>> result = new ArrayList<>(2);\\n        Set<Integer> pseudoCriticalEdges = new HashSet<>();\\n        List<Integer> criticalEdges = new LinkedList<>();\\n\\n        // Finding pseudo-critical edges\\n        for (int i = 0; i < edges.length; i++) {\\n            int from = edges[i][0], to = edges[i][1];\\n            int weight = edges[i][2];\\n            int index = graph[from][to][1];\\n            if (!mstEdgeSet[index]) {\\n                Set<Integer> currentSet = new HashSet<>();\\n                boolean isPseudoCritical = isPath(from, to, weight, -1, minimumSpanningTree, graph, currentSet);\\n                if (isPseudoCritical && currentSet.size() > 0) {\\n                    pseudoCriticalEdges.addAll(currentSet);\\n                    pseudoCriticalEdges.add(index);\\n                }\\n            }\\n        }\\n\\n        // Finding critical edges\\n        for (int i = 0; i < edges.length; i++) {\\n            int from = edges[i][0], to = edges[i][1];\\n            int index = graph[from][to][1];\\n            if (mstEdgeSet[index] && !pseudoCriticalEdges.contains(index)) {\\n                criticalEdges.add(index);\\n            }\\n        }\\n\\n        result.add(criticalEdges);\\n        result.add(new LinkedList<>(pseudoCriticalEdges));\\n        return result;\\n    }\\n\\n    boolean isPath(int from, int to, int weight, int previous, List<Integer>[] minimumSpanningTree, int[][][] graph, Set<Integer> indices) {\\n        if (from == to) {\\n            return true;\\n        }\\n        for (int neighbor : minimumSpanningTree[from]) {\\n            if (previous != neighbor) {\\n                if (isPath(neighbor, to, weight, from, minimumSpanningTree, graph, indices)) {\\n                    if (graph[from][neighbor][0] == weight) {\\n                        indices.add(graph[from][neighbor][1]);\\n                    }\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void buildMinimumSpanningTree(int n, int[][] edges, boolean[] mstEdgeSet, List<Integer>[] minimumSpanningTree, int[][][] graph) {\\n        int weight = 0;\\n        DisjointSet ds = new DisjointSet(n);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (ds.union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n                int[] edge = edges[i];\\n                minimumSpanningTree[edge[0]].add(edge[1]);\\n                minimumSpanningTree[edge[1]].add(edge[0]);\\n                mstEdgeSet[graph[edge[0]][edge[1]][1]] = true;\\n            }\\n        }\\n    }\\n}\\n\\nclass DisjointSet {\\n    int[] parent;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int find(int i) {\\n        return (i == parent[i]) ? i : (parent[i] = find(parent[i]));\\n    }\\n\\n    public boolean union(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if (pu == pv) {\\n            return false;\\n        }\\n        parent[pu] = pv;\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int[][][] graph = new int[n][n][2]; // {weight, index}\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            graph[from][to][0] = weight;\\n            graph[to][from][0] = weight;\\n            graph[from][to][1] = i;\\n            graph[to][from][1] = i;\\n        }\\n\\n        List<Integer>[] minimumSpanningTree = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            minimumSpanningTree[i] = new LinkedList<>();\\n        }\\n\\n        boolean[] mstEdgeSet = new boolean[edges.length];\\n\\n        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        buildMinimumSpanningTree(n, edges, mstEdgeSet, minimumSpanningTree, graph);\\n\\n        List<List<Integer>> result = new ArrayList<>(2);\\n        Set<Integer> pseudoCriticalEdges = new HashSet<>();\\n        List<Integer> criticalEdges = new LinkedList<>();\\n\\n        // Finding pseudo-critical edges\\n        for (int i = 0; i < edges.length; i++) {\\n            int from = edges[i][0], to = edges[i][1];\\n            int weight = edges[i][2];\\n            int index = graph[from][to][1];\\n            if (!mstEdgeSet[index]) {\\n                Set<Integer> currentSet = new HashSet<>();\\n                boolean isPseudoCritical = isPath(from, to, weight, -1, minimumSpanningTree, graph, currentSet);\\n                if (isPseudoCritical && currentSet.size() > 0) {\\n                    pseudoCriticalEdges.addAll(currentSet);\\n                    pseudoCriticalEdges.add(index);\\n                }\\n            }\\n        }\\n\\n        // Finding critical edges\\n        for (int i = 0; i < edges.length; i++) {\\n            int from = edges[i][0], to = edges[i][1];\\n            int index = graph[from][to][1];\\n            if (mstEdgeSet[index] && !pseudoCriticalEdges.contains(index)) {\\n                criticalEdges.add(index);\\n            }\\n        }\\n\\n        result.add(criticalEdges);\\n        result.add(new LinkedList<>(pseudoCriticalEdges));\\n        return result;\\n    }\\n\\n    boolean isPath(int from, int to, int weight, int previous, List<Integer>[] minimumSpanningTree, int[][][] graph, Set<Integer> indices) {\\n        if (from == to) {\\n            return true;\\n        }\\n        for (int neighbor : minimumSpanningTree[from]) {\\n            if (previous != neighbor) {\\n                if (isPath(neighbor, to, weight, from, minimumSpanningTree, graph, indices)) {\\n                    if (graph[from][neighbor][0] == weight) {\\n                        indices.add(graph[from][neighbor][1]);\\n                    }\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void buildMinimumSpanningTree(int n, int[][] edges, boolean[] mstEdgeSet, List<Integer>[] minimumSpanningTree, int[][][] graph) {\\n        int weight = 0;\\n        DisjointSet ds = new DisjointSet(n);\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (ds.union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n                int[] edge = edges[i];\\n                minimumSpanningTree[edge[0]].add(edge[1]);\\n                minimumSpanningTree[edge[1]].add(edge[0]);\\n                mstEdgeSet[graph[edge[0]][edge[1]][1]] = true;\\n            }\\n        }\\n    }\\n}\\n\\nclass DisjointSet {\\n    int[] parent;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int find(int i) {\\n        return (i == parent[i]) ? i : (parent[i] = find(parent[i]));\\n    }\\n\\n    public boolean union(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if (pu == pv) {\\n            return false;\\n        }\\n        parent[pu] = pv;\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929249,
                "title": "easy-solution-python3-c-c-c-java-use-mst-algorihtm-with-image",
                "content": "# Intuition\\nTo your preferred programming language\\nyou can turn.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__ (self, n):\\n        self.parents = list(range(n))\\n        self.weight = 0\\n        self.edgeCount = 0\\n\\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n\\n    def union(self, x, y, w):\\n        r1 = self.find(x)\\n        r2 = self.find(y)\\n\\n        if r1 != r2:\\n            self.parents[r2] = r1\\n            self.weight += w\\n            self.edgeCount += 1\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        edges = [(w,a,b,i) for i, (a,b,w) in enumerate(edges)]\\n        edges.sort()\\n\\n        uf1 = UnionFind(n)\\n        for w, a, b, _ in edges:\\n            uf1.union(a, b, w)\\n\\n\\n        minWeight = uf1.weight\\n\\n\\n        ce = []\\n        pce = []\\n        m = len(edges)\\n\\n\\n        for i in range(m):\\n            uf2 = UnionFind(n)\\n            for j in range(m):\\n                if i == j:\\n                    continue\\n                w,a,b,_ = edges[j]\\n                uf2.union(a,b,w)\\n            \\n            if uf2.weight > minWeight or uf2.edgeCount < n-1:\\n                ce.append(edges[i][3])\\n\\n            else:\\n                \\n                uf3 = UnionFind(n)\\n                w,a,b,_ = edges[i]\\n                uf3.union(a,b,w)\\n                for j in range(m):\\n                    w,a,b,_ = edges[j]\\n                    uf3.union(a,b,w)\\n                \\n                if uf3.weight == minWeight:\\n                    pce.append(edges[i][3])\\n        return ce, pce\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__ (self, n):\\n        self.parents = list(range(n))\\n        self.weight = 0\\n        self.edgeCount = 0\\n\\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n\\n    def union(self, x, y, w):\\n        r1 = self.find(x)\\n        r2 = self.find(y)\\n\\n        if r1 != r2:\\n            self.parents[r2] = r1\\n            self.weight += w\\n            self.edgeCount += 1\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\n        edges = [(w,a,b,i) for i, (a,b,w) in enumerate(edges)]\\n        edges.sort()\\n\\n        uf1 = UnionFind(n)\\n        for w, a, b, _ in edges:\\n            uf1.union(a, b, w)\\n\\n\\n        minWeight = uf1.weight\\n\\n\\n        ce = []\\n        pce = []\\n        m = len(edges)\\n\\n\\n        for i in range(m):\\n            uf2 = UnionFind(n)\\n            for j in range(m):\\n                if i == j:\\n                    continue\\n                w,a,b,_ = edges[j]\\n                uf2.union(a,b,w)\\n            \\n            if uf2.weight > minWeight or uf2.edgeCount < n-1:\\n                ce.append(edges[i][3])\\n\\n            else:\\n                \\n                uf3 = UnionFind(n)\\n                w,a,b,_ = edges[i]\\n                uf3.union(a,b,w)\\n                for j in range(m):\\n                    w,a,b,_ = edges[j]\\n                    uf3.union(a,b,w)\\n                \\n                if uf3.weight == minWeight:\\n                    pce.append(edges[i][3])\\n        return ce, pce\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180571,
                "title": "c-understandable-solution-walkthrough-t-c-o-ev-based-on-mst",
                "content": "**A DSU Class Where Both The Functions Are Implemented in Their Best State**\\n\\n    The findParent() Has A Time Complexity Amortized To O(1) from O(logN)\\n    Using Path Compression.\\n  \\n    The Union Function Used The Method Of Size Compression To Balance The Height Of\\n    The Tree.  \\n    \\n    Sort The Edges According To Their Weight Which Has A Time Complexity Of O(ElogE)\\n    Using An Appropriate Comparator Function\\n    \\n    Create The Minimum Spanning Tree Using Kruskal\\'s Algo\\n    \\n*     CRITICAL EDGE :\\n    Now For Critical Edge We Run Through A Brute Force Approach Of Excluding A Single Edge\\n    And Forming The Minimum Spanning Tree\\n    \\n    **If The Cost Of It Is Greater Than The Cost Of The Initially Formed MST, Then It Is\\n    Definitely A Critical Edge**\\n\\n    **Another Case Is Possible Where The Cost Comes To Be Less Than Cost Of MST, Which Is\\n        Impossible In Sense. Hence It Means Without That Edge The MST Cant Be Formed**\\n        So This Is Also A Critical Edge.\\n\\n\\t*****Mind That There Can Be Edges Which Are Not Considered In The MST.\\n    This Is Handled In The Pseudo Critical Edge List    \\n   \\n*    PSEUDO CRITICAL EDGE :\\n   Now We Forcefully Include The Edges Which Are Not There In The Critical Edges.\\n    \\n    After That We Check Whether The Cost Is Same As That Of MST Or Not.\\n    If Equal Then It Is A Pseudo Critical Edge Else Not.\\n\\t\\n\\tTime Complexity : O(ElogE)+ O(EV) + O(EV) ~O(EV)\\n\\tSpace Complexity : O(E+V)\\n\\t\\n```\\nclass Solution {\\npublic:\\n\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n};\\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[2]<v2[2];        \\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        int len=edges.size();\\n        for(int i=0;i<len;i++)\\n            edges[i].push_back(i);\\n  \\n        sort(edges.begin(),edges.end(),comp);\\n \\n        DSU dsu;\\n        int cost=0;\\n        vector<int> par(n);\\n        vector<int> size(n,1);\\n        for(int i=0;i<n;i++)par[i]=i;\\n        vector<bool> isPart(len,0);\\n        // First MST\\n        int c=0;\\n        for(int i=0;i<len;i++)\\n        {   \\n            if(c==n-1)break;\\n            if(dsu.findParent(edges[i][0],par)!=dsu.findParent(edges[i][1],par))\\n            {   \\n                dsu.Union(edges[i][0],edges[i][1],size,par);\\n                isPart[edges[i][3]]=1;\\n                cost+=edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical,pseudocritical;\\n        // Critical Edge Find\\n        for(int i=0;i<len;i++)\\n        {\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            \\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            vector<bool> temp(len,0);\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   \\n                if(c==n-1)break;\\n                //Create New MST Excluding ith Edge\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    temp[edges[j][3]]=1;\\n                    tempCost+=edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if(tempCost==cost)\\n            {\\n                for(int k=0;k<len;k++)\\n                {\\n                    if(temp[k])isPart[k]=1;\\n                }    \\n            }\\n            else\\n                critical.push_back(edges[i][3]);\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[edges[i][3]])continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            tempDSU.Union(edges[i][0],edges[i][1],tempSize,tempPar);\\n            tempCost+=edges[i][2];\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   //Create New MST Excluding This Edge\\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    tempCost+=edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if(tempCost==cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for(auto &it : critical)\\n            isPart[it]=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return {critical,pseudocritical};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n};\\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[2]<v2[2];        \\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        int len=edges.size();\\n        for(int i=0;i<len;i++)\\n            edges[i].push_back(i);\\n  \\n        sort(edges.begin(),edges.end(),comp);\\n \\n        DSU dsu;\\n        int cost=0;\\n        vector<int> par(n);\\n        vector<int> size(n,1);\\n        for(int i=0;i<n;i++)par[i]=i;\\n        vector<bool> isPart(len,0);\\n        // First MST\\n        int c=0;\\n        for(int i=0;i<len;i++)\\n        {   \\n            if(c==n-1)break;\\n            if(dsu.findParent(edges[i][0],par)!=dsu.findParent(edges[i][1],par))\\n            {   \\n                dsu.Union(edges[i][0],edges[i][1],size,par);\\n                isPart[edges[i][3]]=1;\\n                cost+=edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical,pseudocritical;\\n        // Critical Edge Find\\n        for(int i=0;i<len;i++)\\n        {\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            \\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            vector<bool> temp(len,0);\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   \\n                if(c==n-1)break;\\n                //Create New MST Excluding ith Edge\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    temp[edges[j][3]]=1;\\n                    tempCost+=edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if(tempCost==cost)\\n            {\\n                for(int k=0;k<len;k++)\\n                {\\n                    if(temp[k])isPart[k]=1;\\n                }    \\n            }\\n            else\\n                critical.push_back(edges[i][3]);\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[edges[i][3]])continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            tempDSU.Union(edges[i][0],edges[i][1],tempSize,tempPar);\\n            tempCost+=edges[i][2];\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   //Create New MST Excluding This Edge\\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    tempCost+=edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if(tempCost==cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for(auto &it : critical)\\n            isPart[it]=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return {critical,pseudocritical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931764,
                "title": "explained-with-images-and-steps-hard-to-understand-made-easy",
                "content": "# Intuition\\nThere are two algorithms to find MST.\\n- Prim\\'s Algorithm\\n- Kruskal\\'s Algorithm\\n\\nWe will be using Kruskal\\'s algorithm in this case. Those of you who don\\'t know, Kruskal\\'s algorithm is actually a modification of the union find algorithm. You need to understand the Union Find algorithm properly to understand Kruskal\\'s algorithm.\\n\\nWe will divide this solution to steps:\\n\\n## Step 1 (Create a new array to store the edges and corresponding indices):\\n\\nTo calculate MST, we are concerned with minimum weights. Therefore, we will need to sort the array. But this will change the original index of the array. So, create a new array and store exisiting values along with their indices.\\n\\n``` java []\\nint m = edges.length;\\nint[][] newEdges = new int[m][4];\\nfor(int i=0; i<m; i++) {\\n    for(int j=0; j<3; j++) {\\n        newEdges[i][j] = edges[i][j];\\n    }\\n    newEdges[i][3] = i;\\n}\\n```\\n\\n## Step 2 (Sort the edges array):\\n\\nWe sort the array in ascending order based on their weights.\\nThe array elements are:\\n```\\nindex:       0    1     2       3\\nnewEdges = {from, to, weight, index}\\n```\\n``` java []\\nArrays.sort(newEdges, (a, b) -> a[2]-b[2]);\\n```\\n\\n## Step 3 (Write a class for UnionFind):\\n\\nWe will need union find algorithm. So, let\\'s write a class for it.\\n\\n``` java []\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    int maxSize;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        maxSize = 1;\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    public int find(int a) {\\n        while(parent[a]!=a) {\\n            parent[a] = parent[parent[a]];\\n            a = parent[a];\\n        }\\n        return a;\\n    }\\n    public boolean makeUnion(int a, int b) {\\n        int parA = find(a), parB = find(b);\\n        if(parA != parB) {\\n            if(rank[parA] < rank[parB]) {\\n                parent[parA] = parB;\\n                rank[parB] += rank[parA];\\n                maxSize = Math.max(maxSize, rank[parB]);\\n            }\\n            else {\\n                parent[parB] = parA;\\n                rank[parA] += rank[parB];\\n                maxSize = Math.max(maxSize, rank[parA]);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n## Step 4 (Calculate the Weight of Actual MST):\\n\\nThe visualization how Kruskal\\'s algorithm works is shown below.\\n\\n<img style=\"background: #F3FDE8\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/MST_kruskal_en.gif/600px-MST_kruskal_en.gif\" />\\n\\nReference: [wikimedia.org](https://commons.wikimedia.org/wiki/File:MST_kruskal_en.gif)\\n\\nUse the union find approach and calculate the actual Minimum Spanning Tree.\\n\\nUsing the union find algorithm, calculate the weight of the standard MST.\\n\\n``` java []\\nint weight = 0;\\nUnionFind ufMST = new UnionFind(n);\\nfor(int[] edge : newEdges) {\\n    if(ufMST.makeUnion(edge[0], edge[1])) {\\n        weight += edge[2];\\n    }\\n}\\n```\\n\\n## Step 5 (Find the Critical and Pseudo Critical Edges):\\n\\nThe above part was easy. But from now it gets a bit tricky. We need to properly understand what a critical and pseudo path is.\\n\\n- **Critical Path**:\\n\\nLet\\'s suppose we delete the edge between node 0 and 1.\\n\\n![Untitled presentation.png](https://assets.leetcode.com/users/images/60e19e15-8e5a-4c60-a5dc-53473e8796ea_1692456577.7516568.png)\\n\\nWe can see from the right side of the image that we can form these trees. All of them has `weight > actual weight`. So, they are not a spanning tree. This happened because we removed the edge $<0,1>$ from the edges. So, edge $<0, 1>$ is a critical edge.\\n\\nSimilarly, if we remove edge $<1, 2>$, we will get spanning tree having more weight than actual. So, this is also a critical path.\\n\\n**Remember, Spanning tree is a connected graph**. If removing an edge disconnects the graph, it will not be a spanning tree. Hence, that edge is critical.\\nSo, two conditions for an edge to be critical. Without that edge:\\n1. Calculated weight becomes greater than actual MST weight. \\n2. The graph may become disconnected.\\n\\n- **Pseudo Path**:\\nThis could be tricky to understand. We can forcefully include an edge in the spanning tree union to see if the total weight becomes equal to the actual MST weight. If so, then this edge that we\\'ve forcefully included is a pseudo edge.\\n\\n![image.png](https://assets.leetcode.com/users/images/4313ba64-cc33-4c40-a0bf-1dcca8be4f19_1692457336.7808957.png)\\n\\nFrom the above image we can see that edges $<2, 2>, <5, 3>, <4, 3>$ \\nand $<3, 2>$ are pseudo edges. Because, we can forcefully include them in the spanning tree and find the weight to be equal.\\n\\n**Remember, Minimum Spanning Tree is not Unique!!**\\n\\n``` java []\\nfor(int i=0; i<m; i++) {\\n    UnionFind ufCritical = new UnionFind(n);\\n    int ignoreWeight = 0;\\n    // ignoring edge i\\n    // Union all the edges except i\\n    for(int j=0; j<m; j++) {\\n        if(i!=j && ufCritical.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n            ignoreWeight += newEdges[j][2];\\n        }\\n    }\\n    // if not all vertices are in the union or, weight has increased\\n    // that means we cannot form MST without edge i.\\n    // So, it is a critical edge\\n    if(ufCritical.maxSize < n || ignoreWeight > weight) {\\n        // add it\\'s original index\\n        result.get(0).add(newEdges[i][3]);\\n    }\\n    else {\\n        UnionFind ufForce = new UnionFind(n);\\n        // we don\\'t know if edge i was in our original MST\\n        // but we will forcefully include it\\n        ufForce.makeUnion(newEdges[i][0], newEdges[i][1]);\\n        int forceWeight = newEdges[i][2]; // cause we have already taken edge i\\n        for(int j=0; j<m; j++) {\\n            if(i!=j && ufForce.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                forceWeight += newEdges[j][2];\\n            }\\n        }\\n        if(forceWeight == weight) {\\n            // if the weight after forcing an edge is equal to the original MST weight\\n            // that means this is a pseudo edge.\\n            result.get(1).add(newEdges[i][3]);\\n        }\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(V E)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(V+E) = O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    int maxSize;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        maxSize = 1;\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    public int find(int a) {\\n        while(parent[a]!=a) {\\n            parent[a] = parent[parent[a]];\\n            a = parent[a];\\n        }\\n        return a;\\n    }\\n    public boolean makeUnion(int a, int b) {\\n        int parA = find(a), parB = find(b);\\n        if(parA != parB) {\\n            if(rank[parA] < rank[parB]) {\\n                parent[parA] = parB;\\n                rank[parB] += rank[parA];\\n                maxSize = Math.max(maxSize, rank[parB]);\\n            }\\n            else {\\n                parent[parB] = parA;\\n                rank[parA] += rank[parB];\\n                maxSize = Math.max(maxSize, rank[parA]);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int m = edges.length;\\n        int[][] newEdges = new int[m][4];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<3; j++) {\\n                newEdges[i][j] = edges[i][j];\\n            }\\n            newEdges[i][3] = i;\\n        }\\n\\n        Arrays.sort(newEdges, (a, b)->a[2]-b[2]);\\n\\n        int weight = 0;\\n        UnionFind ufMST = new UnionFind(n);\\n        for(int[] edge : newEdges) {\\n            if(ufMST.makeUnion(edge[0], edge[1])) {\\n                weight += edge[2];\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        // critical edges result.get(0)\\n        result.add(new ArrayList<>());\\n        // pseudo critical edges result.get(1)\\n        result.add(new ArrayList<>());\\n\\n        for(int i=0; i<m; i++) {\\n            UnionFind ufCritical = new UnionFind(n);\\n            int ignoreWeight = 0;\\n            // ignoring edge i\\n            // Union all the edges except i\\n            for(int j=0; j<m; j++) {\\n                if(i!=j && ufCritical.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                    ignoreWeight += newEdges[j][2];\\n                }\\n            }\\n            // if not all vertices are in the union or, weight has increased\\n            // that means we cannot form MST without edge i.\\n            // So, it is a critical edge\\n            if(ufCritical.maxSize < n || ignoreWeight > weight) {\\n                // add it\\'s original index\\n                result.get(0).add(newEdges[i][3]);\\n            }\\n            else {\\n                UnionFind ufForce = new UnionFind(n);\\n                // we don\\'t know if edge i was in our original MST\\n                // but we will forcefully include it\\n                ufForce.makeUnion(newEdges[i][0], newEdges[i][1]);\\n                int forceWeight = newEdges[i][2]; // cause we have already taken edge i\\n                for(int j=0; j<m; j++) {\\n                    if(i!=j && ufForce.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                        forceWeight += newEdges[j][2];\\n                    }\\n                }\\n                if(forceWeight == weight) {\\n                    // if the weight after forcing an edge is equal to the original MST weight\\n                    // that means this is a pseudo edge.\\n                    result.get(1).add(newEdges[i][3]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "``` java []\\nint m = edges.length;\\nint[][] newEdges = new int[m][4];\\nfor(int i=0; i<m; i++) {\\n    for(int j=0; j<3; j++) {\\n        newEdges[i][j] = edges[i][j];\\n    }\\n    newEdges[i][3] = i;\\n}\\n```\n```\\nindex:       0    1     2       3\\nnewEdges = {from, to, weight, index}\\n```\n``` java []\\nArrays.sort(newEdges, (a, b) -> a[2]-b[2]);\\n```\n``` java []\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    int maxSize;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        maxSize = 1;\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    public int find(int a) {\\n        while(parent[a]!=a) {\\n            parent[a] = parent[parent[a]];\\n            a = parent[a];\\n        }\\n        return a;\\n    }\\n    public boolean makeUnion(int a, int b) {\\n        int parA = find(a), parB = find(b);\\n        if(parA != parB) {\\n            if(rank[parA] < rank[parB]) {\\n                parent[parA] = parB;\\n                rank[parB] += rank[parA];\\n                maxSize = Math.max(maxSize, rank[parB]);\\n            }\\n            else {\\n                parent[parB] = parA;\\n                rank[parA] += rank[parB];\\n                maxSize = Math.max(maxSize, rank[parA]);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` java []\\nint weight = 0;\\nUnionFind ufMST = new UnionFind(n);\\nfor(int[] edge : newEdges) {\\n    if(ufMST.makeUnion(edge[0], edge[1])) {\\n        weight += edge[2];\\n    }\\n}\\n```\n``` java []\\nfor(int i=0; i<m; i++) {\\n    UnionFind ufCritical = new UnionFind(n);\\n    int ignoreWeight = 0;\\n    // ignoring edge i\\n    // Union all the edges except i\\n    for(int j=0; j<m; j++) {\\n        if(i!=j && ufCritical.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n            ignoreWeight += newEdges[j][2];\\n        }\\n    }\\n    // if not all vertices are in the union or, weight has increased\\n    // that means we cannot form MST without edge i.\\n    // So, it is a critical edge\\n    if(ufCritical.maxSize < n || ignoreWeight > weight) {\\n        // add it\\'s original index\\n        result.get(0).add(newEdges[i][3]);\\n    }\\n    else {\\n        UnionFind ufForce = new UnionFind(n);\\n        // we don\\'t know if edge i was in our original MST\\n        // but we will forcefully include it\\n        ufForce.makeUnion(newEdges[i][0], newEdges[i][1]);\\n        int forceWeight = newEdges[i][2]; // cause we have already taken edge i\\n        for(int j=0; j<m; j++) {\\n            if(i!=j && ufForce.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                forceWeight += newEdges[j][2];\\n            }\\n        }\\n        if(forceWeight == weight) {\\n            // if the weight after forcing an edge is equal to the original MST weight\\n            // that means this is a pseudo edge.\\n            result.get(1).add(newEdges[i][3]);\\n        }\\n    }\\n}\\n```\n``` java []\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    int maxSize;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        maxSize = 1;\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    public int find(int a) {\\n        while(parent[a]!=a) {\\n            parent[a] = parent[parent[a]];\\n            a = parent[a];\\n        }\\n        return a;\\n    }\\n    public boolean makeUnion(int a, int b) {\\n        int parA = find(a), parB = find(b);\\n        if(parA != parB) {\\n            if(rank[parA] < rank[parB]) {\\n                parent[parA] = parB;\\n                rank[parB] += rank[parA];\\n                maxSize = Math.max(maxSize, rank[parB]);\\n            }\\n            else {\\n                parent[parB] = parA;\\n                rank[parA] += rank[parB];\\n                maxSize = Math.max(maxSize, rank[parA]);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int m = edges.length;\\n        int[][] newEdges = new int[m][4];\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<3; j++) {\\n                newEdges[i][j] = edges[i][j];\\n            }\\n            newEdges[i][3] = i;\\n        }\\n\\n        Arrays.sort(newEdges, (a, b)->a[2]-b[2]);\\n\\n        int weight = 0;\\n        UnionFind ufMST = new UnionFind(n);\\n        for(int[] edge : newEdges) {\\n            if(ufMST.makeUnion(edge[0], edge[1])) {\\n                weight += edge[2];\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        // critical edges result.get(0)\\n        result.add(new ArrayList<>());\\n        // pseudo critical edges result.get(1)\\n        result.add(new ArrayList<>());\\n\\n        for(int i=0; i<m; i++) {\\n            UnionFind ufCritical = new UnionFind(n);\\n            int ignoreWeight = 0;\\n            // ignoring edge i\\n            // Union all the edges except i\\n            for(int j=0; j<m; j++) {\\n                if(i!=j && ufCritical.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                    ignoreWeight += newEdges[j][2];\\n                }\\n            }\\n            // if not all vertices are in the union or, weight has increased\\n            // that means we cannot form MST without edge i.\\n            // So, it is a critical edge\\n            if(ufCritical.maxSize < n || ignoreWeight > weight) {\\n                // add it\\'s original index\\n                result.get(0).add(newEdges[i][3]);\\n            }\\n            else {\\n                UnionFind ufForce = new UnionFind(n);\\n                // we don\\'t know if edge i was in our original MST\\n                // but we will forcefully include it\\n                ufForce.makeUnion(newEdges[i][0], newEdges[i][1]);\\n                int forceWeight = newEdges[i][2]; // cause we have already taken edge i\\n                for(int j=0; j<m; j++) {\\n                    if(i!=j && ufForce.makeUnion(newEdges[j][0], newEdges[j][1])) {\\n                        forceWeight += newEdges[j][2];\\n                    }\\n                }\\n                if(forceWeight == weight) {\\n                    // if the weight after forcing an edge is equal to the original MST weight\\n                    // that means this is a pseudo edge.\\n                    result.get(1).add(newEdges[i][3]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313151,
                "title": "using-disjoint-set",
                "content": "# Intuition\\nUsing Disjoint Set Union.\\nKrushkal\\'s Algorithim.\\n\\n\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/4774f259-a0a2-4c97-af45-daf5e4d5b24e_1679166662.242037.webp)\\n\\n\\n```Java []\\nclass Solution {\\n    public void union(int u, int v, int[] parent) {\\n        int pu = find(u, parent);\\n        int pv = find(v, parent);\\n        if(pu != pv) {\\n            parent[pv] = pu;\\n        }\\n    }\\n\\n    public int find(int node, int[] parent) {\\n        if(parent[node] == node) {\\n            return node;\\n        }\\n        return find(parent[node], parent);\\n    }\\n\\n    public int mst(int n, int[][] edges, int includeEdge[], int excludeEdge[]) {\\n\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        int ans = 0;\\n        int size = 0;\\n        if(includeEdge != null) {\\n            int parent1 = find(includeEdge[0], parent);\\n            int parent2 = find(includeEdge[1], parent);\\n            union(parent1, parent2, parent);\\n            ans += includeEdge[2];\\n            size += 1;\\n        }\\n        \\n        for(int[] edge : edges) {\\n            if(excludeEdge != null && edge[0] == excludeEdge[0] && edge[1] == excludeEdge[1] && edge[2] ==  excludeEdge[2]) {\\n                continue;\\n            }\\n            if(includeEdge != null && edge[0] == includeEdge[0] && edge[1] == includeEdge[1] && edge[2] ==  includeEdge[2]) {\\n                continue;\\n            }\\n            int u = edge[0];\\n            int v = edge[1];\\n            int cost = edge[2];\\n            int p1 = find(u, parent);\\n            int p2 = find(v, parent);\\n            if(p1 != p2) {\\n                union(p1, p2, parent);\\n                ans += cost;\\n                size += 1;\\n            }\\n        }\\n\\n        return (size == n - 1) ? ans : Integer.MAX_VALUE; \\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int originalEdges[][] = new int[edges.length][3];\\n        for(int i = 0; i < edges.length; i++) {\\n            originalEdges[i][0] = edges[i][0];\\n            originalEdges[i][1] = edges[i][1];\\n            originalEdges[i][2] = edges[i][2];\\n        }\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        int originalCost = mst(n, edges, null, null);\\n        for(int i = 0; i < originalEdges.length; i++) {\\n            int excludedCost = mst(n, edges, null, originalEdges[i]);\\n            int includedCost = mst(n, edges, originalEdges[i], null);\\n            if(excludedCost > originalCost) {\\n                criticalEdges.add(i);\\n            } else if(includedCost == originalCost) {\\n                pseudoCriticalEdges.add(i);\\n            }\\n        }\\n        result.add(criticalEdges);\\n        result.add(pseudoCriticalEdges);\\n        return result;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution :\\n    def find(self,u,parent):\\n        if u == parent[u] : return u\\n        return self.find(parent[u], parent)\\n\\n    def unionDSU(self,u,v,parent) :\\n        p1 = self.find(u, parent)\\n        p2 = self.find(v, parent)\\n        parent[p2] = p1\\n\\n    def mst(self,n,edges,includeEdge,excludeEdge) :\\n\\n        parent=[]\\n        for i in range(n): \\n            parent.append(i);\\n        \\n        ans = 0\\n        count = 0\\n\\n        if len(includeEdge) != 0 :\\n            self.unionDSU(includeEdge[0], includeEdge[1], parent)\\n            ans += includeEdge[2]\\n            count += 1\\n        \\n        for edge in edges:\\n            u = edge[0];\\n            v = edge[1];\\n            cost = edge[2];\\n\\n            if len(excludeEdge) != 0 and excludeEdge[0] == u and excludeEdge[1] == v and excludeEdge[2] == cost :\\n                continue\\n            \\n\\n            if len(includeEdge) != 0 and includeEdge[0] == u and includeEdge[1] == v and includeEdge[2] == cost :\\n                continue\\n            \\n\\n            p1 = self.find(u, parent)\\n            p2 = self.find(v, parent)\\n\\n            if p1 != p2:\\n                self.unionDSU(p1, p2, parent)\\n                ans += cost\\n                count += 1\\n            \\n        \\n        return  ans if count==n-1 else float(\\'inf\\')\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        originalEdges=[]\\n        for edge in edges : \\n            originalEdge=[edge[0], edge[1], edge[2]]\\n            originalEdges.append(originalEdge)\\n        \\n\\n        result=[]\\n        criticalEdges=[]\\n        pseudoCriticalEdges=[]\\n\\n        \\n        edges=sorted(edges, key = lambda x: x[2])\\n\\n        emptyVector=[]\\n        originalCost = self.mst(n, edges, emptyVector, emptyVector)\\n\\n        \\n        for i in range(len(originalEdges)): \\n\\n            excludedCost = self.mst(n, edges, emptyVector, originalEdges[i])\\n            includedCost = self.mst(n, edges, originalEdges[i], emptyVector)\\n\\n            if excludedCost > originalCost :\\n                criticalEdges.append(i)\\n            elif includedCost == originalCost : \\n                pseudoCriticalEdges.append(i)\\n            \\n        \\n        result.append(criticalEdges)\\n        result.append(pseudoCriticalEdges)\\n        return result\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int find(int u, vector<int>& parent) {\\n        if(u == parent[u]) return u;\\n        return find(parent[u], parent);\\n    }\\n\\n    void unionDSU(int u, int v, vector<int>& parent) {\\n        int p1 = find(u, parent);\\n        int p2 = find(v, parent);\\n        parent[p2] = p1;\\n    }\\n\\n    int mst(int n, vector<vector<int>>& edges, vector<int>& includeEdge, vector<int>& excludeEdge) {\\n\\n        vector<int> parent;\\n        for(int i = 0; i < n; i++) {\\n            parent.push_back(i);\\n        }\\n        int ans = 0;\\n        int count = 0;\\n\\n        if(includeEdge.size() != 0) {\\n            unionDSU(includeEdge[0], includeEdge[1], parent);\\n            ans += includeEdge[2];\\n            count += 1;\\n        }\\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int cost = edge[2];\\n\\n            if(excludeEdge.size() != 0 && excludeEdge[0] == u && excludeEdge[1] == v && excludeEdge[2] == cost) {\\n                continue;\\n            }\\n\\n            if(includeEdge.size() != 0 && includeEdge[0] == u && includeEdge[1] == v && includeEdge[2] == cost) {\\n                continue;\\n            }\\n\\n            int p1 = find(u, parent);\\n            int p2 = find(v, parent);\\n\\n            if(p1 != p2) {\\n                unionDSU(p1, p2, parent);\\n                ans += cost;\\n                count += 1;\\n            }\\n        }\\n        return count == n - 1 ? ans : INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> originalEdges;\\n        for(auto edge : edges) {\\n            vector<int> originalEdge{edge[0], edge[1], edge[2]};\\n            originalEdges.push_back(originalEdge);\\n        }\\n\\n        vector<vector<int>> result;\\n        vector<int> criticalEdges;\\n        vector<int> pseudoCriticalEdges;\\n\\n        sort(edges.begin(), edges.end(), \\n        [](const vector<int> &x, const vector<int> &y) { return x[2] < y[2]; });\\n\\n        vector<int> emptyVector;\\n        int originalCost = mst(n, edges, emptyVector, emptyVector);\\n\\n        for(int i = 0; i < originalEdges.size(); i++) {\\n            int excludedCost = mst(n, edges, emptyVector, originalEdges[i]);\\n            int includedCost = mst(n, edges, originalEdges[i], emptyVector);\\n            if(excludedCost > originalCost) {\\n                criticalEdges.push_back(i);\\n            } else if(includedCost == originalCost) {\\n                pseudoCriticalEdges.push_back(i);\\n            }\\n        }\\n        result.push_back(criticalEdges);\\n        result.push_back(pseudoCriticalEdges);\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public void union(int u, int v, int[] parent) {\\n        int pu = find(u, parent);\\n        int pv = find(v, parent);\\n        if(pu != pv) {\\n            parent[pv] = pu;\\n        }\\n    }\\n\\n    public int find(int node, int[] parent) {\\n        if(parent[node] == node) {\\n            return node;\\n        }\\n        return find(parent[node], parent);\\n    }\\n\\n    public int mst(int n, int[][] edges, int includeEdge[], int excludeEdge[]) {\\n\\n        int[] parent = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        int ans = 0;\\n        int size = 0;\\n        if(includeEdge != null) {\\n            int parent1 = find(includeEdge[0], parent);\\n            int parent2 = find(includeEdge[1], parent);\\n            union(parent1, parent2, parent);\\n            ans += includeEdge[2];\\n            size += 1;\\n        }\\n        \\n        for(int[] edge : edges) {\\n            if(excludeEdge != null && edge[0] == excludeEdge[0] && edge[1] == excludeEdge[1] && edge[2] ==  excludeEdge[2]) {\\n                continue;\\n            }\\n            if(includeEdge != null && edge[0] == includeEdge[0] && edge[1] == includeEdge[1] && edge[2] ==  includeEdge[2]) {\\n                continue;\\n            }\\n            int u = edge[0];\\n            int v = edge[1];\\n            int cost = edge[2];\\n            int p1 = find(u, parent);\\n            int p2 = find(v, parent);\\n            if(p1 != p2) {\\n                union(p1, p2, parent);\\n                ans += cost;\\n                size += 1;\\n            }\\n        }\\n\\n        return (size == n - 1) ? ans : Integer.MAX_VALUE; \\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int originalEdges[][] = new int[edges.length][3];\\n        for(int i = 0; i < edges.length; i++) {\\n            originalEdges[i][0] = edges[i][0];\\n            originalEdges[i][1] = edges[i][1];\\n            originalEdges[i][2] = edges[i][2];\\n        }\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        int originalCost = mst(n, edges, null, null);\\n        for(int i = 0; i < originalEdges.length; i++) {\\n            int excludedCost = mst(n, edges, null, originalEdges[i]);\\n            int includedCost = mst(n, edges, originalEdges[i], null);\\n            if(excludedCost > originalCost) {\\n                criticalEdges.add(i);\\n            } else if(includedCost == originalCost) {\\n                pseudoCriticalEdges.add(i);\\n            }\\n        }\\n        result.add(criticalEdges);\\n        result.add(pseudoCriticalEdges);\\n        return result;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution :\\n    def find(self,u,parent):\\n        if u == parent[u] : return u\\n        return self.find(parent[u], parent)\\n\\n    def unionDSU(self,u,v,parent) :\\n        p1 = self.find(u, parent)\\n        p2 = self.find(v, parent)\\n        parent[p2] = p1\\n\\n    def mst(self,n,edges,includeEdge,excludeEdge) :\\n\\n        parent=[]\\n        for i in range(n): \\n            parent.append(i);\\n        \\n        ans = 0\\n        count = 0\\n\\n        if len(includeEdge) != 0 :\\n            self.unionDSU(includeEdge[0], includeEdge[1], parent)\\n            ans += includeEdge[2]\\n            count += 1\\n        \\n        for edge in edges:\\n            u = edge[0];\\n            v = edge[1];\\n            cost = edge[2];\\n\\n            if len(excludeEdge) != 0 and excludeEdge[0] == u and excludeEdge[1] == v and excludeEdge[2] == cost :\\n                continue\\n            \\n\\n            if len(includeEdge) != 0 and includeEdge[0] == u and includeEdge[1] == v and includeEdge[2] == cost :\\n                continue\\n            \\n\\n            p1 = self.find(u, parent)\\n            p2 = self.find(v, parent)\\n\\n            if p1 != p2:\\n                self.unionDSU(p1, p2, parent)\\n                ans += cost\\n                count += 1\\n            \\n        \\n        return  ans if count==n-1 else float(\\'inf\\')\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        \\n        originalEdges=[]\\n        for edge in edges : \\n            originalEdge=[edge[0], edge[1], edge[2]]\\n            originalEdges.append(originalEdge)\\n        \\n\\n        result=[]\\n        criticalEdges=[]\\n        pseudoCriticalEdges=[]\\n\\n        \\n        edges=sorted(edges, key = lambda x: x[2])\\n\\n        emptyVector=[]\\n        originalCost = self.mst(n, edges, emptyVector, emptyVector)\\n\\n        \\n        for i in range(len(originalEdges)): \\n\\n            excludedCost = self.mst(n, edges, emptyVector, originalEdges[i])\\n            includedCost = self.mst(n, edges, originalEdges[i], emptyVector)\\n\\n            if excludedCost > originalCost :\\n                criticalEdges.append(i)\\n            elif includedCost == originalCost : \\n                pseudoCriticalEdges.append(i)\\n            \\n        \\n        result.append(criticalEdges)\\n        result.append(pseudoCriticalEdges)\\n        return result\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int find(int u, vector<int>& parent) {\\n        if(u == parent[u]) return u;\\n        return find(parent[u], parent);\\n    }\\n\\n    void unionDSU(int u, int v, vector<int>& parent) {\\n        int p1 = find(u, parent);\\n        int p2 = find(v, parent);\\n        parent[p2] = p1;\\n    }\\n\\n    int mst(int n, vector<vector<int>>& edges, vector<int>& includeEdge, vector<int>& excludeEdge) {\\n\\n        vector<int> parent;\\n        for(int i = 0; i < n; i++) {\\n            parent.push_back(i);\\n        }\\n        int ans = 0;\\n        int count = 0;\\n\\n        if(includeEdge.size() != 0) {\\n            unionDSU(includeEdge[0], includeEdge[1], parent);\\n            ans += includeEdge[2];\\n            count += 1;\\n        }\\n        for(auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int cost = edge[2];\\n\\n            if(excludeEdge.size() != 0 && excludeEdge[0] == u && excludeEdge[1] == v && excludeEdge[2] == cost) {\\n                continue;\\n            }\\n\\n            if(includeEdge.size() != 0 && includeEdge[0] == u && includeEdge[1] == v && includeEdge[2] == cost) {\\n                continue;\\n            }\\n\\n            int p1 = find(u, parent);\\n            int p2 = find(v, parent);\\n\\n            if(p1 != p2) {\\n                unionDSU(p1, p2, parent);\\n                ans += cost;\\n                count += 1;\\n            }\\n        }\\n        return count == n - 1 ? ans : INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> originalEdges;\\n        for(auto edge : edges) {\\n            vector<int> originalEdge{edge[0], edge[1], edge[2]};\\n            originalEdges.push_back(originalEdge);\\n        }\\n\\n        vector<vector<int>> result;\\n        vector<int> criticalEdges;\\n        vector<int> pseudoCriticalEdges;\\n\\n        sort(edges.begin(), edges.end(), \\n        [](const vector<int> &x, const vector<int> &y) { return x[2] < y[2]; });\\n\\n        vector<int> emptyVector;\\n        int originalCost = mst(n, edges, emptyVector, emptyVector);\\n\\n        for(int i = 0; i < originalEdges.size(); i++) {\\n            int excludedCost = mst(n, edges, emptyVector, originalEdges[i]);\\n            int includedCost = mst(n, edges, originalEdges[i], emptyVector);\\n            if(excludedCost > originalCost) {\\n                criticalEdges.push_back(i);\\n            } else if(includedCost == originalCost) {\\n                pseudoCriticalEdges.push_back(i);\\n            }\\n        }\\n        result.push_back(criticalEdges);\\n        result.push_back(pseudoCriticalEdges);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697725,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=Ryrt3A0frRo\\n\\nNot doing well, too many failed attempts.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=Ryrt3A0frRo\\n\\nNot doing well, too many failed attempts.",
                "codeTag": "Unknown"
            },
            {
                "id": 702027,
                "title": "python3-prim-s-algo",
                "content": "Prim\\'s algo \\nPer [Wikipedia](https://en.wikipedia.org/wiki/Prim%27s_algorithm), Prim\\'s (also known as Jarn\\xEDk\\'s) algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex. \\n\\nMy implementation reflects below coursera course by Prof. Robert Sedgewick\\nhttps://www.coursera.org/lecture/algorithms-part2/prims-algorithm-HoHKu\\n\\n```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = dict()\\n        for u, v, w in edges: \\n            graph.setdefault(u, []).append((v, w))\\n            graph.setdefault(v, []).append((u, w))\\n            \\n        ref = self.mst(n, graph)\\n        critical, pseudo = [], []\\n        for i in range(len(edges)):\\n            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)\\n            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)\\n        return [critical, pseudo]\\n            \\n        \\n    def mst(self, n, graph, init=None, exclude=None):\\n        \"\"\"Return weight of MST of given graph using Prim\\'s algo\"\"\"\\n\\n        def visit(u): \\n            \"\"\"Mark node and put its edges to priority queue\"\"\"\\n            marked[u] = True\\n            for v, w in graph.get(u, []):\\n                if exclude and u in exclude and v in exclude: continue\\n                if not marked[v]: heappush(pq, (w, u, v))\\n                    \\n        ans = 0\\n        marked = [False]*n\\n        pq = [] #min prioirty queue\\n        \\n        if init: \\n            u, v, w = init\\n            ans += w\\n            marked[u] = marked[v] = True\\n            visit(u) or visit(v)\\n        else:\\n            visit(0)\\n\\n        while pq: \\n            w, u, v = heappop(pq)\\n            if marked[u] and marked[v]: continue\\n            ans += w\\n            if not marked[u]: visit(u)\\n            if not marked[v]: visit(v)\\n                \\n        return ans if all(marked) else inf\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        graph = dict()\\n        for u, v, w in edges: \\n            graph.setdefault(u, []).append((v, w))\\n            graph.setdefault(v, []).append((u, w))\\n            \\n        ref = self.mst(n, graph)\\n        critical, pseudo = [], []\\n        for i in range(len(edges)):\\n            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)\\n            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)\\n        return [critical, pseudo]\\n            \\n        \\n    def mst(self, n, graph, init=None, exclude=None):\\n        \"\"\"Return weight of MST of given graph using Prim\\'s algo\"\"\"\\n\\n        def visit(u): \\n            \"\"\"Mark node and put its edges to priority queue\"\"\"\\n            marked[u] = True\\n            for v, w in graph.get(u, []):\\n                if exclude and u in exclude and v in exclude: continue\\n                if not marked[v]: heappush(pq, (w, u, v))\\n                    \\n        ans = 0\\n        marked = [False]*n\\n        pq = [] #min prioirty queue\\n        \\n        if init: \\n            u, v, w = init\\n            ans += w\\n            marked[u] = marked[v] = True\\n            visit(u) or visit(v)\\n        else:\\n            visit(0)\\n\\n        while pq: \\n            w, u, v = heappop(pq)\\n            if marked[u] and marked[v]: continue\\n            ans += w\\n            if not marked[u]: visit(u)\\n            if not marked[v]: visit(v)\\n                \\n        return ans if all(marked) else inf\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930534,
                "title": "c-kruskal-s-algorithm-beats-95-26-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is Graph Theory Problem for Master\\'s Degree Study. Krusal\\'s algorithm in short:\\n```\\n        for(int i=0; i<e; i++){// in ascending order w.r.t weights\\n            auto& edge=edges[i];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            dist+=d;//sum for weights\\n        }\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Kruskal\\'s algorithm based on Union Find.\\n1. Sort the edges with indexes i\\'s w.r.t. weight\\n2. Compute the weight for MST by using Kruskal\\'s algorithm\\n3. Use Kruskal\\'s Algorithm to compute the minimal weighted spanning tree according to edges[i] exclusive or inclusive. With this info one can find  the critical edges and pseudo-critical edges\\n\\nLet\\'s consider the test case\\n```\\n14\\n[[0,1,13],[0,2,6],[2,3,13],[3,4,4],[0,5,11],[4,6,14],[4,7,8],[2,8,6],[4,9,6],[7,10,4],[5,11,3],[6,12,7],[12,13,9],[7,13,2],[5,13,10],[0,6,4],[2,7,3],[0,7,8],[1,12,9],[10,12,11],[1,2,7],[1,3,10],[3,10,6],[6,10,4],[4,8,5],[1,13,4],[11,13,8],[2,12,10],[5,8,1],[3,7,6],[7,12,12],[1,7,9],[5,9,1],[2,13,10],[10,11,4],[3,5,10],[6,11,14],[5,12,3],[0,8,13],[8,9,1],[3,6,8],[0,3,4],[2,9,6],[0,11,4],[2,5,14],[4,11,2],[7,11,11],[1,11,6],[2,10,12],[0,13,4],[3,9,9],[4,12,3],[6,7,10],[6,8,13],[9,11,3],[1,6,2],[2,4,12],[0,10,3],[3,12,1],[3,8,12],[1,8,6],[8,13,2],[10,13,12],[9,13,11],[2,11,14],[5,10,9],[5,6,10],[2,6,9],[4,10,7],[3,13,10],[4,13,3],[3,11,9],[7,9,14],[6,9,5],[1,5,12],[4,5,3],[11,12,3],[0,4,8],[5,7,8],[9,12,13],[8,12,12],[1,10,6],[1,9,9],[7,8,9],[9,10,13],[8,11,3],[6,13,7],[0,12,10],[1,4,8],[8,10,2]]\\n```\\nUse Kruskal\\'s Algorithm to compute the minimal weighted spanning tree according to edges[i] exclusive or inclusive as follows\\n```\\nminimal weight=29\\n28-> excl:29 incl:29\\n32-> excl:29 incl:29\\n39-> excl:29 incl:29\\n58-> excl:32 incl:29\\n13-> excl:31 incl:29\\n45-> excl:30 incl:29\\n55-> excl:31 incl:29\\n61-> excl:30 incl:29\\n89-> excl:31 incl:29\\n10-> excl:29 incl:29\\n16-> excl:32 incl:29\\n37-> excl:29 incl:29\\n51-> excl:29 incl:29\\n54-> excl:29 incl:29\\n57-> excl:30 incl:29\\n70-> excl:29 incl:29\\n75-> excl:29 incl:29\\n76-> excl:29 incl:29\\n85-> excl:29 incl:29\\n3-> excl:29 incl:30\\n9-> excl:29 incl:31\\n15-> excl:29 incl:29\\n23-> excl:29 incl:29\\n25-> excl:29 incl:29\\n34-> excl:29 incl:30\\n41-> excl:29 incl:30\\n43-> excl:29 incl:30\\n49-> excl:29 incl:30\\n24-> excl:29 incl:31\\n73-> excl:29 incl:30\\n1-> excl:29 incl:32\\n7-> excl:29 incl:32\\n8-> excl:29 incl:32\\n22-> excl:29 incl:32\\n29-> excl:29 incl:32\\n42-> excl:29 incl:32\\n47-> excl:29 incl:31\\n60-> excl:29 incl:31\\n81-> excl:29 incl:31\\n11-> excl:29 incl:32\\n20-> excl:29 incl:32\\n68-> excl:29 incl:33\\n86-> excl:29 incl:32\\n6-> excl:29 incl:34\\n17-> excl:29 incl:34\\n26-> excl:29 incl:34\\n40-> excl:29 incl:33\\n77-> excl:29 incl:34\\n78-> excl:29 incl:35\\n88-> excl:29 incl:33\\n12-> excl:29 incl:35\\n18-> excl:29 incl:34\\n31-> excl:29 incl:34\\n50-> excl:29 incl:35\\n65-> excl:29 incl:36\\n67-> excl:29 incl:34\\n71-> excl:29 incl:35\\n82-> excl:29 incl:34\\n83-> excl:29 incl:36\\n14-> excl:29 incl:37\\n21-> excl:29 incl:35\\n27-> excl:29 incl:36\\n33-> excl:29 incl:36\\n35-> excl:29 incl:36\\n52-> excl:29 incl:35\\n66-> excl:29 incl:35\\n69-> excl:29 incl:36\\n87-> excl:29 incl:36\\n4-> excl:29 incl:37\\n19-> excl:29 incl:37\\n46-> excl:29 incl:37\\n63-> excl:29 incl:38\\n30-> excl:29 incl:38\\n48-> excl:29 incl:38\\n56-> excl:29 incl:38\\n59-> excl:29 incl:38\\n62-> excl:29 incl:39\\n74-> excl:29 incl:37\\n80-> excl:29 incl:38\\n0-> excl:29 incl:38\\n2-> excl:29 incl:39\\n38-> excl:29 incl:39\\n53-> excl:29 incl:38\\n79-> excl:29 incl:39\\n84-> excl:29 incl:40\\n5-> excl:29 incl:39\\n36-> excl:29 incl:39\\n44-> excl:29 incl:40\\n64-> excl:29 incl:40\\n72-> excl:29 incl:41\\n```\\nIt\\'s possible to modify the code with some Optimizations by reducing the times of applying Kruskal\\'s algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\\n# Proposition 1\\n$$\\n\\\\{Critical\\\\}\\\\subset \\\\bigcap MST \\n$$\\nProof. Suppose there were some critical edge e which is not contained in in some MST T. But due to the definition for a critical edge \"An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge\" The cost of T is the same as other MST. A contradiction! Q.E.D.\\n# Proposition 2\\n$$\\n\\\\{Pseudo Critical \\\\}\\\\subset \\\\bigcup MST \\\\setminus \\\\bigcap MST \\n$$\\nProof. Just the definition\" a pseudo-critical edge is that which can appear in some MSTs but not all.\" Q.E.D.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Kruskal\\'s algorithm\\nclass UnionFind {    \\n    vector<int> root, rank;\\npublic:\\n    UnionFind(int n) : root(n), rank(n) {\\n        rank.assign(n, 1);\\n        for (int i = 0; i <n; i++) \\n            root[i] = i;\\n    }\\n\\n    int Find(int x) {\\n        if (x == root[x]) return x;\\n        else return root[x] = Find(root[x]);\\n    }\\n\\n    void Union(int x, int y) {\\n        int rX = Find(x), rY = Find(y);\\n        if (rX == rY)  return;\\n        if (rank[rX] > rank[rY]) swap(rX, rY);   \\n        root[rX] = rY;\\n        if (rank[rX]==rank[rY]) rank[rY]++;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return Find(x) == Find(y);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int e;\\n    int Kruskal(int n, vector<vector<int>>& edges, int removal=-1, int inclusive=-1)   \\n    {\\n        UnionFind uf(n);\\n        int dist=0;\\n        if (inclusive!=-1){\\n            auto& edge=edges[inclusive];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            uf.Union(v, w);\\n            dist+=d;\\n        }\\n        for(int i=0; i<e; i++){\\n            auto& edge=edges[i];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            dist+=d;\\n        }\\n        for(int i=1; i<n; i++)\\n            if (!uf.connected(0, i)) return INT_MAX;//disconnected\\n        return dist;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        e=edges.size();\\n        for(int i=0; i<e; i++){\\n            vector<int>& edge=edges[i];\\n            vector<int> e2={edge[2], i, edge[0], edge[1]};\\n            edge=e2;\\n        }\\n        sort(edges.begin(), edges.end());\\n    //    for(auto& ee: edges)\\n    //        cout<<ee[0]<<\",\"<<ee[1]<<\",\"<<ee[2]<<\",\"<<ee[3]<<endl;\\n\\n        int minWeight= Kruskal(n, edges);\\n        cout<<minWeight<<endl;\\n   \\n        vector<int> critical, pseudo_crt;\\n        \\n        for(int j=0; j<e; j++){ \\n            int i=edges[j][1];\\n            int no_j=Kruskal(n, edges, j), w_j=Kruskal(n, edges, -1, j);\\n        //    cout<<i<<\"-> wo:\"<<no_j<<\" with:\"<<w_j<<endl;  \\n            if(minWeight<no_j)\\n                critical.push_back(i);\\n            else if (minWeight==w_j)\\n                pseudo_crt.push_back(i);\\n        }\\n        return {critical, pseudo_crt};\\n    }\\n};\\n```\\n# Code with some Optimizations by reducing the times of applying Kruskal\\'s algorithm Beats 95.26%\\n\\n```\\n//Kruskal\\'s algorithm\\nclass Solution {\\npublic:\\n    int e;\\n    vector<bool> i_edge;\\n    int Kruskal(int n, vector<vector<int>>& edges,  \\n    vector<int>& MST, //edges for Minimal spanning Tree\\n    int removal=-1, int inclusive=-1)   \\n    {\\n        UnionFind uf(n);\\n        int dist=0;\\n        int edges_choosen=0;\\n        if (inclusive!=-1){\\n            auto& edge=edges[inclusive];\\n            int d=edge[0], index=edge[1], v=edge[2], w=edge[3];\\n            uf.Union(v, w);\\n            edges_choosen++;\\n            dist+=d;\\n            MST.push_back(inclusive);\\n        }\\n        \\n        for(int i=0; i<e; i++){\\n            auto& edge=edges[i];\\n            int d=edge[0], index=edge[1], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            edges_choosen++;\\n            dist+=d;\\n            MST.push_back(i);\\n        }\\n        if (edges_choosen!=n-1) return INT_MAX;//disconnected\\n        return dist;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        e=edges.size();\\n        for(int i=0; i<e; i++){\\n            vector<int>& edge=edges[i];\\n            vector<int> e2={edge[2], i, edge[0], edge[1]};\\n            edge=e2;\\n        }\\n        sort(edges.begin(), edges.end());\\n    \\n        vector<int> MST;\\n        int minWeight=Kruskal(n, edges, MST);\\n\\n        vector<int> critical, pseudo_crt;\\n        vector<bool> ctl(e,0);//bool tables for indexs Critical edges\\n        vector<bool> ctl_ps(e,0);// tables for indexes for ctl/ps_ctl edges\\n    //    cout<<\"eMST=[\";\\n        for(int j: MST){\\n            int i=edges[j][1];\\n            vector<int> mst;\\n            int no_j=Kruskal(n, edges, mst, j, -1);\\n            if(minWeight<no_j){\\n                critical.push_back(i);\\n                ctl[i]=1;\\n            }\\n            else if (minWeight==no_j){\\n                for(int k: mst)\\n                    ctl_ps[edges[k][1]]=1;\\n            }     \\n    //        cout<<i<<\",\";\\n        }     \\n    //    cout<<\"]\\\\n\";\\n    //    cout<<minWeight<<endl;\\n         \\n        for(int j=0; j<e; j++){ \\n            int i=edges[j][1];\\n            int w_j;\\n            if (ctl_ps[i]==0){\\n                MST.clear();\\n                w_j=Kruskal(n, edges, MST, -1, j);  \\n            }\\n            if ((ctl_ps[i]||minWeight==w_j) && ctl[i]!=1){\\n                pseudo_crt.push_back(i);\\n                for(int k: MST)\\n                    ctl_ps[edges[k][1]]=1;\\n            }\\n               \\n        }\\n        return {critical, pseudo_crt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n        for(int i=0; i<e; i++){// in ascending order w.r.t weights\\n            auto& edge=edges[i];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            dist+=d;//sum for weights\\n        }\\n```\n```\\n14\\n[[0,1,13],[0,2,6],[2,3,13],[3,4,4],[0,5,11],[4,6,14],[4,7,8],[2,8,6],[4,9,6],[7,10,4],[5,11,3],[6,12,7],[12,13,9],[7,13,2],[5,13,10],[0,6,4],[2,7,3],[0,7,8],[1,12,9],[10,12,11],[1,2,7],[1,3,10],[3,10,6],[6,10,4],[4,8,5],[1,13,4],[11,13,8],[2,12,10],[5,8,1],[3,7,6],[7,12,12],[1,7,9],[5,9,1],[2,13,10],[10,11,4],[3,5,10],[6,11,14],[5,12,3],[0,8,13],[8,9,1],[3,6,8],[0,3,4],[2,9,6],[0,11,4],[2,5,14],[4,11,2],[7,11,11],[1,11,6],[2,10,12],[0,13,4],[3,9,9],[4,12,3],[6,7,10],[6,8,13],[9,11,3],[1,6,2],[2,4,12],[0,10,3],[3,12,1],[3,8,12],[1,8,6],[8,13,2],[10,13,12],[9,13,11],[2,11,14],[5,10,9],[5,6,10],[2,6,9],[4,10,7],[3,13,10],[4,13,3],[3,11,9],[7,9,14],[6,9,5],[1,5,12],[4,5,3],[11,12,3],[0,4,8],[5,7,8],[9,12,13],[8,12,12],[1,10,6],[1,9,9],[7,8,9],[9,10,13],[8,11,3],[6,13,7],[0,12,10],[1,4,8],[8,10,2]]\\n```\n```\\nminimal weight=29\\n28-> excl:29 incl:29\\n32-> excl:29 incl:29\\n39-> excl:29 incl:29\\n58-> excl:32 incl:29\\n13-> excl:31 incl:29\\n45-> excl:30 incl:29\\n55-> excl:31 incl:29\\n61-> excl:30 incl:29\\n89-> excl:31 incl:29\\n10-> excl:29 incl:29\\n16-> excl:32 incl:29\\n37-> excl:29 incl:29\\n51-> excl:29 incl:29\\n54-> excl:29 incl:29\\n57-> excl:30 incl:29\\n70-> excl:29 incl:29\\n75-> excl:29 incl:29\\n76-> excl:29 incl:29\\n85-> excl:29 incl:29\\n3-> excl:29 incl:30\\n9-> excl:29 incl:31\\n15-> excl:29 incl:29\\n23-> excl:29 incl:29\\n25-> excl:29 incl:29\\n34-> excl:29 incl:30\\n41-> excl:29 incl:30\\n43-> excl:29 incl:30\\n49-> excl:29 incl:30\\n24-> excl:29 incl:31\\n73-> excl:29 incl:30\\n1-> excl:29 incl:32\\n7-> excl:29 incl:32\\n8-> excl:29 incl:32\\n22-> excl:29 incl:32\\n29-> excl:29 incl:32\\n42-> excl:29 incl:32\\n47-> excl:29 incl:31\\n60-> excl:29 incl:31\\n81-> excl:29 incl:31\\n11-> excl:29 incl:32\\n20-> excl:29 incl:32\\n68-> excl:29 incl:33\\n86-> excl:29 incl:32\\n6-> excl:29 incl:34\\n17-> excl:29 incl:34\\n26-> excl:29 incl:34\\n40-> excl:29 incl:33\\n77-> excl:29 incl:34\\n78-> excl:29 incl:35\\n88-> excl:29 incl:33\\n12-> excl:29 incl:35\\n18-> excl:29 incl:34\\n31-> excl:29 incl:34\\n50-> excl:29 incl:35\\n65-> excl:29 incl:36\\n67-> excl:29 incl:34\\n71-> excl:29 incl:35\\n82-> excl:29 incl:34\\n83-> excl:29 incl:36\\n14-> excl:29 incl:37\\n21-> excl:29 incl:35\\n27-> excl:29 incl:36\\n33-> excl:29 incl:36\\n35-> excl:29 incl:36\\n52-> excl:29 incl:35\\n66-> excl:29 incl:35\\n69-> excl:29 incl:36\\n87-> excl:29 incl:36\\n4-> excl:29 incl:37\\n19-> excl:29 incl:37\\n46-> excl:29 incl:37\\n63-> excl:29 incl:38\\n30-> excl:29 incl:38\\n48-> excl:29 incl:38\\n56-> excl:29 incl:38\\n59-> excl:29 incl:38\\n62-> excl:29 incl:39\\n74-> excl:29 incl:37\\n80-> excl:29 incl:38\\n0-> excl:29 incl:38\\n2-> excl:29 incl:39\\n38-> excl:29 incl:39\\n53-> excl:29 incl:38\\n79-> excl:29 incl:39\\n84-> excl:29 incl:40\\n5-> excl:29 incl:39\\n36-> excl:29 incl:39\\n44-> excl:29 incl:40\\n64-> excl:29 incl:40\\n72-> excl:29 incl:41\\n```\n```\\n//Kruskal\\'s algorithm\\nclass UnionFind {    \\n    vector<int> root, rank;\\npublic:\\n    UnionFind(int n) : root(n), rank(n) {\\n        rank.assign(n, 1);\\n        for (int i = 0; i <n; i++) \\n            root[i] = i;\\n    }\\n\\n    int Find(int x) {\\n        if (x == root[x]) return x;\\n        else return root[x] = Find(root[x]);\\n    }\\n\\n    void Union(int x, int y) {\\n        int rX = Find(x), rY = Find(y);\\n        if (rX == rY)  return;\\n        if (rank[rX] > rank[rY]) swap(rX, rY);   \\n        root[rX] = rY;\\n        if (rank[rX]==rank[rY]) rank[rY]++;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return Find(x) == Find(y);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int e;\\n    int Kruskal(int n, vector<vector<int>>& edges, int removal=-1, int inclusive=-1)   \\n    {\\n        UnionFind uf(n);\\n        int dist=0;\\n        if (inclusive!=-1){\\n            auto& edge=edges[inclusive];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            uf.Union(v, w);\\n            dist+=d;\\n        }\\n        for(int i=0; i<e; i++){\\n            auto& edge=edges[i];\\n            int d=edge[0], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            dist+=d;\\n        }\\n        for(int i=1; i<n; i++)\\n            if (!uf.connected(0, i)) return INT_MAX;//disconnected\\n        return dist;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        e=edges.size();\\n        for(int i=0; i<e; i++){\\n            vector<int>& edge=edges[i];\\n            vector<int> e2={edge[2], i, edge[0], edge[1]};\\n            edge=e2;\\n        }\\n        sort(edges.begin(), edges.end());\\n    //    for(auto& ee: edges)\\n    //        cout<<ee[0]<<\",\"<<ee[1]<<\",\"<<ee[2]<<\",\"<<ee[3]<<endl;\\n\\n        int minWeight= Kruskal(n, edges);\\n        cout<<minWeight<<endl;\\n   \\n        vector<int> critical, pseudo_crt;\\n        \\n        for(int j=0; j<e; j++){ \\n            int i=edges[j][1];\\n            int no_j=Kruskal(n, edges, j), w_j=Kruskal(n, edges, -1, j);\\n        //    cout<<i<<\"-> wo:\"<<no_j<<\" with:\"<<w_j<<endl;  \\n            if(minWeight<no_j)\\n                critical.push_back(i);\\n            else if (minWeight==w_j)\\n                pseudo_crt.push_back(i);\\n        }\\n        return {critical, pseudo_crt};\\n    }\\n};\\n```\n```\\n//Kruskal\\'s algorithm\\nclass Solution {\\npublic:\\n    int e;\\n    vector<bool> i_edge;\\n    int Kruskal(int n, vector<vector<int>>& edges,  \\n    vector<int>& MST, //edges for Minimal spanning Tree\\n    int removal=-1, int inclusive=-1)   \\n    {\\n        UnionFind uf(n);\\n        int dist=0;\\n        int edges_choosen=0;\\n        if (inclusive!=-1){\\n            auto& edge=edges[inclusive];\\n            int d=edge[0], index=edge[1], v=edge[2], w=edge[3];\\n            uf.Union(v, w);\\n            edges_choosen++;\\n            dist+=d;\\n            MST.push_back(inclusive);\\n        }\\n        \\n        for(int i=0; i<e; i++){\\n            auto& edge=edges[i];\\n            int d=edge[0], index=edge[1], v=edge[2], w=edge[3];\\n            if (i==removal || i==inclusive) continue;\\n            if (uf.Find(v) == uf.Find(w)) continue;\\n            uf.Union(v, w);\\n            edges_choosen++;\\n            dist+=d;\\n            MST.push_back(i);\\n        }\\n        if (edges_choosen!=n-1) return INT_MAX;//disconnected\\n        return dist;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        e=edges.size();\\n        for(int i=0; i<e; i++){\\n            vector<int>& edge=edges[i];\\n            vector<int> e2={edge[2], i, edge[0], edge[1]};\\n            edge=e2;\\n        }\\n        sort(edges.begin(), edges.end());\\n    \\n        vector<int> MST;\\n        int minWeight=Kruskal(n, edges, MST);\\n\\n        vector<int> critical, pseudo_crt;\\n        vector<bool> ctl(e,0);//bool tables for indexs Critical edges\\n        vector<bool> ctl_ps(e,0);// tables for indexes for ctl/ps_ctl edges\\n    //    cout<<\"eMST=[\";\\n        for(int j: MST){\\n            int i=edges[j][1];\\n            vector<int> mst;\\n            int no_j=Kruskal(n, edges, mst, j, -1);\\n            if(minWeight<no_j){\\n                critical.push_back(i);\\n                ctl[i]=1;\\n            }\\n            else if (minWeight==no_j){\\n                for(int k: mst)\\n                    ctl_ps[edges[k][1]]=1;\\n            }     \\n    //        cout<<i<<\",\";\\n        }     \\n    //    cout<<\"]\\\\n\";\\n    //    cout<<minWeight<<endl;\\n         \\n        for(int j=0; j<e; j++){ \\n            int i=edges[j][1];\\n            int w_j;\\n            if (ctl_ps[i]==0){\\n                MST.clear();\\n                w_j=Kruskal(n, edges, MST, -1, j);  \\n            }\\n            if ((ctl_ps[i]||minWeight==w_j) && ctl[i]!=1){\\n                pseudo_crt.push_back(i);\\n                for(int k: MST)\\n                    ctl_ps[edges[k][1]]=1;\\n            }\\n               \\n        }\\n        return {critical, pseudo_crt};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 699223,
                "title": "kruskal-s-algorithm-with-union-find-c",
                "content": "1. Use Kruskal\\'s algorithm to find the base MST\\n2. For each edge, if MST excluding this edge results in higher weights, add this edge to critical edge list. Otherwise, if MST including this edge results in the same weight as in the base MST, add this edge to pseudo-crtitcal edge list.\\n3. Use union-find to detect cycle in each case.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& eds) {\\n        vector<vector<int>> edges;\\n        edges.reserve(eds.size());\\n        copy(eds.begin(), eds.end(), back_inserter(edges));\\n        for (int i = 0; i<edges.size(); i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](vector<int>& a, vector<int>& b){\\n            return a[2]<b[2];\\n        });\\n        int nn = edges.size();\\n        int base = MST(edges, -1, nn, n);\\n        vector<vector<int>> res;\\n        vector<int> cr, pcr;\\n        for (int i = 0; i<nn; i++){\\n          int newVal = MST(edges, i, nn, n);\\n          if (newVal > base) cr.push_back(edges[i][3]);\\n          else{\\n              newVal = MST_p(edges, i, nn, n);\\n              if (newVal == base) pcr.push_back(edges[i][3]);\\n          }\\n        }\\n        res.push_back(cr);\\n        res.push_back(pcr);\\n        return res;\\n    }\\n    int MST(vector<vector<int>>& es, int i, int n, int nn){\\n        vector<int> vec(nn, -1);\\n        int res = 0;\\n        int e_n = 0;\\n        for (int j = 0; j<n; j++){\\n            if (j == i) continue;\\n            vector<int> vv = es[j];\\n            if (find(vec, vv[0]) == find(vec, vv[1])){\\n                continue;\\n            }\\n            res += vv[2];\\n            Union(vec, vv[0], vv[1]);\\n            e_n++;\\n        }\\n        if (e_n < nn-1) return INT_MAX;\\n        return res;\\n    }\\n    int MST_p(vector<vector<int>>& es, int i, int n, int nn){\\n        vector<int> vec(nn, -1);\\n        int res = es[i][2];\\n        Union(vec, es[i][0], es[i][1]);\\n        for (int j = 0; j<n; j++){\\n            if (j == i) continue;\\n            vector<int> vv = es[j];\\n            if (find(vec, vv[0]) == find(vec, vv[1])){\\n                continue;\\n            }\\n            res += vv[2];\\n            Union(vec, vv[0], vv[1]);\\n        }\\n        return res;\\n    }\\n    int find(vector<int>& vec, int i)  \\n    {  \\n        if (vec[i] == -1)  \\n            return i;  \\n        return find(vec, vec[i]);  \\n    }   \\n    void Union(vector<int>& vec, int x, int y)  \\n    {  \\n        int xs = find(vec, x);  \\n        int ys = find(vec, y);  \\n        if(xs != ys) \\n        {  \\n            vec[xs] = ys;  \\n        }  \\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& eds) {\\n        vector<vector<int>> edges;\\n        edges.reserve(eds.size());\\n        copy(eds.begin(), eds.end(), back_inserter(edges));\\n        for (int i = 0; i<edges.size(); i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](vector<int>& a, vector<int>& b){\\n            return a[2]<b[2];\\n        });\\n        int nn = edges.size();\\n        int base = MST(edges, -1, nn, n);\\n        vector<vector<int>> res;\\n        vector<int> cr, pcr;\\n        for (int i = 0; i<nn; i++){\\n          int newVal = MST(edges, i, nn, n);\\n          if (newVal > base) cr.push_back(edges[i][3]);\\n          else{\\n              newVal = MST_p(edges, i, nn, n);\\n              if (newVal == base) pcr.push_back(edges[i][3]);\\n          }\\n        }\\n        res.push_back(cr);\\n        res.push_back(pcr);\\n        return res;\\n    }\\n    int MST(vector<vector<int>>& es, int i, int n, int nn){\\n        vector<int> vec(nn, -1);\\n        int res = 0;\\n        int e_n = 0;\\n        for (int j = 0; j<n; j++){\\n            if (j == i) continue;\\n            vector<int> vv = es[j];\\n            if (find(vec, vv[0]) == find(vec, vv[1])){\\n                continue;\\n            }\\n            res += vv[2];\\n            Union(vec, vv[0], vv[1]);\\n            e_n++;\\n        }\\n        if (e_n < nn-1) return INT_MAX;\\n        return res;\\n    }\\n    int MST_p(vector<vector<int>>& es, int i, int n, int nn){\\n        vector<int> vec(nn, -1);\\n        int res = es[i][2];\\n        Union(vec, es[i][0], es[i][1]);\\n        for (int j = 0; j<n; j++){\\n            if (j == i) continue;\\n            vector<int> vv = es[j];\\n            if (find(vec, vv[0]) == find(vec, vv[1])){\\n                continue;\\n            }\\n            res += vv[2];\\n            Union(vec, vv[0], vv[1]);\\n        }\\n        return res;\\n    }\\n    int find(vector<int>& vec, int i)  \\n    {  \\n        if (vec[i] == -1)  \\n            return i;  \\n        return find(vec, vec[i]);  \\n    }   \\n    void Union(vector<int>& vec, int x, int y)  \\n    {  \\n        int xs = find(vec, x);  \\n        int ys = find(vec, y);  \\n        if(xs != ys) \\n        {  \\n            vec[xs] = ys;  \\n        }  \\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697707,
                "title": "java-variant-of-finding-mst-with-explanation",
                "content": "This question is similar to find MST. But we need some tricks to verify whether an edge \\n\\n1) belongs to at least one MST.\\n2) belongs to every MST.\\n\\nTo check 1), we enforce the MST generating process to include current edge and see whether it has the same value as our MST.\\n\\nTo check 2), we exclude current edge from MST generating process and see whether MST can be obtained.\\n\\n**Solution1**\\nNumber of edges is at most N^2. For each edge, we need to find the MST, which takes O(N^2 logN). So total time complexity is O(N^4 logN)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criq = new ArrayList<>();\\n        List<Integer> pseu_criq = new ArrayList<>();\\n        \\n        int mst = MST(Integer.MAX_VALUE, Integer.MAX_VALUE, edges, n);\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            int notInclude = MST(Integer.MAX_VALUE, i, edges, n);\\n            int mustInclude = MST(i, Integer.MAX_VALUE, edges, n);\\n            \\n            if (notInclude > mst || notInclude == -1) {\\n                criq.add(i);\\n            } else if (mustInclude == mst) {\\n                pseu_criq.add(i);\\n            }\\n        }\\n        \\n        result.add(criq);\\n        result.add(pseu_criq);\\n        \\n        return result;\\n    }\\n    \\n    private int find(int node, int[] parent) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        parent[node] = find(parent[node], parent);\\n        return parent[node];\\n    }\\n    \\n    private int MST(int mustIncludeEdge, int NotIncludeEdge, int[][] edges, int n) {\\n        int result = 0;\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            parent[i] = i;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            if (i != NotIncludeEdge) {\\n                pq.offer(edges[i]);\\n            }\\n        }\\n        \\n        if (mustIncludeEdge != Integer.MAX_VALUE) {\\n            int start = edges[mustIncludeEdge][0];\\n            int end = edges[mustIncludeEdge][1];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            result += edges[mustIncludeEdge][2];\\n            parent[ps] = pe;\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int[] edge = pq.poll();\\n            int pa = find(edge[0], parent), pb = find(edge[1], parent);\\n            if (pa == pb) {\\n                continue;\\n            }\\n            \\n            result += edge[2];\\n            parent[pa] = pb;\\n        }\\n        \\n        // Detect whether graph is connected\\n        for (int i = 1; i < n; i ++) {\\n            if (find(i - 1, parent) != find(i, parent)) {\\n                return -1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n\\n**Solution2: Improve time complexity to O(E^2 + ElogE) by sorting edges first**\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criq = new ArrayList<>();\\n        List<Integer> pseu_criq = new ArrayList<>();\\n        Map<int[], Integer> map = new HashMap<>();\\n        for (int i = 0; i < edges.length; i ++) { //memorize original index of edges\\n            map.put(edges[i], i); \\n        }\\n        Arrays.sort(edges, (a, b) -> (a[2] - b[2]));\\n        int mst = MST(Integer.MAX_VALUE, Integer.MAX_VALUE, edges, n);\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            int notInclude = MST(Integer.MAX_VALUE, i, edges, n);\\n            int mustInclude = MST(i, Integer.MAX_VALUE, edges, n);\\n            \\n            if (notInclude > mst || notInclude == -1) {\\n                criq.add(map.get(edges[i]));\\n            } else if (mustInclude == mst) {\\n                pseu_criq.add(map.get(edges[i]));\\n            }\\n        }\\n        \\n        result.add(criq);\\n        result.add(pseu_criq);\\n        \\n        return result;\\n    }\\n    \\n    private int find(int node, int[] parent) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        parent[node] = find(parent[node], parent);\\n        return parent[node];\\n    }\\n    \\n    private int MST(int mustIncludeEdge, int NotIncludeEdge, int[][] edges, int n) {\\n        int result = 0;\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            parent[i] = i;\\n        }\\n        \\n        if (mustIncludeEdge != Integer.MAX_VALUE) {\\n            int start = edges[mustIncludeEdge][0];\\n            int end = edges[mustIncludeEdge][1];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            result += edges[mustIncludeEdge][2];\\n            parent[ps] = pe;\\n        }\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            if (i == mustIncludeEdge || i == NotIncludeEdge) {\\n                continue;\\n            }\\n            int start = edges[i][0], end = edges[i][1], weight = edges[i][2];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            if (ps != pe) {\\n                result += weight;\\n                parent[ps] = pe;\\n            }\\n        }\\n        \\n        // Detect whether graph is connected\\n        for (int i = 1; i < n; i ++) {\\n            if (find(i - 1, parent) != find(i, parent)) {\\n                return -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criq = new ArrayList<>();\\n        List<Integer> pseu_criq = new ArrayList<>();\\n        \\n        int mst = MST(Integer.MAX_VALUE, Integer.MAX_VALUE, edges, n);\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            int notInclude = MST(Integer.MAX_VALUE, i, edges, n);\\n            int mustInclude = MST(i, Integer.MAX_VALUE, edges, n);\\n            \\n            if (notInclude > mst || notInclude == -1) {\\n                criq.add(i);\\n            } else if (mustInclude == mst) {\\n                pseu_criq.add(i);\\n            }\\n        }\\n        \\n        result.add(criq);\\n        result.add(pseu_criq);\\n        \\n        return result;\\n    }\\n    \\n    private int find(int node, int[] parent) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        parent[node] = find(parent[node], parent);\\n        return parent[node];\\n    }\\n    \\n    private int MST(int mustIncludeEdge, int NotIncludeEdge, int[][] edges, int n) {\\n        int result = 0;\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            parent[i] = i;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[2] - b[2]));\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            if (i != NotIncludeEdge) {\\n                pq.offer(edges[i]);\\n            }\\n        }\\n        \\n        if (mustIncludeEdge != Integer.MAX_VALUE) {\\n            int start = edges[mustIncludeEdge][0];\\n            int end = edges[mustIncludeEdge][1];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            result += edges[mustIncludeEdge][2];\\n            parent[ps] = pe;\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            int[] edge = pq.poll();\\n            int pa = find(edge[0], parent), pb = find(edge[1], parent);\\n            if (pa == pb) {\\n                continue;\\n            }\\n            \\n            result += edge[2];\\n            parent[pa] = pb;\\n        }\\n        \\n        // Detect whether graph is connected\\n        for (int i = 1; i < n; i ++) {\\n            if (find(i - 1, parent) != find(i, parent)) {\\n                return -1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> criq = new ArrayList<>();\\n        List<Integer> pseu_criq = new ArrayList<>();\\n        Map<int[], Integer> map = new HashMap<>();\\n        for (int i = 0; i < edges.length; i ++) { //memorize original index of edges\\n            map.put(edges[i], i); \\n        }\\n        Arrays.sort(edges, (a, b) -> (a[2] - b[2]));\\n        int mst = MST(Integer.MAX_VALUE, Integer.MAX_VALUE, edges, n);\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            int notInclude = MST(Integer.MAX_VALUE, i, edges, n);\\n            int mustInclude = MST(i, Integer.MAX_VALUE, edges, n);\\n            \\n            if (notInclude > mst || notInclude == -1) {\\n                criq.add(map.get(edges[i]));\\n            } else if (mustInclude == mst) {\\n                pseu_criq.add(map.get(edges[i]));\\n            }\\n        }\\n        \\n        result.add(criq);\\n        result.add(pseu_criq);\\n        \\n        return result;\\n    }\\n    \\n    private int find(int node, int[] parent) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        parent[node] = find(parent[node], parent);\\n        return parent[node];\\n    }\\n    \\n    private int MST(int mustIncludeEdge, int NotIncludeEdge, int[][] edges, int n) {\\n        int result = 0;\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i ++) {\\n            parent[i] = i;\\n        }\\n        \\n        if (mustIncludeEdge != Integer.MAX_VALUE) {\\n            int start = edges[mustIncludeEdge][0];\\n            int end = edges[mustIncludeEdge][1];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            result += edges[mustIncludeEdge][2];\\n            parent[ps] = pe;\\n        }\\n        \\n        for (int i = 0; i < edges.length; i ++) {\\n            if (i == mustIncludeEdge || i == NotIncludeEdge) {\\n                continue;\\n            }\\n            int start = edges[i][0], end = edges[i][1], weight = edges[i][2];\\n            int ps = find(start, parent), pe = find(end, parent);\\n            if (ps != pe) {\\n                result += weight;\\n                parent[ps] = pe;\\n            }\\n        }\\n        \\n        // Detect whether graph is connected\\n        for (int i = 1; i < n; i ++) {\\n            if (find(i - 1, parent) != find(i, parent)) {\\n                return -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938760,
                "title": "c-detailed-explanation-time-complexity-analysis-solution-using-krushkal-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the ***problem description*** the followings are **evident**:\\n1. We are dealing with minimum spanning tree (MST).\\n2. Critical edges are present in every possible MSTs.\\n3. Pseudo critical edges are present in only some of the MSTs. (But they must be present in atlest one of the MSTs)\\n\\n**Mental Map:**\\n1. We need to return the indices of this edges, so we will need to store this information in our edgeList datastructure.\\n2. We need a function/methed to find MST (We will use krushkal\\'s Algorithm)\\n\\n\\n# Approach\\n1. Find the \"mst\" of the given graph.\\n2. Now, one by one skipping an edge find the \"curr_mst\" of the graph.\\n-- (Here, Skipping means, not allowing that edge to be part of the MST)\\n3. If \"curr_mst\" > \"mst\" then we can certainly claim that the skipped edge belongs to critical edge.\\n4. If \"curr_mst\" == \"mst\" then this might be a pseudoCritical edge.\\n-- But why \"might be\" ?? \\n    Because, it may happen, this edge will never be part of our MST\\n-- e.g : n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\n    Here, edges[5] = [1,4,6] is never part of a MST (the way are doing the processing, i.e: skipping edge)\\n5. So, to verify this, we will force this edge to be part of our MST, and calculate the \"curr_mst\" again.\\n-- If \"curr_mst\" == \"mst\" (after recalculation), We can certainly say that this, edge belongs to pseudoCritical edge.\\n\\n# Complexity\\n- Time complexity: \\n-- O(E^2 * \\u03B1(V)), \\u03B1: Ackermann Function, E: Edge Count, V: Node Count\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n-- O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU {\\nprivate:\\n    int sz;\\n    vector<int> root, rank;\\npublic:\\n    DSU(int sz){\\n        this->sz = sz;\\n        root.resize(sz);\\n        rank.resize(sz);\\n        for(int i = 0; i < sz; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(root[x] == x) return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    bool unionSet(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return false;\\n        if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        return true;\\n    }\\n\\n    void reset() {\\n        for(int i = 0; i < sz; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    int N;\\n    DSU *dsu;\\n    int edgeCount;\\n    vector<vector<int>> myEdges;\\n    int findMSTwithCondition(int avoidMe, bool alreadyPickedOne) {  \\n        // If avoidMe == -1 then find MST for the given edgeList\\n        // If alreadyPickedOne == true, then our dsu already has that information recorded\\n        // This, function will try to find the MST with above two condition\\n        // If Spanning Tree is not possible it will return INT_MAX\\n        int ans = 0;\\n        int totalOp = 0;\\n        if (alreadyPickedOne) totalOp++;\\n        for (int i = 0; i < edgeCount; i++) {                        // O(edgeCount * \\u03B1(V))\\n            if (totalOp == N - 1) break;\\n            if (myEdges[i][3] == avoidMe) continue;\\n            if (dsu->unionSet(myEdges[i][1], myEdges[i][2])) {\\n                ans += myEdges[i][0];\\n                totalOp++;\\n            }\\n        }\\n        // Reset the DSU\\n        dsu->reset();\\n        return totalOp == N - 1 ? ans : INT_MAX;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        /* Approach:\\n            1. Krushkal Algorithm -- T.C: O(E^2 * \\u03B1(V)), S.C: O(E); V: No. of nodes(n), E: no of edges\\n                -- Intuition:\\n                    -- Find the \"mst\" of the given graph\\n                    -- Now, find the \"curr_mst\" if a particular edge is not selected\\n                    -- If \"curr_mst\" > \"mst\" then edge we skipped belongs to critical edge\\n                    -- If \"curr_mst\" == \"mst\" then this edge might be a pseudoCritical edge\\n                        -- But why \"might be\" ?? Because, it may happen that this edge will never be part of our MST\\n                        -- e.g : n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\n                            Here, edges[5] = [1,4,6] is never part of a MST (the way are doing the processing, i.e: skipping edge)\\n                        So, to verify this, we will force this edge to be part of our MST, and calculate the \"curr_mst\" again\\n                        If \"curr_mst\" == \"mst\" then with certainty we can say this edge belongs to pseudoCritical edge\\n        */\\n\\n        // Approach 1 -- Krushkal\\n        N = n;\\n        edgeCount = edges.size();\\n        myEdges.clear();\\n        myEdges.assign(edgeCount, {});\\n\\n        // Insert index to the edgeList\\n        for (int i = 0; i < edgeCount; i++) {\\n            myEdges[i].push_back(edges[i][2]);\\n            myEdges[i].push_back(edges[i][0]);\\n            myEdges[i].push_back(edges[i][1]);\\n            myEdges[i].push_back(i);\\n        }\\n        // Sort myEdges based on weight                             // T.C: O(E log E)\\n        sort(myEdges.begin(), myEdges.end(), [](auto const &v1, auto const &v2) ->bool {return v1[0] < v2[0];});\\n        // Have a new DSU to find the MST of the tree\\n        dsu = new DSU(N);                     // O(n)\\n        int mst = findMSTwithCondition(-1, false);\\n        if (mst == INT_MAX) {\\n            // Spanning Tree Not possible for this graph\\n            delete dsu;\\n            return {};\\n        }\\n\\n        vector<int> critical;\\n        vector<int> pseudoCritical;\\n        for (int i = 0; i < edgeCount; i++) {                       // T.C: O(edgeCount^2 * \\u03B1(V))\\n            // Find MST by not taking ith edge\\n            int curr_mst = findMSTwithCondition(i, false);\\n            if (curr_mst > mst)                 // Definitely a critical edge\\n                critical.push_back(i);\\n            else if (curr_mst == mst) {         // Might be a pseudoCritical edge\\n                // Let\\'s calculate MST by taking this edge\\n                curr_mst = edges[i][2];\\n                dsu->unionSet(edges[i][0], edges[i][1]);\\n                curr_mst += findMSTwithCondition(-1, true);\\n                if (curr_mst == mst) pseudoCritical.push_back(i);   // We are sure this is a pseudoCritical edge\\n            }\\n        }\\n\\n        delete dsu;\\n        return {critical, pseudoCritical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass DSU {\\nprivate:\\n    int sz;\\n    vector<int> root, rank;\\npublic:\\n    DSU(int sz){\\n        this->sz = sz;\\n        root.resize(sz);\\n        rank.resize(sz);\\n        for(int i = 0; i < sz; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(root[x] == x) return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    bool unionSet(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return false;\\n        if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        return true;\\n    }\\n\\n    void reset() {\\n        for(int i = 0; i < sz; i++){\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    int N;\\n    DSU *dsu;\\n    int edgeCount;\\n    vector<vector<int>> myEdges;\\n    int findMSTwithCondition(int avoidMe, bool alreadyPickedOne) {  \\n        // If avoidMe == -1 then find MST for the given edgeList\\n        // If alreadyPickedOne == true, then our dsu already has that information recorded\\n        // This, function will try to find the MST with above two condition\\n        // If Spanning Tree is not possible it will return INT_MAX\\n        int ans = 0;\\n        int totalOp = 0;\\n        if (alreadyPickedOne) totalOp++;\\n        for (int i = 0; i < edgeCount; i++) {                        // O(edgeCount * \\u03B1(V))\\n            if (totalOp == N - 1) break;\\n            if (myEdges[i][3] == avoidMe) continue;\\n            if (dsu->unionSet(myEdges[i][1], myEdges[i][2])) {\\n                ans += myEdges[i][0];\\n                totalOp++;\\n            }\\n        }\\n        // Reset the DSU\\n        dsu->reset();\\n        return totalOp == N - 1 ? ans : INT_MAX;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        /* Approach:\\n            1. Krushkal Algorithm -- T.C: O(E^2 * \\u03B1(V)), S.C: O(E); V: No. of nodes(n), E: no of edges\\n                -- Intuition:\\n                    -- Find the \"mst\" of the given graph\\n                    -- Now, find the \"curr_mst\" if a particular edge is not selected\\n                    -- If \"curr_mst\" > \"mst\" then edge we skipped belongs to critical edge\\n                    -- If \"curr_mst\" == \"mst\" then this edge might be a pseudoCritical edge\\n                        -- But why \"might be\" ?? Because, it may happen that this edge will never be part of our MST\\n                        -- e.g : n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\n                            Here, edges[5] = [1,4,6] is never part of a MST (the way are doing the processing, i.e: skipping edge)\\n                        So, to verify this, we will force this edge to be part of our MST, and calculate the \"curr_mst\" again\\n                        If \"curr_mst\" == \"mst\" then with certainty we can say this edge belongs to pseudoCritical edge\\n        */\\n\\n        // Approach 1 -- Krushkal\\n        N = n;\\n        edgeCount = edges.size();\\n        myEdges.clear();\\n        myEdges.assign(edgeCount, {});\\n\\n        // Insert index to the edgeList\\n        for (int i = 0; i < edgeCount; i++) {\\n            myEdges[i].push_back(edges[i][2]);\\n            myEdges[i].push_back(edges[i][0]);\\n            myEdges[i].push_back(edges[i][1]);\\n            myEdges[i].push_back(i);\\n        }\\n        // Sort myEdges based on weight                             // T.C: O(E log E)\\n        sort(myEdges.begin(), myEdges.end(), [](auto const &v1, auto const &v2) ->bool {return v1[0] < v2[0];});\\n        // Have a new DSU to find the MST of the tree\\n        dsu = new DSU(N);                     // O(n)\\n        int mst = findMSTwithCondition(-1, false);\\n        if (mst == INT_MAX) {\\n            // Spanning Tree Not possible for this graph\\n            delete dsu;\\n            return {};\\n        }\\n\\n        vector<int> critical;\\n        vector<int> pseudoCritical;\\n        for (int i = 0; i < edgeCount; i++) {                       // T.C: O(edgeCount^2 * \\u03B1(V))\\n            // Find MST by not taking ith edge\\n            int curr_mst = findMSTwithCondition(i, false);\\n            if (curr_mst > mst)                 // Definitely a critical edge\\n                critical.push_back(i);\\n            else if (curr_mst == mst) {         // Might be a pseudoCritical edge\\n                // Let\\'s calculate MST by taking this edge\\n                curr_mst = edges[i][2];\\n                dsu->unionSet(edges[i][0], edges[i][1]);\\n                curr_mst += findMSTwithCondition(-1, true);\\n                if (curr_mst == mst) pseudoCritical.push_back(i);   // We are sure this is a pseudoCritical edge\\n            }\\n        }\\n\\n        delete dsu;\\n        return {critical, pseudoCritical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929233,
                "title": "c-dsu",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a DSU class for union-find operations\\n    class DSU {\\n        vector<int> parent, size;\\n    public:\\n        DSU(int n) {\\n            parent.resize(n);\\n            size.resize(n, 1);\\n            for (int i = 0; i < n; ++i)\\n                parent[i] = i;\\n        }\\n        \\n        int find(int x) {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n        \\n        bool unite(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY)\\n                return false;\\n            \\n            if (size[rootX] < size[rootY]) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            } else {\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n            }\\n            \\n            return true;\\n        }\\n\\n        int getSize(int x) {  // Add a public method to get the size of a set\\n            return size[find(x)];\\n        }\\n    };\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        for (int i = 0; i < m; ++i)\\n            edges[i].push_back(i); // Store the original index\\n        \\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        \\n        DSU dsu(n);\\n        int mstWeight = 0;\\n        for (int i = 0; i < m; ++i) {\\n            if (dsu.unite(edges[i][0], edges[i][1]))\\n                mstWeight += edges[i][2];\\n        }\\n        \\n        vector<int> critical, pseudoCritical;\\n        for (int i = 0; i < m; ++i) {\\n            DSU tempDsu(n);\\n            int weightWithout = 0;\\n            for (int j = 0; j < m; ++j) {\\n                if (i != j && tempDsu.unite(edges[j][0], edges[j][1]))\\n                    weightWithout += edges[j][2];\\n            }\\n            \\n            if (tempDsu.getSize(0) != n || weightWithout > mstWeight)\\n                critical.push_back(edges[i][3]); // Store the original index\\n            else {\\n                DSU newDsu(n);\\n                newDsu.unite(edges[i][0], edges[i][1]);\\n                int weightWith = edges[i][2];\\n                for (int j = 0; j < m; ++j) {\\n                    if (i != j && newDsu.unite(edges[j][0], edges[j][1]))\\n                        weightWith += edges[j][2];\\n                }\\n                \\n                if (weightWith == mstWeight)\\n                    pseudoCritical.push_back(edges[i][3]); // Store the original index\\n            }\\n        }\\n        \\n        return {critical, pseudoCritical};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a DSU class for union-find operations\\n    class DSU {\\n        vector<int> parent, size;\\n    public:\\n        DSU(int n) {\\n            parent.resize(n);\\n            size.resize(n, 1);\\n            for (int i = 0; i < n; ++i)\\n                parent[i] = i;\\n        }\\n        \\n        int find(int x) {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n        \\n        bool unite(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY)\\n                return false;\\n            \\n            if (size[rootX] < size[rootY]) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n            } else {\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n            }\\n            \\n            return true;\\n        }\\n\\n        int getSize(int x) {  // Add a public method to get the size of a set\\n            return size[find(x)];\\n        }\\n    };\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n        for (int i = 0; i < m; ++i)\\n            edges[i].push_back(i); // Store the original index\\n        \\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        \\n        DSU dsu(n);\\n        int mstWeight = 0;\\n        for (int i = 0; i < m; ++i) {\\n            if (dsu.unite(edges[i][0], edges[i][1]))\\n                mstWeight += edges[i][2];\\n        }\\n        \\n        vector<int> critical, pseudoCritical;\\n        for (int i = 0; i < m; ++i) {\\n            DSU tempDsu(n);\\n            int weightWithout = 0;\\n            for (int j = 0; j < m; ++j) {\\n                if (i != j && tempDsu.unite(edges[j][0], edges[j][1]))\\n                    weightWithout += edges[j][2];\\n            }\\n            \\n            if (tempDsu.getSize(0) != n || weightWithout > mstWeight)\\n                critical.push_back(edges[i][3]); // Store the original index\\n            else {\\n                DSU newDsu(n);\\n                newDsu.unite(edges[i][0], edges[i][1]);\\n                int weightWith = edges[i][2];\\n                for (int j = 0; j < m; ++j) {\\n                    if (i != j && newDsu.unite(edges[j][0], edges[j][1]))\\n                        weightWith += edges[j][2];\\n                }\\n                \\n                if (weightWith == mstWeight)\\n                    pseudoCritical.push_back(edges[i][3]); // Store the original index\\n            }\\n        }\\n        \\n        return {critical, pseudoCritical};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929226,
                "title": "beats-98-intuition-approach-explained-hard-made-easy",
                "content": "# Intuition\\nThe intuition behind this solution lies in the fact that critical edges directly impact the MST\\'s weight, while pseudo-critical edges do not necessarily affect the MST\\'s weight. By building the MST and analyzing the impact of removing edges, the algorithm can categorize edges into critical and pseudo-critical groups.\\n\\n# Approach\\nLet\\'s break down the solution step by step :\\n\\n1. **Understanding the DSU:**\\n   - You start by understanding that you need a data structure called **Disjoint Set Union (DSU)** to manage the connectivity of vertices. This data structure has two main operations: finding the parent of a set (group) and uniting two sets.\\n   \\n2. **Sorting Edges for Greedy Selection:**\\n   - You have a list of edges, each with a weight representing its importance. You realize that you can prioritize selecting edges based on their weights to build the Minimum Spanning Tree (MST) greedily.\\n   - So, you sort the edges in ascending order of their weights. This will help you pick edges with the lowest weights first while building the MST.\\n   \\n3. **Building the Minimum Spanning Tree (MST):**\\n   - Now that the edges are sorted, you\\'re ready to construct the MST using a greedy approach.\\n   - You iterate through the sorted edges one by one. For each edge:\\n     - You check if the two nodes of the edge are not already in the same group (set) using the DSU.\\n     - If they are not, you unite the sets containing those nodes (DSU\\'s union operation), signifying that they are now connected in the MST, and you add the edge to the MST.\\n   \\n4. **Finding Critical Edges:**\\n   - With the MST constructed, you focus on identifying critical edges, which are edges that, when removed, would increase the total weight of the MST.\\n   - To find these, you iterate through the edges in your MST:\\n     - For each edge, you temporarily remove it from the MST and calculate the weight of the new MST.\\n     - If this new weight is greater than the original MST weight, you mark the edge as critical. Otherwise, you leave it in the MST.\\n\\n5. **Finding Pseudo-Critical Edges:**\\n   - Next, you want to find pseudo-critical edges, which are edges that could be in some MSTs but not all.\\n   - You iterate through each edge (including the ones not in the MST):\\n     - For each edge, you simulate building an MST without that edge.\\n     - If the weight of this new MST is the same as the weight of the original MST, you consider the edge as pseudo-critical.\\n\\n6. **Final Categorization and Cleaning Up:**\\n   - Now you have two lists: one for critical edges and one for pseudo-critical edges.\\n   - However, some edges could be both critical and pseudo-critical, which you don\\'t want. So you make sure to remove those from the pseudo-critical list.\\n   - Finally, you have a complete list of critical edges and pseudo-critical edges that you can return as the result.\\n\\n# Complexity\\n- Time complexity: $$O(E * log E)$$  mainly comes from the sorting step O(E log E) where E is the number of edges and the DSU operations O(E)\\n\\n- Space complexity: $$O(n + len)$$ where n is the number of vertices and len is the number of edges in the graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class DSU {\\n    public:\\n        int findParent(int node, vector<int>& par) {\\n            if (par[node] == node) return node;\\n            return par[node] = findParent(par[node], par);\\n        }\\n        void Union(int u, int v, vector<int>& size, vector<int>& par) {\\n            int pu = findParent(u, par);\\n            int pv = findParent(v, par);\\n            if (pu == pv) return;\\n            if (size[pu] <= size[pv]) {\\n                par[pu] = pv;\\n                size[pv]++;\\n            } else {\\n                par[pv] = pu;\\n                size[pu]++;\\n            }\\n        }\\n    };\\n\\n    static bool comp(vector<int>& v1, vector<int>& v2) {\\n        return v1[2] < v2[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int len = edges.size();\\n        for (int i = 0; i < len; i++)\\n            edges[i].push_back(i);\\n\\n        sort(edges.begin(), edges.end(), comp);\\n\\n        DSU dsu;\\n        int cost = 0;\\n        vector<int> par(n);\\n        vector<int> size(n, 1);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n        vector<bool> isPart(len, 0);\\n        int c = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (c == n - 1) break;\\n            if (dsu.findParent(edges[i][0], par) != dsu.findParent(edges[i][1], par)) {\\n                dsu.Union(edges[i][0], edges[i][1], size, par);\\n                isPart[edges[i][3]] = 1;\\n                cost += edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical, pseudocritical;\\n        for (int i = 0; i < len; i++) {\\n            DSU tempDSU;\\n            vector<int> tempPar(n, 0);\\n            for (int j = 0; j < n; j++) tempPar[j] = j;\\n\\n            vector<int> tempSize(n, 1);\\n            int tempCost = 0;\\n            vector<bool> temp(len, 0);\\n            int c = 0;\\n            for (int j = 0; j < len; j++) {\\n                if (c == n - 1) break;\\n                if (j == i) continue;\\n                if (tempDSU.findParent(edges[j][0], tempPar) != tempDSU.findParent(edges[j][1], tempPar)) {\\n                    tempDSU.Union(edges[j][0], edges[j][1], tempSize, tempPar);\\n                    temp[edges[j][3]] = 1;\\n                    tempCost += edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if (tempCost == cost) {\\n                for (int k = 0; k < len; k++) {\\n                    if (temp[k]) isPart[k] = 1;\\n                }\\n            } else\\n                critical.push_back(edges[i][3]);\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (isPart[edges[i][3]]) continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n, 0);\\n            for (int j = 0; j < n; j++) tempPar[j] = j;\\n            vector<int> tempSize(n, 1);\\n            int tempCost = 0;\\n            tempDSU.Union(edges[i][0], edges[i][1], tempSize, tempPar);\\n            tempCost += edges[i][2];\\n            int c = 0;\\n            for (int j = 0; j < len; j++) {\\n                if (c == n - 1) break;\\n                if (j == i) continue;\\n                if (tempDSU.findParent(edges[j][0], tempPar) != tempDSU.findParent(edges[j][1], tempPar)) {\\n                    tempDSU.Union(edges[j][0], edges[j][1], tempSize, tempPar);\\n                    tempCost += edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if (tempCost == cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for (auto& it : critical)\\n            isPart[it] = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return { critical, pseudocritical };\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU {\\n    public:\\n        int findParent(int node, vector<int>& par) {\\n            if (par[node] == node) return node;\\n            return par[node] = findParent(par[node], par);\\n        }\\n        void Union(int u, int v, vector<int>& size, vector<int>& par) {\\n            int pu = findParent(u, par);\\n            int pv = findParent(v, par);\\n            if (pu == pv) return;\\n            if (size[pu] <= size[pv]) {\\n                par[pu] = pv;\\n                size[pv]++;\\n            } else {\\n                par[pv] = pu;\\n                size[pu]++;\\n            }\\n        }\\n    };\\n\\n    static bool comp(vector<int>& v1, vector<int>& v2) {\\n        return v1[2] < v2[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int len = edges.size();\\n        for (int i = 0; i < len; i++)\\n            edges[i].push_back(i);\\n\\n        sort(edges.begin(), edges.end(), comp);\\n\\n        DSU dsu;\\n        int cost = 0;\\n        vector<int> par(n);\\n        vector<int> size(n, 1);\\n        for (int i = 0; i < n; i++) par[i] = i;\\n        vector<bool> isPart(len, 0);\\n        int c = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (c == n - 1) break;\\n            if (dsu.findParent(edges[i][0], par) != dsu.findParent(edges[i][1], par)) {\\n                dsu.Union(edges[i][0], edges[i][1], size, par);\\n                isPart[edges[i][3]] = 1;\\n                cost += edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical, pseudocritical;\\n        for (int i = 0; i < len; i++) {\\n            DSU tempDSU;\\n            vector<int> tempPar(n, 0);\\n            for (int j = 0; j < n; j++) tempPar[j] = j;\\n\\n            vector<int> tempSize(n, 1);\\n            int tempCost = 0;\\n            vector<bool> temp(len, 0);\\n            int c = 0;\\n            for (int j = 0; j < len; j++) {\\n                if (c == n - 1) break;\\n                if (j == i) continue;\\n                if (tempDSU.findParent(edges[j][0], tempPar) != tempDSU.findParent(edges[j][1], tempPar)) {\\n                    tempDSU.Union(edges[j][0], edges[j][1], tempSize, tempPar);\\n                    temp[edges[j][3]] = 1;\\n                    tempCost += edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if (tempCost == cost) {\\n                for (int k = 0; k < len; k++) {\\n                    if (temp[k]) isPart[k] = 1;\\n                }\\n            } else\\n                critical.push_back(edges[i][3]);\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (isPart[edges[i][3]]) continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n, 0);\\n            for (int j = 0; j < n; j++) tempPar[j] = j;\\n            vector<int> tempSize(n, 1);\\n            int tempCost = 0;\\n            tempDSU.Union(edges[i][0], edges[i][1], tempSize, tempPar);\\n            tempCost += edges[i][2];\\n            int c = 0;\\n            for (int j = 0; j < len; j++) {\\n                if (c == n - 1) break;\\n                if (j == i) continue;\\n                if (tempDSU.findParent(edges[j][0], tempPar) != tempDSU.findParent(edges[j][1], tempPar)) {\\n                    tempDSU.Union(edges[j][0], edges[j][1], tempSize, tempPar);\\n                    tempCost += edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if (tempCost == cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for (auto& it : critical)\\n            isPart[it] = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return { critical, pseudocritical };\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929197,
                "title": "simple-java-solution-beginner-friendly-easy-to-understand",
                "content": "# Approach\\n```\\nKruskal algorithm + Union Find\\n```\\n\\nCertainly, in this approach, you iterate through all edges while simulating Kruskal\\'s algorithm. For each edge, you skip it and create a new spanning tree. By comparing the new spanning tree\\'s cost with the original minimum spanning tree\\'s cost, you classify the edge as critical if the new cost surpasses the original or if excluding the edge causes disconnection. If the costs match, the edge is marked as pseudo-critical, subject to a subsequent check for inclusion while maintaining the minimum cost. This method helps determine critical edges that must be included, pseudo-critical edges that could be included, and non-critical edges that are safe to omit from the minimum spanning tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  `O(E * V * log(E))` where `E` = number of edges\\n`V` = number of vertices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(E + V)`  where `E` = number of edges\\n`V` = number of vertices.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class UnionFind {\\n        int[] root;\\n        int count;\\n\\n        public UnionFind(int size) {\\n            root = new int[size];\\n            count = size;\\n            for (int i = 0; i < size; i++) root[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n\\n        public void union(int x, int y) {\\n            int rootX = find(x) , rootY = find(y);\\n            if (rootX != rootY) {\\n                root[rootX] = rootY;\\n                count--;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] oldedges) {\\n        int[][] edges = new int[oldedges.length][4];\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            edges[i][0] = oldedges[i][0];\\n            edges[i][1] = oldedges[i][1];\\n            edges[i][2] = oldedges[i][2];\\n            edges[i][3] = i;\\n        }\\n    \\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        int min = cost(n, edges, null, null);\\n        List<Integer> criticals = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            int costWithoutEdge = cost(n, edges, null, edge);\\n            if (costWithoutEdge != min) {\\n                criticals.add(edge[3]);\\n            } else if (costWithoutEdge == min) {\\n                int costWithEdge = cost(n, edges, edge, null);\\n                if (costWithEdge == min) {\\n                    pseudo.add(edge[3]);\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ans.add(criticals);\\n        ans.add(pseudo);\\n        return ans; \\n    }\\n\\n    public int cost(int n, int[][] edges, int[] pick, int[] skip) {\\n        UnionFind uf = new UnionFind(n);\\n\\n        int ans = 0;\\n\\n        if (pick != null) {\\n            ans += pick[2];\\n            uf.union(pick[0], pick[1]);\\n        }\\n        \\n        for (int[] edge: edges) {\\n            if (skip != null) {\\n                if (edge[0] == skip[0] && edge[1] == skip[1]) continue;\\n            }\\n            \\n            if (uf.find(edge[0]) == uf.find(edge[1])) continue;\\n            uf.union(edge[0], edge[1]);\\n            ans += edge[2];\\n            if (uf.count == 1) break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nKruskal algorithm + Union Find\\n```\n```\\nclass Solution {\\n    class UnionFind {\\n        int[] root;\\n        int count;\\n\\n        public UnionFind(int size) {\\n            root = new int[size];\\n            count = size;\\n            for (int i = 0; i < size; i++) root[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n\\n        public void union(int x, int y) {\\n            int rootX = find(x) , rootY = find(y);\\n            if (rootX != rootY) {\\n                root[rootX] = rootY;\\n                count--;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] oldedges) {\\n        int[][] edges = new int[oldedges.length][4];\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            edges[i][0] = oldedges[i][0];\\n            edges[i][1] = oldedges[i][1];\\n            edges[i][2] = oldedges[i][2];\\n            edges[i][3] = i;\\n        }\\n    \\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        int min = cost(n, edges, null, null);\\n        List<Integer> criticals = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            int costWithoutEdge = cost(n, edges, null, edge);\\n            if (costWithoutEdge != min) {\\n                criticals.add(edge[3]);\\n            } else if (costWithoutEdge == min) {\\n                int costWithEdge = cost(n, edges, edge, null);\\n                if (costWithEdge == min) {\\n                    pseudo.add(edge[3]);\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ans.add(criticals);\\n        ans.add(pseudo);\\n        return ans; \\n    }\\n\\n    public int cost(int n, int[][] edges, int[] pick, int[] skip) {\\n        UnionFind uf = new UnionFind(n);\\n\\n        int ans = 0;\\n\\n        if (pick != null) {\\n            ans += pick[2];\\n            uf.union(pick[0], pick[1]);\\n        }\\n        \\n        for (int[] edge: edges) {\\n            if (skip != null) {\\n                if (edge[0] == skip[0] && edge[1] == skip[1]) continue;\\n            }\\n            \\n            if (uf.find(edge[0]) == uf.find(edge[1])) continue;\\n            uf.union(edge[0], edge[1]);\\n            ans += edge[2];\\n            if (uf.count == 1) break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709049,
                "title": "python-kruskal-s-algorithm",
                "content": "```\\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\tgraph = collections.defaultdict(list)\\n\\t# removed- edge that should not be considered, parent - for DSU, (mst_w,k) - initial values\\n\\tdef kruskal(removed, parent, mst_w, k): \\n\\t\\tdef find(x):\\n\\t\\t\\tif x!=parent[x]:\\n\\t\\t\\t\\tparent[x]=find(parent[x])\\n\\t\\t\\treturn parent[x]\\n\\t\\tdef union(x,y):\\n\\t\\t\\tpx,py = find(x),find(y)\\n\\t\\t\\tif px==py: return False\\n\\t\\t\\tparent[px]=py\\n\\t\\t\\treturn True\\n\\t\\tfor _from,_to,w in sorted(edges, key=lambda x:x[2]):\\n\\t\\t\\tedge = [_from,_to,w]\\n\\t\\t\\tif edge==removed: continue\\n\\t\\t\\tif union(_from,_to):\\n\\t\\t\\t\\tmst_w+=w\\n\\t\\t\\t\\tk+=1\\n\\t\\treturn mst_w if k==n else float(\\'inf\\')\\n\\tres = [[],[]]\\n\\t# Original MST weight by considering all edges\\n\\tmst_w = kruskal(None, [i for i in range(n)], 0, 1)\\n\\tfor i,edge in enumerate(edges):\\n\\t    # remove this edge and see if MST weight has increased, if yes -> critical edge\\n\\t\\trem_w = kruskal(edge, [i for i in range(n)], 0, 1)\\n\\t\\tif rem_w > mst_w: \\n\\t\\t\\tres[0].append(i)\\n\\t\\telse:\\n\\t\\t    # If hasn\\'t increased, add this edge to the DSU initial values and see if MST weight remains same, if yes -> pseudo critical edge\\n\\t\\t\\tparent = [i for i in range(n)]\\n\\t\\t\\tparent[edge[0]]=edge[1]\\n\\t\\t\\tadd_w = kruskal(edge, parent, edge[2], 2)\\n\\t\\t\\tif add_w == mst_w:\\n\\t\\t\\t\\tres[1].append(i)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\tgraph = collections.defaultdict(list)\\n\\t# removed- edge that should not be considered, parent - for DSU, (mst_w,k) - initial values\\n\\tdef kruskal(removed, parent, mst_w, k): \\n\\t\\tdef find(x):\\n\\t\\t\\tif x!=parent[x]:\\n\\t\\t\\t\\tparent[x]=find(parent[x])\\n\\t\\t\\treturn parent[x]\\n\\t\\tdef union(x,y):\\n\\t\\t\\tpx,py = find(x),find(y)\\n\\t\\t\\tif px==py: return False\\n\\t\\t\\tparent[px]=py\\n\\t\\t\\treturn True\\n\\t\\tfor _from,_to,w in sorted(edges, key=lambda x:x[2]):\\n\\t\\t\\tedge = [_from,_to,w]\\n\\t\\t\\tif edge==removed: continue\\n\\t\\t\\tif union(_from,_to):\\n\\t\\t\\t\\tmst_w+=w\\n\\t\\t\\t\\tk+=1\\n\\t\\treturn mst_w if k==n else float(\\'inf\\')\\n\\tres = [[],[]]\\n\\t# Original MST weight by considering all edges\\n\\tmst_w = kruskal(None, [i for i in range(n)], 0, 1)\\n\\tfor i,edge in enumerate(edges):\\n\\t    # remove this edge and see if MST weight has increased, if yes -> critical edge\\n\\t\\trem_w = kruskal(edge, [i for i in range(n)], 0, 1)\\n\\t\\tif rem_w > mst_w: \\n\\t\\t\\tres[0].append(i)\\n\\t\\telse:\\n\\t\\t    # If hasn\\'t increased, add this edge to the DSU initial values and see if MST weight remains same, if yes -> pseudo critical edge\\n\\t\\t\\tparent = [i for i in range(n)]\\n\\t\\t\\tparent[edge[0]]=edge[1]\\n\\t\\t\\tadd_w = kruskal(edge, parent, edge[2], 2)\\n\\t\\t\\tif add_w == mst_w:\\n\\t\\t\\t\\tres[1].append(i)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706840,
                "title": "mst-using-kruskal-algorithm-with-disjoint-sets",
                "content": "**Idea** The cost in making the MST is fist found, then based on definition \\nOn removing any edge from our graph ,if we make a new MST and the cost of that MST comes greater than our previous cost , then the edge is a critical edge\\nOn adding any edge to our graph, if we make a new MST from the graph and find that the MST is already containing them (otherwise condition) then it is pseudo critcal \\nJust think of it as {pseudo critical edges} = MST - {critcial edges}\\nThe code for the given can be optimized using PriorityQueues ,but I have considered as simple considering in O(n^2)\\n**Code**\\n```\\nclass Solution {\\n    class DisjointSets{\\n        class Node{\\n            int data;\\n            int rank;\\n            Node parent;\\n        }\\n        HashMap<Integer,Node>nodemap = new HashMap<>();\\n        int count;\\n        void makeSet(int data_){\\n            Node node = new Node(); \\n            node.data = data_; node.parent = node; node.rank = 0;\\n            nodemap.put(data_,node);\\n        }\\n        public Node find(Node node){\\n            if(node == node.parent) return node;\\n            node.parent = find(node.parent);\\n            return node.parent;\\n        }\\n        public int findParent(int node){\\n            return find(nodemap.get(node)).data;\\n        }\\n        public void union(int data1,int data2){\\n            Node node1 = nodemap.get(data1),node2 = nodemap.get(data2);\\n            Node parent1 = find(node1),parent2 = find(node2);\\n            if(parent1 == parent2) return;\\n             if(parent1.rank >= parent2.rank){\\n                parent1.rank = (parent1.rank == parent2.rank)?parent1.rank + 1: parent1.rank;\\n                parent2.parent = parent1;\\n            }\\n             else{\\n                parent1.parent = parent2;\\n                }\\n            count--;\\n        }\\n    }\\n    public int costMST(int n,int [][]edges,int []include,int []exclude){\\n        DisjointSets ds = new DisjointSets();\\n        ds.count = n;\\n        for(int i=0;i<n;i++){\\n            ds.makeSet(i);\\n        }\\n        int finalCost = 0;\\n        if(include!=null){\\n            ds.union(include[0],include[1]);\\n            finalCost+=include[2];\\n        }\\n        for(int []edge : edges){\\n            if(edge!=exclude && ds.findParent(edge[0])!=ds.findParent(edge[1])){\\n                ds.union(edge[0],edge[1]);\\n                finalCost+=edge[2];\\n            }\\n        }\\n        return ds.count == 1? finalCost : Integer.MAX_VALUE;\\n    }\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer>critical = new ArrayList<>();\\n        List<Integer>pseudo = new ArrayList<>();\\n        HashMap<int[],Integer>edgeMap = new HashMap<>();\\n        int counter = 0;\\n        for(int []e : edges){\\n            edgeMap.put(e,counter);\\n            counter++;\\n        }\\n        Arrays.sort(edges,(edge1, edge2)-> Integer.compare(edge1[2],edge2[2]));\\n        int minCost = costMST(n,edges,null,null);\\n        for(int []edge : edges){\\n            int exclusionCost = costMST(n,edges,null,edge);\\n            if(exclusionCost > minCost){\\n                critical.add(edgeMap.get(edge));\\n            }\\n            else{\\n                int inclusionCost = costMST(n,edges,edge,null);\\n                if(inclusionCost == minCost){\\n                    pseudo.add(edgeMap.get(edge));\\n                }\\n            }\\n        }\\n        List<List<Integer>>finalRes = new ArrayList<>();\\n        finalRes.add(critical);\\n        finalRes.add(pseudo);\\n        return finalRes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class DisjointSets{\\n        class Node{\\n            int data;\\n            int rank;\\n            Node parent;\\n        }\\n        HashMap<Integer,Node>nodemap = new HashMap<>();\\n        int count;\\n        void makeSet(int data_){\\n            Node node = new Node(); \\n            node.data = data_; node.parent = node; node.rank = 0;\\n            nodemap.put(data_,node);\\n        }\\n        public Node find(Node node){\\n            if(node == node.parent) return node;\\n            node.parent = find(node.parent);\\n            return node.parent;\\n        }\\n        public int findParent(int node){\\n            return find(nodemap.get(node)).data;\\n        }\\n        public void union(int data1,int data2){\\n            Node node1 = nodemap.get(data1),node2 = nodemap.get(data2);\\n            Node parent1 = find(node1),parent2 = find(node2);\\n            if(parent1 == parent2) return;\\n             if(parent1.rank >= parent2.rank){\\n                parent1.rank = (parent1.rank == parent2.rank)?parent1.rank + 1: parent1.rank;\\n                parent2.parent = parent1;\\n            }\\n             else{\\n                parent1.parent = parent2;\\n                }\\n            count--;\\n        }\\n    }\\n    public int costMST(int n,int [][]edges,int []include,int []exclude){\\n        DisjointSets ds = new DisjointSets();\\n        ds.count = n;\\n        for(int i=0;i<n;i++){\\n            ds.makeSet(i);\\n        }\\n        int finalCost = 0;\\n        if(include!=null){\\n            ds.union(include[0],include[1]);\\n            finalCost+=include[2];\\n        }\\n        for(int []edge : edges){\\n            if(edge!=exclude && ds.findParent(edge[0])!=ds.findParent(edge[1])){\\n                ds.union(edge[0],edge[1]);\\n                finalCost+=edge[2];\\n            }\\n        }\\n        return ds.count == 1? finalCost : Integer.MAX_VALUE;\\n    }\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer>critical = new ArrayList<>();\\n        List<Integer>pseudo = new ArrayList<>();\\n        HashMap<int[],Integer>edgeMap = new HashMap<>();\\n        int counter = 0;\\n        for(int []e : edges){\\n            edgeMap.put(e,counter);\\n            counter++;\\n        }\\n        Arrays.sort(edges,(edge1, edge2)-> Integer.compare(edge1[2],edge2[2]));\\n        int minCost = costMST(n,edges,null,null);\\n        for(int []edge : edges){\\n            int exclusionCost = costMST(n,edges,null,edge);\\n            if(exclusionCost > minCost){\\n                critical.add(edgeMap.get(edge));\\n            }\\n            else{\\n                int inclusionCost = costMST(n,edges,edge,null);\\n                if(inclusionCost == minCost){\\n                    pseudo.add(edgeMap.get(edge));\\n                }\\n            }\\n        }\\n        List<List<Integer>>finalRes = new ArrayList<>();\\n        finalRes.add(critical);\\n        finalRes.add(pseudo);\\n        return finalRes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937762,
                "title": "using-prim-s-algorithm",
                "content": "All solution given (In solution section) uses Kruskal\\'s algorithm.\\nHere is my code which uses Prim\\'s Algorithm.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mst_cost(vector<vector<pair<int,int>>> &g,int a=-1,int b=-1,int w_ab=0){\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int mst = 0;\\n        int num_edge_mst = 0;\\n        unordered_set<int> included;         \\n        if(a==-1 && b==-1){\\n            int min_nbr = -1,w=1e8;\\n            for(int i=0;i<g[0].size();i++){\\n                auto nbr = g[0][i];\\n                if(nbr.second < w){\\n                    w = nbr.second;\\n                    min_nbr = nbr.first;\\n                }\\n            }\\n            a = 0;\\n            b = min_nbr;\\n            w_ab = w;\\n        }    \\n        included.insert(a);\\n        included.insert(b);\\n        pq.push({-1,a});\\n        pq.push({-1,b});\\n        mst += w_ab;\\n        num_edge_mst += 1;  \\n        while(!pq.empty() && num_edge_mst<g.size()-1){      \\n            auto f = pq.top();                          \\n            pq.pop();                                           \\n            if(f.first > 0 && (included.find(f.second)==included.end())){\\n                mst += f.first;\\n                num_edge_mst += 1;\\n                included.insert(f.second);\\n            }                               \\n            for(auto nbr:g[f.second]){\\n                if(included.find(nbr.first) != included.end()) continue;\\n                pq.push({nbr.second,nbr.first});\\n            }                          \\n        }                           \\n        return mst;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<vector<pair<int,int>>> g(n);\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            g[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        int MST = mst_cost(g);  \\n        vector<int> critical;\\n        vector<int> p_critical;\\n        for(int i=0;i<edges.size();i++){\\n            auto e = edges[i];\\n            int a = e[0],b = e[1],w = e[2];\\n            for(int j=0;j<g[a].size();j++){\\n                if(g[a][j].first == b) g[a][j].second = 1001;\\n            }\\n            for(int j=0;j<g[b].size();j++){\\n                if(g[b][j].first == a) g[b][j].second = 1001;\\n            }                                       \\n            int mst_e = mst_cost(g);                          \\n            if(mst_e > MST){\\n                critical.push_back(i);\\n            }\\n            for(int j=0;j<g[a].size();j++){\\n                if(g[a][j].first == b) g[a][j].second = w;\\n            }\\n            for(int j=0;j<g[b].size();j++){\\n                if(g[b][j].first == a) g[b][j].second = w;\\n            }\\n            \\n            int mst_e1 = mst_cost(g,a,b,w);             \\n            if(mst_e1 == MST){\\n                if(mst_e <= MST)\\n                p_critical.push_back(i);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(p_critical);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mst_cost(vector<vector<pair<int,int>>> &g,int a=-1,int b=-1,int w_ab=0){\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int mst = 0;\\n        int num_edge_mst = 0;\\n        unordered_set<int> included;         \\n        if(a==-1 && b==-1){\\n            int min_nbr = -1,w=1e8;\\n            for(int i=0;i<g[0].size();i++){\\n                auto nbr = g[0][i];\\n                if(nbr.second < w){\\n                    w = nbr.second;\\n                    min_nbr = nbr.first;\\n                }\\n            }\\n            a = 0;\\n            b = min_nbr;\\n            w_ab = w;\\n        }    \\n        included.insert(a);\\n        included.insert(b);\\n        pq.push({-1,a});\\n        pq.push({-1,b});\\n        mst += w_ab;\\n        num_edge_mst += 1;  \\n        while(!pq.empty() && num_edge_mst<g.size()-1){      \\n            auto f = pq.top();                          \\n            pq.pop();                                           \\n            if(f.first > 0 && (included.find(f.second)==included.end())){\\n                mst += f.first;\\n                num_edge_mst += 1;\\n                included.insert(f.second);\\n            }                               \\n            for(auto nbr:g[f.second]){\\n                if(included.find(nbr.first) != included.end()) continue;\\n                pq.push({nbr.second,nbr.first});\\n            }                          \\n        }                           \\n        return mst;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        vector<vector<pair<int,int>>> g(n);\\n        for(int i=0;i<edges.size();i++){\\n            g[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            g[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        int MST = mst_cost(g);  \\n        vector<int> critical;\\n        vector<int> p_critical;\\n        for(int i=0;i<edges.size();i++){\\n            auto e = edges[i];\\n            int a = e[0],b = e[1],w = e[2];\\n            for(int j=0;j<g[a].size();j++){\\n                if(g[a][j].first == b) g[a][j].second = 1001;\\n            }\\n            for(int j=0;j<g[b].size();j++){\\n                if(g[b][j].first == a) g[b][j].second = 1001;\\n            }                                       \\n            int mst_e = mst_cost(g);                          \\n            if(mst_e > MST){\\n                critical.push_back(i);\\n            }\\n            for(int j=0;j<g[a].size();j++){\\n                if(g[a][j].first == b) g[a][j].second = w;\\n            }\\n            for(int j=0;j<g[b].size();j++){\\n                if(g[b][j].first == a) g[b][j].second = w;\\n            }\\n            \\n            int mst_e1 = mst_cost(g,a,b,w);             \\n            if(mst_e1 == MST){\\n                if(mst_e <= MST)\\n                p_critical.push_back(i);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(p_critical);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929365,
                "title": "c-mst-fastest-easy-to-understand",
                "content": "# C++ | MST | Fastest | Easy to Understand\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104971,
                "title": "java-union-find-and-kruskal-based-solution-with-comments",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<int[]> weights = new ArrayList<>();\\n        for (int[] edge : edges) {\\n            weights.add(edge);\\n        }\\n        Collections.sort(weights, (w1, w2) -> Integer.compare(w1[2], w2[2]));\\n        \\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n        // Min cost of MST.\\n        int minCost = costOfMST(n, weights, null, null);\\n        for (int i = 0; i < edges.length; ++i) {\\n            int[] edge = edges[i];\\n            if (costOfMST(n, weights, null, edge) > minCost) {\\n                // Without critical edge, cost increases.\\n                critical.add(i);\\n            } else if (costOfMST(n, weights, edge, null) == minCost) {\\n                // Since edge is not critical, as long as it can be part of MST, it\\'s pseudo.\\n                pseudo.add(i);\\n            }\\n        }\\n        return Arrays.asList(critical, pseudo);\\n    }\\n    \\n    private int costOfMST(int n, List<int[]> edges, int[] required, int[] avoid) {\\n        int cost = 0;\\n        DSU dsu = new DSU(n);\\n        if (required != null) {\\n            dsu.union(required[0], required[1]);\\n            cost += required[2];\\n        }\\n        for (int[] edge : edges) {\\n            if (edge != avoid && dsu.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n            if (dsu.getGroups() == 1) {\\n                return cost;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    static class DSU {\\n        private int[] parents;\\n        private int[] rank;\\n        private int size;\\n\\n        public DSU(int size) {\\n          this.size = size;\\n          parents = new int[size];\\n          rank = new int[size];\\n          for (int i = 0; i < size; ++i) {\\n            parents[i] = i;\\n          }\\n        }\\n\\n        public boolean union(int x, int y) {\\n          int parentX = find(x);\\n          int parentY = find(y);\\n          if (parentX == parentY) {\\n            return false;\\n          }\\n\\n          if (rank[parentX] < rank[parentY]) {\\n            parents[parentX] = parentY;\\n          }\\n          else {\\n            parents[parentY] = parentX;\\n            if (rank[parentX] == rank[parentY]) {\\n              ++rank[parentX];\\n            }\\n          }\\n\\n          --size;\\n          return true;\\n        }\\n\\n        public int getGroups() {\\n          return size;\\n        }\\n\\n        public int find(int x) {\\n          while (parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n          }\\n\\n          return parents[x];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<int[]> weights = new ArrayList<>();\\n        for (int[] edge : edges) {\\n            weights.add(edge);\\n        }\\n        Collections.sort(weights, (w1, w2) -> Integer.compare(w1[2], w2[2]));\\n        \\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n        // Min cost of MST.\\n        int minCost = costOfMST(n, weights, null, null);\\n        for (int i = 0; i < edges.length; ++i) {\\n            int[] edge = edges[i];\\n            if (costOfMST(n, weights, null, edge) > minCost) {\\n                // Without critical edge, cost increases.\\n                critical.add(i);\\n            } else if (costOfMST(n, weights, edge, null) == minCost) {\\n                // Since edge is not critical, as long as it can be part of MST, it\\'s pseudo.\\n                pseudo.add(i);\\n            }\\n        }\\n        return Arrays.asList(critical, pseudo);\\n    }\\n    \\n    private int costOfMST(int n, List<int[]> edges, int[] required, int[] avoid) {\\n        int cost = 0;\\n        DSU dsu = new DSU(n);\\n        if (required != null) {\\n            dsu.union(required[0], required[1]);\\n            cost += required[2];\\n        }\\n        for (int[] edge : edges) {\\n            if (edge != avoid && dsu.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n            if (dsu.getGroups() == 1) {\\n                return cost;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n    \\n    static class DSU {\\n        private int[] parents;\\n        private int[] rank;\\n        private int size;\\n\\n        public DSU(int size) {\\n          this.size = size;\\n          parents = new int[size];\\n          rank = new int[size];\\n          for (int i = 0; i < size; ++i) {\\n            parents[i] = i;\\n          }\\n        }\\n\\n        public boolean union(int x, int y) {\\n          int parentX = find(x);\\n          int parentY = find(y);\\n          if (parentX == parentY) {\\n            return false;\\n          }\\n\\n          if (rank[parentX] < rank[parentY]) {\\n            parents[parentX] = parentY;\\n          }\\n          else {\\n            parents[parentY] = parentX;\\n            if (rank[parentX] == rank[parentY]) {\\n              ++rank[parentX];\\n            }\\n          }\\n\\n          --size;\\n          return true;\\n        }\\n\\n        public int getGroups() {\\n          return size;\\n        }\\n\\n        public int find(int x) {\\n          while (parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n          }\\n\\n          return parents[x];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790688,
                "title": "c-dsu-dfs-logic-and-comments",
                "content": "```\\n/* The idea is to construct a MST using Krushkal \\' s and then remove every edge in MST to check if it is critical or pseudo critical edge.\\nAfter removing one of the edge  tree becomes a bipartite graph . Do a dfs to divide the vertex into two regions .\\nNow if any edge(s) with same weight connecting both parts is found the edges are pseudo critical else the edge is critical edge\\nInitially we consider every edge as critical then remove them later if it is not a critical edge\\n*/\\nclass Solution {\\npublic:\\n    int root(vector<int> &v,int x){\\n        while(x!=v[x]){\\n            v[x]=v[v[x]];\\n            x=v[x];\\n        }\\n        return x;\\n    }\\n    bool find(vector<int> &v,int A,int B){\\n        return root(v,A)==root(v,B);\\n    }\\n    void un(vector<int> &v,int A,int B){\\n        int root_A=root(v,A);\\n        int root_B=root(v,B);\\n        v[root_A]=root_B;\\n    }\\n    void init(vector<int> &v,int n){\\n        for(int i=0;i<n;++i){\\n            v[i]=i;\\n        }\\n    }\\n    void dfs(vector<vector<int> >&g,int s,vector<int> &v,int t,int n){\\n        // cout<<s<<\" \";\\n        v[s]=t;\\n        for(int i=0;i<g[s].size();++i){\\n            if(v[g[s][i]]==0 && g[s][i]!=n){\\n                dfs(g,g[s][i],v,t,n);\\n            }\\n        }\\n    }\\n\\t//for debugging\\n    void print(vector<int> &v){\\n        for(int i=0;i<v.size();++i)\\n            cout<<v[i]<<\" \";\\n        cout<<\"\\\\n\";\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> v(n);\\n        init(v,n);\\n        int spnWeight=0;\\n        map<int,vector<int> >m;\\n        for(int i=0;i<edges.size();++i){\\n            edges[i].push_back(i);\\n            m[i]=edges[i];\\n        }\\n        \\n        \\n        sort(edges.begin(),edges.end(),[](vector<int> &v1,vector<int> &v2){\\n            return v1[2]<v2[2];\\n        });\\n        \\n        vector<vector<int> > g(n);\\n        set<int> edgeset;\\n\\t\\t//create MST and store it\\n        for(int i=0;i<edges.size();++i){\\n            if(!find(v,edges[i][0],edges[i][1])){\\n                un(v,edges[i][0],edges[i][1]);\\n                g[edges[i][0]].push_back(edges[i][1]);\\n                g[edges[i][1]].push_back(edges[i][0]);\\n                edgeset.insert(edges[i][3]);\\n                spnWeight+=edges[i][2];\\n            }\\n        }\\n        // cout<<spnWeight<<\"\\\\n\";\\n        set<int> pseud;\\n        vector<int> er;\\n\\t\\t\\n\\t\\t//iterate over the edges and find the critical edges\\n        for(int i:edgeset){\\n            vector<int> vertex(n);\\n            dfs(g,m[i][0],vertex,1,m[i][1]);\\n            dfs(g,m[i][1],vertex,2,m[i][0]);\\n            // print(vertex);\\n            bool f=true;\\n            for(int j=0;j<edges.size();++j){\\n                if(edges[j][2]<m[i][2]) continue;\\n                if(edges[j][2]>m[i][2]) break;\\n                if(edges[j][2]==m[i][2] && vertex[edges[j][0]]!=vertex[edges[j][1]]){\\n                    // cout<<1<<\" \";\\n                    if(m[i][3]!=edges[j][3]){\\n                        pseud.insert(edges[j][3]);\\n                        f=false;\\n                    }\\n                }\\n            }\\n            \\n            if(!f){\\n                pseud.insert(m[i][3]);\\n                er.push_back(i);\\n            }\\n        }\\n        for(int i=0;i<er.size();++i){\\n            edgeset.erase(er[i]);\\n        }\\n        vector<int> critical,pseudo;\\n        for(int i:edgeset)\\n            critical.push_back(i);\\n        for(int i:pseud)\\n            pseudo.push_back(i);\\n        \\n        vector<vector<int> >ans;\\n        ans.push_back(critical);\\n        ans.push_back(pseudo);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int root(vector<int> &v,int x){\\n        while(x!=v[x]){\\n            v[x]=v[v[x]];\\n            x=v[x];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 698247,
                "title": "java-kruskals",
                "content": "```\\nclass Solution {\\n    \\n    int[][] edges;\\n    int n;\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int _n, int[][] _edges) {\\n        this.edges = _edges;\\n        this.n = _n;\\n        List<Integer> critical = new ArrayList<Integer>();\\n        List<Integer> nonCritical = new ArrayList<Integer>();\\n        Map<int[],Integer> graph = new HashMap<int[],Integer>();\\n        for(int i = 0; i<edges.length;i++)graph.put(edges[i],i);\\n        Arrays.sort(edges,(a,b)->a[2]-b[2]);\\n        int minSpanningTree = findMinSpanningTree(0,-1);\\n        for(int i = 0; i<edges.length;i++){\\n            int index = graph.get(edges[i]);\\n            if(findMinSpanningTree(0,i)>minSpanningTree)critical.add(index);\\n            else if(findMinSpanningTree(i,-1)==minSpanningTree)nonCritical.add(index);\\n        }\\n        return List.of(critical,nonCritical);\\n    }\\n    \\n    private int findMinSpanningTree(int start, int skip){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        if(skip!=0){\\n           uf.union(edges[start][0],edges[start][1]);\\n           cost+=edges[start][2]; \\n        }\\n        for(int i =0; i<edges.length;i++){\\n            if(i==skip)continue;\\n            int[] edge = edges[i];\\n            if(uf.find(edge[0])!=uf.find(edge[1])){\\n                uf.union(edge[0],edge[1]);\\n                cost+=edge[2];\\n            }\\n        }\\n        return uf.count == n-1 ? cost : Integer.MAX_VALUE;\\n    }\\n    \\n    class UnionFind{\\n        \\n        int[] parent;\\n        int count;\\n        \\n        public UnionFind(int n){\\n            this.parent = new int[n];\\n            this.count = 0;\\n            for(int i = 0;i<n;i++)this.parent[i] = i;\\n        }\\n        \\n        public void union(int a, int b){\\n            this.count++;\\n            a = find(a);\\n            b = find(b);\\n            parent[a] = b;\\n        }\\n        \\n        public int find(int n){\\n            while(parent[n]!=n){\\n                n = parent[n];\\n            }\\n            return n;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] edges;\\n    int n;\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int _n, int[][] _edges) {\\n        this.edges = _edges;\\n        this.n = _n;\\n        List<Integer> critical = new ArrayList<Integer>();\\n        List<Integer> nonCritical = new ArrayList<Integer>();\\n        Map<int[],Integer> graph = new HashMap<int[],Integer>();\\n        for(int i = 0; i<edges.length;i++)graph.put(edges[i],i);\\n        Arrays.sort(edges,(a,b)->a[2]-b[2]);\\n        int minSpanningTree = findMinSpanningTree(0,-1);\\n        for(int i = 0; i<edges.length;i++){\\n            int index = graph.get(edges[i]);\\n            if(findMinSpanningTree(0,i)>minSpanningTree)critical.add(index);\\n            else if(findMinSpanningTree(i,-1)==minSpanningTree)nonCritical.add(index);\\n        }\\n        return List.of(critical,nonCritical);\\n    }\\n    \\n    private int findMinSpanningTree(int start, int skip){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        if(skip!=0){\\n           uf.union(edges[start][0],edges[start][1]);\\n           cost+=edges[start][2]; \\n        }\\n        for(int i =0; i<edges.length;i++){\\n            if(i==skip)continue;\\n            int[] edge = edges[i];\\n            if(uf.find(edge[0])!=uf.find(edge[1])){\\n                uf.union(edge[0],edge[1]);\\n                cost+=edge[2];\\n            }\\n        }\\n        return uf.count == n-1 ? cost : Integer.MAX_VALUE;\\n    }\\n    \\n    class UnionFind{\\n        \\n        int[] parent;\\n        int count;\\n        \\n        public UnionFind(int n){\\n            this.parent = new int[n];\\n            this.count = 0;\\n            for(int i = 0;i<n;i++)this.parent[i] = i;\\n        }\\n        \\n        public void union(int a, int b){\\n            this.count++;\\n            a = find(a);\\n            b = find(b);\\n            parent[a] = b;\\n        }\\n        \\n        public int find(int n){\\n            while(parent[n]!=n){\\n                n = parent[n];\\n            }\\n            return n;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698236,
                "title": "python-pretty-simple-solution-with-prim-s-commented-no-union-find-cause-i-m-scared-of-that-shit",
                "content": "Prim\\'s is the most straightforward solution for me, since Kruskal\\'s needs to maintain like union-find trees which I tend to avoid, and Beluga\\'s algorithm or whatever it\\'s called... also needs to maintain union-find structures?  But Prim\\'s is nice and prim: you only need to think of one tree that you continually grow, so all you need is a set of vertices that are in the tree, and a queue of edges-to-explore that come out of the tree.\\n\\n```python\\nfrom heapq import heappush, heappop\\n\\ndef prims(n, adj, must = None):\\n    \"\"\"takes n, adjacency list `adj`, and optionally a (u,v,weight) edge `must`. \\n\\tIf `must` is given, start prim\\'s with that edge and those two vertices already present.\\n\\tReturns the size of the MST (or a really really big number if impossible i.e. graph is disconnected).\"\"\"\\n    frontier = []\\n    vs = set()\\n    ans = 0\\n    def process_vertex(ve):\\n        for edge in adj[ve]:\\n            if edge[0] in vs:\\n                continue\\n            heappush(frontier, (edge[1], edge[0]))\\n        vs.add(ve)\\n    if must is not None:\\n        ans += must[2]\\n        process_vertex(must[0])\\n        process_vertex(must[1])\\n    else:\\n        process_vertex(0)\\n    while len(vs) < n:\\n        if len(frontier) == 0:\\n            return 100000000000000000\\n        w, u = heappop(frontier)\\n        if u in vs:\\n            continue\\n        ans += w\\n        process_vertex(u)\\n    return ans\\n    \\ndef make_adj(n, edges):\\n    adj = [[] for i in range(n)]\\n    for edge in edges:\\n        u, v, w = edge\\n        adj[u].append((v, w))\\n        adj[v].append((u, w))\\n    return adj\\n\\ndef remove_edge(edges, i):\\n    return [edge for j, edge in enumerate(edges) if j!=i]\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t    # first, find the size of the MST\\n        adj = make_adj(n, edges)\\n        minimum = prims(n, adj)\\n        crit = []\\n        pseu = []\\n        print(minimum)\\n\\t\\t# now, for each edge, check an MST which must use that edge, and check an MST that can\\'t use that edge.\\n\\t\\t# for each, if the size of the MST matches the size of the original MST, we know if the edge is critical and/or pseudocritical\\n        for i in range(len(edges)):\\n\\t\\t   # get size of MST that must use this edge. If as small as original, this edge is pseudocritical.\\n            if prims(n, adj, edges[i]) == minimum:\\n                pseu.append(i)\\n\\t\\t\\t# get size of MST on the graph that has this edge removed.  If it\\'s not as small as original, this edge is critical.\\n            e = remove_edge(edges, i)\\n            adj_p = make_adj(n, e)\\n            if prims(n, adj_p) > minimum:\\n                crit.append(i)\\n        return [crit, list(set(pseu) - set(crit))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom heapq import heappush, heappop\\n\\ndef prims(n, adj, must = None):\\n    \"\"\"takes n, adjacency list `adj`, and optionally a (u,v,weight) edge `must`. \\n\\tIf `must` is given, start prim\\'s with that edge and those two vertices already present.\\n\\tReturns the size of the MST (or a really really big number if impossible i.e. graph is disconnected).\"\"\"\\n    frontier = []\\n    vs = set()\\n    ans = 0\\n    def process_vertex(ve):\\n        for edge in adj[ve]:\\n            if edge[0] in vs:\\n                continue\\n            heappush(frontier, (edge[1], edge[0]))\\n        vs.add(ve)\\n    if must is not None:\\n        ans += must[2]\\n        process_vertex(must[0])\\n        process_vertex(must[1])\\n    else:\\n        process_vertex(0)\\n    while len(vs) < n:\\n        if len(frontier) == 0:\\n            return 100000000000000000\\n        w, u = heappop(frontier)\\n        if u in vs:\\n            continue\\n        ans += w\\n        process_vertex(u)\\n    return ans\\n    \\ndef make_adj(n, edges):\\n    adj = [[] for i in range(n)]\\n    for edge in edges:\\n        u, v, w = edge\\n        adj[u].append((v, w))\\n        adj[v].append((u, w))\\n    return adj\\n\\ndef remove_edge(edges, i):\\n    return [edge for j, edge in enumerate(edges) if j!=i]\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t    # first, find the size of the MST\\n        adj = make_adj(n, edges)\\n        minimum = prims(n, adj)\\n        crit = []\\n        pseu = []\\n        print(minimum)\\n\\t\\t# now, for each edge, check an MST which must use that edge, and check an MST that can\\'t use that edge.\\n\\t\\t# for each, if the size of the MST matches the size of the original MST, we know if the edge is critical and/or pseudocritical\\n        for i in range(len(edges)):\\n\\t\\t   # get size of MST that must use this edge. If as small as original, this edge is pseudocritical.\\n            if prims(n, adj, edges[i]) == minimum:\\n                pseu.append(i)\\n\\t\\t\\t# get size of MST on the graph that has this edge removed.  If it\\'s not as small as original, this edge is critical.\\n            e = remove_edge(edges, i)\\n            adj_p = make_adj(n, e)\\n            if prims(n, adj_p) > minimum:\\n                crit.append(i)\\n        return [crit, list(set(pseu) - set(crit))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932824,
                "title": "beats-98-self-explanatory-with-comments-c-code",
                "content": "```\\nclass DSU{\\nprivate:\\n    vector<int> par, size;\\npublic:\\n    DSU(int n){\\n        par = vector<int>(n+1);\\n        size = vector<int>(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    \\n    bool merge(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) \\n            return false;\\n        if(size[a] < size[b]){\\n            swap(a, b);\\n        }\\n        par[b] = a;\\n        return true;\\n    }\\n    \\n    int find(int node){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node]);\\n    }\\n    \\n    void reset(){\\n        for(int i=0; i<par.size(); i++){\\n            par[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int getMstVal(DSU &d, vector<vector<int>>& edges, int n, int skip){\\n        int mstVal = 0;\\n        for(int i=0; i<edges.size(); i++){\\n            if(i == skip) continue;\\n            if(d.merge(edges[i][0], edges[i][1])){\\n                mstVal += edges[i][2];\\n                if(--n == 0){\\n                    return mstVal;      \\n                }\\n            }\\n        }\\n        return -1;     //invalid value to respresent disconnected tree\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        //find actual mst value\\n        \\n        // I will not use this edge and find mst value to compare\\n        // If it\\'s same, it means it\\'s not a critical\\n        // else it\\'s critical\\n        \\n        //I will forcefully use this edge, and find mst value to compare\\n        //If it\\'s same, it\\'s psuedo critical\\n        //else not\\n        \\n        \\n        // To keep original index of each edge\\n        int orgIndex = 0;\\n        for(auto &edge:edges){\\n            edge.push_back(orgIndex++);\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [](vector<int> &a, vector<int> &b){\\n            return a[2]<b[2];\\n        });\\n        \\n        DSU d(n);\\n        int actualMst = getMstVal(d, edges, n - 1, -1);\\n        vector<vector<int>> ans(2);\\n        for(int i=0; i<edges.size(); i++) {\\n            d.reset();\\n            int curMst = getMstVal(d, edges, n - 1, i);\\n            if(curMst != actualMst){\\n                ans[0].push_back(edges[i][3]);\\n                continue;\\n            }\\n            \\n            d.reset();\\n            d.merge(edges[i][0], edges[i][1]);\\n            curMst = edges[i][2] + getMstVal(d, edges, n - 2, -1);\\n            if(curMst == actualMst){\\n                ans[1].push_back(edges[i][3]);\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU{\\nprivate:\\n    vector<int> par, size;\\npublic:\\n    DSU(int n){\\n        par = vector<int>(n+1);\\n        size = vector<int>(n+1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    \\n    bool merge(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) \\n            return false;\\n        if(size[a] < size[b]){\\n            swap(a, b);\\n        }\\n        par[b] = a;\\n        return true;\\n    }\\n    \\n    int find(int node){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node]);\\n    }\\n    \\n    void reset(){\\n        for(int i=0; i<par.size(); i++){\\n            par[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int getMstVal(DSU &d, vector<vector<int>>& edges, int n, int skip){\\n        int mstVal = 0;\\n        for(int i=0; i<edges.size(); i++){\\n            if(i == skip) continue;\\n            if(d.merge(edges[i][0], edges[i][1])){\\n                mstVal += edges[i][2];\\n                if(--n == 0){\\n                    return mstVal;      \\n                }\\n            }\\n        }\\n        return -1;     //invalid value to respresent disconnected tree\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        //find actual mst value\\n        \\n        // I will not use this edge and find mst value to compare\\n        // If it\\'s same, it means it\\'s not a critical\\n        // else it\\'s critical\\n        \\n        //I will forcefully use this edge, and find mst value to compare\\n        //If it\\'s same, it\\'s psuedo critical\\n        //else not\\n        \\n        \\n        // To keep original index of each edge\\n        int orgIndex = 0;\\n        for(auto &edge:edges){\\n            edge.push_back(orgIndex++);\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [](vector<int> &a, vector<int> &b){\\n            return a[2]<b[2];\\n        });\\n        \\n        DSU d(n);\\n        int actualMst = getMstVal(d, edges, n - 1, -1);\\n        vector<vector<int>> ans(2);\\n        for(int i=0; i<edges.size(); i++) {\\n            d.reset();\\n            int curMst = getMstVal(d, edges, n - 1, i);\\n            if(curMst != actualMst){\\n                ans[0].push_back(edges[i][3]);\\n                continue;\\n            }\\n            \\n            d.reset();\\n            d.merge(edges[i][0], edges[i][1]);\\n            curMst = edges[i][2] + getMstVal(d, edges, n - 2, -1);\\n            if(curMst == actualMst){\\n                ans[1].push_back(edges[i][3]);\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931491,
                "title": "o-m-log-n-solution",
                "content": "# Intuition\\nImagine during Kruskal\\'s algorithm we have processed some prefix of sorted by weight edges and following several edges (some group of edges `G`) are all edges of the graph with weight `w`. We will process such groups with equal weight together in described algorithm.\\nAlso by DSU I mean Disjoint Set Union structure used in Kruskal\\'s algorithm.\\n##### Lemma 1:\\nIf an edge from `G` has endpoints in different sets of current state of DSU (different connected components) then it\\'s either *critical* or *pseudo-critical*.\\n##### Lemma 2:\\nConsider one more graph with nodes representing current different sets of DSU and edges from `G`. If an edge from `G` is a bridge in this graph, it is *critical*, otherwise (it is in some cycle) it\\'s *pseudo-critical*.\\n\\n# Approach\\nSo to decide whether the edge is *critical* or *pseudo-critical* we need to find all bridges in some graph with O(`|G|`) edges.\\nOne way to do it is [special DFS](https://cp-algorithms.com/graph/bridge-searching.html).\\nAnother way is [keeping special DSU for 2-edge-connected components](https://cp-algorithms.com/graph/bridge-searching-online.html). This way seems to be more appropriate as it automatically performs part of Kruskal\\'s algorithm (DSU for connected components).\\n\\n# Complexity\\n- Time complexity:\\nO(m * log(n))\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [] (const auto& x, const auto& y) {\\n            return x[2] < y[2];\\n        });\\n        \\n        init(n);\\n        vector<vector<int>> ans(2);\\n        \\n        for (int i = 0; i < edges.size(); ) {\\n            vector<int> good;\\n            for (int start = i; i < edges.size() && edges[start][2] == edges[i][2]; ++i) {\\n                if (find_cc(edges[i][0]) != find_cc(edges[i][1])) {\\n                    good.push_back(i);\\n                }\\n            }\\n            for (int i : good) {\\n                add_edge(edges[i][0], edges[i][1]);\\n            }\\n            for (int i : good) {\\n                ans[find_2ecc(edges[i][0]) == find_2ecc(edges[i][1])].push_back(edges[i][3]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\n    // taken from https://cp-algorithms.com/graph/bridge-searching-online.html:\\n\\n    vector<int> par, dsu_2ecc, dsu_cc, dsu_cc_size;\\n    int bridges;\\n    int lca_iteration;\\n    vector<int> last_visit;\\n    \\n    void init(int n) {\\n        par.resize(n);\\n        dsu_2ecc.resize(n);\\n        dsu_cc.resize(n);\\n        dsu_cc_size.resize(n);\\n        lca_iteration = 0;\\n        last_visit.assign(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            dsu_2ecc[i] = i;\\n            dsu_cc[i] = i;\\n            dsu_cc_size[i] = 1;\\n            par[i] = -1;\\n        }\\n        bridges = 0;\\n    }\\n\\n    int find_2ecc(int v) {\\n        if (v == -1)\\n            return -1;\\n        return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);\\n    }\\n\\n    int find_cc(int v) {\\n        v = find_2ecc(v);\\n        return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);\\n    }\\n\\n    void make_root(int v) {\\n        v = find_2ecc(v);\\n        int root = v;\\n        int child = -1;\\n        while (v != -1) {\\n            int p = find_2ecc(par[v]);\\n            par[v] = child;\\n            dsu_cc[v] = root;\\n            child = v;\\n            v = p;\\n        }\\n        dsu_cc_size[root] = dsu_cc_size[child];\\n    }\\n\\n    void merge_path (int a, int b) {\\n        ++lca_iteration;\\n        vector<int> path_a, path_b;\\n        int lca = -1;\\n        while (lca == -1) {\\n            if (a != -1) {\\n                a = find_2ecc(a);\\n                path_a.push_back(a);\\n                if (last_visit[a] == lca_iteration){\\n                    lca = a;\\n                    break;\\n                    }\\n                last_visit[a] = lca_iteration;\\n                a = par[a];\\n            }\\n            if (b != -1) {\\n                b = find_2ecc(b);\\n                path_b.push_back(b);\\n                if (last_visit[b] == lca_iteration){\\n                    lca = b;\\n                    break;\\n                    }\\n                last_visit[b] = lca_iteration;\\n                b = par[b];\\n            }\\n\\n        }\\n\\n        for (int v : path_a) {\\n            dsu_2ecc[v] = lca;\\n            if (v == lca)\\n                break;\\n            --bridges;\\n        }\\n        for (int v : path_b) {\\n            dsu_2ecc[v] = lca;\\n            if (v == lca)\\n                break;\\n            --bridges;\\n        }\\n    }\\n\\n    void add_edge(int a, int b) {\\n        a = find_2ecc(a);\\n        b = find_2ecc(b);\\n        if (a == b)\\n            return;\\n\\n        int ca = find_cc(a);\\n        int cb = find_cc(b);\\n\\n        if (ca != cb) {\\n            ++bridges;\\n            if (dsu_cc_size[ca] > dsu_cc_size[cb]) {\\n                swap(a, b);\\n                swap(ca, cb);\\n            }\\n            make_root(a);\\n            par[a] = dsu_cc[a] = b;\\n            dsu_cc_size[cb] += dsu_cc_size[a];\\n        } else {\\n            merge_path(a, b);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [] (const auto& x, const auto& y) {\\n            return x[2] < y[2];\\n        });\\n        \\n        init(n);\\n        vector<vector<int>> ans(2);\\n        \\n        for (int i = 0; i < edges.size(); ) {\\n            vector<int> good;\\n            for (int start = i; i < edges.size() && edges[start][2] == edges[i][2]; ++i) {\\n                if (find_cc(edges[i][0]) != find_cc(edges[i][1])) {\\n                    good.push_back(i);\\n                }\\n            }\\n            for (int i : good) {\\n                add_edge(edges[i][0], edges[i][1]);\\n            }\\n            for (int i : good) {\\n                ans[find_2ecc(edges[i][0]) == find_2ecc(edges[i][1])].push_back(edges[i][3]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\n    // taken from https://cp-algorithms.com/graph/bridge-searching-online.html:\\n\\n    vector<int> par, dsu_2ecc, dsu_cc, dsu_cc_size;\\n    int bridges;\\n    int lca_iteration;\\n    vector<int> last_visit;\\n    \\n    void init(int n) {\\n        par.resize(n);\\n        dsu_2ecc.resize(n);\\n        dsu_cc.resize(n);\\n        dsu_cc_size.resize(n);\\n        lca_iteration = 0;\\n        last_visit.assign(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            dsu_2ecc[i] = i;\\n            dsu_cc[i] = i;\\n            dsu_cc_size[i] = 1;\\n            par[i] = -1;\\n        }\\n        bridges = 0;\\n    }\\n\\n    int find_2ecc(int v) {\\n        if (v == -1)\\n            return -1;\\n        return dsu_2ecc[v] == v ? v : dsu_2ecc[v] = find_2ecc(dsu_2ecc[v]);\\n    }\\n\\n    int find_cc(int v) {\\n        v = find_2ecc(v);\\n        return dsu_cc[v] == v ? v : dsu_cc[v] = find_cc(dsu_cc[v]);\\n    }\\n\\n    void make_root(int v) {\\n        v = find_2ecc(v);\\n        int root = v;\\n        int child = -1;\\n        while (v != -1) {\\n            int p = find_2ecc(par[v]);\\n            par[v] = child;\\n            dsu_cc[v] = root;\\n            child = v;\\n            v = p;\\n        }\\n        dsu_cc_size[root] = dsu_cc_size[child];\\n    }\\n\\n    void merge_path (int a, int b) {\\n        ++lca_iteration;\\n        vector<int> path_a, path_b;\\n        int lca = -1;\\n        while (lca == -1) {\\n            if (a != -1) {\\n                a = find_2ecc(a);\\n                path_a.push_back(a);\\n                if (last_visit[a] == lca_iteration){\\n                    lca = a;\\n                    break;\\n                    }\\n                last_visit[a] = lca_iteration;\\n                a = par[a];\\n            }\\n            if (b != -1) {\\n                b = find_2ecc(b);\\n                path_b.push_back(b);\\n                if (last_visit[b] == lca_iteration){\\n                    lca = b;\\n                    break;\\n                    }\\n                last_visit[b] = lca_iteration;\\n                b = par[b];\\n            }\\n\\n        }\\n\\n        for (int v : path_a) {\\n            dsu_2ecc[v] = lca;\\n            if (v == lca)\\n                break;\\n            --bridges;\\n        }\\n        for (int v : path_b) {\\n            dsu_2ecc[v] = lca;\\n            if (v == lca)\\n                break;\\n            --bridges;\\n        }\\n    }\\n\\n    void add_edge(int a, int b) {\\n        a = find_2ecc(a);\\n        b = find_2ecc(b);\\n        if (a == b)\\n            return;\\n\\n        int ca = find_cc(a);\\n        int cb = find_cc(b);\\n\\n        if (ca != cb) {\\n            ++bridges;\\n            if (dsu_cc_size[ca] > dsu_cc_size[cb]) {\\n                swap(a, b);\\n                swap(ca, cb);\\n            }\\n            make_root(a);\\n            par[a] = dsu_cc[a] = b;\\n            dsu_cc_size[cb] += dsu_cc_size[a];\\n        } else {\\n            merge_path(a, b);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931429,
                "title": "python-simple-and-elegant-prim-s-20lines",
                "content": "# Intuition\\n1. Calculate the cost of the Minimum Spanning Tree (MST) as $C$.\\n2. For each edge, compute the cost if excluded, denoted as $C_e$, and the cost if included, denoted as $C_i$.\\n3. An edge is considered critical if $C_e > C$, and pseudo-critical if $C_e = C = C_i$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(E^2 logV)$$\\n\\n- Space complexity:\\n$$O(E)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = [(a, b, c, i) for i, (a, b, c) in enumerate(edges)]\\n        edges.sort(key = lambda x: x[2])\\n        maxCost = 1000 * 100\\n\\n        def getMSTCost(E, V, C):\\n            \\'\\'\\' \\n                E: edge exclusive set\\n                V: nodes in MST\\n                C: current Cost\\n            \\'\\'\\'\\n            nonlocal edges, n, maxCost\\n            if len(V) == n:\\n                return C\\n            else:\\n                for a, b, c, i in edges:\\n                    if i not in E and (a in V and b not in V or a not in V and b in V):\\n                        return getMSTCost(E | set([i]), V | set([a, b]), C + c)\\n            return maxCost\\n        \\n        C = getMSTCost(set(), set([0]), 0)\\n\\n        critical, pseudo_critical = [], []\\n        for a, b, c, i in edges:\\n            if getMSTCost(set([i]), set([0]), 0) > C:\\n                critical += [i]\\n            elif getMSTCost(set([i]), set([a, b]), c) == C:\\n                pseudo_critical += [i]\\n\\n        return [critical, pseudo_critical]\\n```\\n\\nNote that this impl is not optimized.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = [(a, b, c, i) for i, (a, b, c) in enumerate(edges)]\\n        edges.sort(key = lambda x: x[2])\\n        maxCost = 1000 * 100\\n\\n        def getMSTCost(E, V, C):\\n            \\'\\'\\' \\n                E: edge exclusive set\\n                V: nodes in MST\\n                C: current Cost\\n            \\'\\'\\'\\n            nonlocal edges, n, maxCost\\n            if len(V) == n:\\n                return C\\n            else:\\n                for a, b, c, i in edges:\\n                    if i not in E and (a in V and b not in V or a not in V and b in V):\\n                        return getMSTCost(E | set([i]), V | set([a, b]), C + c)\\n            return maxCost\\n        \\n        C = getMSTCost(set(), set([0]), 0)\\n\\n        critical, pseudo_critical = [], []\\n        for a, b, c, i in edges:\\n            if getMSTCost(set([i]), set([0]), 0) > C:\\n                critical += [i]\\n            elif getMSTCost(set([i]), set([a, b]), c) == C:\\n                pseudo_critical += [i]\\n\\n        return [critical, pseudo_critical]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930552,
                "title": "easy-to-understand-c-kruskal-s-algorithm-commented-code-runtime-110ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the question deas with MST\\'s, we have two standard algorithms in our arsenal - Prim\\'s and Kruskal\\'s. We can use disjoint Set to form MST\\'s and keep track of size of components. So, we will be using Kruskal\\'s algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the MST wt of the entire graph. Now remove each edge and check if removing that edge increase the MST wt or if this edge is a bridge between components, if it does/is, then it is a critical edge, else we check if it is a pseudo-critical edge. For this, we check if we include this edge in an MST, and form the MST, will the MST weight remain same or increase. If it remains same, then this edge need not be present in all MSTs. This is because we already checked if this edge is critical, and as removing this edge doesn\\'t increase MST weight and including this edge also doesn\\'t have any effect, then this edge is pseudo critical.\\n\\nTip: Use another vector that also stores the index of the edge with it and sort it for kruskal, we call this ```edgeCopy```.\\n# Complexity\\n- Time complexity: $$O(m^2\\u22C5 \\u03B1(n))$$, where m is the number of edges, n is the number of nodes and \\u03B1 is the inverse Ackermann function.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m+n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    public:\\n    vector<int> size, parent;\\n\\n    DisjointSet(int n)\\n    {\\n        size.resize(n, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i < n; i++)\\n        parent[i] = i;\\n    }\\n\\n    int findUPar(int node)\\n    {\\n        if (parent[node] == node)\\n        return node;\\n\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n\\n        if (ulp_u == ulp_v)\\n        return;\\n\\n        if (size[ulp_u] >= size[ulp_v])\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        else\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // Step 1 - Find the MST wt of the entire graph. Now remove each edge and check if removing that edge increase the MST wt, if it does, then it is a critical edge, else we check if it is a pseudo-critical edge.\\n        // Use another vector that also stores the index of the edge with it and sort it for kruskal\\n        vector<vector<int>> edgeCopy;\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1], wt = edges[i][2];\\n            edgeCopy.push_back({wt, u, v, i});\\n        }\\n        sort(edgeCopy.begin(), edgeCopy.end());\\n\\n        // Figure out the weight of MST!\\n        DisjointSet MST(n);\\n        int mstWt = 0;\\n        for (auto &it: edgeCopy)\\n        {\\n            int wt = it[0], u = it[1], v = it[2];\\n            if (MST.findUPar(u) != MST.findUPar(v))\\n            {\\n                mstWt += wt;\\n                MST.unionBySize(u, v);\\n            }\\n        }\\n\\n        vector<int> criticalEdges;\\n        vector<int> pseudocritEdges;\\n\\n        // Iterate edgeCopy and try removing an edge and check if it\\'s critical.\\n        for (int i = 0; i < edgeCopy.size(); i++)\\n        {\\n            // If weight increases or if all nodes aren\\'t in 1 component, this edge is critical\\n            int newMSTwt = 0;\\n            DisjointSet ds(n);\\n            int edgeIndex = edgeCopy[i][3];\\n            // Ignoring the edge to check for criticality\\n            for (int j = 0; j < edgeCopy.size(); j++)\\n            {\\n                if (i != j) // ignore edge\\n                {\\n                    int wt = edgeCopy[j][0], u = edgeCopy[j][1], v = edgeCopy[j][2];\\n                    if (ds.findUPar(u) != ds.findUPar(v))\\n                    {\\n                        newMSTwt += wt;\\n                        ds.unionBySize(u, v);\\n                    }\\n                }\\n            }\\n            if (newMSTwt > mstWt || ds.size[ds.findUPar(0)] < n) // weight increased or more than 1 component MST\\n            criticalEdges.push_back(edgeIndex);\\n            else\\n            {\\n                // We only check for pseudoCritical when we know it\\'s not critical!\\n                // Iterate edgeCopy and try forcing this edge and check if it\\'s pseudo critical.\\n                // If the total weight of the resulting MST is the same as the mstWt, this edge is pseudo-critical.\\n            int forcedMSTwt = 0;\\n            DisjointSet forcedDs(n);\\n            int forcedWt = edgeCopy[i][0], forcedU = edgeCopy[i][1], forcedV = edgeCopy[i][2];\\n            forcedDs.unionBySize(forcedU, forcedV);\\n            forcedMSTwt += forcedWt;\\n            // add this edge to Ds and create MST to check if it\\'s psedo critical or not\\n            for (int j = 0; j < edgeCopy.size(); j++)\\n            {\\n                if (i != j) // ignore edge as already counted\\n                {\\n                    int wt = edgeCopy[j][0], u = edgeCopy[j][1], v = edgeCopy[j][2];\\n                    if (forcedDs.findUPar(u) != forcedDs.findUPar(v))\\n                    {\\n                        forcedMSTwt += wt;\\n                        forcedDs.unionBySize(u, v);\\n                    }\\n                }\\n            }\\n            if (forcedMSTwt == mstWt) // weight remained  same\\n            pseudocritEdges.push_back(edgeIndex);\\n            }\\n        }\\n        vector<vector<int>> res;\\n        res.push_back(criticalEdges);\\n        res.push_back(pseudocritEdges);\\n        return res;\\n    }\\n};\\n```\\n\\n![Screenshot 2023-08-19 151429.png](https://assets.leetcode.com/users/images/5d5eb943-02d7-4758-ae58-6c75492851f5_1692438273.183074.png)\\n",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```edgeCopy```\n```\\nclass DisjointSet {\\n    public:\\n    vector<int> size, parent;\\n\\n    DisjointSet(int n)\\n    {\\n        size.resize(n, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i < n; i++)\\n        parent[i] = i;\\n    }\\n\\n    int findUPar(int node)\\n    {\\n        if (parent[node] == node)\\n        return node;\\n\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n\\n        if (ulp_u == ulp_v)\\n        return;\\n\\n        if (size[ulp_u] >= size[ulp_v])\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        else\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // Step 1 - Find the MST wt of the entire graph. Now remove each edge and check if removing that edge increase the MST wt, if it does, then it is a critical edge, else we check if it is a pseudo-critical edge.\\n        // Use another vector that also stores the index of the edge with it and sort it for kruskal\\n        vector<vector<int>> edgeCopy;\\n        for (int i = 0; i < edges.size(); i++)\\n        {\\n            int u = edges[i][0], v = edges[i][1], wt = edges[i][2];\\n            edgeCopy.push_back({wt, u, v, i});\\n        }\\n        sort(edgeCopy.begin(), edgeCopy.end());\\n\\n        // Figure out the weight of MST!\\n        DisjointSet MST(n);\\n        int mstWt = 0;\\n        for (auto &it: edgeCopy)\\n        {\\n            int wt = it[0], u = it[1], v = it[2];\\n            if (MST.findUPar(u) != MST.findUPar(v))\\n            {\\n                mstWt += wt;\\n                MST.unionBySize(u, v);\\n            }\\n        }\\n\\n        vector<int> criticalEdges;\\n        vector<int> pseudocritEdges;\\n\\n        // Iterate edgeCopy and try removing an edge and check if it\\'s critical.\\n        for (int i = 0; i < edgeCopy.size(); i++)\\n        {\\n            // If weight increases or if all nodes aren\\'t in 1 component, this edge is critical\\n            int newMSTwt = 0;\\n            DisjointSet ds(n);\\n            int edgeIndex = edgeCopy[i][3];\\n            // Ignoring the edge to check for criticality\\n            for (int j = 0; j < edgeCopy.size(); j++)\\n            {\\n                if (i != j) // ignore edge\\n                {\\n                    int wt = edgeCopy[j][0], u = edgeCopy[j][1], v = edgeCopy[j][2];\\n                    if (ds.findUPar(u) != ds.findUPar(v))\\n                    {\\n                        newMSTwt += wt;\\n                        ds.unionBySize(u, v);\\n                    }\\n                }\\n            }\\n            if (newMSTwt > mstWt || ds.size[ds.findUPar(0)] < n) // weight increased or more than 1 component MST\\n            criticalEdges.push_back(edgeIndex);\\n            else\\n            {\\n                // We only check for pseudoCritical when we know it\\'s not critical!\\n                // Iterate edgeCopy and try forcing this edge and check if it\\'s pseudo critical.\\n                // If the total weight of the resulting MST is the same as the mstWt, this edge is pseudo-critical.\\n            int forcedMSTwt = 0;\\n            DisjointSet forcedDs(n);\\n            int forcedWt = edgeCopy[i][0], forcedU = edgeCopy[i][1], forcedV = edgeCopy[i][2];\\n            forcedDs.unionBySize(forcedU, forcedV);\\n            forcedMSTwt += forcedWt;\\n            // add this edge to Ds and create MST to check if it\\'s psedo critical or not\\n            for (int j = 0; j < edgeCopy.size(); j++)\\n            {\\n                if (i != j) // ignore edge as already counted\\n                {\\n                    int wt = edgeCopy[j][0], u = edgeCopy[j][1], v = edgeCopy[j][2];\\n                    if (forcedDs.findUPar(u) != forcedDs.findUPar(v))\\n                    {\\n                        forcedMSTwt += wt;\\n                        forcedDs.unionBySize(u, v);\\n                    }\\n                }\\n            }\\n            if (forcedMSTwt == mstWt) // weight remained  same\\n            pseudocritEdges.push_back(edgeIndex);\\n            }\\n        }\\n        vector<vector<int>> res;\\n        res.push_back(criticalEdges);\\n        res.push_back(pseudocritEdges);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929851,
                "title": "beats-96-memory-wise",
                "content": "\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find_parent(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union_sets(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find_MST(graph, block, e):\\n            uf = UnionFind(n)\\n            weight = 0\\n            \\n            if e != -1:\\n                weight += edges[e][2]\\n                uf.union_sets(edges[e][0], edges[e][1])\\n            \\n            for i in range(len(edges)):\\n                if i == block:\\n                    continue\\n                \\n                if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                    continue\\n                \\n                uf.union_sets(edges[i][0], edges[i][1])\\n                weight += edges[i][2]\\n            \\n            for i in range(n):\\n                if uf.find_parent(i) != uf.find_parent(0):\\n                    return float(\\'inf\\')\\n            \\n            return weight\\n        \\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i, edge in enumerate(edges):\\n            edge.append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        mst_weight = find_MST(edges, -1, -1)\\n        \\n        for i, edge in enumerate(edges):\\n            if mst_weight < find_MST(edges, i, -1):\\n                critical.append(edge[3])\\n            elif mst_weight == find_MST(edges, -1, i):\\n                pseudo_critical.append(edge[3])\\n        \\n        return [critical, pseudo_critical]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find_parent(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find_parent(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union_sets(self, u, v):\\n        pu, pv = self.find_parent(u), self.find_parent(v)\\n        self.parent[pu] = pv\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find_MST(graph, block, e):\\n            uf = UnionFind(n)\\n            weight = 0\\n            \\n            if e != -1:\\n                weight += edges[e][2]\\n                uf.union_sets(edges[e][0], edges[e][1])\\n            \\n            for i in range(len(edges)):\\n                if i == block:\\n                    continue\\n                \\n                if uf.find_parent(edges[i][0]) == uf.find_parent(edges[i][1]):\\n                    continue\\n                \\n                uf.union_sets(edges[i][0], edges[i][1])\\n                weight += edges[i][2]\\n            \\n            for i in range(n):\\n                if uf.find_parent(i) != uf.find_parent(0):\\n                    return float(\\'inf\\')\\n            \\n            return weight\\n        \\n        critical = []\\n        pseudo_critical = []\\n        \\n        for i, edge in enumerate(edges):\\n            edge.append(i)\\n        \\n        edges.sort(key=lambda x: x[2])\\n        mst_weight = find_MST(edges, -1, -1)\\n        \\n        for i, edge in enumerate(edges):\\n            if mst_weight < find_MST(edges, i, -1):\\n                critical.append(edge[3])\\n            elif mst_weight == find_MST(edges, -1, i):\\n                pseudo_critical.append(edge[3])\\n        \\n        return [critical, pseudo_critical]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957061,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(E*E)\\n\\n- Space complexity:O(E)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par, rank;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        rank.resize(n+1, 0);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        int pu=findp(u), pv=findp(v);\\n        if(pu==pv){return;}\\n        if(rank[pu]<rank[pv]){\\n            par[pu]=pv;\\n        }\\n        else{\\n            par[pv]=pu;\\n            rank[pu]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mst(int n, vector<pair<int, pair<int, int>>>& v, pair<int, pair<int, int>>a, pair<int, pair<int, int>>b){\\n        disjointset d(n);\\n        int ans=0;\\n        if(a.second.first!=-1 && a.second.second!=-1){d.un(a.second.first, a.second.second); ans+=a.first;}\\n        //if(b.second.first!=-1 && b.second.second!=-1){d.un(b.second.first, b.second.second);}\\n        for(auto it: v){\\n            if(b!=it && (d.findp(it.second.first)!=d.findp(it.second.second))){\\n                ans+=it.first;\\n                d.un(it.second.first, it.second.second);\\n            }\\n        }\\n        set<int>s;\\n        for(int i=0; i<n; i++){s.insert(d.findp(i));}\\n        if(s.size()==1){return ans;}\\n        return INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<pair<int, pair<int, int>>>v;\\n        vector<vector<int>>ans;\\n        vector<int>c, p;\\n        int i=0;\\n        map<pair<int, int>, int>m;\\n        for(auto it: edges){\\n            v.push_back({it[2], {it[0], it[1]}});\\n            m[{it[0], it[1]}]=i;\\n            i++;\\n        }\\n        sort(v.begin(), v.end());\\n        int sum=mst(n, v, {-1, {-1, -1}}, {-1, {-1, -1}});\\n        //cout<<sum<<endl;\\n        for(auto it: v){\\n            int s1=mst(n, v, {-1, {-1, -1}}, it), s2=mst(n, v, it, {-1, {-1, -1}});\\n            cout<<sum<<\" \"<<s1<<\" \"<<s2<<endl;\\n            if(s1>sum){c.push_back(m[{it.second.first, it.second.second}]);}\\n            else{\\n                if(s2==sum){p.push_back(m[{it.second.first, it.second.second}]);}\\n            }\\n        }\\n        ans.push_back(c);\\n        ans.push_back(p);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par, rank;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        rank.resize(n+1, 0);\\n        for(int i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        int pu=findp(u), pv=findp(v);\\n        if(pu==pv){return;}\\n        if(rank[pu]<rank[pv]){\\n            par[pu]=pv;\\n        }\\n        else{\\n            par[pv]=pu;\\n            rank[pu]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mst(int n, vector<pair<int, pair<int, int>>>& v, pair<int, pair<int, int>>a, pair<int, pair<int, int>>b){\\n        disjointset d(n);\\n        int ans=0;\\n        if(a.second.first!=-1 && a.second.second!=-1){d.un(a.second.first, a.second.second); ans+=a.first;}\\n        //if(b.second.first!=-1 && b.second.second!=-1){d.un(b.second.first, b.second.second);}\\n        for(auto it: v){\\n            if(b!=it && (d.findp(it.second.first)!=d.findp(it.second.second))){\\n                ans+=it.first;\\n                d.un(it.second.first, it.second.second);\\n            }\\n        }\\n        set<int>s;\\n        for(int i=0; i<n; i++){s.insert(d.findp(i));}\\n        if(s.size()==1){return ans;}\\n        return INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<pair<int, pair<int, int>>>v;\\n        vector<vector<int>>ans;\\n        vector<int>c, p;\\n        int i=0;\\n        map<pair<int, int>, int>m;\\n        for(auto it: edges){\\n            v.push_back({it[2], {it[0], it[1]}});\\n            m[{it[0], it[1]}]=i;\\n            i++;\\n        }\\n        sort(v.begin(), v.end());\\n        int sum=mst(n, v, {-1, {-1, -1}}, {-1, {-1, -1}});\\n        //cout<<sum<<endl;\\n        for(auto it: v){\\n            int s1=mst(n, v, {-1, {-1, -1}}, it), s2=mst(n, v, it, {-1, {-1, -1}});\\n            cout<<sum<<\" \"<<s1<<\" \"<<s2<<endl;\\n            if(s1>sum){c.push_back(m[{it.second.first, it.second.second}]);}\\n            else{\\n                if(s2==sum){p.push_back(m[{it.second.first, it.second.second}]);}\\n            }\\n        }\\n        ans.push_back(c);\\n        ans.push_back(p);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 702727,
                "title": "javascript-simple-understandable-code-with-100-memory",
                "content": "```\\nclass UnionFind {\\n    constructor(n) {\\n        this.parents = [];\\n        for(let i = 0; i < n; i++) {\\n            this.parents.push(i);\\n        }\\n        this.count = n;\\n    }\\n\\n    find(index) {\\n        const parent = this.parents[index];\\n        if(parent === index) return index;\\n\\n        let root = this.find(parent);\\n        this.parents[index] = root;\\n        return root;\\n    }\\n\\n    union(index1, index2) {\\n        let p1 = this.find(index1);\\n        let p2 = this.find(index2);\\n\\n        if(p1 !== p2) {\\n            this.count--;\\n            this.parents[p1] = p2;\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let criticalEdges = [], psuedoCriticalEdges = [], map = new Map();\\n    \\n    edges.forEach((edge, i) => map.set(edge, i));\\n    \\n    edges.sort((a, b) => a[2] - b[2]);\\n    \\n    const buildMST = (pick, skip) => {\\n        let uf = new UnionFind(n), cost = 0;\\n        \\n        if(pick !== null) {\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(let edge of edges) {\\n            if(edge !== skip && uf.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER;\\n    };\\n    \\n    const minCost = buildMST(null, null);\\n    \\n    for(let edge of edges) {\\n        const index = map.get(edge);\\n        const costWithout = buildMST(null, edge);\\n        if(costWithout > minCost) {\\n            criticalEdges.push(index);\\n        } else {\\n            const costWith = buildMST(edge, null);\\n            if(costWith === minCost) psuedoCriticalEdges.push(index);\\n        }\\n    }\\n    \\n    return [criticalEdges, psuedoCriticalEdges];\\n};\\n```\\nThis solution is converted to javascript from Java solution posted by luo122174088. Suggestions are welcome for further optimizations.",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n    constructor(n) {\\n        this.parents = [];\\n        for(let i = 0; i < n; i++) {\\n            this.parents.push(i);\\n        }\\n        this.count = n;\\n    }\\n\\n    find(index) {\\n        const parent = this.parents[index];\\n        if(parent === index) return index;\\n\\n        let root = this.find(parent);\\n        this.parents[index] = root;\\n        return root;\\n    }\\n\\n    union(index1, index2) {\\n        let p1 = this.find(index1);\\n        let p2 = this.find(index2);\\n\\n        if(p1 !== p2) {\\n            this.count--;\\n            this.parents[p1] = p2;\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let criticalEdges = [], psuedoCriticalEdges = [], map = new Map();\\n    \\n    edges.forEach((edge, i) => map.set(edge, i));\\n    \\n    edges.sort((a, b) => a[2] - b[2]);\\n    \\n    const buildMST = (pick, skip) => {\\n        let uf = new UnionFind(n), cost = 0;\\n        \\n        if(pick !== null) {\\n            uf.union(pick[0], pick[1]);\\n            cost += pick[2];\\n        }\\n        \\n        for(let edge of edges) {\\n            if(edge !== skip && uf.union(edge[0], edge[1])) {\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER;\\n    };\\n    \\n    const minCost = buildMST(null, null);\\n    \\n    for(let edge of edges) {\\n        const index = map.get(edge);\\n        const costWithout = buildMST(null, edge);\\n        if(costWithout > minCost) {\\n            criticalEdges.push(index);\\n        } else {\\n            const costWith = buildMST(edge, null);\\n            if(costWith === minCost) psuedoCriticalEdges.push(index);\\n        }\\n    }\\n    \\n    return [criticalEdges, psuedoCriticalEdges];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938886,
                "title": "c-solution-for-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem revolves around identifying critical and pseudo-critical edges in a minimum spanning tree (MST) of a weighted undirected graph. A critical edge is one whose removal would cause the MST weight to increase, and a pseudo-critical edge is one that can appear in some MSTs but not all.\\n\\nThe main idea is to iterate through all edges in ascending order of weights, consider each edge\\'s impact on the MST, and identify if it\\'s critical or pseudo-critical.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initial Preparation: First, the input edges are modified to include their indices for identification purposes. Then, they are sorted based on their weights in ascending order.\\n\\n1. MST Calculation: The MSTWeight function calculates the weight of the MST while considering optional skipIndex (an edge to skip) and addIndex (an edge to include). This function uses the Union-Find (Disjoint Set Union) data structure to efficiently determine the MST\\'s weight.\\n\\n1. Identifying Critical and Pseudo-Critical Edges: Iterate through each edge, and:\\n\\n- Calculate the MST weight without considering the current edge (skipIndex).\\n- If the MST weight changes, the current edge is critical.\\n- Calculate the MST weight by including only the current edge (addIndex).\\n- If the MST weight remains the same as the original, the edge is pseudo-critical.\\n4. Returning Results: The indices of critical and pseudo-critical edges are collected in separate lists, which are returned as the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Sorting the edges initially takes O(m * log m) time.\\n- Each iteration over the edges takes O(m) time.\\n- Calculating the MST weight for each edge (worst case) takes O(n * alpha(n)) time (amortized constant time for Union-Find operations).\\n- The overall time complexity is dominated by the sorting step, resulting in O(m * log m), where m is the number of edges.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the input edges array is O(m).\\n- The Union-Find data structure uses O(n) space.\\n- The space complexity is dominated by the input edges array, resulting in O(m).\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int m = edges.Length;\\n        for (int i = 0; i < m; i++) {\\n            edges[i] = new int[] { edges[i][0], edges[i][1], edges[i][2], i };\\n        }\\n        \\n        Array.Sort(edges, (a, b) => a[2] - b[2]);\\n        \\n        int mstWeight = MSTWeight(n, edges, -1, -1);\\n        \\n        List<int> criticalEdges = new List<int>();\\n        List<int> pseudoCriticalEdges = new List<int>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (mstWeight != MSTWeight(n, edges, i, -1)) {\\n                criticalEdges.Add(edges[i][3]);\\n            } else if (mstWeight == MSTWeight(n, edges, -1, i)) {\\n                pseudoCriticalEdges.Add(edges[i][3]);\\n            }\\n        }\\n        \\n        return new List<IList<int>> { criticalEdges, pseudoCriticalEdges };\\n    }\\n    \\n    private int MSTWeight(int n, int[][] edges, int skipIndex, int addIndex) {\\n        int weight = 0;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        if (addIndex != -1) {\\n            uf.Union(edges[addIndex][0], edges[addIndex][1]);\\n            weight += edges[addIndex][2];\\n        }\\n        \\n        for (int i = 0; i < edges.Length; i++) {\\n            if (i == skipIndex || i == addIndex) continue;\\n            if (uf.Union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n            }\\n        }\\n        \\n        return uf.Count == 1 ? weight : int.MaxValue;\\n    }\\n}\\n\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    public int Count { get; private set; }\\n    \\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        rank = new int[size];\\n        Count = size;\\n        for (int i = 0; i < size; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int Find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = Find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    public bool Union(int x, int y) {\\n        int rootX = Find(x);\\n        int rootY = Find(y);\\n        \\n        if (rootX == rootY) {\\n            return false;\\n        }\\n        \\n        if (rank[rootX] > rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else if (rank[rootX] < rank[rootY]) {\\n            parent[rootX] = rootY;\\n        } else {\\n            parent[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        \\n        Count--;\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int m = edges.Length;\\n        for (int i = 0; i < m; i++) {\\n            edges[i] = new int[] { edges[i][0], edges[i][1], edges[i][2], i };\\n        }\\n        \\n        Array.Sort(edges, (a, b) => a[2] - b[2]);\\n        \\n        int mstWeight = MSTWeight(n, edges, -1, -1);\\n        \\n        List<int> criticalEdges = new List<int>();\\n        List<int> pseudoCriticalEdges = new List<int>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (mstWeight != MSTWeight(n, edges, i, -1)) {\\n                criticalEdges.Add(edges[i][3]);\\n            } else if (mstWeight == MSTWeight(n, edges, -1, i)) {\\n                pseudoCriticalEdges.Add(edges[i][3]);\\n            }\\n        }\\n        \\n        return new List<IList<int>> { criticalEdges, pseudoCriticalEdges };\\n    }\\n    \\n    private int MSTWeight(int n, int[][] edges, int skipIndex, int addIndex) {\\n        int weight = 0;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        if (addIndex != -1) {\\n            uf.Union(edges[addIndex][0], edges[addIndex][1]);\\n            weight += edges[addIndex][2];\\n        }\\n        \\n        for (int i = 0; i < edges.Length; i++) {\\n            if (i == skipIndex || i == addIndex) continue;\\n            if (uf.Union(edges[i][0], edges[i][1])) {\\n                weight += edges[i][2];\\n            }\\n        }\\n        \\n        return uf.Count == 1 ? weight : int.MaxValue;\\n    }\\n}\\n\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    public int Count { get; private set; }\\n    \\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        rank = new int[size];\\n        Count = size;\\n        for (int i = 0; i < size; i++) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int Find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = Find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    \\n    public bool Union(int x, int y) {\\n        int rootX = Find(x);\\n        int rootY = Find(y);\\n        \\n        if (rootX == rootY) {\\n            return false;\\n        }\\n        \\n        if (rank[rootX] > rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else if (rank[rootX] < rank[rootY]) {\\n            parent[rootX] = rootY;\\n        } else {\\n            parent[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        \\n        Count--;\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932823,
                "title": "c-super-easy-clean-code-mst-fully-optimized-beats-100-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct DSU{\\n    int parent[101];\\n    int size[101];\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findParent(int node){\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    bool unionBySize(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return false;\\n\\n        if(size[pu] < size[pv]){\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n        return true;\\n    }\\n};\\nint sz;\\nclass Solution {\\nprivate:\\n    int kruskal(vector<vector<int>>& edges, int n, int skip, int pick){\\n        DSU dsu(n);\\n        int sum = 0;\\n\\n        if(pick > -1){\\n            dsu.unionBySize(edges[pick][0],edges[pick][1]);\\n            sum += edges[pick][2];\\n            n--;\\n        }\\n\\n        for(int i=0; i<sz; i++){\\n            if(skip == i) continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(dsu.unionBySize(u,v)){\\n                sum += edges[i][2];\\n                n--;\\n            }\\n        }\\n        \\n        if(n == 1) return sum;\\n        return 1e9;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            edges[i].push_back(i);\\n        }\\n        auto comp = [&](vector<int>& a, vector<int>& b){\\n            return a[2] < b[2];\\n        };\\n        sort(edges.begin(),edges.end(),comp);\\n\\n        int mst_wt = kruskal(edges,n,-1,-1);\\n\\n        vector<int> critical;\\n        vector<int> pseudo;\\n        for(int i=0; i<sz; i++){\\n\\n            if(kruskal(edges,n,i,-1) > mst_wt){\\n                critical.push_back(edges[i][3]);\\n            }\\n            else if(kruskal(edges,n,-1,i) == mst_wt){\\n                pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n\\n        return {critical,pseudo};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct DSU{\\n    int parent[101];\\n    int size[101];\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findParent(int node){\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    bool unionBySize(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return false;\\n\\n        if(size[pu] < size[pv]){\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n        return true;\\n    }\\n};\\nint sz;\\nclass Solution {\\nprivate:\\n    int kruskal(vector<vector<int>>& edges, int n, int skip, int pick){\\n        DSU dsu(n);\\n        int sum = 0;\\n\\n        if(pick > -1){\\n            dsu.unionBySize(edges[pick][0],edges[pick][1]);\\n            sum += edges[pick][2];\\n            n--;\\n        }\\n\\n        for(int i=0; i<sz; i++){\\n            if(skip == i) continue;\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(dsu.unionBySize(u,v)){\\n                sum += edges[i][2];\\n                n--;\\n            }\\n        }\\n        \\n        if(n == 1) return sum;\\n        return 1e9;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        sz = edges.size();\\n        for(int i=0; i<sz; i++){\\n            edges[i].push_back(i);\\n        }\\n        auto comp = [&](vector<int>& a, vector<int>& b){\\n            return a[2] < b[2];\\n        };\\n        sort(edges.begin(),edges.end(),comp);\\n\\n        int mst_wt = kruskal(edges,n,-1,-1);\\n\\n        vector<int> critical;\\n        vector<int> pseudo;\\n        for(int i=0; i<sz; i++){\\n\\n            if(kruskal(edges,n,i,-1) > mst_wt){\\n                critical.push_back(edges[i][3]);\\n            }\\n            else if(kruskal(edges,n,-1,i) == mst_wt){\\n                pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n\\n        return {critical,pseudo};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932684,
                "title": "beats-100-beginner-friendly",
                "content": "**Please upvote.**\\n# Code\\n```\\nclass Solution {\\nprivate: \\nclass DSU{\\nprivate:\\n        vector<int> parent, rank;\\npublic: \\n        int maxSize;\\n        DSU(int size){\\n            maxSize = 0;\\n            parent.resize(size);\\n            rank.resize(size, 1);\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n        }\\npublic:\\n   int find(int vert){\\n       if(parent[vert] == vert) return vert;\\n       return parent[vert] = find(parent[vert]);\\n   }\\n   void join(int vert1, int vert2){\\n       int rep1 = find(vert1);\\n       int rep2 = find(vert2);\\n       if(rep1 != rep2){\\n           int rank1 = rank[rep1], rank2 = rank[rep2];\\n           if(rank1 < rank2){\\n               swap(rep1, rep2);\\n           }\\n           parent[rep2] = rep1;\\n           rank[rep1] += rank[rep2];\\n           maxSize = max(maxSize, rank[rep1]);\\n       }\\n   }  \\n        \\n};    \\npublic:\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> egWithIndx(sz, vector<int>(4));\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx] = edges[indx];\\n            egWithIndx[indx].push_back(indx);\\n        }\\n        sort(egWithIndx.begin(), egWithIndx.end(), [](const vector<int> & eg1, vector<int>& eg2)->bool{\\n            return eg1[2] < eg2[2];\\n        });\\n        DSU ogMST(n);\\n        int ogWt = 0;\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            vector<int> &eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n        cout<<\"ogWt \"<<ogWt<<endl;\\n\\n        vector<vector<int>> result(2);\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            auto &eg = egWithIndx[eIndx];\\n            DSU newSpT(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                vector<int> &eg = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                result[0].push_back(eg[3]);\\n                cout<<\"maxSize\"<<newSpT.maxSize<<\" newWt \"<<newWt<<endl;\\n            }else{\\n                DSU newSpT1(n);\\n                vector<int> &eg = egWithIndx[eIndx];\\n                newSpT1.join(eg[0], eg[1]);\\n                int newWt1 = eg[2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    vector<int> &eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    result[1].push_back(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\nclass DSU{\\nprivate:\\n        vector<int> parent, rank;\\npublic: \\n        int maxSize;\\n        DSU(int size){\\n            maxSize = 0;\\n            parent.resize(size);\\n            rank.resize(size, 1);\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n        }\\npublic:\\n   int find(int vert){\\n       if(parent[vert] == vert) return vert;\\n       return parent[vert] = find(parent[vert]);\\n   }\\n   void join(int vert1, int vert2){\\n       int rep1 = find(vert1);\\n       int rep2 = find(vert2);\\n       if(rep1 != rep2){\\n           int rank1 = rank[rep1], rank2 = rank[rep2];\\n           if(rank1 < rank2){\\n               swap(rep1, rep2);\\n           }\\n           parent[rep2] = rep1;\\n           rank[rep1] += rank[rep2];\\n           maxSize = max(maxSize, rank[rep1]);\\n       }\\n   }  \\n        \\n};    \\npublic:\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> egWithIndx(sz, vector<int>(4));\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx] = edges[indx];\\n            egWithIndx[indx].push_back(indx);\\n        }\\n        sort(egWithIndx.begin(), egWithIndx.end(), [](const vector<int> & eg1, vector<int>& eg2)->bool{\\n            return eg1[2] < eg2[2];\\n        });\\n        DSU ogMST(n);\\n        int ogWt = 0;\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            vector<int> &eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n        cout<<\"ogWt \"<<ogWt<<endl;\\n\\n        vector<vector<int>> result(2);\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            auto &eg = egWithIndx[eIndx];\\n            DSU newSpT(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                vector<int> &eg = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                result[0].push_back(eg[3]);\\n                cout<<\"maxSize\"<<newSpT.maxSize<<\" newWt \"<<newWt<<endl;\\n            }else{\\n                DSU newSpT1(n);\\n                vector<int> &eg = egWithIndx[eIndx];\\n                newSpT1.join(eg[0], eg[1]);\\n                int newWt1 = eg[2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    vector<int> &eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    result[1].push_back(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3931781,
                "title": "easy-spanning-tree-solution",
                "content": "\\n# **PLS UPVOTE MY SOLUTION IF YOU LIKE IT AND COMMENT FOR DOUBTS**\\n# Approach\\nClass UnionFind:\\n\\nThis class implements the Union-Find data structure with path compression and union by rank optimizations. It is used to efficiently track and merge connected components.\\nFunction findCriticalAndPseudoCriticalEdges:\\n\\nThis function takes the number of nodes n and a vector of edges representing the graph\\'s edges.\\nIt sorts the edges based on their weights in ascending order.\\nFor each edge, it pushes its index into the vector to keep track of its original position.\\nIt calculates the MST of the original graph (origin_mst) by calling the GetMST function without blocking any edge.\\nIt iterates through all edges and calculates their impact on the MST:\\nIf the MST weight increases after removing an edge, that edge is marked as critical.\\nIf the MST weight remains the same after removing an edge, that edge is marked as non-critical.\\nReturns a vector containing two sub-vectors: critical edges and non-critical edges.\\nFunction GetMST:\\n\\nThis function calculates the weight of the MST using Kruskal\\'s algorithm.\\nIt takes the number of nodes n, the edges vector, an index of an edge to be blocked (blockedge), and an index of a potential edge to be included in the MST (pre_edge).\\nInitializes Union-Find and weight variables.\\nIf a pre_edge is provided, adds its weight to the MST and unions its endpoints.\\nIterates through edges (excluding the blocked edge if specified):\\nIf the endpoints of an edge are not in the same connected component, it is added to the MST and the endpoints are united.\\nChecks if all nodes are in the same connected component (MST is formed).\\nReturns the total weight of the MST.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(E log E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int n) {\\n        rank = vector<int>(n, 1);\\n        f.resize(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n    }\\n    \\n    int Find(int x) {\\n        if (x == f[x]) return x;\\n        else return f[x] = Find(f[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        int fx = Find(x), fy = Find(y);\\n        if (fx == fy) return;\\n        if (rank[fx] > rank[fy]) swap(fx, fy);\\n        f[fx] = fy;\\n        if (rank[fx] == rank[fy]) rank[fy]++;\\n    }\\n    \\nprivate:\\n    vector<int> f, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int origin_mst = GetMST(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (origin_mst < GetMST(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (origin_mst == GetMST(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n    \\nprivate:\\n    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {\\n        UnionFind uf(n);\\n        int weight = 0;\\n        if (pre_edge != -1) {\\n            weight += edges[pre_edge][2];\\n            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == blockedge) continue;\\n            const auto& edge = edges[i];\\n            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;\\n            uf.Union(edge[0], edge[1]);\\n            weight += edge[2];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (uf.Find(i) != uf.Find(0)) return 1e9+7;\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931584,
                "title": "ruby-unionfind",
                "content": "\\n# Code\\n```ruby\\nclass NilClass\\n    def >(v) = true\\nend\\n\\nclass Graph\\n    class UnionFind\\n        attr_reader :parents\\n\\n        def initialize(n) = @parents = (0...n).to_a\\n    \\n        def find_parent(i) = (parents[i] == i ? i : (@parents[i] = find_parent(parents[i])))\\n\\n        def union(*uv)\\n            pu, pv = uv.collect {|e| find_parent(e) }\\n            @parents[pu] = pv\\n        end\\n\\n    end\\n\\n    attr_reader :n, :edges\\n\\n    def initialize(n, edges)\\n        @n = n\\n        (@edges = edges.each_with_index.collect {|a, idx| a << idx }).sort_by! {|e| e[2] }\\n    end\\n\\n    def findMST(blk = nil, e = nil)\\n        w, uf = 0, UnionFind.new(n)\\n        unless e.nil? then\\n            w += edges[e][2]\\n            uf.union(*edges[e][0..1])\\n        end\\n        edges.each_with_index {|e, i|\\n            unless i == blk || uf.find_parent(e[0]) == uf.find_parent(e[1]) then\\n                uf.union(*e[0..1])\\n                w += e[2]\\n            end\\n        }\\n        p0 = uf.find_parent(0)\\n        (1...n).any? {|i| uf.find_parent(i) != p0 } ? nil : w\\n    end\\n\\n    def solve\\n        mstw = findMST\\n        edges.each_with_index.each_with_object([[], []]) {|(e, i), (c, pc)|\\n            if findMST(i) > mstw then\\n                c << e.last\\n            else\\n                pc << e.last if mstw == findMST(nil, i)\\n            end\\n        }\\n    end\\nend\\n\\ndef find_critical_and_pseudo_critical_edges(n, edges)\\n    Graph.new(n, edges).solve\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass NilClass\\n    def >(v) = true\\nend\\n\\nclass Graph\\n    class UnionFind\\n        attr_reader :parents\\n\\n        def initialize(n) = @parents = (0...n).to_a\\n    \\n        def find_parent(i) = (parents[i] == i ? i : (@parents[i] = find_parent(parents[i])))\\n\\n        def union(*uv)\\n            pu, pv = uv.collect {|e| find_parent(e) }\\n            @parents[pu] = pv\\n        end\\n\\n    end\\n\\n    attr_reader :n, :edges\\n\\n    def initialize(n, edges)\\n        @n = n\\n        (@edges = edges.each_with_index.collect {|a, idx| a << idx }).sort_by! {|e| e[2] }\\n    end\\n\\n    def findMST(blk = nil, e = nil)\\n        w, uf = 0, UnionFind.new(n)\\n        unless e.nil? then\\n            w += edges[e][2]\\n            uf.union(*edges[e][0..1])\\n        end\\n        edges.each_with_index {|e, i|\\n            unless i == blk || uf.find_parent(e[0]) == uf.find_parent(e[1]) then\\n                uf.union(*e[0..1])\\n                w += e[2]\\n            end\\n        }\\n        p0 = uf.find_parent(0)\\n        (1...n).any? {|i| uf.find_parent(i) != p0 } ? nil : w\\n    end\\n\\n    def solve\\n        mstw = findMST\\n        edges.each_with_index.each_with_object([[], []]) {|(e, i), (c, pc)|\\n            if findMST(i) > mstw then\\n                c << e.last\\n            else\\n                pc << e.last if mstw == findMST(nil, i)\\n            end\\n        }\\n    end\\nend\\n\\ndef find_critical_and_pseudo_critical_edges(n, edges)\\n    Graph.new(n, edges).solve\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931298,
                "title": "video-solution-explanation-with-drawings-java-c",
                "content": "# Intuition, approach and complexity discussed in detail in video solution.\\nhttps://youtu.be/PafEXCOUvWk\\n\\n\\n# Code\\nJava\\n```\\nclass Solution {   \\n    private class DSU{\\n        private Integer parent[] = null, rank[] = null;\\n        public int maxSize;\\n        public DSU(int size){\\n            parent = new Integer[size];\\n            rank = new Integer[size];\\n            Arrays.fill(rank, 1);\\n            maxSize = 0;\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n\\n        }\\n        public int find(int vert){\\n            if(parent[vert] == vert) return vert;\\n            return parent[vert] = find(parent[vert]);\\n        }\\n        void join(int vert1, int vert2){\\n            int rep1 = find(vert1);\\n            int rep2 = find(vert2);\\n            if(rep1 != rep2){\\n                int rank1 = rank[rep1], rank2 = rank[rep2];\\n                if(rank1 < rank2){\\n                    swap(rep1, rep2);\\n                }\\n                parent[rep2] = rep1;\\n                rank[rep1] += rank[rep2];\\n                maxSize = Math.max(maxSize, rank[rep1]);\\n            }\\n        }\\n    }       \\n    private void swap(int val1, int val2){\\n        int temp = val1;\\n        val1 = val2;\\n        val2 = temp;\\n    }       \\n   public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int sz = edges.length;\\n        int[][] egWithIndx = new int[sz][4];\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx][0] = edges[indx][0];\\n            egWithIndx[indx][1] = edges[indx][1];\\n            egWithIndx[indx][2] = edges[indx][2];\\n            egWithIndx[indx][3] = indx;\\n        }\\n        Arrays.sort(egWithIndx, (a, b)->(a[2] - b[2]));\\n\\n        DSU ogMST = new DSU(n);\\n        int ogWt = 0;\\n\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            int []eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            DSU newSpT = new DSU(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                int eg[] = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                int eg[] = egWithIndx[eIndx];\\n                result.get(0).add(eg[3]);\\n            }else{\\n                DSU newSpT1 = new DSU(n);\\n                newSpT1.join(egWithIndx[eIndx][0], egWithIndx[eIndx][1]);\\n                int newWt1 = egWithIndx[eIndx][2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    int []eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    int []eg = egWithIndx[eIndx];\\n                    result.get(1).add(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;  \\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\nprivate: \\nclass DSU{\\nprivate:\\n        vector<int> parent, rank;\\npublic: \\n        int maxSize;\\n        DSU(int size){\\n            maxSize = 0;\\n            parent.resize(size);\\n            rank.resize(size, 1);\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n        }\\npublic:\\n   int find(int vert){\\n       if(parent[vert] == vert) return vert;\\n       return parent[vert] = find(parent[vert]);\\n   }\\n   void join(int vert1, int vert2){\\n       int rep1 = find(vert1);\\n       int rep2 = find(vert2);\\n       if(rep1 != rep2){\\n           int rank1 = rank[rep1], rank2 = rank[rep2];\\n           if(rank1 < rank2){\\n               swap(rep1, rep2);\\n           }\\n           parent[rep2] = rep1;\\n           rank[rep1] += rank[rep2];\\n           maxSize = max(maxSize, rank[rep1]);\\n       }\\n   }  \\n        \\n};    \\npublic:\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> egWithIndx(sz, vector<int>(4));\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx] = edges[indx];\\n            egWithIndx[indx].push_back(indx);\\n        }\\n        sort(egWithIndx.begin(), egWithIndx.end(), [](const vector<int> & eg1, vector<int>& eg2)->bool{\\n            return eg1[2] < eg2[2];\\n        });\\n        DSU ogMST(n);\\n        int ogWt = 0;\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            vector<int> &eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n        cout<<\"ogWt \"<<ogWt<<endl;\\n\\n        vector<vector<int>> result(2);\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            auto &eg = egWithIndx[eIndx];\\n            DSU newSpT(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                vector<int> &eg = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                result[0].push_back(eg[3]);\\n                cout<<\"maxSize\"<<newSpT.maxSize<<\" newWt \"<<newWt<<endl;\\n            }else{\\n                DSU newSpT1(n);\\n                vector<int> &eg = egWithIndx[eIndx];\\n                newSpT1.join(eg[0], eg[1]);\\n                int newWt1 = eg[2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    vector<int> &eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    result[1].push_back(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {   \\n    private class DSU{\\n        private Integer parent[] = null, rank[] = null;\\n        public int maxSize;\\n        public DSU(int size){\\n            parent = new Integer[size];\\n            rank = new Integer[size];\\n            Arrays.fill(rank, 1);\\n            maxSize = 0;\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n\\n        }\\n        public int find(int vert){\\n            if(parent[vert] == vert) return vert;\\n            return parent[vert] = find(parent[vert]);\\n        }\\n        void join(int vert1, int vert2){\\n            int rep1 = find(vert1);\\n            int rep2 = find(vert2);\\n            if(rep1 != rep2){\\n                int rank1 = rank[rep1], rank2 = rank[rep2];\\n                if(rank1 < rank2){\\n                    swap(rep1, rep2);\\n                }\\n                parent[rep2] = rep1;\\n                rank[rep1] += rank[rep2];\\n                maxSize = Math.max(maxSize, rank[rep1]);\\n            }\\n        }\\n    }       \\n    private void swap(int val1, int val2){\\n        int temp = val1;\\n        val1 = val2;\\n        val2 = temp;\\n    }       \\n   public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int sz = edges.length;\\n        int[][] egWithIndx = new int[sz][4];\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx][0] = edges[indx][0];\\n            egWithIndx[indx][1] = edges[indx][1];\\n            egWithIndx[indx][2] = edges[indx][2];\\n            egWithIndx[indx][3] = indx;\\n        }\\n        Arrays.sort(egWithIndx, (a, b)->(a[2] - b[2]));\\n\\n        DSU ogMST = new DSU(n);\\n        int ogWt = 0;\\n\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            int []eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            DSU newSpT = new DSU(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                int eg[] = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                int eg[] = egWithIndx[eIndx];\\n                result.get(0).add(eg[3]);\\n            }else{\\n                DSU newSpT1 = new DSU(n);\\n                newSpT1.join(egWithIndx[eIndx][0], egWithIndx[eIndx][1]);\\n                int newWt1 = egWithIndx[eIndx][2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    int []eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    int []eg = egWithIndx[eIndx];\\n                    result.get(1).add(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;  \\n    }\\n}\\n```\n```\\nclass Solution {\\nprivate: \\nclass DSU{\\nprivate:\\n        vector<int> parent, rank;\\npublic: \\n        int maxSize;\\n        DSU(int size){\\n            maxSize = 0;\\n            parent.resize(size);\\n            rank.resize(size, 1);\\n            for(int vert = 0; vert < size; vert++){\\n                parent[vert] = vert;\\n            }\\n        }\\npublic:\\n   int find(int vert){\\n       if(parent[vert] == vert) return vert;\\n       return parent[vert] = find(parent[vert]);\\n   }\\n   void join(int vert1, int vert2){\\n       int rep1 = find(vert1);\\n       int rep2 = find(vert2);\\n       if(rep1 != rep2){\\n           int rank1 = rank[rep1], rank2 = rank[rep2];\\n           if(rank1 < rank2){\\n               swap(rep1, rep2);\\n           }\\n           parent[rep2] = rep1;\\n           rank[rep1] += rank[rep2];\\n           maxSize = max(maxSize, rank[rep1]);\\n       }\\n   }  \\n        \\n};    \\npublic:\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int sz = edges.size();\\n        vector<vector<int>> egWithIndx(sz, vector<int>(4));\\n        for(int indx = 0; indx < sz; indx++){\\n            egWithIndx[indx] = edges[indx];\\n            egWithIndx[indx].push_back(indx);\\n        }\\n        sort(egWithIndx.begin(), egWithIndx.end(), [](const vector<int> & eg1, vector<int>& eg2)->bool{\\n            return eg1[2] < eg2[2];\\n        });\\n        DSU ogMST(n);\\n        int ogWt = 0;\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            vector<int> &eg = egWithIndx[eIndx];\\n            if(ogMST.find(eg[0]) != ogMST.find(eg[1])){\\n                ogMST.join(eg[0], eg[1]);\\n                ogWt += eg[2];\\n            }    \\n        }\\n        cout<<\"ogWt \"<<ogWt<<endl;\\n\\n        vector<vector<int>> result(2);\\n        for(int eIndx = 0; eIndx < sz; eIndx++){\\n            auto &eg = egWithIndx[eIndx];\\n            DSU newSpT(n);\\n            int newWt = 0;\\n            for(int newEg = 0; newEg < sz; newEg++){\\n                if(newEg == eIndx)continue;\\n                vector<int> &eg = egWithIndx[newEg];\\n                if(newSpT.find(eg[0]) != newSpT.find(eg[1])){\\n                    newSpT.join(eg[0], eg[1]);\\n                    newWt += eg[2];\\n                }    \\n            }\\n            if(newSpT.maxSize < n || newWt > ogWt){\\n                result[0].push_back(eg[3]);\\n                cout<<\"maxSize\"<<newSpT.maxSize<<\" newWt \"<<newWt<<endl;\\n            }else{\\n                DSU newSpT1(n);\\n                vector<int> &eg = egWithIndx[eIndx];\\n                newSpT1.join(eg[0], eg[1]);\\n                int newWt1 = eg[2];\\n                for(int newEg = 0; newEg < sz; newEg++){\\n                    if(newEg == eIndx)continue;\\n                    vector<int> &eg = egWithIndx[newEg];\\n                    if(newSpT1.find(eg[0]) != newSpT1.find(eg[1])){\\n                        newSpT1.join(eg[0], eg[1]);\\n                        newWt1 += eg[2];\\n                    }    \\n                }\\n                if(newSpT1.maxSize == n && newWt1 == ogWt){\\n                    result[1].push_back(eg[3]);\\n                }\\n            }\\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3930866,
                "title": "beginner-friendly-java-code-fully-explained",
                "content": "# Intuition\\nWe are given a graph represented by an array of edges, where each edge has a weight. We want to find critical and pseudo-critical edges in the graph. Critical edges are those that, when removed, increase the overall weight of the minimum spanning tree (MST). Pseudo-critical edges are those that are not critical but become critical when added to the MST. We can solve this problem using Kruskal\\'s algorithm for minimum spanning trees.\\n\\n# Approach\\n1. **Disjoint Set Data Structure (`DisjointSet`):** We define a `DisjointSet` class to manage the union-find operations for the graph\\'s vertices.\\n\\n2. **Graph Representation (`Graph`):** We define a `Graph` class to handle the graph\\'s representation and operations.\\n   - In the constructor, we initialize the sorted edge array `se` and sort it based on the edges\\' weights.\\n   - We implement three methods:\\n     - `kruskal()`: This method implements Kruskal\\'s algorithm to find the weight of the MST.\\n     - `kruskalInc()`: This method calculates the weight of the MST when an edge is included.\\n     - `kruskalExc()`: This method calculates the weight of the MST when an edge is excluded.\\n\\n3. **Solution (`Solution`):** We define a `Solution` class to solve the problem.\\n   - In the `findCriticalAndPseudoCriticalEdges` method, we iterate through each edge and calculate the weight of the MST after including and excluding the edge. Based on these calculations, we determine if the edge is critical or pseudo-critical.\\n\\n\\n**Let\\'s go through two examples to understand how the given solution works**\\n\\n**Example 1:**\\n\\nConsider the following graph with 4 nodes and 5 edges:\\n\\n```\\n   1\\n0 ----- 1\\n|\\\\     |\\n| \\\\3   |4\\n|  \\\\   |\\n|   \\\\  |\\n|    \\\\ |\\n2----- 3\\n   5\\n```\\n\\nEdges: `[[0, 1, 1], [0, 2, 3], [1, 2, 2], [1, 3, 4], [2, 3, 5]]`\\n\\nIn this example, we\\'ll find the critical and pseudo-critical edges.\\n\\n1. **Constructing the MST and Initial Weights:**\\n   - We use Kruskal\\'s algorithm to construct the Minimum Spanning Tree (MST). Initially, all edges are included in the MST with their original weights:\\n     - `MST Weight`: 1 + 2 + 3 = 6\\n\\n2. **Finding Critical Edges:**\\n   - For each edge, we calculate the MST weight after excluding it:\\n     - For edge `[0, 1, 1]`: MST weight after excluding = 3 + 4 = 7 (increased, so critical)\\n     - For edge `[0, 2, 3]`: MST weight after excluding = 1 + 4 = 5 (decreased, not critical)\\n     - For edge `[1, 2, 2]`: MST weight after excluding = 1 + 4 = 5 (decreased, not critical)\\n     - For edge `[1, 3, 4]`: MST weight after excluding = 3 + 2 = 5 (decreased, not critical)\\n     - For edge `[2, 3, 5]`: MST weight after excluding = 3 + 2 = 5 (decreased, not critical)\\n   - So, the critical edge is `[0, 1, 1]`.\\n\\n3. **Finding Pseudo-Critical Edges:**\\n   - For each edge, we calculate the MST weight after including it:\\n     - For edge `[0, 1, 1]`: MST weight after including = 1 + 2 + 2 + 3 = 8 (increased, not pseudo-critical)\\n     - For edge `[0, 2, 3]`: MST weight after including = 1 + 2 + 3 + 4 = 10 (increased, so pseudo-critical)\\n     - For edge `[1, 2, 2]`: MST weight after including = 1 + 2 + 2 + 4 = 9 (increased, not pseudo-critical)\\n     - For edge `[1, 3, 4]`: MST weight after including = 1 + 2 + 2 + 3 = 8 (increased, not pseudo-critical)\\n     - For edge `[2, 3, 5]`: MST weight after including = 1 + 2 + 2 + 3 = 8 (increased, not pseudo-critical)\\n   - So, the pseudo-critical edge is `[0, 2, 3]`.\\n\\n**Example 2:**\\n\\nConsider a similar graph with different edge weights:\\n\\n```\\n   3\\n0 ----- 1\\n|       |\\n|1      |4\\n|       |\\n|       |\\n2----- 3\\n   2\\n```\\n\\nEdges: `[[0, 1, 3], [0, 2, 1], [1, 3, 4], [2, 3, 2]]`\\n\\n1. **Constructing the MST and Initial Weights:**\\n   - MST: `[[0, 2, 1], [2, 3, 2], [0, 1, 3]]`\\n   - `MST Weight`: 1 + 2 + 3 = 6\\n\\n2. **Finding Critical Edges:**\\n   - For each edge, we calculate the MST weight after excluding it:\\n     - For edge `[0, 1, 3]`: MST weight after excluding = 3 + 2 = 5 (decreased, not critical)\\n     - For edge `[0, 2, 1]`: MST weight after excluding = 3 + 4 = 7 (increased, so critical)\\n     - For edge `[1, 3, 4]`: MST weight after excluding = 1 + 2 = 3 (decreased, not critical)\\n     - For edge `[2, 3, 2]`: MST weight after excluding = 1 + 4 = 5 (decreased, not critical)\\n   - So, the critical edge is `[0, 2, 1]`.\\n\\n3. **Finding Pseudo-Critical Edges:**\\n   - For each edge, we calculate the MST weight after including it:\\n     - For edge `[0, 1, 3]`: MST weight after including = 3 + 2 + 4 = 9 (increased, not pseudo-critical)\\n     - For edge `[0, 2, 1]`: MST weight after including = 1 + 2 + 2 + 3 = 8 (decreased, not pseudo-critical)\\n     - For edge `[1, 3, 4]`: MST weight after including = 1 + 2 + 2 + 3 = 8 (decreased, not pseudo-critical)\\n     - For edge `[2, 3, 2]`: MST weight after including = 1 + 2 + 4 = 7 (decreased, so pseudo-critical)\\n   - So, the pseudo-critical edge is `[2, 3, 2]`.\\n\\nThese examples illustrate how the solution identifies critical and pseudo-critical edges in a given graph using Kruskal\\'s algorithm and the provided code.\\n\\n## Complexity\\n- Time complexity:\\n  - Constructing the `DisjointSet`: $$O(n)$$\\n  - Sorting the edges: $$O(E \\\\log E)$$, where $$E$$ is the number of edges.\\n  - Kruskal\\'s algorithm: $$O(E \\\\alpha(V))$$, where $$\\\\alpha$$ is the inverse Ackermann function and $$V$$ is the number of vertices.\\n  - Overall time complexity: $$O(E \\\\log E + E \\\\alpha(V))$$\\n- Space complexity:\\n  - `DisjointSet`: $$O(n)$$\\n  - `Graph`: $$O(E)$$\\n  - `Solution`: $$O(E)$$\\n  - Overall space complexity: $$O(E)$$\\n\\nPlease note that the time complexity of Kruskal\\'s algorithm is usually dominated by $$O(E \\\\log E)$$ due to the sorting step, but the amortized time complexity of union-find operations using disjoint set can be considered as nearly constant ($$\\\\alpha(V)$$ is a very slow-growing function).\\n# Code\\n```\\nclass DisjointSet {\\n    int[] parent;\\n    int[] rank;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Initialize each vertex as its own parent\\n            rank[i] = 0; // Initialize rank to 0\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]); // Path compression\\n        }\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY; // Attach smaller rank tree under root of high rank tree\\n            } else if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX; // Attach smaller rank tree under root of high rank tree\\n            } else {\\n                parent[rootY] = rootX; // Attach one tree under root of another, increment rank\\n                rank[rootX]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Graph {\\n    int se[][];\\n    int n;\\n\\n    public Graph(int edges[][], int n) {\\n        int size = edges.length;\\n        se = new int[size][3];\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            se[i] = edges[i].clone();\\n        }\\n        Arrays.sort(se, (x, y) -> (x[2] - y[2])); // Sort edges based on weights\\n        this.n = n;\\n    }\\n\\n    public int kruskal() {\\n        int sum = 0;\\n\\n        DisjointSet ds = new DisjointSet(n);\\n\\n        for (int[] e : se) {\\n            int f = e[0];\\n            int t = e[1];\\n            int w = e[2];\\n\\n            int pf = ds.find(f);\\n            int pt = ds.find(t);\\n\\n            if (pf != pt) {\\n                ds.union(pf, pt); // Union the vertices if they are not in the same set\\n                sum += w; // Add the weight of the edge to the total MST weight\\n            }\\n        }\\n\\n        return sum; // Return the total weight of the MST\\n    }\\n\\n    // Other methods for calculating MST weights with specific edge inclusion/exclusion\\n    // (kruskalInc and kruskalExc) can be implemented similarly.\\n}\\n\\nclass Solution {\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        res.add(new ArrayList<>()); // List to store critical edges\\n        res.add(new ArrayList<>()); // List to store pseudo-critical edges\\n\\n        Graph g = new Graph(edges, n);\\n\\n        int org = g.kruskal(); // Calculate the weight of the original MST\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int e[] = edges[i];\\n\\n            int exc = g.kruskalExc(e[0], e[1], e[2]); // MST weight after excluding the edge\\n\\n            if (org != exc) {\\n                res.get(0).add(i); // If MST weight increased, edge is critical\\n            } else {\\n                int inc = g.kruskalInc(e[0], e[1], e[2]); // MST weight after including the edge\\n\\n                if (org == inc) {\\n                    res.get(1).add(i); // If MST weight remains same, edge is pseudo-critical\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\n   1\\n0 ----- 1\\n|\\\\     |\\n| \\\\3   |4\\n|  \\\\   |\\n|   \\\\  |\\n|    \\\\ |\\n2----- 3\\n   5\\n```\n```\\n   3\\n0 ----- 1\\n|       |\\n|1      |4\\n|       |\\n|       |\\n2----- 3\\n   2\\n```\n```\\nclass DisjointSet {\\n    int[] parent;\\n    int[] rank;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Initialize each vertex as its own parent\\n            rank[i] = 0; // Initialize rank to 0\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]); // Path compression\\n        }\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY; // Attach smaller rank tree under root of high rank tree\\n            } else if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX; // Attach smaller rank tree under root of high rank tree\\n            } else {\\n                parent[rootY] = rootX; // Attach one tree under root of another, increment rank\\n                rank[rootX]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Graph {\\n    int se[][];\\n    int n;\\n\\n    public Graph(int edges[][], int n) {\\n        int size = edges.length;\\n        se = new int[size][3];\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            se[i] = edges[i].clone();\\n        }\\n        Arrays.sort(se, (x, y) -> (x[2] - y[2])); // Sort edges based on weights\\n        this.n = n;\\n    }\\n\\n    public int kruskal() {\\n        int sum = 0;\\n\\n        DisjointSet ds = new DisjointSet(n);\\n\\n        for (int[] e : se) {\\n            int f = e[0];\\n            int t = e[1];\\n            int w = e[2];\\n\\n            int pf = ds.find(f);\\n            int pt = ds.find(t);\\n\\n            if (pf != pt) {\\n                ds.union(pf, pt); // Union the vertices if they are not in the same set\\n                sum += w; // Add the weight of the edge to the total MST weight\\n            }\\n        }\\n\\n        return sum; // Return the total weight of the MST\\n    }\\n\\n    // Other methods for calculating MST weights with specific edge inclusion/exclusion\\n    // (kruskalInc and kruskalExc) can be implemented similarly.\\n}\\n\\nclass Solution {\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        res.add(new ArrayList<>()); // List to store critical edges\\n        res.add(new ArrayList<>()); // List to store pseudo-critical edges\\n\\n        Graph g = new Graph(edges, n);\\n\\n        int org = g.kruskal(); // Calculate the weight of the original MST\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int e[] = edges[i];\\n\\n            int exc = g.kruskalExc(e[0], e[1], e[2]); // MST weight after excluding the edge\\n\\n            if (org != exc) {\\n                res.get(0).add(i); // If MST weight increased, edge is critical\\n            } else {\\n                int inc = g.kruskalInc(e[0], e[1], e[2]); // MST weight after including the edge\\n\\n                if (org == inc) {\\n                    res.get(1).add(i); // If MST weight remains same, edge is pseudo-critical\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930827,
                "title": "beats-100-c-kruskal-s-algorithm-beginner-friendly-easy-to-understand-disjoint-set",
                "content": "# Intuition\\nUse the Kruskal\\'s algorithm to find the minimum spanning tree by sorting the edges and picking edges from ones with smaller weights.\\nUse a disjoint set to avoid adding redundant edges that result in a cycle.\\n\\nTo find if one edge is critical, delete that edge and re-run the MST algorithm and see if the weight of the new MST increases.\\n\\nTo find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(E\\u2217logE) + 2E*O(E\\\\*4\\u03B1\\\\*2))**\\nfor sorting + then applying Kruskal for each edge to check if its critical/pseudo-critical\\nTC of every Kruskal:\\nWe are using the disjoint set operations inside a loop. The loop will continue to E times. Inside that loop, there are two disjoint set operations like findParent() and unionByRank() each taking 4 and so it will result in 4\\u03B1\\\\*2. That is why the last term O(E*4\\u03B1\\\\*2) is added.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n    Disjoint set takes O(N) space for storing each node\\'s parent and rank\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    public:\\n    vector<int> rank,parent;\\n    DSU(int n)\\n    {\\n        rank.resize(n);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    int findParent(int i)\\n    {\\n        if(parent[i]==i)    return i;\\n        return parent[i]=findParent(parent[i]);\\n    }\\n    void unionByRank(int u,int v)\\n    {\\n        u=findParent(u);\\n        v=findParent(v);\\n        if(u==v) return;\\n        if(rank[u]>rank[v])\\n            parent[v]=u;\\n        else if(rank[u]<rank[v])\\n            parent[u]=v;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n        return;\\n    }\\n    bool sameComponent(int u,int v){\\n        return findParent(u)==findParent(v);\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int>& e1,vector<int>& e2)\\n    {\\n        return e1[2]<e2[2];\\n    }\\n    int kruskal(int n, vector<vector<int>>& edges,int exclude=-1,int include=-1)\\n    {\\n        DSU dsu(n+1);\\n        int mstWt=0;\\n        int cnt=0;\\n        if(include!=-1)\\n        {\\n            int u=edges[include][0];\\n            int v=edges[include][1];\\n            int wt=edges[include][2];\\n            mstWt+=wt;\\n            cnt++;\\n            dsu.unionByRank(u,v);\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(i==exclude)  continue;\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            int wt=edges[i][2];\\n            if(dsu.sameComponent(u,v))  continue;\\n            mstWt+=wt;\\n            cnt++;\\n            dsu.unionByRank(u,v);\\n        }\\n        return (cnt==n-1)?mstWt:INT_MAX;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int E=edges.size();\\n        for(int i=0;i<E;i++)\\n            edges[i].push_back(i);  //numbering all edges\\n        sort(edges.begin(),edges.end(),comparator);\\n        int mstWt=kruskal(n,edges,-1,-1);\\n        set<int> critical,pcritical;\\n        for(int i=0;i<E;i++)\\n        {\\n            int newMstWt=kruskal(n,edges,i,-1);\\n            if(newMstWt!=mstWt)\\n                critical.insert(edges[i][3]);\\n        }\\n        for(int i=0;i<E;i++)\\n        {\\n            int newMstWt=kruskal(n,edges,-1,i);\\n            if(newMstWt==mstWt && critical.find(edges[i][3])==critical.end())\\n                pcritical.insert(edges[i][3]);\\n        }\\n        vector<vector<int>> ans(2);\\n        for(auto it:critical)\\n            ans[0].push_back(it);\\n        for(auto it:pcritical)\\n            ans[1].push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass DSU{\\n    public:\\n    vector<int> rank,parent;\\n    DSU(int n)\\n    {\\n        rank.resize(n);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    int findParent(int i)\\n    {\\n        if(parent[i]==i)    return i;\\n        return parent[i]=findParent(parent[i]);\\n    }\\n    void unionByRank(int u,int v)\\n    {\\n        u=findParent(u);\\n        v=findParent(v);\\n        if(u==v) return;\\n        if(rank[u]>rank[v])\\n            parent[v]=u;\\n        else if(rank[u]<rank[v])\\n            parent[u]=v;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n        return;\\n    }\\n    bool sameComponent(int u,int v){\\n        return findParent(u)==findParent(v);\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int>& e1,vector<int>& e2)\\n    {\\n        return e1[2]<e2[2];\\n    }\\n    int kruskal(int n, vector<vector<int>>& edges,int exclude=-1,int include=-1)\\n    {\\n        DSU dsu(n+1);\\n        int mstWt=0;\\n        int cnt=0;\\n        if(include!=-1)\\n        {\\n            int u=edges[include][0];\\n            int v=edges[include][1];\\n            int wt=edges[include][2];\\n            mstWt+=wt;\\n            cnt++;\\n            dsu.unionByRank(u,v);\\n        }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(i==exclude)  continue;\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            int wt=edges[i][2];\\n            if(dsu.sameComponent(u,v))  continue;\\n            mstWt+=wt;\\n            cnt++;\\n            dsu.unionByRank(u,v);\\n        }\\n        return (cnt==n-1)?mstWt:INT_MAX;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int E=edges.size();\\n        for(int i=0;i<E;i++)\\n            edges[i].push_back(i);  //numbering all edges\\n        sort(edges.begin(),edges.end(),comparator);\\n        int mstWt=kruskal(n,edges,-1,-1);\\n        set<int> critical,pcritical;\\n        for(int i=0;i<E;i++)\\n        {\\n            int newMstWt=kruskal(n,edges,i,-1);\\n            if(newMstWt!=mstWt)\\n                critical.insert(edges[i][3]);\\n        }\\n        for(int i=0;i<E;i++)\\n        {\\n            int newMstWt=kruskal(n,edges,-1,i);\\n            if(newMstWt==mstWt && critical.find(edges[i][3])==critical.end())\\n                pcritical.insert(edges[i][3]);\\n        }\\n        vector<vector<int>> ans(2);\\n        for(auto it:critical)\\n            ans[0].push_back(it);\\n        for(auto it:pcritical)\\n            ans[1].push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929756,
                "title": "c-simple-solution-using-kruskal-algorithm",
                "content": "# Intuition\\n- Firstly, run the MST algorithm to find the total weight of Minimum Spanning Tree of the graph.\\n- To find if one edge is critical, delete that edge and re-run the MST algorithm and see if the weight of the new MST increases.\\n- To find if a non-critical edge is peudo-critical, include that edge and re-run the MST algorithm and see if the weight of the new MST the same.\\n- Since we only interactive with edges of the MST, so Kruskal\\'s Algorithm is a best fit to solve this problem.\\n\\n# Approach\\nWe use the kruskal MST algorithm, and denote the total MST weight as `original_mst`.\\nTo generate critical and pseudo-critical lists, we enumerate each edge:\\n\\n1. If deleting the edge and re-calculating the mst again makes mst total weight increase (or can\\'t form mst), then the edge goes into critical list.\\n2. If we force adding the edge to the mst (by first adding the edge to the mst edge set and run the standard MST algorithm for the rest of the edges), and find that the mst doesn\\'t change, then the edge goes into pseudo-critical list. (This is because if an edge can be in any mst, we can always add it to the edge set first, without changing the final mst total weight).\\n\\n# Complexity\\n- Time complexity: `O(ElogE + ElogV)`, which is approximately `O(ElogV)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(V + E)`, where V is the number of vertices and E is the number of edges in the graph.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for (int i=0; i<=n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) {\\n            return;\\n        }\\n        if (ulp_u < ulp_v) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_u] += size[ulp_v];\\n        } else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    int kruskal(int n, vector<vector<int>>& edges, int skip, int prev = -1) {\\n        DisjointSet ds(n);\\n        int mst_weight = 0;\\n        if (prev != -1) {\\n            mst_weight += edges[prev][2];\\n            ds.unionBySize(edges[prev][0], edges[prev][1]);\\n        }\\n        for (int i=0; i<edges.size(); i++) {\\n            if (i == skip) {\\n                continue;\\n            }\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int wt = edges[i][2];\\n            if (ds.findUPar(u) == ds.findUPar(v)) {\\n                continue;\\n            }\\n            ds.unionBySize(u, v);\\n            mst_weight += wt;\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (ds.findUPar(i) != ds.findUPar(0)) {\\n                return INT_MAX;\\n            }\\n        }\\n        return mst_weight;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i=0; i<edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int original_mst = kruskal(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i=0; i<edges.size(); i++) {\\n            if (original_mst < kruskal(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (original_mst == kruskal(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for (int i=0; i<=n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) {\\n            return;\\n        }\\n        if (ulp_u < ulp_v) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_u] += size[ulp_v];\\n        } else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    int kruskal(int n, vector<vector<int>>& edges, int skip, int prev = -1) {\\n        DisjointSet ds(n);\\n        int mst_weight = 0;\\n        if (prev != -1) {\\n            mst_weight += edges[prev][2];\\n            ds.unionBySize(edges[prev][0], edges[prev][1]);\\n        }\\n        for (int i=0; i<edges.size(); i++) {\\n            if (i == skip) {\\n                continue;\\n            }\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int wt = edges[i][2];\\n            if (ds.findUPar(u) == ds.findUPar(v)) {\\n                continue;\\n            }\\n            ds.unionBySize(u, v);\\n            mst_weight += wt;\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (ds.findUPar(i) != ds.findUPar(0)) {\\n                return INT_MAX;\\n            }\\n        }\\n        return mst_weight;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for (int i=0; i<edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int original_mst = kruskal(n, edges, -1);\\n        vector<int> critical, non_critical;\\n        for (int i=0; i<edges.size(); i++) {\\n            if (original_mst < kruskal(n, edges, i)) {\\n                critical.push_back(edges[i][3]);\\n            } else if (original_mst == kruskal(n, edges, -1, i)) {\\n                non_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, non_critical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929724,
                "title": "100-best-solution-and-easy-understanble-with-comments-mst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# plss Upvote For Me :(\\n\\n# Creating Class For MST Algorithm\\nclass UnionFind:\\n    def __init__ (self, n):\\n        self.parents = list(range(n))  # Initialy Every Vertex Is It\\'s Own Parent\\n        self.weight = 0                # Initialy Weight = 0\\n        self.edgeCount = 0             # Initialy edgeCount = 0\\n\\n    def find(self, x):                 # Find Function TO Find The Parent Of X Recursively\\n        if x != self.parents[x]:       # If X is not it\\'s Own Parent\\n            self.parents[x] = self.find(self.parents[x])    # then Finding It\\'s Parent\\n        return self.parents[x]         # Returning The Parent Of X\\n\\n    def union(self, x, y, w):          # Union Function TO Creating MST Algo\\n        r1 = self.find(x)              # Finding The X Parent\\n        r2 = self.find(y)              # Finding The Y Parent\\n\\n        if r1 != r2:                   # If the Parents Are Not Same\\n            self.parents[r2] = r1      # The create Parent of r2 to r1\\n            self.weight += w           # Incresing the Weight\\n            self.edgeCount += 1        # Increasing The EsgeCount by 1\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Step 1: Sorting the edges List\\n        edges = [(w,a,b,i) for i, (a,b,w) in enumerate(edges)]  # As we have to return i (index)\\n        edges.sort()\\n\\n        # Step 2: Finding the First MinWeight In entire edges\\n        uf1 = UnionFind(n)\\n        for w, a, b, _ in edges:\\n            uf1.union(a, b, w)\\n\\n        minWeight = uf1.weight\\n\\n        # Step 3: Defining The Critical and Pseudo Critical Edges Empty \\n        ce = []\\n        pce = []\\n        m = len(edges)\\n\\n\\n        # step 4: Now Including And Excludeing the edges to find Critical and PsuedoCritical edges\\n        for i in range(m):\\n            uf2 = UnionFind(n)              # Creting New uf2 UnionFind Class\\n            for j in range(m):              # for every edge\\n                if i == j:\\n                    continue\\n                w,a,b,_ = edges[j]    \\n                uf2.union(a,b,w)            # Unioning the x, y\\n            \\n            # if curr weight is greather or we didn\\'t draw the proper graph\\n            if uf2.weight > minWeight or uf2.edgeCount < n-1:\\n                ce.append(edges[i][3])     # It is a Critical Edge\\n\\n\\n            else:\\n                # Forcefully adding the edge i and again doing MST Algo\\n                uf3 = UnionFind(n)               # creating new object Class\\n                w,a,b,_ = edges[i]               # taking the i edges\\n                uf3.union(a,b,w)                 # unioning the first i edge\\n                for j in range(m):\\n                    w,a,b,_ = edges[j]           # Uninoning the edges acordingly\\n                    uf3.union(a,b,w)\\n                \\n                if uf3.weight == minWeight:      # If curr weight == min wight\\n                    pce.append(edges[i][3])      # it is a PseudoCritical Edge\\n\\n        return ce, pce    # Now Returning The Critical Edge And PseudoCretical Edge\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# plss Upvote For Me :(\\n\\n# Creating Class For MST Algorithm\\nclass UnionFind:\\n    def __init__ (self, n):\\n        self.parents = list(range(n))  # Initialy Every Vertex Is It\\'s Own Parent\\n        self.weight = 0                # Initialy Weight = 0\\n        self.edgeCount = 0             # Initialy edgeCount = 0\\n\\n    def find(self, x):                 # Find Function TO Find The Parent Of X Recursively\\n        if x != self.parents[x]:       # If X is not it\\'s Own Parent\\n            self.parents[x] = self.find(self.parents[x])    # then Finding It\\'s Parent\\n        return self.parents[x]         # Returning The Parent Of X\\n\\n    def union(self, x, y, w):          # Union Function TO Creating MST Algo\\n        r1 = self.find(x)              # Finding The X Parent\\n        r2 = self.find(y)              # Finding The Y Parent\\n\\n        if r1 != r2:                   # If the Parents Are Not Same\\n            self.parents[r2] = r1      # The create Parent of r2 to r1\\n            self.weight += w           # Incresing the Weight\\n            self.edgeCount += 1        # Increasing The EsgeCount by 1\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # Step 1: Sorting the edges List\\n        edges = [(w,a,b,i) for i, (a,b,w) in enumerate(edges)]  # As we have to return i (index)\\n        edges.sort()\\n\\n        # Step 2: Finding the First MinWeight In entire edges\\n        uf1 = UnionFind(n)\\n        for w, a, b, _ in edges:\\n            uf1.union(a, b, w)\\n\\n        minWeight = uf1.weight\\n\\n        # Step 3: Defining The Critical and Pseudo Critical Edges Empty \\n        ce = []\\n        pce = []\\n        m = len(edges)\\n\\n\\n        # step 4: Now Including And Excludeing the edges to find Critical and PsuedoCritical edges\\n        for i in range(m):\\n            uf2 = UnionFind(n)              # Creting New uf2 UnionFind Class\\n            for j in range(m):              # for every edge\\n                if i == j:\\n                    continue\\n                w,a,b,_ = edges[j]    \\n                uf2.union(a,b,w)            # Unioning the x, y\\n            \\n            # if curr weight is greather or we didn\\'t draw the proper graph\\n            if uf2.weight > minWeight or uf2.edgeCount < n-1:\\n                ce.append(edges[i][3])     # It is a Critical Edge\\n\\n\\n            else:\\n                # Forcefully adding the edge i and again doing MST Algo\\n                uf3 = UnionFind(n)               # creating new object Class\\n                w,a,b,_ = edges[i]               # taking the i edges\\n                uf3.union(a,b,w)                 # unioning the first i edge\\n                for j in range(m):\\n                    w,a,b,_ = edges[j]           # Uninoning the edges acordingly\\n                    uf3.union(a,b,w)\\n                \\n                if uf3.weight == minWeight:      # If curr weight == min wight\\n                    pce.append(edges[i][3])      # it is a PseudoCritical Edge\\n\\n        return ce, pce    # Now Returning The Critical Edge And PseudoCretical Edge\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929433,
                "title": "c-easy-to-understand-union-find",
                "content": "# Code\\n```\\nstruct mycmp{\\n     bool operator()(vector<int>&a , vector<int>&b){\\n         if(a[2] < b[2]) return true;\\n         else return false;\\n     }\\n};\\nclass DSU{\\n       vector<int> parent;\\n       vector<int> rank;\\n       public:\\n       DSU(int n){\\n           parent.resize(n);\\n           rank.resize(n , 0);\\n           for(int i = 0 ; i < n  ;i++)parent[i] = i;\\n       }\\n       int findPar(int node){\\n           if(parent[node] == node)return node;\\n           return parent[node] = findPar(parent[node]);\\n       }\\n       void UnionByRank(int u , int v){\\n           int pu = findPar(u);\\n           int pv = findPar(v);\\n           if(pu == pv) return;\\n\\n           if(rank[pu] > rank[pv]){\\n               parent[pv] = pu;\\n           }else if(rank[pv] > rank[pu]){\\n               parent[pu] = pv;\\n           }else{\\n               parent[pv] = pu;\\n               rank[pu]++;\\n           }\\n       }\\n};\\nint MSTWeight(int n, vector<vector<int>> &edges){\\n       DSU ds(n);\\n       int result = 0;\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       return result;\\n}\\nint MSTWeightPseudoCritical(int n, vector<vector<int>> &edges , vector<int> &arr){\\n       DSU ds(n);\\n       int result = 0;\\n       int pu = arr[0];\\n       int pv = arr[1];\\n       int wt = arr[2];\\n       result+=wt;\\n       ds.UnionByRank(pu , pv);\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       return result;\\n}\\nint MSTWeightCritical(int n, vector<vector<int>> &edges , vector<int> &arr){\\n       DSU ds(n);\\n       int result = 0;\\n       int pu = arr[0];\\n       int pv = arr[1];\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n              if(pu == u && pv == v)continue;\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       for(int i = 0 ; i < n ; i++) {\\n           if(ds.findPar(0) != ds.findPar(i)){\\n               result = (int)1e9;\\n               break;\\n           }\\n       }\\n       return result;\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {        \\n         vector<vector<int>> temp = edges;\\n         sort(temp.begin() , temp.end() , mycmp());\\n         int mst = MSTWeight(n , temp);\\n         vector<vector<int>> answer(2 , vector<int>());\\n         \\n         \\n         for(int i = 0 ; i < edges.size() ; i++){\\n               int number = MSTWeightCritical(n , temp , edges[i]);\\n               if(number > mst){\\n                   answer[0].push_back(i);\\n                   continue;\\n               }\\n               number = MSTWeightPseudoCritical(n , temp , edges[i]);\\n               if(number == mst){\\n                   answer[1].push_back(i);\\n               }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct mycmp{\\n     bool operator()(vector<int>&a , vector<int>&b){\\n         if(a[2] < b[2]) return true;\\n         else return false;\\n     }\\n};\\nclass DSU{\\n       vector<int> parent;\\n       vector<int> rank;\\n       public:\\n       DSU(int n){\\n           parent.resize(n);\\n           rank.resize(n , 0);\\n           for(int i = 0 ; i < n  ;i++)parent[i] = i;\\n       }\\n       int findPar(int node){\\n           if(parent[node] == node)return node;\\n           return parent[node] = findPar(parent[node]);\\n       }\\n       void UnionByRank(int u , int v){\\n           int pu = findPar(u);\\n           int pv = findPar(v);\\n           if(pu == pv) return;\\n\\n           if(rank[pu] > rank[pv]){\\n               parent[pv] = pu;\\n           }else if(rank[pv] > rank[pu]){\\n               parent[pu] = pv;\\n           }else{\\n               parent[pv] = pu;\\n               rank[pu]++;\\n           }\\n       }\\n};\\nint MSTWeight(int n, vector<vector<int>> &edges){\\n       DSU ds(n);\\n       int result = 0;\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       return result;\\n}\\nint MSTWeightPseudoCritical(int n, vector<vector<int>> &edges , vector<int> &arr){\\n       DSU ds(n);\\n       int result = 0;\\n       int pu = arr[0];\\n       int pv = arr[1];\\n       int wt = arr[2];\\n       result+=wt;\\n       ds.UnionByRank(pu , pv);\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       return result;\\n}\\nint MSTWeightCritical(int n, vector<vector<int>> &edges , vector<int> &arr){\\n       DSU ds(n);\\n       int result = 0;\\n       int pu = arr[0];\\n       int pv = arr[1];\\n       for(int i = 0 ; i < edges.size() ; i++){\\n              int u = edges[i][0];\\n              int v = edges[i][1];\\n              int wt = edges[i][2];\\n              if(pu == u && pv == v)continue;\\n              if(ds.findPar(u) == ds.findPar(v))continue;\\n              result+=wt;\\n              ds.UnionByRank(u , v);\\n       }\\n       for(int i = 0 ; i < n ; i++) {\\n           if(ds.findPar(0) != ds.findPar(i)){\\n               result = (int)1e9;\\n               break;\\n           }\\n       }\\n       return result;\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {        \\n         vector<vector<int>> temp = edges;\\n         sort(temp.begin() , temp.end() , mycmp());\\n         int mst = MSTWeight(n , temp);\\n         vector<vector<int>> answer(2 , vector<int>());\\n         \\n         \\n         for(int i = 0 ; i < edges.size() ; i++){\\n               int number = MSTWeightCritical(n , temp , edges[i]);\\n               if(number > mst){\\n                   answer[0].push_back(i);\\n                   continue;\\n               }\\n               number = MSTWeightPseudoCritical(n , temp , edges[i]);\\n               if(number == mst){\\n                   answer[1].push_back(i);\\n               }\\n         }\\n         return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929045,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution :\\n    def find(self,u,parent):\\n        if u==parent[u]:\\n            return u\\n        return self.find(parent[u],parent)\\n\\n    def unionDSU(self,u,v,parent) :\\n        p1=self.find(u,parent)\\n        p2=self.find(v,parent)\\n        parent[p2]=p1\\n\\n    def mst(self,k,edges,includeEdge,excludeEdge) :\\n        n=len(includeEdge)\\n        m=len(excludeEdge)\\n        parent=[]\\n        for i in range(k): \\n            parent.append(i);\\n        \\n        res=0\\n        count=0\\n\\n        if n!= 0 :\\n            self.unionDSU(includeEdge[0], includeEdge[1], parent)\\n            res+=includeEdge[2]\\n            count+=1\\n        \\n        for edge in edges:\\n            u=edge[0];\\n            v=edge[1];\\n            cost=edge[2];\\n\\n            if m!=0 and excludeEdge[0]==u and excludeEdge[1]==v and excludeEdge[2]==cost :\\n                continue\\n            \\n            if n!=0 and includeEdge[0]==u and includeEdge[1]==v and includeEdge[2]==cost :\\n                continue\\n            \\n            p1=self.find(u,parent)\\n            p2=self.find(v,parent)\\n\\n            if p1!= p2:\\n                self.unionDSU(p1, p2, parent)\\n                res+= cost\\n                count += 1\\n                    \\n        return  res if count==k-1 else float(\\'inf\\')\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, k:int, edges:List[List[int]]) -> List[List[int]]:\\n        \\n        originalEdges=[]\\n        for edge in edges : \\n            originalEdge=[edge[0],edge[1],edge[2]]\\n            originalEdges.append(originalEdge)\\n            \\n        X=len(originalEdges)\\n        ans=[]\\n        criticalEdges=[]\\n        pseudoCriticalEdges=[]\\n\\n        \\n        edges=sorted(edges, key = lambda x: x[2])\\n\\n        emptyVector=[]\\n        originalCost = self.mst(k, edges, emptyVector, emptyVector)\\n        \\n        for i in range(X): \\n            excludedCost = self.mst(k, edges, emptyVector, originalEdges[i])\\n            includedCost = self.mst(k, edges, originalEdges[i], emptyVector)\\n\\n            if excludedCost > originalCost :\\n                criticalEdges.append(i)\\n                \\n            elif includedCost==originalCost : \\n                pseudoCriticalEdges.append(i)\\n                    \\n        ans.append(criticalEdges)\\n        ans.append(pseudoCriticalEdges)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    def find(self,u,parent):\\n        if u==parent[u]:\\n            return u\\n        return self.find(parent[u],parent)\\n\\n    def unionDSU(self,u,v,parent) :\\n        p1=self.find(u,parent)\\n        p2=self.find(v,parent)\\n        parent[p2]=p1\\n\\n    def mst(self,k,edges,includeEdge,excludeEdge) :\\n        n=len(includeEdge)\\n        m=len(excludeEdge)\\n        parent=[]\\n        for i in range(k): \\n            parent.append(i);\\n        \\n        res=0\\n        count=0\\n\\n        if n!= 0 :\\n            self.unionDSU(includeEdge[0], includeEdge[1], parent)\\n            res+=includeEdge[2]\\n            count+=1\\n        \\n        for edge in edges:\\n            u=edge[0];\\n            v=edge[1];\\n            cost=edge[2];\\n\\n            if m!=0 and excludeEdge[0]==u and excludeEdge[1]==v and excludeEdge[2]==cost :\\n                continue\\n            \\n            if n!=0 and includeEdge[0]==u and includeEdge[1]==v and includeEdge[2]==cost :\\n                continue\\n            \\n            p1=self.find(u,parent)\\n            p2=self.find(v,parent)\\n\\n            if p1!= p2:\\n                self.unionDSU(p1, p2, parent)\\n                res+= cost\\n                count += 1\\n                    \\n        return  res if count==k-1 else float(\\'inf\\')\\n    \\n    def findCriticalAndPseudoCriticalEdges(self, k:int, edges:List[List[int]]) -> List[List[int]]:\\n        \\n        originalEdges=[]\\n        for edge in edges : \\n            originalEdge=[edge[0],edge[1],edge[2]]\\n            originalEdges.append(originalEdge)\\n            \\n        X=len(originalEdges)\\n        ans=[]\\n        criticalEdges=[]\\n        pseudoCriticalEdges=[]\\n\\n        \\n        edges=sorted(edges, key = lambda x: x[2])\\n\\n        emptyVector=[]\\n        originalCost = self.mst(k, edges, emptyVector, emptyVector)\\n        \\n        for i in range(X): \\n            excludedCost = self.mst(k, edges, emptyVector, originalEdges[i])\\n            includedCost = self.mst(k, edges, originalEdges[i], emptyVector)\\n\\n            if excludedCost > originalCost :\\n                criticalEdges.append(i)\\n                \\n            elif includedCost==originalCost : \\n                pseudoCriticalEdges.append(i)\\n                    \\n        ans.append(criticalEdges)\\n        ans.append(pseudoCriticalEdges)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547969,
                "title": "c-solution-using-dsu-mst-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public class Edge{\\n        public int id{get;set;}\\n        public int from{get;set;}\\n        public int to{get;set;}\\n        public int cost{get;set;}\\n    }\\n    class DSU{\\n        int[] par, sz;\\n        public int componentCount;\\n        public DSU(int n){\\n            par = new int[n];\\n            componentCount = n;\\n            sz = new int[n];\\n            for(int i = 0; i < n;i++){\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        public int FindParent(int u){\\n            if(par[u] == u) return u;\\n            int p = FindParent(par[u]);\\n            par[u] = p;\\n            return p;\\n        }\\n        public bool IsSameComponent(int u , int v) => FindParent(u) == FindParent(v);\\n        public void Join(int u,int v){\\n            u = FindParent(u);\\n            v = FindParent(v);\\n            if(u == v) return;\\n            if(sz[u] < sz[v]) (u,v) = (v,u);\\n            par[v] = u;\\n            sz[u]+=sz[v];\\n            componentCount--;\\n        }\\n    }\\n    int kruskal(PriorityQueue<Edge,int> edges, int nodes,Edge taken = null){\\n        int res = 0;\\n        DSU dsu = new DSU(nodes);\\n        if(taken != null){\\n            dsu.Join(taken.from, taken.to);\\n            res += taken.cost;\\n        }\\n        while(dsu.componentCount > 1 && edges.Count > 0){\\n            var e = edges.Dequeue();\\n            if(dsu.IsSameComponent(e.from, e.to)) continue;\\n            dsu.Join(e.from, e.to);\\n            res += e.cost;\\n        }\\n        if(dsu.componentCount > 1) return Int32.MaxValue;\\n        return res;\\n    }\\n    public PriorityQueue<Edge,int> GetEdges(int[][] edges,int skipedIdx = -1){\\n        PriorityQueue<Edge,int> edgesPq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0;i < edges.Length;i++){\\n            if(i == skipedIdx) continue;\\n            edgesPq.Enqueue(new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]},edges[i][2]);\\n        }\\n        return edgesPq;\\n    }\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost =  kruskal(GetEdges(edges),n);\\n        List<IList<int>> res = new List<IList<int>>(){new List<int>(),new List<int>()};\\n        for(int i = 0; i < edges.Length;i++){\\n            int curCost = kruskal(GetEdges(edges,i),n);\\n            if(curCost > mstCost) res[0].Add(i);\\n            else{\\n                Edge taken = new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]};\\n                curCost = kruskal(GetEdges(edges),n,taken);\\n                if(curCost == mstCost)res[1].Add(i);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Union Find",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public class Edge{\\n        public int id{get;set;}\\n        public int from{get;set;}\\n        public int to{get;set;}\\n        public int cost{get;set;}\\n    }\\n    class DSU{\\n        int[] par, sz;\\n        public int componentCount;\\n        public DSU(int n){\\n            par = new int[n];\\n            componentCount = n;\\n            sz = new int[n];\\n            for(int i = 0; i < n;i++){\\n                par[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        public int FindParent(int u){\\n            if(par[u] == u) return u;\\n            int p = FindParent(par[u]);\\n            par[u] = p;\\n            return p;\\n        }\\n        public bool IsSameComponent(int u , int v) => FindParent(u) == FindParent(v);\\n        public void Join(int u,int v){\\n            u = FindParent(u);\\n            v = FindParent(v);\\n            if(u == v) return;\\n            if(sz[u] < sz[v]) (u,v) = (v,u);\\n            par[v] = u;\\n            sz[u]+=sz[v];\\n            componentCount--;\\n        }\\n    }\\n    int kruskal(PriorityQueue<Edge,int> edges, int nodes,Edge taken = null){\\n        int res = 0;\\n        DSU dsu = new DSU(nodes);\\n        if(taken != null){\\n            dsu.Join(taken.from, taken.to);\\n            res += taken.cost;\\n        }\\n        while(dsu.componentCount > 1 && edges.Count > 0){\\n            var e = edges.Dequeue();\\n            if(dsu.IsSameComponent(e.from, e.to)) continue;\\n            dsu.Join(e.from, e.to);\\n            res += e.cost;\\n        }\\n        if(dsu.componentCount > 1) return Int32.MaxValue;\\n        return res;\\n    }\\n    public PriorityQueue<Edge,int> GetEdges(int[][] edges,int skipedIdx = -1){\\n        PriorityQueue<Edge,int> edgesPq = new(Comparer<int>.Create((a, b) => a.CompareTo(b)));\\n        for(int i = 0;i < edges.Length;i++){\\n            if(i == skipedIdx) continue;\\n            edgesPq.Enqueue(new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]},edges[i][2]);\\n        }\\n        return edgesPq;\\n    }\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost =  kruskal(GetEdges(edges),n);\\n        List<IList<int>> res = new List<IList<int>>(){new List<int>(),new List<int>()};\\n        for(int i = 0; i < edges.Length;i++){\\n            int curCost = kruskal(GetEdges(edges,i),n);\\n            if(curCost > mstCost) res[0].Add(i);\\n            else{\\n                Edge taken = new Edge{id = i,from = edges[i][0], to = edges[i][1],cost = edges[i][2]};\\n                curCost = kruskal(GetEdges(edges),n,taken);\\n                if(curCost == mstCost)res[1].Add(i);\\n            } \\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371211,
                "title": "c-solution-well-commented-beginner-friendly",
                "content": "```\\nclass UnionFind {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    UnionFind(int n){\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++){\\n            //initially every vertex is parent of itself.\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    int Find(int x){\\n        //This function finds the parent of a vertex.\\n        //if a vertex is parent of itself return the vertex.\\n        if(parent[x]==x){\\n            return x;\\n        }\\n        else{\\n            //else recursively call for parent of vertex.\\n            return Find(parent[x]);\\n        }\\n    }\\n    void Union(int x, int y){\\n        //find parents of both vertices.\\n        int parent_x=Find(x);\\n        int parent_y=Find(y);\\n        //if they have same parent, we don\\'t need to unite them.\\n        if(parent_x==parent_y)\\n            return;\\n        //each set is a tree in itself.\\n        //rank is basically height of tree with parent as root.\\n        //if height of tree1>tree2, make tree2 as child of tree1.\\n        //as this would avoid chaining of nodes and hence time complexity.\\n        if(rank[parent_x]>rank[parent_y]){\\n            parent[parent_y]=parent_x;\\n        }\\n        else if(rank[parent_x]<rank[parent_y]){\\n            parent[parent_x]=parent_y;\\n        }\\n        else{\\n            parent[parent_y]=parent_x;\\n            //if both trees have same height, make anyone as child of other.\\n            //this would increase the overall height of resultant tree by 1.\\n            rank[parent_x]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    int MST(vector<vector<int>>&edges, int n, int exclude, int include){\\n        UnionFind uf(n); //create an object of UnionFind class with vertex n as constructor parameter.\\n        int weight=0;//total weight of an MST.\\n        if(include!=-1){\\n            //if we need to include a particular edge without excluding anything.\\n            weight+=edges[include][2];\\n            uf.Union(edges[include][0],edges[include][1]);\\n        }\\n        //We unite u and v to form edges of MST.\\n        //we construct rest of out MST.\\n        for(int i=0;i<edges.size();i++){\\n            //if exclude!=-1 it must be within range 0-n.\\n            //otherwise this block will never be executed(in case of exclude=-1)\\n            if(i==exclude)\\n                continue;\\n            //Now we check if adding this edge forms cycle in MST.\\n            //In an MST, all vertices have same parent\\n            //if these two vertices already have same parent, we don\\'t need to add this edge,\\n            //as this would form a cycle.\\n            //both LHS and RHS return same value if they have a common parent.\\n            if(uf.Find(edges[i][0])==uf.Find(edges[i][1]))\\n                continue;\\n            //if no cycle, add its weight to total and edge to MST.\\n            uf.Union(edges[i][0],edges[i][1]);\\n            weight+=edges[i][2];\\n        }\\n        //if in a special case, we exclude a vertex from MST,\\n        //but there is no other edge connecting that vertex to rest of the graph\\n        //then we may have two or more seperate (disjoint) sets\\n        //and not a single MST.\\n        //in that case we return a very large number to indicate that that vertex is critical.\\n        for (int i=0;i<n;i++) {\\n            if(uf.Find(i)!=uf.Find(0))\\n                return INT_MAX;\\n        }\\n        return weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges){\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n            //We assign a unique number to all edges.\\n        }\\n        sort(edges.begin(),edges.end(),cmp);\\n        int bestMST=MST(edges,n,-1,-1);\\n        //We take most optimal MST possible(no exclusion or inclusion of any particular edge).\\n        vector<int>critical,pseudo_critical;\\n        for(int i=0;i<edges.size();i++){\\n            if(bestMST<MST(edges,n,i,-1)){\\n                //We ignore edge no. i and check if new MST is greater than bestMST.\\n                critical.push_back(edges[i][3]);\\n                //If yes then this edge is critical.\\n            }\\n            else if(bestMST==MST(edges,n,-1,i)){\\n                //We particularly include this edge i and do not exclude anything\\n                //and check if this edge yields same MST or not.\\n                pseudo_critical.push_back(edges[i][3]);\\n                //this edge is pseudo critical.\\n            }\\n        }\\n        return {critical,pseudo_critical};\\n    }\\n};\\n\\n\\n\\n\\nIf you find this helpful, please upvote :-)",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    static bool cmp(vector<int>&a, vector<int>&b){\\n        return a[2]<b[2];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3126987,
                "title": "java-mst-kruskal-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWrote code to implement UnionFind aka Disjoint Set data structure. Calculate minimum cost for Minimum Spanning Tree. And iterate edges to include and exculde to summerize critical and pseudo critical edges.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement Disjoint Set data structure and calculate cost for MST. Iterate all edges to include and exclude; resulted in critical and pseudo critical edges.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(E.log(V))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Map<int[], Integer> edgeIndexMap = new HashMap();\\n        for(int i = 0; i <edges.length; i++)\\n            edgeIndexMap.put(edges[i], i);\\n        List<Integer> criticalEdges = new ArrayList();\\n        List<Integer> pseudoCriticalEdges = new ArrayList();\\n        Arrays.sort(edges, (a,b)->a[2]-b[2]);\\n        int minCost = MST(n, edges, null, null);\\n        for(int[] edge:edges){\\n            int excludeCost = MST(n, edges, null, edge);\\n            if (excludeCost>minCost)\\n                criticalEdges.add(edgeIndexMap.get(edge));\\n            else{\\n                int includeCost = MST(n, edges, edge, null);\\n                if (includeCost == minCost)\\n                    pseudoCriticalEdges.add(edgeIndexMap.get(edge));\\n            }\\n        }\\n        return Arrays.asList(criticalEdges, pseudoCriticalEdges);\\n    }\\n    private int MST(int n, int[][] edges, int[] include, int[] exclude){\\n        int cost=0;\\n        UnionFind uf = new UnionFind(n);\\n        if (include!=null){\\n            uf.union(include[0], include[1]);\\n            cost+=include[2];\\n        }\\n        for(int[] edge: edges)\\n            if (edge!=exclude && (uf.union(edge[0], edge[1])))\\n                cost+=edge[2];\\n        return (uf.components==1)? cost: Integer.MAX_VALUE;\\n    }\\n}\\nclass UnionFind{\\n    int components;\\n    int[] root;\\n    UnionFind(int n){\\n        components =n;\\n        root = new int[n];\\n        for(int i = 0; i<n; i++)\\n            root[i]=i;\\n    }\\n    int find(int v){\\n        if (root[v]==v)\\n            return v;\\n        return find(root[v]);\\n    }\\n    boolean union(int v1, int v2){\\n        int ar1 = find(v1);\\n        int ar2 = find(v2);\\n        if (ar1==ar2)\\n            return false;\\n        root[ar1]=ar2;\\n        components--;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Map<int[], Integer> edgeIndexMap = new HashMap();\\n        for(int i = 0; i <edges.length; i++)\\n            edgeIndexMap.put(edges[i], i);\\n        List<Integer> criticalEdges = new ArrayList();\\n        List<Integer> pseudoCriticalEdges = new ArrayList();\\n        Arrays.sort(edges, (a,b)->a[2]-b[2]);\\n        int minCost = MST(n, edges, null, null);\\n        for(int[] edge:edges){\\n            int excludeCost = MST(n, edges, null, edge);\\n            if (excludeCost>minCost)\\n                criticalEdges.add(edgeIndexMap.get(edge));\\n            else{\\n                int includeCost = MST(n, edges, edge, null);\\n                if (includeCost == minCost)\\n                    pseudoCriticalEdges.add(edgeIndexMap.get(edge));\\n            }\\n        }\\n        return Arrays.asList(criticalEdges, pseudoCriticalEdges);\\n    }\\n    private int MST(int n, int[][] edges, int[] include, int[] exclude){\\n        int cost=0;\\n        UnionFind uf = new UnionFind(n);\\n        if (include!=null){\\n            uf.union(include[0], include[1]);\\n            cost+=include[2];\\n        }\\n        for(int[] edge: edges)\\n            if (edge!=exclude && (uf.union(edge[0], edge[1])))\\n                cost+=edge[2];\\n        return (uf.components==1)? cost: Integer.MAX_VALUE;\\n    }\\n}\\nclass UnionFind{\\n    int components;\\n    int[] root;\\n    UnionFind(int n){\\n        components =n;\\n        root = new int[n];\\n        for(int i = 0; i<n; i++)\\n            root[i]=i;\\n    }\\n    int find(int v){\\n        if (root[v]==v)\\n            return v;\\n        return find(root[v]);\\n    }\\n    boolean union(int v1, int v2){\\n        int ar1 = find(v1);\\n        int ar2 = find(v2);\\n        if (ar1==ar2)\\n            return false;\\n        root[ar1]=ar2;\\n        components--;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696784,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  class DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n};\\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[2]<v2[2];        \\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        int len=edges.size();\\n        for(int i=0;i<len;i++)\\n            edges[i].push_back(i);\\n  \\n        sort(edges.begin(),edges.end(),comp);\\n \\n        DSU dsu;\\n        int cost=0;\\n        vector<int> par(n);\\n        vector<int> size(n,1);\\n        for(int i=0;i<n;i++)par[i]=i;\\n        vector<bool> isPart(len,0);\\n        int c=0;\\n        for(int i=0;i<len;i++)\\n        {   \\n            if(c==n-1)break;\\n            if(dsu.findParent(edges[i][0],par)!=dsu.findParent(edges[i][1],par))\\n            {   \\n                dsu.Union(edges[i][0],edges[i][1],size,par);\\n                isPart[edges[i][3]]=1;\\n                cost+=edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical,pseudocritical;\\n        for(int i=0;i<len;i++)\\n        {\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            \\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            vector<bool> temp(len,0);\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   \\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    temp[edges[j][3]]=1;\\n                    tempCost+=edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if(tempCost==cost)\\n            {\\n                for(int k=0;k<len;k++)\\n                {\\n                    if(temp[k])isPart[k]=1;\\n                }    \\n            }\\n            else\\n                critical.push_back(edges[i][3]);\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[edges[i][3]])continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            tempDSU.Union(edges[i][0],edges[i][1],tempSize,tempPar);\\n            tempCost+=edges[i][2];\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {  \\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    tempCost+=edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if(tempCost==cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for(auto &it : critical)\\n            isPart[it]=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return {critical,pseudocritical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  class DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n};\\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[2]<v2[2];        \\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) \\n    {\\n        int len=edges.size();\\n        for(int i=0;i<len;i++)\\n            edges[i].push_back(i);\\n  \\n        sort(edges.begin(),edges.end(),comp);\\n \\n        DSU dsu;\\n        int cost=0;\\n        vector<int> par(n);\\n        vector<int> size(n,1);\\n        for(int i=0;i<n;i++)par[i]=i;\\n        vector<bool> isPart(len,0);\\n        int c=0;\\n        for(int i=0;i<len;i++)\\n        {   \\n            if(c==n-1)break;\\n            if(dsu.findParent(edges[i][0],par)!=dsu.findParent(edges[i][1],par))\\n            {   \\n                dsu.Union(edges[i][0],edges[i][1],size,par);\\n                isPart[edges[i][3]]=1;\\n                cost+=edges[i][2];\\n                ++c;\\n            }\\n        }\\n        vector<int> critical,pseudocritical;\\n        for(int i=0;i<len;i++)\\n        {\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            \\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            vector<bool> temp(len,0);\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {   \\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    temp[edges[j][3]]=1;\\n                    tempCost+=edges[j][2];\\n                    c++;\\n                }\\n            }\\n            if(tempCost==cost)\\n            {\\n                for(int k=0;k<len;k++)\\n                {\\n                    if(temp[k])isPart[k]=1;\\n                }    \\n            }\\n            else\\n                critical.push_back(edges[i][3]);\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[edges[i][3]])continue;\\n            DSU tempDSU;\\n            vector<int> tempPar(n,0);\\n            for(int j=0;j<n;j++)tempPar[j]=j;\\n            vector<int> tempSize(n,1);\\n            int tempCost=0;\\n            tempDSU.Union(edges[i][0],edges[i][1],tempSize,tempPar);\\n            tempCost+=edges[i][2];\\n            int c=0;\\n            for(int j=0;j<len;j++)\\n            {  \\n                if(c==n-1)break;\\n                if(j==i)continue;               \\n                if(tempDSU.findParent(edges[j][0],tempPar)!=tempDSU.findParent(edges[j][1],tempPar))\\n                {\\n                    tempDSU.Union(edges[j][0],edges[j][1],tempSize,tempPar);\\n                    tempCost+=edges[j][2];\\n                    ++c;\\n                }\\n            }\\n            if(tempCost==cost)\\n                pseudocritical.push_back(edges[i][3]);\\n        }\\n        for(auto &it : critical)\\n            isPart[it]=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(isPart[i])\\n                pseudocritical.push_back(i);\\n        }\\n        return {critical,pseudocritical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298817,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        du = list(range(n))\\n        def ufind(x):\\n            st = x\\n            while du[x] != x:\\n                x = du[x]\\n            while du[st] != x:\\n                y = du[st]\\n                du[st] = x\\n                st = y\\n            return x\\n        def uunion(x,y):\\n            x = ufind(x)\\n            y = ufind(y)\\n            if x > y:\\n                x,y = y,x\\n            du[y] = x\\n        def dfs(node):\\n            dfstack.append(node)\\n            for nxt in eg[node]:\\n                if nxt not in backward:\\n                    backward[nxt] = node\\n                    dfs(nxt)\\n        \\n        outc = []\\n        outp = []\\n        eidx = {tuple(eg[:2]):idx for idx,eg in enumerate(edges)}\\n        edges.sort(key = itemgetter(2), reverse = True)\\n        while edges:\\n            egw = edges[-1][-1]\\n            eg = defaultdict(list)\\n            egcur = []\\n            while edges and edges[-1][-1] == egw:\\n                ea,eb,_ = edges.pop()\\n                if (eac := ufind(ea)) != (ebc := ufind(eb)):\\n                    eg[eac].append(ebc)\\n                    eg[ebc].append(eac)\\n                    egcur.append((ea,eb))\\n            if not eg:\\n                continue\\n            \\n            dfstack = []\\n            backward = dict()\\n            for root in eg.keys():\\n                if root not in backward:\\n                    backward[root] = -1\\n                    dfs(root)\\n            dfsidx = [0]*n\\n            for idx,node in enumerate(dfstack):\\n                dfsidx[node] = idx\\n            egt = dict()\\n            for eac,ebclist in eg.items():\\n                ebct = [ebc for ebc in ebclist if dfsidx[ebc] > dfsidx[eac]]\\n                egt[eac] = ebct\\n            for ebc,eac in backward.items():\\n                if eac != -1:\\n                    egt[eac].remove(ebc)\\n                    egt[ebc].append(eac)\\n\\n            visit_v = set()\\n            visit_e = set()\\n            for node in dfstack:\\n                visit_v.add(node)\\n                for nxt in egt[node]:\\n                    if backward[node] != nxt and (node,nxt) not in visit_e:\\n                        prev = node\\n                        while nxt not in visit_v:\\n                            visit_v.add(nxt)\\n                            visit_e.add((prev,nxt))\\n                            visit_e.add((nxt,prev))\\n                            prev = nxt\\n                            nxt = backward[nxt]\\n                        visit_e.add((prev,nxt))\\n                        visit_e.add((nxt,prev))\\n            for egc in egcur:\\n                ea,eb = egc\\n                eac = ufind(ea)\\n                ebc = ufind(eb)\\n                if (eac,ebc) in visit_e:\\n                    outp.append(eidx[egc])\\n                else:\\n                    outc.append(eidx[egc])\\n            for eac in eg:\\n                for ebc in eg[eac]:\\n                    uunion(eac,ebc)\\n        return [outc,outp]\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        du = list(range(n))\\n        def ufind(x):\\n            st = x\\n            while du[x] != x:\\n                x = du[x]\\n            while du[st] != x:\\n                y = du[st]\\n                du[st] = x\\n                st = y\\n            return x\\n        def uunion(x,y):\\n            x = ufind(x)\\n            y = ufind(y)\\n            if x > y:\\n                x,y = y,x\\n            du[y] = x\\n        def dfs(node):\\n            dfstack.append(node)\\n            for nxt in eg[node]:\\n                if nxt not in backward:\\n                    backward[nxt] = node\\n                    dfs(nxt)\\n        \\n        outc = []\\n        outp = []\\n        eidx = {tuple(eg[:2]):idx for idx,eg in enumerate(edges)}\\n        edges.sort(key = itemgetter(2), reverse = True)\\n        while edges:\\n            egw = edges[-1][-1]\\n            eg = defaultdict(list)\\n            egcur = []\\n            while edges and edges[-1][-1] == egw:\\n                ea,eb,_ = edges.pop()\\n                if (eac := ufind(ea)) != (ebc := ufind(eb)):\\n                    eg[eac].append(ebc)\\n                    eg[ebc].append(eac)\\n                    egcur.append((ea,eb))\\n            if not eg:\\n                continue\\n            \\n            dfstack = []\\n            backward = dict()\\n            for root in eg.keys():\\n                if root not in backward:\\n                    backward[root] = -1\\n                    dfs(root)\\n            dfsidx = [0]*n\\n            for idx,node in enumerate(dfstack):\\n                dfsidx[node] = idx\\n            egt = dict()\\n            for eac,ebclist in eg.items():\\n                ebct = [ebc for ebc in ebclist if dfsidx[ebc] > dfsidx[eac]]\\n                egt[eac] = ebct\\n            for ebc,eac in backward.items():\\n                if eac != -1:\\n                    egt[eac].remove(ebc)\\n                    egt[ebc].append(eac)\\n\\n            visit_v = set()\\n            visit_e = set()\\n            for node in dfstack:\\n                visit_v.add(node)\\n                for nxt in egt[node]:\\n                    if backward[node] != nxt and (node,nxt) not in visit_e:\\n                        prev = node\\n                        while nxt not in visit_v:\\n                            visit_v.add(nxt)\\n                            visit_e.add((prev,nxt))\\n                            visit_e.add((nxt,prev))\\n                            prev = nxt\\n                            nxt = backward[nxt]\\n                        visit_e.add((prev,nxt))\\n                        visit_e.add((nxt,prev))\\n            for egc in egcur:\\n                ea,eb = egc\\n                eac = ufind(ea)\\n                ebc = ufind(eb)\\n                if (eac,ebc) in visit_e:\\n                    outp.append(eidx[egc])\\n                else:\\n                    outc.append(eidx[egc])\\n            for eac in eg:\\n                for ebc in eg[eac]:\\n                    uunion(eac,ebc)\\n        return [outc,outp]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091235,
                "title": "c-mst-disjoint-set-union-find",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n    \\n    int mst(vector<vector<int>>& edges, vector<int> included, vector<int> excluded) {\\n        for(int i = 0; i < prnt.size(); i++) {\\n            prnt[i] = -1;\\n            rnk[i] = 1;\\n        }\\n        \\n        int cost = 0;\\n        if(included.size() > 0) {\\n            merge(included[0], included[1]);\\n            cost += included[2];\\n        }\\n        \\n        for(vector<int> edge: edges) {\\n            if(excluded.size() == edge.size() && excluded[3] == edge[3])\\n                continue;\\n            else if(find(edge[0]) != find(edge[1])) {\\n                merge(edge[0], edge[1]);\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return rnk[find(0)] == prnt.size() ? cost : INT_MAX;\\n    }\\n\\n    \\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        \\n        // add index of i\\'th edge\\n        // {u, v, weight, i}\\n        for(int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        \\n        // sort non-decreasing order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        int min_cost = mst(edges, vector<int>(), vector<int>());\\n        \\n        vector<int> critical, psudo;\\n        for(vector<int> edge: edges) {\\n            // excluding edge\\n            int ex_cost = mst(edges, vector<int>(), edge);\\n            if(ex_cost > min_cost) {\\n                critical.push_back(edge[3]);\\n            } else if(ex_cost == min_cost) {\\n                // included edge\\n                int in_cost = mst(edges, edge, vector<int>());\\n                if(in_cost == ex_cost) \\n                    psudo.push_back(edge[3]);\\n            }\\n        }\\n        \\n        return {critical, psudo};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n    \\n    int mst(vector<vector<int>>& edges, vector<int> included, vector<int> excluded) {\\n        for(int i = 0; i < prnt.size(); i++) {\\n            prnt[i] = -1;\\n            rnk[i] = 1;\\n        }\\n        \\n        int cost = 0;\\n        if(included.size() > 0) {\\n            merge(included[0], included[1]);\\n            cost += included[2];\\n        }\\n        \\n        for(vector<int> edge: edges) {\\n            if(excluded.size() == edge.size() && excluded[3] == edge[3])\\n                continue;\\n            else if(find(edge[0]) != find(edge[1])) {\\n                merge(edge[0], edge[1]);\\n                cost += edge[2];\\n            }\\n        }\\n        \\n        return rnk[find(0)] == prnt.size() ? cost : INT_MAX;\\n    }\\n\\n    \\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        \\n        // add index of i\\'th edge\\n        // {u, v, weight, i}\\n        for(int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n        \\n        // sort non-decreasing order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        int min_cost = mst(edges, vector<int>(), vector<int>());\\n        \\n        vector<int> critical, psudo;\\n        for(vector<int> edge: edges) {\\n            // excluding edge\\n            int ex_cost = mst(edges, vector<int>(), edge);\\n            if(ex_cost > min_cost) {\\n                critical.push_back(edge[3]);\\n            } else if(ex_cost == min_cost) {\\n                // included edge\\n                int in_cost = mst(edges, edge, vector<int>());\\n                if(in_cost == ex_cost) \\n                    psudo.push_back(edge[3]);\\n            }\\n        }\\n        \\n        return {critical, psudo};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957801,
                "title": "java-following-the-lc-hints",
                "content": "I will be honest, getting intution of this question is little bit tricky (atleast for me), but once you get the idea from hints, writing the code is pretty straight forward, anyways here\\'s the implementation, happy leetcoding!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len = edges.length;\\n        \\n        Map<int[], Integer> index = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            int[] edge = edges[i];\\n            index.put(edge, i);\\n        }\\n        \\n        int msp = 0;\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        DSU main = new DSU(n);\\n        int count = 0;\\n        \\n        int i = 0;\\n        while(i < edges.length && count < n) {\\n            int[] edge = edges[i];\\n            if (main.union(edge[0], edge[1]) == true) {\\n                count++;\\n                msp += edge[2];\\n            }\\n            i++;\\n        }\\n        \\n        System.out.println(msp);\\n        \\n        for (i = 0; i < len; i++) {\\n            int[] cur = edges[i];\\n            int curIndex = index.get(cur);\\n            DSU dsu = new DSU(n);\\n            DSU include = new DSU(n);\\n            int cost = 0, includeCost = cur[2];\\n            include.union(cur[0], cur[1]);\\n \\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                int[] edge = edges[j];\\n                if (dsu.union(edge[0], edge[1]) == true) {\\n                    cost += edge[2];\\n                }\\n                if (include.union(edge[0], edge[1]) == true) {\\n                    includeCost += edge[2];\\n                }\\n            }\\n            if (cost != msp) critical.add(curIndex);\\n            else if (includeCost == msp) pseudo.add(curIndex);\\n        }\\n        \\n        ans.add(critical); ans.add(pseudo);\\n        return ans;\\n    }\\n    \\n    class DSU {\\n        int[] root;\\n        int[] rank;\\n        \\n        public DSU (int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY) return false;\\n            \\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n                \\n            } else {\\n                root[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudo = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len = edges.length;\\n        \\n        Map<int[], Integer> index = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            int[] edge = edges[i];\\n            index.put(edge, i);\\n        }\\n        \\n        int msp = 0;\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        DSU main = new DSU(n);\\n        int count = 0;\\n        \\n        int i = 0;\\n        while(i < edges.length && count < n) {\\n            int[] edge = edges[i];\\n            if (main.union(edge[0], edge[1]) == true) {\\n                count++;\\n                msp += edge[2];\\n            }\\n            i++;\\n        }\\n        \\n        System.out.println(msp);\\n        \\n        for (i = 0; i < len; i++) {\\n            int[] cur = edges[i];\\n            int curIndex = index.get(cur);\\n            DSU dsu = new DSU(n);\\n            DSU include = new DSU(n);\\n            int cost = 0, includeCost = cur[2];\\n            include.union(cur[0], cur[1]);\\n \\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                int[] edge = edges[j];\\n                if (dsu.union(edge[0], edge[1]) == true) {\\n                    cost += edge[2];\\n                }\\n                if (include.union(edge[0], edge[1]) == true) {\\n                    includeCost += edge[2];\\n                }\\n            }\\n            if (cost != msp) critical.add(curIndex);\\n            else if (includeCost == msp) pseudo.add(curIndex);\\n        }\\n        \\n        ans.add(critical); ans.add(pseudo);\\n        return ans;\\n    }\\n    \\n    class DSU {\\n        int[] root;\\n        int[] rank;\\n        \\n        public DSU (int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public boolean union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY) return false;\\n            \\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n                \\n            } else {\\n                root[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690298,
                "title": "java-kruskal-union-find-easy-to-understand",
                "content": "First of all, we find the cost of a MST, and call it `min_cost`. Then think about the following questions: \\n* How to check if an edge is critical? \\n* How to check if an edge is pseudo-critical? \\n\\nAnswer:\\n* We know that deleting a critical edge will increase the cost of MST. \\n\\t\\tHence, if the cost after deletion is larger than the `min_cost`, then such an edge is critical.\\n* We know that a pseudo-critical edge \\n\\t1. Exists in some MSTs. => We must use this edge to find the MST. The cost will be equal to the `min_cost`.\\n\\t2. Does not exists in all MSTs. => The cost after deletion is equal to the `min_cost`.\\n```\\nclass Solution {\\n    int[][] edges;\\n    int cost; // min_cost\\n    DSU dsu;\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        this.dsu = new DSU(n);\\n        int[][] es = new int[edges.length][4];\\n        for (int i = 0; i < edges.length; i++) {\\n            es[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};\\n        }\\n        Arrays.sort(es, (a, b) -> (a[2] - b[2]));\\n        this.edges = es;\\n        this.cost = findCost(es.length, true); // Find the min_cost.\\n        Set<Integer> s1 = criticalEdges(), s2 = pseudoCriticalEdges(s1);\\n        return new ArrayList<>(Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2)));\\n    }\\n\\t\\n\\t// Find the cost with current edges.\\n\\t// skip == true means we delete this edge and then find the cost.\\n\\t// skip == false means we must use this edge to find the cost.\\n    private int findCost(int index, boolean skip) {\\n        this.dsu.reset();\\n        int cost = 0;\\n        if (!skip) {\\n            cost += this.edges[index][2];\\n            this.dsu.union(this.edges[index][0], this.edges[index][1]);\\n        }\\n        for (int i = 0; i < this.edges.length; i++) {\\n            if (i == index) continue;\\n            int[] e = this.edges[i];\\n            if (!this.dsu.formCycle(e[0], e[1])) {\\n                cost += e[2];\\n                this.dsu.union(e[0], e[1]);\\n            }\\n        }\\n        return cost;\\n    }\\n    \\n\\t// Find the critical edges: check if the cost after deletion is larger than the min_cost.\\n    private Set<Integer> criticalEdges() {\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < this.edges.length; i++) {\\n            if (this.cost != findCost(i, true)) {\\n                res.add(edges[i][3]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// Find the pseudo critical edges:\\n\\t// 1. Use this edge to find the MST. The cost will be equal to the min_cost.\\n\\t// 2. The cost after deletion is equal to the min_cost.\\n    private Set<Integer> pseudoCriticalEdges(Set<Integer> s1) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < this.edges.length; i++) {\\n\\t\\t\\t// Note that s1 is the set of crititcal edges. \\n\\t\\t\\t// For edges in s1, the cost after deletion is larger than the min_cost.\\n\\t\\t\\t// Then the edges not in s1 are the edges that the cost after deletion is equal to the min_cost.\\n            if (!s1.contains(edges[i][3]) && this.cost == findCost(i, false)) {\\n                res.add(edges[i][3]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass DSU {\\n    int[] parent, size;\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        Arrays.fill(size, 1);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (x != parent[x]) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    public boolean formCycle(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    public void union(int x, int y) {\\n        int rootX = find(x), rootY = find(y);\\n        if (rootX == rootY) return;\\n        if (size[rootX] < size[rootY]) {\\n            size[rootY] += size[rootX];\\n            parent[rootX] = rootY;\\n        } else {\\n            size[rootX] += size[rootY];\\n            parent[rootY] = rootX;\\n        }\\n    }\\n    public void reset() {\\n        Arrays.fill(size, 1);\\n        for (int i = 0; i < parent.length; i++) parent[i] = i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] edges;\\n    int cost; // min_cost\\n    DSU dsu;\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        this.dsu = new DSU(n);\\n        int[][] es = new int[edges.length][4];\\n        for (int i = 0; i < edges.length; i++) {\\n            es[i] = new int[]{edges[i][0], edges[i][1], edges[i][2], i};\\n        }\\n        Arrays.sort(es, (a, b) -> (a[2] - b[2]));\\n        this.edges = es;\\n        this.cost = findCost(es.length, true); // Find the min_cost.\\n        Set<Integer> s1 = criticalEdges(), s2 = pseudoCriticalEdges(s1);\\n        return new ArrayList<>(Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2)));\\n    }\\n\\t\\n\\t// Find the cost with current edges.\\n\\t// skip == true means we delete this edge and then find the cost.\\n\\t// skip == false means we must use this edge to find the cost.\\n    private int findCost(int index, boolean skip) {\\n        this.dsu.reset();\\n        int cost = 0;\\n        if (!skip) {\\n            cost += this.edges[index][2];\\n            this.dsu.union(this.edges[index][0], this.edges[index][1]);\\n        }\\n        for (int i = 0; i < this.edges.length; i++) {\\n            if (i == index) continue;\\n            int[] e = this.edges[i];\\n            if (!this.dsu.formCycle(e[0], e[1])) {\\n                cost += e[2];\\n                this.dsu.union(e[0], e[1]);\\n            }\\n        }\\n        return cost;\\n    }\\n    \\n\\t// Find the critical edges: check if the cost after deletion is larger than the min_cost.\\n    private Set<Integer> criticalEdges() {\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < this.edges.length; i++) {\\n            if (this.cost != findCost(i, true)) {\\n                res.add(edges[i][3]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t// Find the pseudo critical edges:\\n\\t// 1. Use this edge to find the MST. The cost will be equal to the min_cost.\\n\\t// 2. The cost after deletion is equal to the min_cost.\\n    private Set<Integer> pseudoCriticalEdges(Set<Integer> s1) {\\n        Set<Integer> res = new HashSet<>();\\n        for (int i = 0; i < this.edges.length; i++) {\\n\\t\\t\\t// Note that s1 is the set of crititcal edges. \\n\\t\\t\\t// For edges in s1, the cost after deletion is larger than the min_cost.\\n\\t\\t\\t// Then the edges not in s1 are the edges that the cost after deletion is equal to the min_cost.\\n            if (!s1.contains(edges[i][3]) && this.cost == findCost(i, false)) {\\n                res.add(edges[i][3]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass DSU {\\n    int[] parent, size;\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        Arrays.fill(size, 1);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (x != parent[x]) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    public boolean formCycle(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    public void union(int x, int y) {\\n        int rootX = find(x), rootY = find(y);\\n        if (rootX == rootY) return;\\n        if (size[rootX] < size[rootY]) {\\n            size[rootY] += size[rootX];\\n            parent[rootX] = rootY;\\n        } else {\\n            size[rootX] += size[rootY];\\n            parent[rootY] = rootX;\\n        }\\n    }\\n    public void reset() {\\n        Arrays.fill(size, 1);\\n        for (int i = 0; i < parent.length; i++) parent[i] = i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623639,
                "title": "python-80ms-100-faster-building-mst-only-once-with-descriptions",
                "content": "From the CRLS textbook, the edge list L of MST should be the same, even if you have more than 1 MST.  In combination with Kruskal\\'s, this means the edges that were given up because of cycles are noncritical edges if the cycle also contains another edge with the same weight. \\nIn other words, these noncritical-equal-weight edges only get selected/discarded w.r.t MST because of their order in the sorting of edges; if their ordering in the sort are interchangeable due to being equaal in weight so is their status to the MST. \\n\\n\\'\\'\\'\\nclass Solution(object):\\n    nonCritical = list()\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"  \\n        \\n        rank = [1] * n \\n        parent = [i for i in range(n)]\\n        critical = list()\\n        noncritical = list()\\n        mst = list()\\n        adj = [[] for i in range(n)]\\n        \\n        def find(i):\\n            if parent[i] == i:\\n                return i\\n            parent[i] = find(parent[i])  # this will eventually set root to be parent[i]\\n            return parent[i]\\n    \\n        def union(pu, pv):\\n            if rank[pu] > rank[pv]:\\n                parent[pv] = pu\\n            elif rank[pu] < rank[pv]:\\n                parent[pu] = pv\\n            else:\\n                parent[pv] = pu\\n                rank[pv] += 1\\n    \\n        def dfsPath(adj, nodeweight, v, stack, vis):\\n            u = nodeweight[0]\\n            vis[u] = 1\\n            stack.append(nodeweight)\\n            if u == v:\\n                return True\\n            for child in adj[u]:\\n                if not vis[child[0]]:\\n                    if dfsPath(adj, child, v, stack, vis):\\n                        return True\\n            stack.pop(-1)\\n        \\n        edges = [(u, v, w, i) for i, (u,v,w) in enumerate(edges)]\\n        edges.sort(key = lambda x: x[2])\\n        e = len(edges)\\n        count = 0\\n        i = 0\\n        #Kruskal\\'s\\n        while i < e:\\n            if count == n-1 and edges[i][2] > curr: \\n                # if mst is complete and the rest edges have lengths greater than all tree edges\\n                break\\n            (u, v, w, ind) = edges[i]\\n            urep = find(u)\\n            vrep = find(v)\\n            if urep != vrep: # we can safely add this edge\\n                adj[u].append((v, w, ind))\\n                adj[v].append((u, w, ind))\\n                mst.append(ind)\\n                curr = w\\n                count += 1\\n                union(urep, vrep)\\n            else:# adding this edge would form a cycle; \\n                 # this edge would either be equal to or greater than the last added MST edge\\n                if curr == w :\\n                    # check to see whether the cycle contains another edge with the same weight\\n                    stack = list()\\n                    vis = [0] * n\\n                    dfsPath(adj, (u,0,n) , v, stack, vis) # find path in mst from u to v\\n                    # stack should contain ending node and edge weights and inds \\n                    # the (v, w, ind) from (u, v, w, ind) starting situation (u, u, 0, n) \\n                    for halfEdge in stack:\\n                        if halfEdge[1] == w:# if path has edges with same weight as the one not being added\\n                            if halfEdge[2] not in noncritical: # then those edges are noncritical\\n                                noncritical.append(halfEdge[2]) \\n                            if ind not in noncritical: # the edge (u, v, w, ind) can replace be replaced by those edges, \\n                                noncritical.append(ind)        \\n            i+= 1\\n        for i in mst:\\n            if i not in noncritical:\\n                critical.append(i)\\n        return [critical, noncritical]\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "From the CRLS textbook, the edge list L of MST should be the same, even if you have more than 1 MST.  In combination with Kruskal\\'s, this means the edges that were given up because of cycles are noncritical edges if the cycle also contains another edge with the same weight. \\nIn other words, these noncritical-equal-weight edges only get selected/discarded w.r.t MST because of their order in the sorting of edges; if their ordering in the sort are interchangeable due to being equaal in weight so is their status to the MST. \\n\\n\\'\\'\\'\\nclass Solution(object):\\n    nonCritical = list()\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"  \\n        \\n        rank = [1] * n \\n        parent = [i for i in range(n)]\\n        critical = list()\\n        noncritical = list()\\n        mst = list()\\n        adj = [[] for i in range(n)]\\n        \\n        def find(i):\\n            if parent[i] == i:\\n                return i\\n            parent[i] = find(parent[i])  # this will eventually set root to be parent[i]\\n            return parent[i]\\n    \\n        def union(pu, pv):\\n            if rank[pu] > rank[pv]:\\n                parent[pv] = pu\\n            elif rank[pu] < rank[pv]:\\n                parent[pu] = pv\\n            else:\\n                parent[pv] = pu\\n                rank[pv] += 1\\n    \\n        def dfsPath(adj, nodeweight, v, stack, vis):\\n            u = nodeweight[0]\\n            vis[u] = 1\\n            stack.append(nodeweight)\\n            if u == v:\\n                return True\\n            for child in adj[u]:\\n                if not vis[child[0]]:\\n                    if dfsPath(adj, child, v, stack, vis):\\n                        return True\\n            stack.pop(-1)\\n        \\n        edges = [(u, v, w, i) for i, (u,v,w) in enumerate(edges)]\\n        edges.sort(key = lambda x: x[2])\\n        e = len(edges)\\n        count = 0\\n        i = 0\\n        #Kruskal\\'s\\n        while i < e:\\n            if count == n-1 and edges[i][2] > curr: \\n                # if mst is complete and the rest edges have lengths greater than all tree edges\\n                break\\n            (u, v, w, ind) = edges[i]\\n            urep = find(u)\\n            vrep = find(v)\\n            if urep != vrep: # we can safely add this edge\\n                adj[u].append((v, w, ind))\\n                adj[v].append((u, w, ind))\\n                mst.append(ind)\\n                curr = w\\n                count += 1\\n                union(urep, vrep)\\n            else:# adding this edge would form a cycle; \\n                 # this edge would either be equal to or greater than the last added MST edge\\n                if curr == w :\\n                    # check to see whether the cycle contains another edge with the same weight\\n                    stack = list()\\n                    vis = [0] * n\\n                    dfsPath(adj, (u,0,n) , v, stack, vis) # find path in mst from u to v\\n                    # stack should contain ending node and edge weights and inds \\n                    # the (v, w, ind) from (u, v, w, ind) starting situation (u, u, 0, n) \\n                    for halfEdge in stack:\\n                        if halfEdge[1] == w:# if path has edges with same weight as the one not being added\\n                            if halfEdge[2] not in noncritical: # then those edges are noncritical\\n                                noncritical.append(halfEdge[2]) \\n                            if ind not in noncritical: # the edge (u, v, w, ind) can replace be replaced by those edges, \\n                                noncritical.append(ind)        \\n            i+= 1\\n        for i in mst:\\n            if i not in noncritical:\\n                critical.append(i)\\n        return [critical, noncritical]\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1377844,
                "title": "java-exactly-based-on-hints-union-by-rank-and-mst-22-ms-beats-98-time",
                "content": "```\\nclass DisjointSetUnion{\\n   private int N;\\n   private int[] rank, parent;\\n\\n   public DisjointSetUnion(int N){\\n       this.N = N;\\n       this.rank = new int[N];\\n       this.parent = new int[N];\\n       this.reset();\\n    }\\n\\n   public void reset(){\\n       for(int i = 0; i < N; i++){\\n           this.rank[i] = 1;\\n           this.parent[i] = i;\\n       }\\n   }\\n\\n   public boolean union(int u, int v){\\n      if(u != v){\\n         int x = find(u);\\n         int y = find(v);\\n         if(x != y){\\n            if(rank[x] > rank[y]){\\n                rank[x] += rank[y];\\n                parent[y] = x;\\n            }else{\\n                rank[y] += rank[x];\\n                parent[x] = y;\\n            }\\n\\n            return true;\\n         }\\n      }\\n\\n      return false;\\n   }\\n\\n   private int find(int u){\\n      int x = u;\\n      while(x != parent[x]){\\n         x = parent[x];\\n      }\\n\\n      parent[u] = x;\\n      return x;\\n   }\\n}\\n\\nclass Edge implements Comparable<Edge>{\\n   private int start, end, weight, index;\\n\\n   public Edge(int start, int end, int weight, int index){\\n       this.start = start;\\n       this.end = end;\\n       this.weight = weight;\\n       this.index = index;\\n   }\\n\\n   public int getIndex(){\\n       return this.index;\\n   }\\n\\n   public int getStart(){\\n      return this.start;\\n   }\\n\\n   public int getEnd(){\\n      return this.end;\\n   }\\n\\n   public int getWeight(){\\n      return this.weight;\\n   }\\n\\n   @Override\\n   public int compareTo(Edge other){\\n       return this.weight - other.weight;\\n   }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        DisjointSetUnion set = new DisjointSetUnion(n);\\n        int i, weight, E = edges.length;\\n       Edge[] edgeArray = new Edge[E];\\n       for(i = 0; i < E; i++){\\n           edgeArray[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i);\\n       } \\n        \\n       Arrays.sort(edgeArray);\\n       int mst = getMstWeight(set, edgeArray, n, E, -1, -1);\\n\\n       List<Integer> critical = new ArrayList<Integer>();\\n       List<Integer> nonCritical = new ArrayList<Integer>();\\n\\n       for(i = 0; i < E; i++){\\n           // do not include this edge\\n           weight = getMstWeight(set, edgeArray, n, E, -1, i);\\n           if(weight > mst){\\n               critical.add(edgeArray[i].getIndex());\\n           }else{\\n               // forcefully include this edge\\n               weight = getMstWeight(set, edgeArray, n, E, i, -1);\\n               if(weight == mst){\\n                  nonCritical.add(edgeArray[i].getIndex());\\n               }\\n           }\\n       }\\n\\n       List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       result.add(critical);\\n       result.add(nonCritical);\\n       return result;\\n    }\\n\\n    private int getMstWeight(DisjointSetUnion set, Edge[] edgeArray, int n, int E, int include, int ignore){\\n        set.reset();\\n        \\n        int weight = 0;\\n        int edgeCount = 0;\\n        Edge current;\\n        if(include != -1){\\n           current = edgeArray[include];\\n           set.union(current.getStart(), current.getEnd());\\n           weight += current.getWeight();\\n           ++edgeCount;\\n        }\\n\\n        for(int i = 0; (i < E) && (edgeCount < n - 1); i++){\\n           if(i != ignore){\\n               current = edgeArray[i];\\n               if(set.union(current.getStart(), current.getEnd())){\\n                   weight += current.getWeight();\\n                   ++edgeCount;\\n               }\\n           }\\n        }\\n\\n        return (edgeCount == n - 1) ? weight : Integer.MAX_VALUE; // important check for disconnected MST\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DisjointSetUnion{\\n   private int N;\\n   private int[] rank, parent;\\n\\n   public DisjointSetUnion(int N){\\n       this.N = N;\\n       this.rank = new int[N];\\n       this.parent = new int[N];\\n       this.reset();\\n    }\\n\\n   public void reset(){\\n       for(int i = 0; i < N; i++){\\n           this.rank[i] = 1;\\n           this.parent[i] = i;\\n       }\\n   }\\n\\n   public boolean union(int u, int v){\\n      if(u != v){\\n         int x = find(u);\\n         int y = find(v);\\n         if(x != y){\\n            if(rank[x] > rank[y]){\\n                rank[x] += rank[y];\\n                parent[y] = x;\\n            }else{\\n                rank[y] += rank[x];\\n                parent[x] = y;\\n            }\\n\\n            return true;\\n         }\\n      }\\n\\n      return false;\\n   }\\n\\n   private int find(int u){\\n      int x = u;\\n      while(x != parent[x]){\\n         x = parent[x];\\n      }\\n\\n      parent[u] = x;\\n      return x;\\n   }\\n}\\n\\nclass Edge implements Comparable<Edge>{\\n   private int start, end, weight, index;\\n\\n   public Edge(int start, int end, int weight, int index){\\n       this.start = start;\\n       this.end = end;\\n       this.weight = weight;\\n       this.index = index;\\n   }\\n\\n   public int getIndex(){\\n       return this.index;\\n   }\\n\\n   public int getStart(){\\n      return this.start;\\n   }\\n\\n   public int getEnd(){\\n      return this.end;\\n   }\\n\\n   public int getWeight(){\\n      return this.weight;\\n   }\\n\\n   @Override\\n   public int compareTo(Edge other){\\n       return this.weight - other.weight;\\n   }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        DisjointSetUnion set = new DisjointSetUnion(n);\\n        int i, weight, E = edges.length;\\n       Edge[] edgeArray = new Edge[E];\\n       for(i = 0; i < E; i++){\\n           edgeArray[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i);\\n       } \\n        \\n       Arrays.sort(edgeArray);\\n       int mst = getMstWeight(set, edgeArray, n, E, -1, -1);\\n\\n       List<Integer> critical = new ArrayList<Integer>();\\n       List<Integer> nonCritical = new ArrayList<Integer>();\\n\\n       for(i = 0; i < E; i++){\\n           // do not include this edge\\n           weight = getMstWeight(set, edgeArray, n, E, -1, i);\\n           if(weight > mst){\\n               critical.add(edgeArray[i].getIndex());\\n           }else{\\n               // forcefully include this edge\\n               weight = getMstWeight(set, edgeArray, n, E, i, -1);\\n               if(weight == mst){\\n                  nonCritical.add(edgeArray[i].getIndex());\\n               }\\n           }\\n       }\\n\\n       List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       result.add(critical);\\n       result.add(nonCritical);\\n       return result;\\n    }\\n\\n    private int getMstWeight(DisjointSetUnion set, Edge[] edgeArray, int n, int E, int include, int ignore){\\n        set.reset();\\n        \\n        int weight = 0;\\n        int edgeCount = 0;\\n        Edge current;\\n        if(include != -1){\\n           current = edgeArray[include];\\n           set.union(current.getStart(), current.getEnd());\\n           weight += current.getWeight();\\n           ++edgeCount;\\n        }\\n\\n        for(int i = 0; (i < E) && (edgeCount < n - 1); i++){\\n           if(i != ignore){\\n               current = edgeArray[i];\\n               if(set.union(current.getStart(), current.getEnd())){\\n                   weight += current.getWeight();\\n                   ++edgeCount;\\n               }\\n           }\\n        }\\n\\n        return (edgeCount == n - 1) ? weight : Integer.MAX_VALUE; // important check for disconnected MST\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363252,
                "title": "c-kruskal-s-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findPar(int x, vector<int> &parent)\\n    {\\n        while(x != parent[x])\\n            x = parent[x];\\n        return x;\\n    }\\n    void unionn(int x, int y, vector<int> &parent, vector<int> &rank)\\n    {\\n        x = findPar(x,parent);\\n        y = findPar(y, parent);\\n        if(rank[x] < rank[y])\\n            parent[x] = y;\\n        else if(rank[x] > rank[y])\\n            parent[y] = x;\\n        else\\n        {\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n    int MST(int &n, vector<vector<int>> &edges, vector<int> &include, vector<int> &exclude)//O(E)\\n    {\\n        int cost = 0;\\n        vector<int> rank(n,0);\\n        vector<int> parent(n);\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n\\n//if my must include edge is not null then I will join them and add their cost if they do not have same component\\n        if(include.size() != 0)\\n        {\\n            if(findPar(include[0],parent) != findPar(include[1],parent))\\n            {\\n                unionn(include[0], include[1], parent, rank);\\n                cost += include[2];\\n            }\\n        }\\n        for(auto edge: edges)//O(E) as union find operation constant only for loop\\n        {\\n//if curr edge is not equal to must exclude vertex we will check further and do simple kruskal\\'s method\\n            if(edge != exclude)\\n            {\\n                if(findPar(edge[0],parent) != findPar(edge[1],parent))\\n                {\\n                    unionn(edge[0],edge[1],parent,rank);\\n                    cost += edge[2];\\n                }\\n            }\\n        }\\n        //now if kruskal was not possbile by excluding any node, means all nodes can\\'t be connected together then in that case we will return INF \\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            //means when all are not connected so return\\n            if(findPar(i,parent) != findPar(0,parent))\\n                return 1e5;\\n        }\\n        return cost;\\n    }\\n    static bool compare(vector<int> &a, vector<int> &b)\\n    {\\n        return a[2] < b[2];///sorting according to weigths in asc order\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, \\n    vector<vector<int>>& edges) \\n    {\\n        vector<int> criticalEdge;\\n        vector<int> pseudoEdge;\\n        map<vector<int>,int> edgeIndex;\\n//map of edge and index as I want the indexes for the ans\\n        \\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            edgeIndex[edges[i]] = i;\\n        }\\n        sort(edges.begin(), edges.end(), compare);//O(ElogE);\\n        \\n        vector<int> temp;\\n//empty vector which I am going to pass when I want the must include include edge null and same for must exclude edge\\n        \\n        int minCost = MST(n, edges, temp, temp);//min cost considering all edges\\n\\n        for(auto edge: edges)//O(E^2)\\n        {\\n//I will check if by excluding and including current edge in the loop what effect it has on cost\\n            int exclude_cost = MST(n, edges,temp, edge);//(n,edges,include,exclude)\\n            if(exclude_cost > minCost)\\n                criticalEdge.push_back(edgeIndex[edge]);//means critical edge as by excluding it our cost gets increased\\n            else\\n            {\\n                int include_cost = MST(n,edges,edge,temp);\\n                if(include_cost == minCost)//means pseudoEdge as by excluding and including it doesn\\'t effect our minCost \\n                    pseudoEdge.push_back(edgeIndex[edge]);\\n            }\\n        }\\n        return {criticalEdge, pseudoEdge};//our final ans\\n        \\n        //hope you all understood it well :)\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findPar(int x, vector<int> &parent)\\n    {\\n        while(x != parent[x])\\n            x = parent[x];\\n        return x;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 850385,
                "title": "python-simple-double-dsu-o-e-2-solution",
                "content": "Not the fastest algorithm, but perhaps one of the easiest-to-code solutions during a contest. The code is plain and straight-forward:\\n```python\\nclass DSU:\\n    def __init__(self, N: int):\\n        # initially, every node forms a partition of size 1\\n        self.par = list(range(N))   #             the partition to which every node belongs\\n        self.sz = [1] * N           # the size of ...\\n    \\n    def find(self, x: int) -> int:\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x: int, y: int) -> bool:\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.sz[yr] = self.sz[xr]\\n        return True\\n    \\n    def size(self, x: int) -> int:\\n        return self.sz[self.find(x)]\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = sorted((w, u, v, i) for i, (u, v, w) in enumerate(edges))\\n        critical, pseudo = [], []\\n        for _w, _u, _v, i in edges:\\n            dsu1, dsu2 = DSU(n), DSU(n)\\n            dsu1.union(_u, _v)\\n            s1, s2 = _w, 0\\n            for w, u, v, j in edges:\\n                if i == j:\\n                    continue\\n                if dsu1.union(u, v):\\n                    s1 += w\\n                if dsu2.union(u, v):\\n                    s2 += w\\n            if s1 == s2:\\n                pseudo.append(i)\\n            elif s1 < s2 or dsu2.union(_u, _v):\\n                critical.append(i)\\n        return critical, pseudo\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self, N: int):\\n        # initially, every node forms a partition of size 1\\n        self.par = list(range(N))   #             the partition to which every node belongs\\n        self.sz = [1] * N           # the size of ...\\n    \\n    def find(self, x: int) -> int:\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    \\n    def union(self, x: int, y: int) -> bool:\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.sz[yr] = self.sz[xr]\\n        return True\\n    \\n    def size(self, x: int) -> int:\\n        return self.sz[self.find(x)]\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        edges = sorted((w, u, v, i) for i, (u, v, w) in enumerate(edges))\\n        critical, pseudo = [], []\\n        for _w, _u, _v, i in edges:\\n            dsu1, dsu2 = DSU(n), DSU(n)\\n            dsu1.union(_u, _v)\\n            s1, s2 = _w, 0\\n            for w, u, v, j in edges:\\n                if i == j:\\n                    continue\\n                if dsu1.union(u, v):\\n                    s1 += w\\n                if dsu2.union(u, v):\\n                    s2 += w\\n            if s1 == s2:\\n                pseudo.append(i)\\n            elif s1 < s2 or dsu2.union(_u, _v):\\n                critical.append(i)\\n        return critical, pseudo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700003,
                "title": "well-structured-c-o-eloge-code-with-clear-comments-kruskal-tarjan",
                "content": "The code was inspired by this [post](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/698025/O(ElogE)-Kruskal%2BTarjan). To solve the problem with O(ElogE) time complexity, you need to understand several algorithms as prerequisites:\\n1. Kruskal\\u2019s Minimum Spanning Tree Algorithm (LeetCode medium [problem](https://leetcode.com/problems/connecting-cities-with-minimum-cost/))\\n\\t* \\tUnion-find (or disjoint set) data structure\\n2. Tarjan\\'s bridge-finding algorithm (Leetcode hard [problem](https://leetcode.com/problems/critical-connections-in-a-network/))\\n```\\nclass UnionFind {\\n    vector<int> setof, rank;\\npublic:\\n    UnionFind(int n) {\\n        setof.resize(n);\\n        rank.resize(n);\\n        for (int i = 0; i < n; ++i) {\\n            setof[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx != ry) {\\n            if (rank[rx] > rank[ry]) {\\n                swap(rx, ry);\\n            }\\n            setof[rx] = ry;\\n            if (rank[rx] == rank[ry]) {\\n                rank[ry]++;\\n            }\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (setof[x] == x) {\\n            return x;\\n        }\\n        return setof[x] = find(setof[x]);\\n    }\\n};\\n\\nclass TarjanSolver {\\n    int n;\\n    unordered_map<int, int> nodes;\\n    unordered_set<int> bridges;\\n    vector<vector<vector<int>>> edges;\\n    vector<int> ancestors;\\n    vector<bool> vis;\\npublic:\\n    TarjanSolver(vector<vector<int>>& inputEdges) {\\n        n = 0;\\n        nodes.clear();\\n        for (vector<int>& e : inputEdges) {\\n            for (int j = 0; j < 2; ++j) {\\n                if (nodes.count(e[j]) == 0) {\\n                    // map node indices to component indices in the new graph\\n                    nodes[e[j]] = n++;\\n                }\\n                e[j] = nodes[e[j]];\\n            }\\n        }\\n        edges.assign(n, {});\\n        for (vector<int>& e : inputEdges) {\\n            int u = e[0], v = e[1], i = e[2];\\n            edges[u].push_back({v, i});\\n            edges[v].push_back({u, i});\\n        }\\n    }\\n    \\n    /*\\n        returns 2 lists:\\n        1. indices of critical edges\\n        2. indices of pseudo-critical edges\\n    */\\n    vector<vector<int>> solve() {\\n        bridges.clear();\\n        ancestors.assign(n, 0);\\n        vis.assign(n, false);\\n        for (int u = 0; u < n; ++u) {\\n            if (!vis[u]) {\\n                dfs(u, -1, 0);\\n            }\\n        }\\n        vector<vector<int>> result(2, vector<int>());\\n        for (int u = 0; u < n; ++u) {\\n            for (int j = 0; j < edges[u].size(); ++j) {\\n                int v = edges[u][j][0], i = edges[u][j][1];\\n                // avoid duplicates\\n                if (u < v) {\\n                    // critical edge\\n                    if (bridges.count(i) > 0) {\\n                        result[0].push_back(i);\\n                    }\\n                    // pseudo-critical edge\\n                    else {\\n                        result[1].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\nprivate:\\n    void dfs(int u, int from, int depth) {\\n        vis[u] = true;\\n        ancestors[u] = depth;\\n        for (int j = 0; j < edges[u].size(); ++j) {\\n            int v = edges[u][j][0], i = edges[u][j][1];\\n            // the edge from parent to current node\\n            if (i == from) {\\n                continue;\\n            }\\n            if (!vis[v]) {\\n                dfs(v, i, depth + 1);\\n                if (depth < ancestors[v]) {\\n                    bridges.insert(i);\\n                }\\n            }\\n            ancestors[u] = min(ancestors[u], ancestors[v]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> result(2, vector<int>());\\n        UnionFind components(n);\\n        \\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        \\n        for (int l = 0, r = 0; l < edges.size(); l = r) {\\n            // edges with indices in [l, r) have the same weight\\n            while (r < edges.size() && edges[l][2] == edges[r][2]) {\\n                ++r;\\n            }\\n            \\n            // shrink components into nodes, and run Tarjan\\'s bridge-finding algorithm on the new graph\\n            // critical edges will be bridges and pseudo-critical edges will be the rest\\n            // non-critical edges will not appear in the new graph\\n            vector<vector<int>> connections;\\n            for (int j = l; j < r; ++j) {\\n                int u = components.find(edges[j][0]), v = components.find(edges[j][1]), i = edges[j][3];\\n                if (u != v) {\\n                    connections.push_back({u, v, i});\\n                }\\n            }\\n            vector<vector<int>> subResult = TarjanSolver(connections).solve();\\n            result[0].insert(result[0].end(), subResult[0].begin(), subResult[0].end());\\n            result[1].insert(result[1].end(), subResult[1].begin(), subResult[1].end());\\n            \\n            // kruskal: merge components\\n            for (int j = l; j < r; ++j) {\\n                int u = components.find(edges[j][0]), v = components.find(edges[j][1]);\\n                if (u != v) {\\n                    components.merge(u, v);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\n    vector<int> setof, rank;\\npublic:\\n    UnionFind(int n) {\\n        setof.resize(n);\\n        rank.resize(n);\\n        for (int i = 0; i < n; ++i) {\\n            setof[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rx = find(x), ry = find(y);\\n        if (rx != ry) {\\n            if (rank[rx] > rank[ry]) {\\n                swap(rx, ry);\\n            }\\n            setof[rx] = ry;\\n            if (rank[rx] == rank[ry]) {\\n                rank[ry]++;\\n            }\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (setof[x] == x) {\\n            return x;\\n        }\\n        return setof[x] = find(setof[x]);\\n    }\\n};\\n\\nclass TarjanSolver {\\n    int n;\\n    unordered_map<int, int> nodes;\\n    unordered_set<int> bridges;\\n    vector<vector<vector<int>>> edges;\\n    vector<int> ancestors;\\n    vector<bool> vis;\\npublic:\\n    TarjanSolver(vector<vector<int>>& inputEdges) {\\n        n = 0;\\n        nodes.clear();\\n        for (vector<int>& e : inputEdges) {\\n            for (int j = 0; j < 2; ++j) {\\n                if (nodes.count(e[j]) == 0) {\\n                    // map node indices to component indices in the new graph\\n                    nodes[e[j]] = n++;\\n                }\\n                e[j] = nodes[e[j]];\\n            }\\n        }\\n        edges.assign(n, {});\\n        for (vector<int>& e : inputEdges) {\\n            int u = e[0], v = e[1], i = e[2];\\n            edges[u].push_back({v, i});\\n            edges[v].push_back({u, i});\\n        }\\n    }\\n    \\n    /*\\n        returns 2 lists:\\n        1. indices of critical edges\\n        2. indices of pseudo-critical edges\\n    */\\n    vector<vector<int>> solve() {\\n        bridges.clear();\\n        ancestors.assign(n, 0);\\n        vis.assign(n, false);\\n        for (int u = 0; u < n; ++u) {\\n            if (!vis[u]) {\\n                dfs(u, -1, 0);\\n            }\\n        }\\n        vector<vector<int>> result(2, vector<int>());\\n        for (int u = 0; u < n; ++u) {\\n            for (int j = 0; j < edges[u].size(); ++j) {\\n                int v = edges[u][j][0], i = edges[u][j][1];\\n                // avoid duplicates\\n                if (u < v) {\\n                    // critical edge\\n                    if (bridges.count(i) > 0) {\\n                        result[0].push_back(i);\\n                    }\\n                    // pseudo-critical edge\\n                    else {\\n                        result[1].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\nprivate:\\n    void dfs(int u, int from, int depth) {\\n        vis[u] = true;\\n        ancestors[u] = depth;\\n        for (int j = 0; j < edges[u].size(); ++j) {\\n            int v = edges[u][j][0], i = edges[u][j][1];\\n            // the edge from parent to current node\\n            if (i == from) {\\n                continue;\\n            }\\n            if (!vis[v]) {\\n                dfs(v, i, depth + 1);\\n                if (depth < ancestors[v]) {\\n                    bridges.insert(i);\\n                }\\n            }\\n            ancestors[u] = min(ancestors[u], ancestors[v]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> result(2, vector<int>());\\n        UnionFind components(n);\\n        \\n        for (int i = 0; i < edges.size(); ++i) {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        \\n        for (int l = 0, r = 0; l < edges.size(); l = r) {\\n            // edges with indices in [l, r) have the same weight\\n            while (r < edges.size() && edges[l][2] == edges[r][2]) {\\n                ++r;\\n            }\\n            \\n            // shrink components into nodes, and run Tarjan\\'s bridge-finding algorithm on the new graph\\n            // critical edges will be bridges and pseudo-critical edges will be the rest\\n            // non-critical edges will not appear in the new graph\\n            vector<vector<int>> connections;\\n            for (int j = l; j < r; ++j) {\\n                int u = components.find(edges[j][0]), v = components.find(edges[j][1]), i = edges[j][3];\\n                if (u != v) {\\n                    connections.push_back({u, v, i});\\n                }\\n            }\\n            vector<vector<int>> subResult = TarjanSolver(connections).solve();\\n            result[0].insert(result[0].end(), subResult[0].begin(), subResult[0].end());\\n            result[1].insert(result[1].end(), subResult[1].begin(), subResult[1].end());\\n            \\n            // kruskal: merge components\\n            for (int j = l; j < r; ++j) {\\n                int u = components.find(edges[j][0]), v = components.find(edges[j][1]);\\n                if (u != v) {\\n                    components.merge(u, v);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698312,
                "title": "java-intuitive-solution-using-prim-s-and-graph-partitions-with-detailed-explanation-o-ev",
                "content": "Honestly this was kind of nasty to implement but hey it works and makes sense. \\n\\nStep 1: Generate an MST (using standard Prim\\'s algorithm).\\nStep 2: For every edge in the MST: consider the cut formed by removing (only) this edge e of weight w from the MST. For all edges in the original graph crossing this e-induced cut, we have that any such edge that also has weight w and was not in our formed MST from Step 1 can be added to the cut to create a new MST (with the same weight as our initial MST). If there is more than one edge satisfying this criteria (so an edge besides just e), then all such edges are pseudo-critical. Else e is a critical edge.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Set<int[]>> G = new ArrayList();\\n        for (int i = 0; i < n; i++) G.add(new HashSet());\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            G.get(e[0]).add(new int[]{e[1], e[2], i});\\n            G.get(e[1]).add(new int[]{e[0], e[2], i});\\n        }\\n        Set<Integer> V = new HashSet();\\n        V.add(0);\\n        PriorityQueue<int[]> PQ = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        PQ.addAll(G.get(0));\\n        List<Integer> MST = new ArrayList();\\n        while (!PQ.isEmpty()) {\\n            while (!PQ.isEmpty() && V.contains(PQ.peek()[0])) PQ.poll();\\n            if (PQ.isEmpty()) break;\\n            int[] top = PQ.poll();\\n            MST.add(top[2]);\\n            V.add(top[0]);\\n            for (int[] e : G.get(top[0]))\\n                if (!V.contains(e[0])) PQ.add(e);\\n        }\\n        int[][] mstEdges = new int[MST.size()][3];\\n        for (int i = 0; i < MST.size(); i++) mstEdges[i] = edges[MST.get(i)];\\n        Set<Integer> criticals = new HashSet(), pseudos = new HashSet();\\n        for (int i = 0; i < mstEdges.length; i++) {\\n            List<Set<Integer>> partition = genCut(mstEdges, n, i);\\n            Set<Integer> P1 = partition.get(0), P2 = partition.get(1);\\n            int w = mstEdges[i][2];\\n            Set<Integer> mins = new HashSet();\\n            mins.add(MST.get(i));\\n            for (int u : P1) \\n                for (int[] e : G.get(u)) \\n                    if (P2.contains(e[0]) && e[1] == w) {\\n                        mins.add(e[2]);\\n                    }\\n            if (mins.size() > 1) pseudos.addAll(mins);\\n            else criticals.addAll(mins);\\n        }\\n        return Arrays.asList(new ArrayList(criticals), new ArrayList(pseudos));\\n    }\\n    \\n    private List<Set<Integer>> genCut(int[][] E, int n, int removeIdx) {\\n        List<Set<Integer>> G = new ArrayList();\\n        for (int i = 0; i < n; i++) G.add(new HashSet());\\n        for (int i = 0; i < E.length; i++) {\\n            if (i == removeIdx) continue;\\n            int[] e = E[i];\\n            G.get(e[0]).add(e[1]);\\n            G.get(e[1]).add(e[0]);\\n        }\\n        Set<Integer> S1 = new HashSet();\\n        S1.add(0);\\n        dfs(0, G, S1);\\n        int idx2 = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (!S1.contains(i)) {\\n                idx2 = i;\\n                break;\\n            }\\n        }\\n        Set<Integer> S2 = new HashSet();\\n        S2.add(idx2);\\n        dfs(idx2, G, S2);\\n        return Arrays.asList(S1, S2);\\n    }\\n    \\n    private void dfs(int u, List<Set<Integer>> G, Set<Integer> V) {\\n        for (int v : G.get(u))\\n            if (!V.contains(v)) {\\n                V.add(v);\\n                dfs(v, G, V);\\n            }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Set<int[]>> G = new ArrayList();\\n        for (int i = 0; i < n; i++) G.add(new HashSet());\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            G.get(e[0]).add(new int[]{e[1], e[2], i});\\n            G.get(e[1]).add(new int[]{e[0], e[2], i});\\n        }\\n        Set<Integer> V = new HashSet();\\n        V.add(0);\\n        PriorityQueue<int[]> PQ = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        PQ.addAll(G.get(0));\\n        List<Integer> MST = new ArrayList();\\n        while (!PQ.isEmpty()) {\\n            while (!PQ.isEmpty() && V.contains(PQ.peek()[0])) PQ.poll();\\n            if (PQ.isEmpty()) break;\\n            int[] top = PQ.poll();\\n            MST.add(top[2]);\\n            V.add(top[0]);\\n            for (int[] e : G.get(top[0]))\\n                if (!V.contains(e[0])) PQ.add(e);\\n        }\\n        int[][] mstEdges = new int[MST.size()][3];\\n        for (int i = 0; i < MST.size(); i++) mstEdges[i] = edges[MST.get(i)];\\n        Set<Integer> criticals = new HashSet(), pseudos = new HashSet();\\n        for (int i = 0; i < mstEdges.length; i++) {\\n            List<Set<Integer>> partition = genCut(mstEdges, n, i);\\n            Set<Integer> P1 = partition.get(0), P2 = partition.get(1);\\n            int w = mstEdges[i][2];\\n            Set<Integer> mins = new HashSet();\\n            mins.add(MST.get(i));\\n            for (int u : P1) \\n                for (int[] e : G.get(u)) \\n                    if (P2.contains(e[0]) && e[1] == w) {\\n                        mins.add(e[2]);\\n                    }\\n            if (mins.size() > 1) pseudos.addAll(mins);\\n            else criticals.addAll(mins);\\n        }\\n        return Arrays.asList(new ArrayList(criticals), new ArrayList(pseudos));\\n    }\\n    \\n    private List<Set<Integer>> genCut(int[][] E, int n, int removeIdx) {\\n        List<Set<Integer>> G = new ArrayList();\\n        for (int i = 0; i < n; i++) G.add(new HashSet());\\n        for (int i = 0; i < E.length; i++) {\\n            if (i == removeIdx) continue;\\n            int[] e = E[i];\\n            G.get(e[0]).add(e[1]);\\n            G.get(e[1]).add(e[0]);\\n        }\\n        Set<Integer> S1 = new HashSet();\\n        S1.add(0);\\n        dfs(0, G, S1);\\n        int idx2 = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (!S1.contains(i)) {\\n                idx2 = i;\\n                break;\\n            }\\n        }\\n        Set<Integer> S2 = new HashSet();\\n        S2.add(idx2);\\n        dfs(idx2, G, S2);\\n        return Arrays.asList(S1, S2);\\n    }\\n    \\n    private void dfs(int u, List<Set<Integer>> G, Set<Integer> V) {\\n        for (int v : G.get(u))\\n            if (!V.contains(v)) {\\n                V.add(v);\\n                dfs(v, G, V);\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697941,
                "title": "accepted-c-solution-kruskal-s-algo",
                "content": "```\\n     public class Solution\\n    {\\n        public class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private int Kruskal(int n, (int from, int to, int w, int origIndex)[] newEdges, int? ignoreIdx, int? forceAddedIdx)\\n        {\\n            int sum = 0;\\n            Unions dsu = new Unions(n);\\n            int count = 0;\\n\\n            if (forceAddedIdx.HasValue)\\n            {\\n                var edge = newEdges[forceAddedIdx.Value];\\n                var v1 = edge.from;\\n                var v2 = edge.to;\\n                dsu.Union(v1, v2);\\n                sum += edge.w;\\n                count++;\\n            }\\n\\n            for (int i = 0; i < newEdges.Length; i++)\\n            {\\n                var edge = newEdges[i];\\n                var v1 = edge.from;\\n                var v2 = edge.to;\\n                if (dsu.Find(v1) == dsu.Find(v2))\\n                {\\n                    continue;\\n                }\\n\\n                if (ignoreIdx.HasValue && ignoreIdx == i)\\n                {\\n                    continue;\\n                }\\n\\n                dsu.Union(v1, v2);\\n                sum += edge.w;\\n                count++;\\n            }\\n\\n            return count == n - 1 ? sum : -1;\\n        }\\n\\n        public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges)\\n        {\\n            IList<int> crit = new List<int>();\\n            IList<int> pseudoCrit = new List<int>();\\n\\n            (int from, int to, int w, int origIndex)[] newEdges = new (int @from, int to, int w, int origIndex)[edges.Length];\\n            for (int i = 0; i < edges.Length; i++)\\n            {\\n                var edge = edges[i];\\n                var v1 = edge[0];\\n                var v2 = edge[1];\\n                var w = edge[2];\\n\\n                newEdges[i] = (v1, v2, w, i);\\n            }\\n\\n            Array.Sort(newEdges, (e1, e2) => e1.w.CompareTo(e2.w));\\n            int targetSum = Kruskal(n, newEdges, null, null);\\n\\n\\n            for (int i = 0; i < newEdges.Length; i++)\\n            {\\n                var excludeThis = Kruskal(n, newEdges, i, null);\\n                if (excludeThis < 0 || excludeThis > targetSum)\\n                {\\n                    crit.Add(newEdges[i].origIndex);\\n                    continue;\\n                }\\n\\n                var forceIncludeThis = Kruskal(n, newEdges, null, i);\\n                if (forceIncludeThis == targetSum)\\n                {\\n                    pseudoCrit.Add(newEdges[i].origIndex);\\n                }\\n            }\\n\\n            \\n            return new List<IList<int>>(){crit, pseudoCrit};\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n     public class Solution\\n    {\\n        public class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private int Kruskal(int n, (int from, int to, int w, int origIndex)[] newEdges, int? ignoreIdx, int? forceAddedIdx)\\n        {\\n            int sum = 0;\\n            Unions dsu = new Unions(n);\\n            int count = 0;\\n\\n            if (forceAddedIdx.HasValue)\\n            {\\n                var edge = newEdges[forceAddedIdx.Value];\\n                var v1 = edge.from;\\n                var v2 = edge.to;\\n                dsu.Union(v1, v2);\\n                sum += edge.w;\\n                count++;\\n            }\\n\\n            for (int i = 0; i < newEdges.Length; i++)\\n            {\\n                var edge = newEdges[i];\\n                var v1 = edge.from;\\n                var v2 = edge.to;\\n                if (dsu.Find(v1) == dsu.Find(v2))\\n                {\\n                    continue;\\n                }\\n\\n                if (ignoreIdx.HasValue && ignoreIdx == i)\\n                {\\n                    continue;\\n                }\\n\\n                dsu.Union(v1, v2);\\n                sum += edge.w;\\n                count++;\\n            }\\n\\n            return count == n - 1 ? sum : -1;\\n        }\\n\\n        public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges)\\n        {\\n            IList<int> crit = new List<int>();\\n            IList<int> pseudoCrit = new List<int>();\\n\\n            (int from, int to, int w, int origIndex)[] newEdges = new (int @from, int to, int w, int origIndex)[edges.Length];\\n            for (int i = 0; i < edges.Length; i++)\\n            {\\n                var edge = edges[i];\\n                var v1 = edge[0];\\n                var v2 = edge[1];\\n                var w = edge[2];\\n\\n                newEdges[i] = (v1, v2, w, i);\\n            }\\n\\n            Array.Sort(newEdges, (e1, e2) => e1.w.CompareTo(e2.w));\\n            int targetSum = Kruskal(n, newEdges, null, null);\\n\\n\\n            for (int i = 0; i < newEdges.Length; i++)\\n            {\\n                var excludeThis = Kruskal(n, newEdges, i, null);\\n                if (excludeThis < 0 || excludeThis > targetSum)\\n                {\\n                    crit.Add(newEdges[i].origIndex);\\n                    continue;\\n                }\\n\\n                var forceIncludeThis = Kruskal(n, newEdges, null, i);\\n                if (forceIncludeThis == targetSum)\\n                {\\n                    pseudoCrit.Add(newEdges[i].origIndex);\\n                }\\n            }\\n\\n            \\n            return new List<IList<int>>(){crit, pseudoCrit};\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950081,
                "title": "easy-c-solution-using-kruskal-s-algorithm-with-dsu-with-path-compression-and-union-by-rank",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    // .................................................. //\\n    // DSU implementation //\\n    // creating struct for edge\\n    struct Edge {\\n        int src, dst, wt , serial;\\n        Edge(int s, int d, int w, int n) {\\n            src = s;\\n            dst = d;\\n            wt = w;\\n            serial = n;\\n        }\\n    };\\n    // Using Union by rank and path compression\\n    vector<int> par;\\n    vector<int> rank;\\n    // path compression\\n    void initialize(int n) {\\n        par = vector<int>(n);\\n        rank = vector<int>(n);\\n        for(int i = 0; i < n; i++) {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    void unionn(int x, int y) {\\n        int x_rep = find(x), y_rep = find(y);\\n        if(x_rep == y_rep) return;\\n        if(rank[x_rep] < rank[y_rep])   par[x_rep] = y_rep;\\n        else if(rank[x_rep] > rank[y_rep])  par[y_rep] = x_rep;\\n        else {\\n            par[y_rep] = x_rep;\\n            rank[x_rep]++;\\n        }\\n    }\\n    int find(int x) {\\n        if(x == par[x])\\n            return x;\\n        par[x] = find(par[x]);\\n        return par[x];\\n    }\\n    // DSU implementation //\\n    // ................................................... //\\n    vector<Edge> edge;\\n    static bool myCmp(Edge& e1, Edge& e2) {\\n        return e1.wt < e2.wt;\\n    }\\n    int findMSTWt(int n, int m, int include, int exclude) {\\n        int ret = 0;\\n        initialize(n);\\n        // if any edge is to be included include it at first\\n        int i, s = 0;\\n        if(include != -1) {\\n            Edge e = edge[include];\\n            unionn(e.src, e.dst);\\n            ret += e.wt;\\n            s++;\\n        }\\n        // finding MST using Kruskal\\'s Algorithm\\n        for(int i = 0; s < n - 1 and i < m; i++) {\\n            if(i == exclude)    continue;\\n            Edge e = edge[i];\\n            int x = find(e.src);\\n            int y = find(e.dst);\\n            // if no cycle then add\\n            if(x != y) {\\n                ret += e.wt;\\n                unionn(x,y);\\n                s++;\\n            }\\n        }\\n        if(s < n - 1)\\n            ret = 1e8;\\n        return ret;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // using Kruskal\\'s algorithm\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++) {\\n            Edge e(edges[i][0], edges[i][1], edges[i][2], i);\\n            edge.push_back(e);\\n        }\\n        sort(edge.begin() , edge.end() , myCmp);\\n        vector<vector<int>> ans(2);\\n        int mn = findMSTWt(n, m, -1, -1);\\n        // finding critical edges\\n        // just exclude every edge if MST wt. increases then it is critical edge\\n        // finding pseudo - critical edges\\n        // just include every edge if MST wt. remains same then it is pseudo critical edge\\n        for(int i = 0; i < m; i++) {\\n            int curr1 = findMSTWt(n, m, -1, i);\\n            if(curr1 > mn) {\\n                ans[0].push_back(edge[i].serial);\\n                continue;\\n            }\\n            int curr2 = findMSTWt(n, m, i, -1);\\n            if(curr2 == mn)   ans[1].push_back(edge[i].serial);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // .................................................. //\\n    // DSU implementation //\\n    // creating struct for edge\\n    struct Edge {\\n        int src, dst, wt , serial;\\n        Edge(int s, int d, int w, int n) {\\n            src = s;\\n            dst = d;\\n            wt = w;\\n            serial = n;\\n        }\\n    };\\n    // Using Union by rank and path compression\\n    vector<int> par;\\n    vector<int> rank;\\n    // path compression\\n    void initialize(int n) {\\n        par = vector<int>(n);\\n        rank = vector<int>(n);\\n        for(int i = 0; i < n; i++) {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n    void unionn(int x, int y) {\\n        int x_rep = find(x), y_rep = find(y);\\n        if(x_rep == y_rep) return;\\n        if(rank[x_rep] < rank[y_rep])   par[x_rep] = y_rep;\\n        else if(rank[x_rep] > rank[y_rep])  par[y_rep] = x_rep;\\n        else {\\n            par[y_rep] = x_rep;\\n            rank[x_rep]++;\\n        }\\n    }\\n    int find(int x) {\\n        if(x == par[x])\\n            return x;\\n        par[x] = find(par[x]);\\n        return par[x];\\n    }\\n    // DSU implementation //\\n    // ................................................... //\\n    vector<Edge> edge;\\n    static bool myCmp(Edge& e1, Edge& e2) {\\n        return e1.wt < e2.wt;\\n    }\\n    int findMSTWt(int n, int m, int include, int exclude) {\\n        int ret = 0;\\n        initialize(n);\\n        // if any edge is to be included include it at first\\n        int i, s = 0;\\n        if(include != -1) {\\n            Edge e = edge[include];\\n            unionn(e.src, e.dst);\\n            ret += e.wt;\\n            s++;\\n        }\\n        // finding MST using Kruskal\\'s Algorithm\\n        for(int i = 0; s < n - 1 and i < m; i++) {\\n            if(i == exclude)    continue;\\n            Edge e = edge[i];\\n            int x = find(e.src);\\n            int y = find(e.dst);\\n            // if no cycle then add\\n            if(x != y) {\\n                ret += e.wt;\\n                unionn(x,y);\\n                s++;\\n            }\\n        }\\n        if(s < n - 1)\\n            ret = 1e8;\\n        return ret;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // using Kruskal\\'s algorithm\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++) {\\n            Edge e(edges[i][0], edges[i][1], edges[i][2], i);\\n            edge.push_back(e);\\n        }\\n        sort(edge.begin() , edge.end() , myCmp);\\n        vector<vector<int>> ans(2);\\n        int mn = findMSTWt(n, m, -1, -1);\\n        // finding critical edges\\n        // just exclude every edge if MST wt. increases then it is critical edge\\n        // finding pseudo - critical edges\\n        // just include every edge if MST wt. remains same then it is pseudo critical edge\\n        for(int i = 0; i < m; i++) {\\n            int curr1 = findMSTWt(n, m, -1, i);\\n            if(curr1 > mn) {\\n                ans[0].push_back(edge[i].serial);\\n                continue;\\n            }\\n            int curr2 = findMSTWt(n, m, i, -1);\\n            if(curr2 == mn)   ans[1].push_back(edge[i].serial);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935514,
                "title": "",
                "content": "# \\u0406\\u043D\\u0442\\u0443\\u0457\\u0446\\u0456\\u044F\\n\\n\\u041F\\u0456\\u0434 \\u0447\\u0430\\u0441 \\u0440\\u043E\\u0431\\u043E\\u0442\\u0438 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0443 \\u041A\\u0440\\u0443\\u0441\\u043A\\u0430\\u043B\\u0430 \\u043C\\u0438 \\u043E\\u0431\\u0438\\u0440\\u0430\\u0454\\u043C\\u043E \\u043B\\u0438\\u0448\\u0435 \\u0442\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430, \\u044F\\u043A\\u0456 \\u043D\\u0435 \\u0443\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E\\u0442\\u044C \\u0446\\u0438\\u043A\\u043B\\u0456\\u0432 \\u0432 \\u0448\\u0443\\u043A\\u0430\\u043D\\u043E\\u043C\\u0443 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0456. \\u042F\\u043A\\u0449\\u043E \\u043F\\u0440\\u0438\\u0434\\u0438\\u0432\\u0438\\u0442\\u0438\\u0441\\u044C \\u0434\\u043E \\u0446\\u0438\\u043A\\u043B\\u0430 \\u044F\\u043A\\u0438\\u0439 \\u0443\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454 \\u043D\\u043E\\u0432\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u0432 \\u041C\\u0456\\u043D\\u0456\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u043C\\u0443 \\u0414\\u0435\\u0440\\u0435\\u0432\\u0456 - \\u0442\\u043E \\u0432\\u0438\\u044F\\u0432\\u0438\\u0442\\u044C\\u0441\\u044F \\u0449\\u043E \\u0441\\u0435\\u0440\\u0435\\u0434 \\u043D\\u0430\\u0439\\u0432\\u0430\\u0436\\u0447\\u0438\\u0445 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0443\\u0442\\u0432\\u043E\\u0440\\u0435\\u043D\\u043E\\u0433\\u043E \\u0446\\u0438\\u043A\\u043B\\u0443 \\u043C\\u043E\\u0436\\u043D\\u0430 \\u0432\\u0438\\u0434\\u0430\\u043B\\u0438\\u0442\\u0438 \\u0431\\u0443\\u0434\\u044C\\u044F\\u043A\\u0435 \\u043E\\u0434\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E. \\u041F\\u0440\\u0438 \\u0446\\u044C\\u043E\\u043C\\u0443 \\u043D\\u0456 \\u043C\\u043D\\u043E\\u0436\\u0438\\u043D\\u0430 \\u0437\\'\\u0454\\u0434\\u043D\\u0430\\u043D\\u0438\\u0445 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D, \\u043D\\u0456 \\u0441\\u0443\\u043C\\u0430\\u0440\\u043D\\u0430 \\u0432\\u0430\\u0433\\u0430 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u043D\\u0435 \\u0437\\u043C\\u0456\\u043D\\u044F\\u0442\\u044C\\u0441\\u044F.\\n\\n# \\u041F\\u0456\\u0434\\u0445\\u0456\\u0434\\n\\n\\u0414\\u043B\\u044F \\u043A\\u043E\\u0436\\u043D\\u043E\\u0433\\u043E \\u043A\\u0440\\u043E\\u043A\\u0443 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0430 \\u041A\\u0440\\u0443\\u0441\\u043A\\u0430\\u043B\\u0430, \\u044F\\u043A\\u0449\\u043E \\u043D\\u043E\\u0432\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u043D\\u0435 \\u0443\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454 \\u0446\\u0438\\u043A\\u043B\\u0443 - \\u0434\\u043E\\u0434\\u0430\\u0454\\u043C\\u043E \\u0439\\u043E\\u0433\\u043E \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u0433\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430 \\u0442\\u0430 \\u0432\\u0456\\u0434\\u043C\\u0456\\u0447\\u0430\\u0454\\u043C\\u043E \\u044F\\u043A \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435.\\n\\n\\u042F\\u043A\\u0449\\u043E \\u0436 \\u043D\\u043E\\u0432\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u0443\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454 \\u0446\\u0438\\u043A\\u043B (\\u0432 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0456 \\u0432\\u0456\\u043D \\u0431\\u0443\\u0434\\u0435 \\u043E\\u0434\\u0438\\u043D) - \\u0437\\u043D\\u0430\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u044F\\u043A\\u0456 \\u0431\\u0435\\u0440\\u0443\\u0442\\u044C \\u0432 \\u043D\\u044C\\u043E\\u0433\\u043C\\u0443 \\u0443\\u0447\\u0430\\u0441\\u0442\\u044C. \\u041F\\u043E\\u0442\\u043E\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E - \"\\u043D\\u0430\\u0439\\u0432\\u0430\\u0436\\u0447\\u0435\" \\u0441\\u0435\\u0440\\u0435\\u0434 \\u0432\\u0441\\u0456\\u0445 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u044F\\u043A\\u0456 \\u043C\\u043E\\u0436\\u0443\\u0442\\u044C \\u0431\\u0443\\u0442\\u0438 \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0456. \\u0412\\u0441\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0432\\u0430\\u0433\\u0430 \\u044F\\u043A\\u0438\\u0445 \\u0440\\u0456\\u0432\\u043D\\u0430 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u0440\\u0435\\u0431\\u0440\\u0443 (\\u0456 \\u0441\\u0430\\u043C\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E) \\u0432\\u0456\\u0434\\u043C\\u0456\\u0447\\u0430\\u0454\\u043C\\u043E \\u044F\\u043A \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435.\\n\\n\\u0412\\u0438\\u0439\\u043D\\u044F\\u0442\\u043E\\u043A: \\u044F\\u043A\\u0449\\u043E \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0456 \\u043D\\u0435\\u043C\\u0430\\u0454 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0440\\u0456\\u0432\\u043D\\u0438\\u0445 \\u043F\\u043E \\u0432\\u0430\\u0437\\u0456 \\u043D\\u043E\\u0432\\u043E\\u043C\\u0443 \\u0440\\u0435\\u0431\\u0440\\u0443 - \\u0442\\u043E \\u0442\\u0430\\u043A\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u0432\\u0456\\u0434\\u043A\\u0438\\u0434\\u0430\\u0454\\u043C\\u043E \\u0442\\u0430 \\u043D\\u0435 \\u0432\\u0456\\u0434\\u043C\\u0456\\u0447\\u0430\\u0454\\u043C\\u043E \\u044F\\u043A \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435.\\n\\n# \\u0421\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C\\n- \\u041F\\u043E \\u0447\\u0430\\u0441\\u0443:\\n\\u041C\\u0438 \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E \\u043F\\u043E \\u043A\\u043E\\u0436\\u043D\\u043E\\u043C\\u0443 \\u0440\\u0435\\u0431\\u0440\\u0443 \\u043E\\u0434\\u0438\\u043D \\u0440\\u0430\\u0437. \\u0414\\u043B\\u044F \\u043A\\u043E\\u0436\\u043D\\u043E\\u0433\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u043C\\u0438 \\u043F\\u043E\\u0454\\u0434\\u043D\\u0443\\u0454\\u043C\\u043E \\u0433\\u0440\\u0443\\u043F\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D \\u0430\\u0431\\u043E \\u0448\\u0443\\u043A\\u0430\\u0454\\u043C\\u043E \\u0446\\u0438\\u043A\\u043B. \\u0422\\u0430\\u043A \\u0447\\u0430\\u0441\\u043E\\u0432\\u0430 \\u0441\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C $$O(m * n)$$ \\u0434\\u0435 $$m$$ - \\u043A\\u0441\\u0442\\u044C \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0442\\u0430 $$n$$ - \\u043A\\u0441\\u0442\\u044C \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D.\\n\\n\\n- \\u041F\\u043E \\u043F\\u0430\\u043C\\'\\u044F\\u0442\\u0456:\\n\\u041C\\u0438 \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u0454\\u043C\\u043E \\u043A\\u043E\\u043B\\u044C\\u043E\\u0440\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D \\u0442\\u0430 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0432 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0456. \\u041C\\u0438 \\u0442\\u0430\\u043A\\u043E\\u0436 \\u0441\\u043E\\u0440\\u0442\\u0443\\u0454\\u043C\\u043E \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0437\\u0430 \\u0434\\u043E\\u0432\\u0436\\u0438\\u043D\\u043E\\u044E. \\u0422\\u0430\\u043A \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0434\\u0430\\u043D\\u0456 \\u0437\\u0430\\u0439\\u043C\\u0430\\u044E\\u0442\\u044C $$O(m)$$, \\u0430 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043A\\u0430 \\u043F\\u043E\\u0442\\u0440\\u0435\\u0431\\u0443\\u0454 $$O(n)$$.\\n\\n# \\u0425\\u0430\\u0437\\u044F\\u0439\\u0441\\u044C\\u043A\\u0438\\u0439 \\u043A\\u043E\\u0434\\n```\\n// \\u0417\\u0440\\u0443\\u0447\\u043D\\u0430 \\u0441\\u0442\\u0440\\u0443\\u043A\\u0442\\u0443\\u0440\\u0430 \\u0434\\u043B\\u044F \\u0440\\u043E\\u0431\\u043E\\u0442\\u0438 \\u0437 \\u043F\\u043E\\u0442\\u043E\\u043A\\u043E\\u043C \\u0440\\u0435\\u0431\\u0435\\u0440\\nstruct Edge {\\n    int a, b, ind;\\n};\\n\\n\\n// \\u0421\\u0442\\u0440\\u0443\\u043A\\u0442\\u0443\\u0440\\u0430 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0448\\u0443\\u043A\\u0443 \\u0446\\u0438\\u043A\\u043B\\u0456\\u0432\\nstruct RevEdge {\\n    int from, ind;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n\\n        // \\u041C\\u0430\\u043F\\u0430 \\u0432\\u0456\\u0434\\u0441\\u043E\\u0440\\u0442\\u0443\\u0454 \\u0442\\u0430 \\u043E\\u0440\\u0433\\u0430\\u043D\\u0456\\u0437\\u0443\\u0454 \\u0434\\u043B\\u044F \\u043D\\u0430\\u0441 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430\\n        map<int, vector<Edge>> sorted_edges;\\n        for(int i = 0; i < m; ++i) {\\n            sorted_edges[edges[i][2]].push_back({edges[i][0], edges[i][1], i});\\n        }\\n\\n        // \\u041C\\u0456\\u0442\\u043A\\u0438 \\u0440\\u0435\\u0431\\u0435\\u0440:\\n        // 0 - \\u0431\\u0430\\u0437\\u043E\\u0432\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\\n        // 1 - \\u043A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E\\n        // 2 - \\u043F\\u0441\\u0435\\u0432\\u0434\\u043E \\u043A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E\\n        vector<int> marks(m);\\n\\n        // \\u041A\\u043E\\u043B\\u044C\\u043E\\u0440\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\n        vector<int> colors(n);\\n        for(int i = 0; i < n; ++i) colors[i] = i;\\n\\n        // \\u0421\\u043A\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u043D\\u0430\\u043C \\u0449\\u0435 \\u0442\\u0440\\u0435\\u0431\\u0430 \\u0437\\u043D\\u0430\\u0439\\u0442\\u0438?\\n        int to_find = n - 1;\\n\\n        // \\u0420\\u0435\\u0431\\u0440\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430 \\u044F\\u043A\\u0456 \\u0432\\u0438\\u0445\\u043E\\u0434\\u044F\\u0442\\u044C \\u0437 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0438 \\u0437\\u0430 \\u0456\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C\\n        vector<vector<Edge>> connections(n);\\n        for(const auto &edge_pair : sorted_edges) {\\n            // \\u041A\\u043E\\u0436\\u0435\\u043D \\u0440\\u0430\\u0437 \\u043A\\u043E\\u043B\\u0438 \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0454\\u0442\\u044C\\u0441\\u044F \\u0437\\u043E\\u0432\\u043D\\u0456\\u0448\\u043D\\u0456\\u0439 \\u0446\\u0438\\u043A\\u043B - \\u043C\\u0438\\n            // \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0454\\u043C\\u043E \\u0440\\u043E\\u0437\\u0433\\u043B\\u044F\\u0434\\u0430\\u0442\\u0438 \\u043D\\u0430\\u0431\\u0456\\u0440 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0437 \\u0431\\u0456\\u043B\\u044C\\u0448\\u043E\\u044E \\u0432\\u0430\\u0433\\u043E\\u044E.\\n            // \\u042F\\u043A\\u0449\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u0432\\u0436\\u0435 \\u043F\\u043E\\u0431\\u0443\\u0434\\u0430\\u0432\\u043D\\u0435 - \\u0457\\u0445 \\u0440\\u043E\\u0437\\u0433\\u043B\\u044F\\u0434\\u0430\\u0442\\u0438 \\u0432\\u0436\\u0435 \\u043D\\u0435\\n            // \\u0442\\u0440\\u0435\\u0431\\u0430.\\n            if(to_find == 0) break;\\n            // \\u041F\\u043E\\u0442\\u043E\\u0447\\u043D\\u0430 \\u0432\\u0430\\u0433\\u0430 \\u0440\\u0435\\u0431\\u0435\\u0440. \\u0412\\u043E\\u043D\\u0430 \\u0443 \\u0432\\u0441\\u0456\\u0445 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u043E\\u0434\\u043D\\u0430\\u043A\\u043E\\u0432\\u0430.\\n            int w = edge_pair.first;\\n            // \\u0421\\u043F\\u0438\\u0441\\u043E\\u043A \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0437 \\u0446\\u0456\\u0454\\u044E \\u0432\\u0430\\u0433\\u043E\\u044E.\\n            const vector<Edge> &list = edge_pair.second;\\n            for(const auto &edge : list) {\\n                if(colors[edge.a] != colors[edge.b]) {\\n                    // \\u042F\\u043A\\u0449\\u043E \\u043A\\u043E\\u043B\\u044C\\u043E\\u0440\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D \\u0440\\u0456\\u0437\\u043D\\u0456:\\n                    // * \\u0434\\u043E\\u0434\\u0430\\u0454\\u043C\\u043E \\u0434\\u043E \\u0448\\u0443\\u043A\\u0430\\u043D\\u043E\\u0433\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430\\n                    connections[edge.a].push_back(edge);\\n                    connections[edge.b].push_back({edge.b, edge.a, edge.ind});\\n                    // * \\u0432\\u0456\\u0434\\u043C\\u0456\\u0447\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u043E \\u044F\\u043A \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435\\n                    marks[edge.ind] = 1;\\n                    // * \\u043F\\u0435\\u0440\\u0435\\u0444\\u0430\\u0440\\u0431\\u043E\\u0432\\u0443\\u0454\\u043C\\u043E \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0438\\n                    int c = colors[edge.b];\\n                    for(int i = 0; i < n; ++i) \\n                        if(colors[i] == c) colors[i] = colors[edge.a];\\n                    // * \\u0448\\u0443\\u043A\\u0430\\u0442\\u0438 \\u0437\\u0430\\u043B\\u0438\\u0448\\u0438\\u043B\\u043E\\u0441\\u044C \\u043D\\u0430 \\u043E\\u0434\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u043C\\u0435\\u043D\\u0448\\u0435\\n                    --to_find;\\n                    // * \\u043F\\u0440\\u043E\\u0434\\u043E\\u0432\\u0436\\u0443\\u0454\\u043C\\u043E\\n                    continue;\\n                }\\n                // \\u042F\\u043A\\u0449\\u043E \\u0436 \\u0446\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u0443\\u0442\\u0432\\u043E\\u0440\\u0438\\u043B\\u043E \\u0446\\u0438\\u043A\\u043B:\\n                vector<bool> has_prev(n);\\n                vector<RevEdge> prev(n);\\n                queue<int> nodes;\\n                nodes.push(edge.a);\\n                has_prev[edge.a] = true;\\n                // * \\u0448\\u0443\\u043A\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0446\\u0438\\u043A\\u043B\\u0430\\n                while(!nodes.empty() && !has_prev[edge.b]) {\\n                    int node = nodes.front();\\n                    nodes.pop();\\n                    for(Edge conn : connections[node]) {\\n                        if(has_prev[conn.b]) continue;\\n                        has_prev[conn.b] = true;\\n                        prev[conn.b].from = node;\\n                        prev[conn.b].ind = conn.ind;\\n                        if(has_prev[edge.b]) break;\\n                        nodes.push(conn.b);\\n                    }\\n                }\\n                int node = edge.b;\\n                bool alone = true;\\n                // * \\u0448\\u0443\\u043A\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0456 \\u0432\\u0430\\u0433\\u0430 \\u044F\\u043A\\u0438\\u0445 \\u0434\\u043E\\u0440\\u0456\\u0432\\u043D\\u044E\\u0454\\n                //   \\u0432\\u0430\\u0437\\u0456 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u0433\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430\\n                while(node != edge.a) {\\n                    if(edges[prev[node].ind][2] == w) {\\n                        // * \\u0432\\u0441\\u0456 \\u0442\\u0430\\u043A\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430 - \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0456\\n                        marks[prev[node].ind] = 2;\\n                        alone = false;\\n                    }\\n                    node = prev[node].from;\\n                }\\n                // * \\u0432\\u0438\\u0439\\u043D\\u044F\\u0442\\u043E\\u043A: \\u044F\\u043A\\u0449\\u043E \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E - \\u043D\\u0430\\u0439\\u0432\\u0430\\u0436\\u0447\\u0435 \\u0432\\n                // \\u0446\\u0438\\u043A\\u043B\\u0456 - \\u0432\\u043E\\u043D\\u043E \\u043D\\u0435 \\u0437\\u043C\\u043E\\u0436\\u0435 \\u0431\\u0443\\u0442\\u0438 \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0438\\u043C\\n                if(!alone) marks[edge.ind] = 2;\\n            }\\n        }\\n\\n        // \\u0411\\u0443\\u0434\\u0443\\u0454\\u043C\\u043E \\u0442\\u0430 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u044C \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u043D\\u043E \\u0434\\u043E \\u0443\\u043C\\u043E\\u0432\\u0438.\\n        vector<int> C, NC;\\n        for(int i = 0; i < m; ++i)\\n            if(marks[i] == 1) C.push_back(i);\\n            else if(marks[i] == 2) NC.push_back(i);\\n        // \\u041C\\u0443\\u0432 \\u0441\\u0435\\u043C\\u0430\\u043D\\u0442\\u0438\\u043A\\u0430!\\n        return {move(C), move(NC)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// \\u0417\\u0440\\u0443\\u0447\\u043D\\u0430 \\u0441\\u0442\\u0440\\u0443\\u043A\\u0442\\u0443\\u0440\\u0430 \\u0434\\u043B\\u044F \\u0440\\u043E\\u0431\\u043E\\u0442\\u0438 \\u0437 \\u043F\\u043E\\u0442\\u043E\\u043A\\u043E\\u043C \\u0440\\u0435\\u0431\\u0435\\u0440\\nstruct Edge {\\n    int a, b, ind;\\n};\\n\\n\\n// \\u0421\\u0442\\u0440\\u0443\\u043A\\u0442\\u0443\\u0440\\u0430 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0448\\u0443\\u043A\\u0443 \\u0446\\u0438\\u043A\\u043B\\u0456\\u0432\\nstruct RevEdge {\\n    int from, ind;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = edges.size();\\n\\n        // \\u041C\\u0430\\u043F\\u0430 \\u0432\\u0456\\u0434\\u0441\\u043E\\u0440\\u0442\\u0443\\u0454 \\u0442\\u0430 \\u043E\\u0440\\u0433\\u0430\\u043D\\u0456\\u0437\\u0443\\u0454 \\u0434\\u043B\\u044F \\u043D\\u0430\\u0441 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430\\n        map<int, vector<Edge>> sorted_edges;\\n        for(int i = 0; i < m; ++i) {\\n            sorted_edges[edges[i][2]].push_back({edges[i][0], edges[i][1], i});\\n        }\\n\\n        // \\u041C\\u0456\\u0442\\u043A\\u0438 \\u0440\\u0435\\u0431\\u0435\\u0440:\\n        // 0 - \\u0431\\u0430\\u0437\\u043E\\u0432\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\\n        // 1 - \\u043A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E\\n        // 2 - \\u043F\\u0441\\u0435\\u0432\\u0434\\u043E \\u043A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E\\n        vector<int> marks(m);\\n\\n        // \\u041A\\u043E\\u043B\\u044C\\u043E\\u0440\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\n        vector<int> colors(n);\\n        for(int i = 0; i < n; ++i) colors[i] = i;\\n\\n        // \\u0421\\u043A\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u043D\\u0430\\u043C \\u0449\\u0435 \\u0442\\u0440\\u0435\\u0431\\u0430 \\u0437\\u043D\\u0430\\u0439\\u0442\\u0438?\\n        int to_find = n - 1;\\n\\n        // \\u0420\\u0435\\u0431\\u0440\\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430 \\u044F\\u043A\\u0456 \\u0432\\u0438\\u0445\\u043E\\u0434\\u044F\\u0442\\u044C \\u0437 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0438 \\u0437\\u0430 \\u0456\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C\\n        vector<vector<Edge>> connections(n);\\n        for(const auto &edge_pair : sorted_edges) {\\n            // \\u041A\\u043E\\u0436\\u0435\\u043D \\u0440\\u0430\\u0437 \\u043A\\u043E\\u043B\\u0438 \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0454\\u0442\\u044C\\u0441\\u044F \\u0437\\u043E\\u0432\\u043D\\u0456\\u0448\\u043D\\u0456\\u0439 \\u0446\\u0438\\u043A\\u043B - \\u043C\\u0438\\n            // \\u043F\\u043E\\u0447\\u0438\\u043D\\u0430\\u0454\\u043C\\u043E \\u0440\\u043E\\u0437\\u0433\\u043B\\u044F\\u0434\\u0430\\u0442\\u0438 \\u043D\\u0430\\u0431\\u0456\\u0440 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0437 \\u0431\\u0456\\u043B\\u044C\\u0448\\u043E\\u044E \\u0432\\u0430\\u0433\\u043E\\u044E.\\n            // \\u042F\\u043A\\u0449\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u0432\\u0436\\u0435 \\u043F\\u043E\\u0431\\u0443\\u0434\\u0430\\u0432\\u043D\\u0435 - \\u0457\\u0445 \\u0440\\u043E\\u0437\\u0433\\u043B\\u044F\\u0434\\u0430\\u0442\\u0438 \\u0432\\u0436\\u0435 \\u043D\\u0435\\n            // \\u0442\\u0440\\u0435\\u0431\\u0430.\\n            if(to_find == 0) break;\\n            // \\u041F\\u043E\\u0442\\u043E\\u0447\\u043D\\u0430 \\u0432\\u0430\\u0433\\u0430 \\u0440\\u0435\\u0431\\u0435\\u0440. \\u0412\\u043E\\u043D\\u0430 \\u0443 \\u0432\\u0441\\u0456\\u0445 \\u0440\\u0435\\u0431\\u0435\\u0440 \\u043E\\u0434\\u043D\\u0430\\u043A\\u043E\\u0432\\u0430.\\n            int w = edge_pair.first;\\n            // \\u0421\\u043F\\u0438\\u0441\\u043E\\u043A \\u0440\\u0435\\u0431\\u0435\\u0440 \\u0437 \\u0446\\u0456\\u0454\\u044E \\u0432\\u0430\\u0433\\u043E\\u044E.\\n            const vector<Edge> &list = edge_pair.second;\\n            for(const auto &edge : list) {\\n                if(colors[edge.a] != colors[edge.b]) {\\n                    // \\u042F\\u043A\\u0449\\u043E \\u043A\\u043E\\u043B\\u044C\\u043E\\u0440\\u0438 \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D \\u0440\\u0456\\u0437\\u043D\\u0456:\\n                    // * \\u0434\\u043E\\u0434\\u0430\\u0454\\u043C\\u043E \\u0434\\u043E \\u0448\\u0443\\u043A\\u0430\\u043D\\u043E\\u0433\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u0430\\n                    connections[edge.a].push_back(edge);\\n                    connections[edge.b].push_back({edge.b, edge.a, edge.ind});\\n                    // * \\u0432\\u0456\\u0434\\u043C\\u0456\\u0447\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u043E \\u044F\\u043A \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0435\\n                    marks[edge.ind] = 1;\\n                    // * \\u043F\\u0435\\u0440\\u0435\\u0444\\u0430\\u0440\\u0431\\u043E\\u0432\\u0443\\u0454\\u043C\\u043E \\u0432\\u0435\\u0440\\u0448\\u0438\\u043D\\u0438\\n                    int c = colors[edge.b];\\n                    for(int i = 0; i < n; ++i) \\n                        if(colors[i] == c) colors[i] = colors[edge.a];\\n                    // * \\u0448\\u0443\\u043A\\u0430\\u0442\\u0438 \\u0437\\u0430\\u043B\\u0438\\u0448\\u0438\\u043B\\u043E\\u0441\\u044C \\u043D\\u0430 \\u043E\\u0434\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u043C\\u0435\\u043D\\u0448\\u0435\\n                    --to_find;\\n                    // * \\u043F\\u0440\\u043E\\u0434\\u043E\\u0432\\u0436\\u0443\\u0454\\u043C\\u043E\\n                    continue;\\n                }\\n                // \\u042F\\u043A\\u0449\\u043E \\u0436 \\u0446\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E \\u0443\\u0442\\u0432\\u043E\\u0440\\u0438\\u043B\\u043E \\u0446\\u0438\\u043A\\u043B:\\n                vector<bool> has_prev(n);\\n                vector<RevEdge> prev(n);\\n                queue<int> nodes;\\n                nodes.push(edge.a);\\n                has_prev[edge.a] = true;\\n                // * \\u0448\\u0443\\u043A\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0446\\u0438\\u043A\\u043B\\u0430\\n                while(!nodes.empty() && !has_prev[edge.b]) {\\n                    int node = nodes.front();\\n                    nodes.pop();\\n                    for(Edge conn : connections[node]) {\\n                        if(has_prev[conn.b]) continue;\\n                        has_prev[conn.b] = true;\\n                        prev[conn.b].from = node;\\n                        prev[conn.b].ind = conn.ind;\\n                        if(has_prev[edge.b]) break;\\n                        nodes.push(conn.b);\\n                    }\\n                }\\n                int node = edge.b;\\n                bool alone = true;\\n                // * \\u0448\\u0443\\u043A\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430 \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0456 \\u0432\\u0430\\u0433\\u0430 \\u044F\\u043A\\u0438\\u0445 \\u0434\\u043E\\u0440\\u0456\\u0432\\u043D\\u044E\\u0454\\n                //   \\u0432\\u0430\\u0437\\u0456 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u0433\\u043E \\u0440\\u0435\\u0431\\u0440\\u0430\\n                while(node != edge.a) {\\n                    if(edges[prev[node].ind][2] == w) {\\n                        // * \\u0432\\u0441\\u0456 \\u0442\\u0430\\u043A\\u0456 \\u0440\\u0435\\u0431\\u0440\\u0430 - \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0456\\n                        marks[prev[node].ind] = 2;\\n                        alone = false;\\n                    }\\n                    node = prev[node].from;\\n                }\\n                // * \\u0432\\u0438\\u0439\\u043D\\u044F\\u0442\\u043E\\u043A: \\u044F\\u043A\\u0449\\u043E \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u0435 \\u0440\\u0435\\u0431\\u0440\\u043E - \\u043D\\u0430\\u0439\\u0432\\u0430\\u0436\\u0447\\u0435 \\u0432\\n                // \\u0446\\u0438\\u043A\\u043B\\u0456 - \\u0432\\u043E\\u043D\\u043E \\u043D\\u0435 \\u0437\\u043C\\u043E\\u0436\\u0435 \\u0431\\u0443\\u0442\\u0438 \\u041F\\u0441\\u0435\\u0432\\u0434\\u043E \\u041A\\u0440\\u0438\\u0442\\u0438\\u0447\\u043D\\u0438\\u043C\\n                if(!alone) marks[edge.ind] = 2;\\n            }\\n        }\\n\\n        // \\u0411\\u0443\\u0434\\u0443\\u0454\\u043C\\u043E \\u0442\\u0430 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u044C \\u0432\\u0456\\u0434\\u043F\\u043E\\u0432\\u0456\\u0434\\u043D\\u043E \\u0434\\u043E \\u0443\\u043C\\u043E\\u0432\\u0438.\\n        vector<int> C, NC;\\n        for(int i = 0; i < m; ++i)\\n            if(marks[i] == 1) C.push_back(i);\\n            else if(marks[i] == 2) NC.push_back(i);\\n        // \\u041C\\u0443\\u0432 \\u0441\\u0435\\u043C\\u0430\\u043D\\u0442\\u0438\\u043A\\u0430!\\n        return {move(C), move(NC)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933550,
                "title": "simple-and-clear-c-solution",
                "content": "# Prerequisite\\n- Union-find data structure\\n- Kruskal\\'s algorithm\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEdge Type | Relation b/w MST<sub>force</sub>(MST weight with edge forced) and MST<sub>ignore</sub>(MST weight edge ingnored)\\n--- | ---\\nCritical | MST<sub>force</sub> < MST<sub>ignore</sub>\\nPseudo-Critical | MST<sub>force</sub> = MST<sub>ignore</sub>\\nNon-Critical | MST<sub>force</sub> > MST<sub>ignore</sub>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse modified Kruskal\\'s Algorithm to find MST<sub>force</sub> and MST<sub>ignore</sub> for each edge and build up the answer according to the above intuition.\\n\\n# Complexity\\n- Time complexity: $$O(mlogm + m^2)$$, where $$m$$ is the number of edges.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m+n)$$, where $$n$$ is the number of nodes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &par) {\\n        if(par[x]==x) {\\n            return x;\\n        }\\n        return par[x]=find(par[x],par);\\n    }\\n    int MST(int n,int m,bool taken,int ind,vector<vector<int>> &e) {\\n        int res=0,cnt=0;\\n        vector<int> par(n);\\n        for(int i=0;i<n;i++) {\\n            par[i]=i;\\n        }\\n        if(taken) {\\n            par[e[ind][3]]=e[ind][2];\\n            res+=e[ind][0];\\n            cnt++;\\n        }\\n        for(int i=0;i<m;i++) {\\n            if(i==ind) {\\n                continue;\\n            }\\n            int pu=find(e[i][2],par),pv=find(e[i][3],par);\\n            if(pu!=pv) {\\n                par[pv]=pu;\\n                res+=e[i][0];\\n                cnt++;\\n            }\\n        }\\n        return (cnt==n-1?res:INT_MAX);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,vector<vector<int>> &edges) {\\n        int m=edges.size();\\n        vector<vector<int>> e(m);\\n        for(int i=0;i<m;i++) {\\n            e[i]={edges[i][2],i,edges[i][0],edges[i][1]};\\n        }\\n        sort(e.begin(),e.end());\\n        vector<vector<int>> ans(2);\\n        for(int i=0;i<m;i++) {\\n            int takenWeight=MST(n,m,true,i,e),notTakenWeight=MST(n,m,false,i,e);\\n            if(notTakenWeight>takenWeight) {\\n                ans[0].push_back(e[i][1]);\\n            }\\n            else if(notTakenWeight==takenWeight) {\\n                ans[1].push_back(e[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &par) {\\n        if(par[x]==x) {\\n            return x;\\n        }\\n        return par[x]=find(par[x],par);\\n    }\\n    int MST(int n,int m,bool taken,int ind,vector<vector<int>> &e) {\\n        int res=0,cnt=0;\\n        vector<int> par(n);\\n        for(int i=0;i<n;i++) {\\n            par[i]=i;\\n        }\\n        if(taken) {\\n            par[e[ind][3]]=e[ind][2];\\n            res+=e[ind][0];\\n            cnt++;\\n        }\\n        for(int i=0;i<m;i++) {\\n            if(i==ind) {\\n                continue;\\n            }\\n            int pu=find(e[i][2],par),pv=find(e[i][3],par);\\n            if(pu!=pv) {\\n                par[pv]=pu;\\n                res+=e[i][0];\\n                cnt++;\\n            }\\n        }\\n        return (cnt==n-1?res:INT_MAX);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,vector<vector<int>> &edges) {\\n        int m=edges.size();\\n        vector<vector<int>> e(m);\\n        for(int i=0;i<m;i++) {\\n            e[i]={edges[i][2],i,edges[i][0],edges[i][1]};\\n        }\\n        sort(e.begin(),e.end());\\n        vector<vector<int>> ans(2);\\n        for(int i=0;i<m;i++) {\\n            int takenWeight=MST(n,m,true,i,e),notTakenWeight=MST(n,m,false,i,e);\\n            if(notTakenWeight>takenWeight) {\\n                ans[0].push_back(e[i][1]);\\n            }\\n            else if(notTakenWeight==takenWeight) {\\n                ans[1].push_back(e[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933170,
                "title": "c-clean-implementation-clear-short-explanation-no-crap-solution",
                "content": "# Starting\\n###### You must first sort the given list of edges on the basis of weight. I did so by making first element in vector as weight, and added the index of the edge at end of each vector.\\n``` C++ []\\n//GENERATE SORTED LIST\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            edges[i][0]=w,\\n            edges[i][1]=u,\\n            edges[i][2]=v,\\n            edges[i].push_back(i);\\n        }\\n        sort(begin(edges),end(edges));\\n\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n###### Basically, It is literally just a Kruskal question. Find original MST\\'s cost for graph. Then for each edge run Kruskal\\'s Algo.\\n1) You must either **skip edge** and check if the cost of tree increases. If tree cannot form or cost increases then <b>edge is critical</b>\\n2) You must make **sure to include the edge** and check if cost of tree is same as original Kruskal Tree\\'s cost. If yes then edge can replace another edge and is a <b>pseudo-critical edge.</b>\\n# Complexity\\n- Time complexity: $O(E^2V)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(V)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int components,n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int find_parent(int u){\\n        int org=u;\\n        //find parent of u, store in u\\n        while(parent[u]!=u){\\n            u=parent[u];\\n        }\\n        //Path compression - Optional\\n        while(parent[org]!=u){\\n            int next=parent[org];\\n            parent[org]=u;\\n            org=next;\\n        }\\n        return u;\\n    }\\n    void union_func(int u,int v){\\n        int u_parent=find_parent(u);\\n        int v_parent=find_parent(v);\\n        if(u==v) return;\\n        if(size[u_parent]>size[v_parent]){\\n            parent[v_parent]=u_parent;\\n            size[u_parent]+=size[v_parent];\\n        }\\n        else {\\n            parent[u_parent]=v_parent;\\n            size[v_parent]+=size[u_parent];\\n        }\\n        components--;\\n    }\\n    int Kruskal_MST(vector<vector<int>>&edges,int skip,int include){\\n        components=n;\\n        parent.resize(n),size.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i,size[i]=1;\\n\\n        int mst_weight=0;\\n        if(include!=-1){\\n            mst_weight+=edges[include][0];\\n            union_func(edges[include][1],edges[include][2]);\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(i==skip) continue;\\n            int w=edges[i][0],u=edges[i][1],v=edges[i][2],ind=edges[i][3];\\n            if(find_parent(u)==find_parent(v)) continue;\\n            else {\\n                mst_weight+=w;\\n                union_func(u,v);\\n            }\\n        }\\n        return components!=1?INT_MAX:mst_weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2,vector<int>());\\n        this->n=n;\\n        //GENERATE SORTED LIST\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            edges[i][0]=w,\\n            edges[i][1]=u,\\n            edges[i][2]=v,\\n            edges[i].push_back(i);\\n        }\\n        sort(begin(edges),end(edges));\\n\\n        //FIND TRUE KRUSKAL WT\\n        int krusk_min_weight=Kruskal_MST(edges,-1,-1);\\n\\n        //TEST ALL EDGES\\n        for(int i=0;i<edges.size();i++) {\\n            //critical - IF SKIP EDGE, WT INCREASE\\n            //pscritical - IF INCLUDED EDGE, WT SAME\\n            int skip_edge_wt=Kruskal_MST(edges,i,-1); \\n            int include_edge_wt=Kruskal_MST(edges,-1,i);\\n            if(skip_edge_wt>krusk_min_weight)\\n                ans[0].push_back(edges[i][3]);\\n            else if(include_edge_wt==krusk_min_weight)\\n                ans[1].push_back(edges[i][3]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "``` C++ []\\n//GENERATE SORTED LIST\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            edges[i][0]=w,\\n            edges[i][1]=u,\\n            edges[i][2]=v,\\n            edges[i].push_back(i);\\n        }\\n        sort(begin(edges),end(edges));\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int components,n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int find_parent(int u){\\n        int org=u;\\n        //find parent of u, store in u\\n        while(parent[u]!=u){\\n            u=parent[u];\\n        }\\n        //Path compression - Optional\\n        while(parent[org]!=u){\\n            int next=parent[org];\\n            parent[org]=u;\\n            org=next;\\n        }\\n        return u;\\n    }\\n    void union_func(int u,int v){\\n        int u_parent=find_parent(u);\\n        int v_parent=find_parent(v);\\n        if(u==v) return;\\n        if(size[u_parent]>size[v_parent]){\\n            parent[v_parent]=u_parent;\\n            size[u_parent]+=size[v_parent];\\n        }\\n        else {\\n            parent[u_parent]=v_parent;\\n            size[v_parent]+=size[u_parent];\\n        }\\n        components--;\\n    }\\n    int Kruskal_MST(vector<vector<int>>&edges,int skip,int include){\\n        components=n;\\n        parent.resize(n),size.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i,size[i]=1;\\n\\n        int mst_weight=0;\\n        if(include!=-1){\\n            mst_weight+=edges[include][0];\\n            union_func(edges[include][1],edges[include][2]);\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(i==skip) continue;\\n            int w=edges[i][0],u=edges[i][1],v=edges[i][2],ind=edges[i][3];\\n            if(find_parent(u)==find_parent(v)) continue;\\n            else {\\n                mst_weight+=w;\\n                union_func(u,v);\\n            }\\n        }\\n        return components!=1?INT_MAX:mst_weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2,vector<int>());\\n        this->n=n;\\n        //GENERATE SORTED LIST\\n        for(int i=0;i<edges.size();i++){\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            edges[i][0]=w,\\n            edges[i][1]=u,\\n            edges[i][2]=v,\\n            edges[i].push_back(i);\\n        }\\n        sort(begin(edges),end(edges));\\n\\n        //FIND TRUE KRUSKAL WT\\n        int krusk_min_weight=Kruskal_MST(edges,-1,-1);\\n\\n        //TEST ALL EDGES\\n        for(int i=0;i<edges.size();i++) {\\n            //critical - IF SKIP EDGE, WT INCREASE\\n            //pscritical - IF INCLUDED EDGE, WT SAME\\n            int skip_edge_wt=Kruskal_MST(edges,i,-1); \\n            int include_edge_wt=Kruskal_MST(edges,-1,i);\\n            if(skip_edge_wt>krusk_min_weight)\\n                ans[0].push_back(edges[i][3]);\\n            else if(include_edge_wt==krusk_min_weight)\\n                ans[1].push_back(edges[i][3]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932132,
                "title": "faster-94-5-easy-to-understand-dsu-kruskal-with-comment",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n<!-- > **Please do UpVote** it took lot of time to figure out these solutions -->\\n\\n# Complexity \\n- Time complexity: $$O(M*logM)$$ where `M = no of edges` \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass DSU{\\n    int n;\\n    vector<int> par, size;\\npublic:\\n    DSU(int n){\\n        this->n = n;\\n        par.resize(n+1, -1);\\n        size.resize(n+1, 1);\\n    }\\n\\n    int findPar(int u){\\n        return par[u] == -1 ? u : par[u] = findPar(par[u]);\\n    }\\n\\n    bool unite(int u, int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if( u == v ) return false;\\n        if( size[u] > size[v] ) swap(u, v);\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    int minWtKruskal(int n, vector<vector<int>> &edges, vector<int> include, vector<int> exclude){\\n        int mstWt = 0;\\n        DSU dsu(n);\\n\\n        if( include.size() ){\\n            // MST must contain include this edge\\n            dsu.unite(include[0], include[1]);\\n            mstWt += include[2];\\n        }\\n\\n        for(auto &e : edges){\\n            int wt = e[0], u = e[1], v = e[2];\\n            if( exclude.size() && u == exclude[0] && v == exclude[1] ){\\n                // MST must not contain exclude edge\\n                continue;\\n            }\\n            \\n            // Take the current edge in MST if it doesn\\'t form a cycle\\n            if( dsu.findPar(u) != dsu.findPar(v) ){\\n                mstWt +=  wt;\\n                dsu.unite(u, v);\\n            }\\n        }\\n        return mstWt;\\n    }\\n\\n\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& es) {\\n        vector<vector<int>> edges;\\n        vector<vector<int>> ans(2);\\n\\n        for(auto &e : es) edges.push_back({e[2], e[0], e[1]});\\n        sort(edges.begin(), edges.end());\\n\\n        int minWt = minWtKruskal(n, edges, {}, {});\\n\\n        for(int i=0; i<es.size(); i++){\\n            int minWt2 = minWtKruskal(n, edges, {}, es[i]);\\n\\n            if( minWt2 != minWt ){\\n                // Found Critical edge\\n                ans[0].push_back(i);\\n            }else if( minWtKruskal(n, edges, es[i], {}) == minWt ){\\n                // Found Pseudo-critical edge\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<!-- ---\\n\\n# Java Code\\n```\\n\\n``` -->\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass DSU{\\n    int n;\\n    vector<int> par, size;\\npublic:\\n    DSU(int n){\\n        this->n = n;\\n        par.resize(n+1, -1);\\n        size.resize(n+1, 1);\\n    }\\n\\n    int findPar(int u){\\n        return par[u] == -1 ? u : par[u] = findPar(par[u]);\\n    }\\n\\n    bool unite(int u, int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if( u == v ) return false;\\n        if( size[u] > size[v] ) swap(u, v);\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    int minWtKruskal(int n, vector<vector<int>> &edges, vector<int> include, vector<int> exclude){\\n        int mstWt = 0;\\n        DSU dsu(n);\\n\\n        if( include.size() ){\\n            // MST must contain include this edge\\n            dsu.unite(include[0], include[1]);\\n            mstWt += include[2];\\n        }\\n\\n        for(auto &e : edges){\\n            int wt = e[0], u = e[1], v = e[2];\\n            if( exclude.size() && u == exclude[0] && v == exclude[1] ){\\n                // MST must not contain exclude edge\\n                continue;\\n            }\\n            \\n            // Take the current edge in MST if it doesn\\'t form a cycle\\n            if( dsu.findPar(u) != dsu.findPar(v) ){\\n                mstWt +=  wt;\\n                dsu.unite(u, v);\\n            }\\n        }\\n        return mstWt;\\n    }\\n\\n\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& es) {\\n        vector<vector<int>> edges;\\n        vector<vector<int>> ans(2);\\n\\n        for(auto &e : es) edges.push_back({e[2], e[0], e[1]});\\n        sort(edges.begin(), edges.end());\\n\\n        int minWt = minWtKruskal(n, edges, {}, {});\\n\\n        for(int i=0; i<es.size(); i++){\\n            int minWt2 = minWtKruskal(n, edges, {}, es[i]);\\n\\n            if( minWt2 != minWt ){\\n                // Found Critical edge\\n                ans[0].push_back(i);\\n            }else if( minWtKruskal(n, edges, es[i], {}) == minWt ){\\n                // Found Pseudo-critical edge\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931818,
                "title": "golang-kruskal-algorithm",
                "content": "# Complexity\\n- Time complexity:\\nO(mlogm) + O(m * (n+m)) = O(mlogm + m*m + m*n) = O(m^2)\\n\\n- Space complexity:\\nO(m), for storing index\\n\\n# Code\\n```\\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\\n    m := len(edges)\\n\\n    // Append index, since we are reordering/sorting, O(m)\\n    for i := 0; i < m; i++ {\\n        edges[i] = append(edges[i], i)\\n    }\\n\\n    // Sort according to weights, O(mlogm)\\n    sort.Slice(edges, func (i, j int) bool {\\n        return edges[i][2] < edges[j][2]\\n    })\\n\\n    // O(n + m)\\n    mstWeight, _ := Kruskal(n, -1, -1, edges)\\n    result := make([][]int, 2)\\n\\n    // O(m * ((n + m) + (n + m))) -> O(m * (n + m))\\n    for i := 0; i < m; i++ {\\n        // O(n + m)\\n        weight, size := Kruskal(n, i, -1, edges)\\n\\n        if weight > mstWeight || size < n {\\n            result[0] = append(result[0], edges[i][3])\\n        } else {\\n            // Check for Pseudo Critical\\n            // O(n + m)\\n            weight, size = Kruskal(n, -1, i, edges)\\n\\n            // Pseudo Critical\\n            if weight == mstWeight && size == n {\\n                result[1] = append(result[1], edges[i][3])\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n// O(n + m)\\nfunc Kruskal(n, ignoreIdx, forceIdx int, edges [][]int) (int, int) {\\n    m := len(edges)\\n    weight := 0\\n    uf := NewUnionFind(n) // O(n)\\n\\n    if forceIdx != -1 {\\n        uf.Union(edges[forceIdx][0], edges[forceIdx][1])\\n        weight += edges[forceIdx][2]\\n    }\\n\\n    // O(m), union is O(1)\\n    for i := 0; i < m; i++ {\\n        if i == ignoreIdx || i == forceIdx {\\n            continue\\n        }\\n\\n        if uf.Union(edges[i][0], edges[i][1]) {\\n            weight += edges[i][2]\\n        }\\n    }\\n\\n    return weight, uf.MaxSize\\n}\\n\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n    MaxSize int\\n}\\n\\n// O(n)\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n\\n    for i := 0; i < n; i++ {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n\\n    return &UnionFind{\\n        parents : parents,\\n        size : size, \\n    }\\n}\\n\\n// O(1)\\nfunc (uf *UnionFind) Union(i, j int) bool {\\n    p1 := uf.FindParent(i)\\n    p2 := uf.FindParent(j)\\n\\n    if p1 == p2 {\\n        return false\\n    }\\n\\n    if uf.size[p1] < uf.size[p2] {\\n        p1, p2 = p2, p1\\n    }\\n\\n    uf.parents[p2] = p1\\n    uf.size[p1] += uf.size[p2]\\n    uf.MaxSize = max(uf.MaxSize, uf.size[p1])\\n\\n    return true\\n}\\n\\n// O(1)\\nfunc (uf *UnionFind) FindParent(i int) int {\\n    if i != uf.parents[i] {\\n        uf.parents[i] = uf.FindParent(uf.parents[i])\\n    }\\n    return uf.parents[i]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\\n    m := len(edges)\\n\\n    // Append index, since we are reordering/sorting, O(m)\\n    for i := 0; i < m; i++ {\\n        edges[i] = append(edges[i], i)\\n    }\\n\\n    // Sort according to weights, O(mlogm)\\n    sort.Slice(edges, func (i, j int) bool {\\n        return edges[i][2] < edges[j][2]\\n    })\\n\\n    // O(n + m)\\n    mstWeight, _ := Kruskal(n, -1, -1, edges)\\n    result := make([][]int, 2)\\n\\n    // O(m * ((n + m) + (n + m))) -> O(m * (n + m))\\n    for i := 0; i < m; i++ {\\n        // O(n + m)\\n        weight, size := Kruskal(n, i, -1, edges)\\n\\n        if weight > mstWeight || size < n {\\n            result[0] = append(result[0], edges[i][3])\\n        } else {\\n            // Check for Pseudo Critical\\n            // O(n + m)\\n            weight, size = Kruskal(n, -1, i, edges)\\n\\n            // Pseudo Critical\\n            if weight == mstWeight && size == n {\\n                result[1] = append(result[1], edges[i][3])\\n            }\\n        }\\n    }\\n\\n    return result\\n}\\n\\n// O(n + m)\\nfunc Kruskal(n, ignoreIdx, forceIdx int, edges [][]int) (int, int) {\\n    m := len(edges)\\n    weight := 0\\n    uf := NewUnionFind(n) // O(n)\\n\\n    if forceIdx != -1 {\\n        uf.Union(edges[forceIdx][0], edges[forceIdx][1])\\n        weight += edges[forceIdx][2]\\n    }\\n\\n    // O(m), union is O(1)\\n    for i := 0; i < m; i++ {\\n        if i == ignoreIdx || i == forceIdx {\\n            continue\\n        }\\n\\n        if uf.Union(edges[i][0], edges[i][1]) {\\n            weight += edges[i][2]\\n        }\\n    }\\n\\n    return weight, uf.MaxSize\\n}\\n\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n    MaxSize int\\n}\\n\\n// O(n)\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n\\n    for i := 0; i < n; i++ {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n\\n    return &UnionFind{\\n        parents : parents,\\n        size : size, \\n    }\\n}\\n\\n// O(1)\\nfunc (uf *UnionFind) Union(i, j int) bool {\\n    p1 := uf.FindParent(i)\\n    p2 := uf.FindParent(j)\\n\\n    if p1 == p2 {\\n        return false\\n    }\\n\\n    if uf.size[p1] < uf.size[p2] {\\n        p1, p2 = p2, p1\\n    }\\n\\n    uf.parents[p2] = p1\\n    uf.size[p1] += uf.size[p2]\\n    uf.MaxSize = max(uf.MaxSize, uf.size[p1])\\n\\n    return true\\n}\\n\\n// O(1)\\nfunc (uf *UnionFind) FindParent(i int) int {\\n    if i != uf.parents[i] {\\n        uf.parents[i] = uf.FindParent(uf.parents[i])\\n    }\\n    return uf.parents[i]\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931694,
                "title": "find-the-mst-and-compare-it-by-removing-the-edges",
                "content": "```\\nclass Solution {\\npublic:\\n    int N ;\\n    \\n    class UFC{\\n        public :\\n        vector<int > par;\\n        vector<int > rank;\\n        \\n        \\n        UFC(int n)\\n        {\\n            par.resize(n);\\n            rank.resize(n,0);\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                par[i] =i;\\n            }\\n        }\\n        \\n        int find(int x)\\n        {\\n            if(x == par[x])\\n                return x;\\n            return par[x] = find(par[x]);\\n        }\\n        \\n        \\n        bool uni(int x , int y)\\n        {\\n            int xp = find(x);\\n            int yp = find(y);\\n            \\n            if(xp == yp)\\n                return false;\\n            \\n            // cout<<xp<<\" \"<<yp<<endl;\\n            \\n            par[xp] = yp;\\n    \\n            return true;\\n            \\n        }\\n        \\n        \\n        \\n    };\\n    \\n    \\n    int krus( vector<vector<int>>& e , int sk , int inn)\\n    {\\n        UFC UF(N);\\n        int res = 0;\\n        if(inn != -1)\\n        {\\n            UF.uni(e[inn][0],e[inn][1]);\\n            res +=e[inn][2];\\n            \\n        }\\n        \\n        \\n       for(int i=0;i<e.size();i++){\\n           if(sk == i)\\n               continue;\\n            \\n            int u = e[i][0];\\n            int v = e[i][1];\\n            int w = e[i][2];\\n            \\n            int pu = UF.find(u);\\n            int pv = UF.find(v);\\n            if(pu != pv)\\n            {\\n                UF.uni(u,v);\\n                res +=w;\\n            }\\n        }\\n        \\n        for(int i=0;i<N;i++)\\n        {\\n            if(UF.find(i)!=UF.find(0))\\n                return INT_MAX;\\n        }\\n        return res;\\n    }\\n        \\n       \\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& e) {\\n        \\n        N = n;\\n        vector<int> c, pc;\\n        for(int i=0;i<e.size();i++)\\n        {\\n            e[i].push_back(i);\\n        }\\n        \\n        \\n        auto l = [&](vector<int> &v1, vector<int> &v2){\\n            return v1[2]<v2[2];\\n        };\\n        \\n        \\n        \\n        \\n        sort(e.begin(),e.end(),l);\\n        \\n        \\n        int wt  = krus(e,-1,-1);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            if(krus(e,i,-1)>wt)\\n            {\\n                c.push_back(e[i][3]);\\n            }\\n            else if(krus(e,-1,i) == wt)\\n            {\\n                pc.push_back(e[i][3]);\\n            }\\n        }\\n        \\n        return {c,pc};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N ;\\n    \\n    class UFC{\\n        public :\\n        vector<int > par;\\n        vector<int > rank;\\n        \\n        \\n        UFC(int n)\\n        {\\n            par.resize(n);\\n            rank.resize(n,0);\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                par[i] =i;\\n            }\\n        }\\n        \\n        int find(int x)\\n        {\\n            if(x == par[x])\\n                return x;\\n            return par[x] = find(par[x]);\\n        }\\n        \\n        \\n        bool uni(int x , int y)\\n        {\\n            int xp = find(x);\\n            int yp = find(y);\\n            \\n            if(xp == yp)\\n                return false;\\n            \\n            // cout<<xp<<\" \"<<yp<<endl;\\n            \\n            par[xp] = yp;\\n    \\n            return true;\\n            \\n        }\\n        \\n        \\n        \\n    };\\n    \\n    \\n    int krus( vector<vector<int>>& e , int sk , int inn)\\n    {\\n        UFC UF(N);\\n        int res = 0;\\n        if(inn != -1)\\n        {\\n            UF.uni(e[inn][0],e[inn][1]);\\n            res +=e[inn][2];\\n            \\n        }\\n        \\n        \\n       for(int i=0;i<e.size();i++){\\n           if(sk == i)\\n               continue;\\n            \\n            int u = e[i][0];\\n            int v = e[i][1];\\n            int w = e[i][2];\\n            \\n            int pu = UF.find(u);\\n            int pv = UF.find(v);\\n            if(pu != pv)\\n            {\\n                UF.uni(u,v);\\n                res +=w;\\n            }\\n        }\\n        \\n        for(int i=0;i<N;i++)\\n        {\\n            if(UF.find(i)!=UF.find(0))\\n                return INT_MAX;\\n        }\\n        return res;\\n    }\\n        \\n       \\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& e) {\\n        \\n        N = n;\\n        vector<int> c, pc;\\n        for(int i=0;i<e.size();i++)\\n        {\\n            e[i].push_back(i);\\n        }\\n        \\n        \\n        auto l = [&](vector<int> &v1, vector<int> &v2){\\n            return v1[2]<v2[2];\\n        };\\n        \\n        \\n        \\n        \\n        sort(e.begin(),e.end(),l);\\n        \\n        \\n        int wt  = krus(e,-1,-1);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            if(krus(e,i,-1)>wt)\\n            {\\n                c.push_back(e[i][3]);\\n            }\\n            else if(krus(e,-1,i) == wt)\\n            {\\n                pc.push_back(e[i][3]);\\n            }\\n        }\\n        \\n        return {c,pc};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3930836,
                "title": "rust-union-find-kruskal-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (mut s, mut t) = (HashSet::new(), HashSet::new());\\n        let (m, n) = (edges.len(), n as usize);\\n        let cost = Self::kruskal(&edges, m, m, n);\\n    \\n        for k in 0 .. edges.len() {\\n            if Self::kruskal(&edges, k, m, n) > cost { s.insert(k as i32); }\\n            if Self::kruskal(&edges, m, k, n) == cost { t.insert(k as i32); }\\n        }\\n        \\n        let mut ret = vec![vec![]; 2];\\n        for i in &t {\\n            if s.contains(i) == false { ret[1].push(*i); }\\n        }\\n        ret[0] = s.into_iter().collect::<Vec<_>>();\\n        \\n        ret\\n    }\\n\\n    fn find(p: &mut Vec<usize>, i: usize) -> usize {\\n        if p[i] == i { return i }\\n        p[i] = Self::find(p, p[i]);\\n        p[i]\\n    }\\n\\n    fn kruskal(edges: &Vec<Vec<i32>>, exclude: usize, include: usize, n: usize) -> i32 {\\n        let mut p = (0 .. n).into_iter().collect::<Vec<_>>();\\n        let mut edges = edges.clone();\\n        let (mut ret, mut cnt, m) = (0, 0, edges.len());\\n        \\n        if include < m {\\n            let (u, v) = (edges[include][0] as usize, edges[include][1] as usize);\\n            let (i, j) = (Self::find(&mut p, u), Self::find(&mut p, v));\\n            p[i] = j;\\n            cnt += 1;\\n            ret = edges[include][2];\\n        }\\n        if exclude.min(include) < m { edges.remove(exclude.min(include)); }\\n        edges.sort_by(|a, b| a[2].cmp(&b[2]));\\n\\n        for e in  edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            let (i, j) = (Self::find(&mut p, u), Self::find(&mut p, v));\\n            if i == j { continue }\\n            p[i] = j;\\n            cnt += 1;\\n            ret += e[2];            \\n        }\\n        \\n        if cnt + 1 < n { i32::MAX } else { ret }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (mut s, mut t) = (HashSet::new(), HashSet::new());\\n        let (m, n) = (edges.len(), n as usize);\\n        let cost = Self::kruskal(&edges, m, m, n);\\n    \\n        for k in 0 .. edges.len() {\\n            if Self::kruskal(&edges, k, m, n) > cost { s.insert(k as i32); }\\n            if Self::kruskal(&edges, m, k, n) == cost { t.insert(k as i32); }\\n        }\\n        \\n        let mut ret = vec![vec![]; 2];\\n        for i in &t {\\n            if s.contains(i) == false { ret[1].push(*i); }\\n        }\\n        ret[0] = s.into_iter().collect::<Vec<_>>();\\n        \\n        ret\\n    }\\n\\n    fn find(p: &mut Vec<usize>, i: usize) -> usize {\\n        if p[i] == i { return i }\\n        p[i] = Self::find(p, p[i]);\\n        p[i]\\n    }\\n\\n    fn kruskal(edges: &Vec<Vec<i32>>, exclude: usize, include: usize, n: usize) -> i32 {\\n        let mut p = (0 .. n).into_iter().collect::<Vec<_>>();\\n        let mut edges = edges.clone();\\n        let (mut ret, mut cnt, m) = (0, 0, edges.len());\\n        \\n        if include < m {\\n            let (u, v) = (edges[include][0] as usize, edges[include][1] as usize);\\n            let (i, j) = (Self::find(&mut p, u), Self::find(&mut p, v));\\n            p[i] = j;\\n            cnt += 1;\\n            ret = edges[include][2];\\n        }\\n        if exclude.min(include) < m { edges.remove(exclude.min(include)); }\\n        edges.sort_by(|a, b| a[2].cmp(&b[2]));\\n\\n        for e in  edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            let (i, j) = (Self::find(&mut p, u), Self::find(&mut p, v));\\n            if i == j { continue }\\n            p[i] = j;\\n            cnt += 1;\\n            ret += e[2];            \\n        }\\n        \\n        if cnt + 1 < n { i32::MAX } else { ret }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930405,
                "title": "kotlin-beats-100-runtime-and-memory-explanation",
                "content": "# Intuition\\nI thought of using Kruskal\\'s algorithm for finding the minimum spanning tree (MST) of the graph. \\n\\n# Approach\\n\\n- The function findParent is a recursive function that finds the parent of a node p in a disjoint-set data structure represented by an array parent. It uses path compression technique to optimize future lookups.\\n- The function union performs union operation on two nodes u and v in the disjoint-set data structure using their respective parents from parent.\\n- The function findCriticalAndPseudoCriticalEdges:\\n    -  initializes two empty lists - critical and pseudoCritical. \\n    - Modifies each edge by adding another element at index 3 to store its original index.\\n    - Sorts the modified edges array based on ascending order of weights.\\n    - Calculates MST weight without including any edge (block = -1) using initial call to findMST.\\n    - If MST weight is less than MST weight including all edges except one (e), adds that edge\\'s original index to list critical.\\n     - If MST weight is equal to MST weight excluding only one edge (e), adds that edge\\'s original index to list pseudoCritical.\\n     - Creates a new list called result, adds critical and pseudoCritical lists to it, and returns result.\\n- The  function findMST calculates the weight of the minimum spanning tree (MST) for a given graph represented by edges.\\n    - Initializes an array called parent with each vertex as its own parent.\\n    - If parameter e is not equal to -1, includes the edge at index e in the MST calculation by updating its weight and performing union operation on its vertices using union function.\\n    - Iterates through all edges in the graph except when an edge\\'s index matches the value of block:\\n        - If both vertices of an edge have different parents in disjoint-set data structure, performs union operation on them using union function and updates total weight.\\n        - Checks if any vertex has a different parent than vertex 0. If true, returns maximum integer value indicating that no MST was found.\\n    - Returns total weight, that helps to build up array of results\\n# Complexity\\n- Time complexity:\\n$$O((E + V) log V)$$ \\n- Space complexity:\\n$$O(V)$$\\n# Code\\n```\\nclass Solution {\\n    fun findParent(p: Int, parent: IntArray): Int =\\n        if (parent[p] == p) p else findParent(parent[p], parent).also { parent[p] = it }\\n\\n    fun union(u: Int, v: Int, parent: IntArray) {\\n        parent[findParent(u, parent)] = findParent(v, parent)\\n    }\\n\\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\\n        val critical: MutableList<Int> = ArrayList()\\n        val pseudoCritical: MutableList<Int> = ArrayList()\\n        for (i in edges.indices) {\\n            var edge = edges[i]\\n            edge = Arrays.copyOf(edge, edge.size + 1)\\n            edge[3] = i\\n            edges[i] = edge\\n        }\\n        Arrays.sort(edges) { a: IntArray, b: IntArray -> Integer.compare(a[2], b[2]) }\\n        val mstwt = findMST(n, edges, -1, -1)\\n        for (i in edges.indices)\\n            if (mstwt < findMST(n, edges, i, -1)) critical.add(edges[i][3]) else if (mstwt == findMST(n,edges,-1,i)\\n            ) pseudoCritical.add(edges[i][3])\\n\\n        val result: MutableList<List<Int>> = ArrayList()\\n        result.add(critical)\\n        result.add(pseudoCritical)\\n        return result\\n    }\\n\\n    private fun findMST(n: Int, edges: Array<IntArray>, block: Int, e: Int): Int {\\n        val parent = IntArray(n)\\n        for (i in 0 until n) parent[i] = i\\n        var weight = 0\\n        if (e != -1) {\\n            weight += edges[e][2]\\n            union(edges[e][0], edges[e][1], parent)\\n        }\\n        for (i in edges.indices) {\\n            if (i == block) continue\\n            if (findParent(edges[i][0], parent) == findParent(edges[i][1], parent)) continue\\n            union(edges[i][0], edges[i][1], parent)\\n            weight += edges[i][2]\\n        }\\n        for (i in 0 until n) if (findParent(i, parent) != findParent(0, parent)) return Int.MAX_VALUE\\n        return weight\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n    fun findParent(p: Int, parent: IntArray): Int =\\n        if (parent[p] == p) p else findParent(parent[p], parent).also { parent[p] = it }\\n\\n    fun union(u: Int, v: Int, parent: IntArray) {\\n        parent[findParent(u, parent)] = findParent(v, parent)\\n    }\\n\\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\\n        val critical: MutableList<Int> = ArrayList()\\n        val pseudoCritical: MutableList<Int> = ArrayList()\\n        for (i in edges.indices) {\\n            var edge = edges[i]\\n            edge = Arrays.copyOf(edge, edge.size + 1)\\n            edge[3] = i\\n            edges[i] = edge\\n        }\\n        Arrays.sort(edges) { a: IntArray, b: IntArray -> Integer.compare(a[2], b[2]) }\\n        val mstwt = findMST(n, edges, -1, -1)\\n        for (i in edges.indices)\\n            if (mstwt < findMST(n, edges, i, -1)) critical.add(edges[i][3]) else if (mstwt == findMST(n,edges,-1,i)\\n            ) pseudoCritical.add(edges[i][3])\\n\\n        val result: MutableList<List<Int>> = ArrayList()\\n        result.add(critical)\\n        result.add(pseudoCritical)\\n        return result\\n    }\\n\\n    private fun findMST(n: Int, edges: Array<IntArray>, block: Int, e: Int): Int {\\n        val parent = IntArray(n)\\n        for (i in 0 until n) parent[i] = i\\n        var weight = 0\\n        if (e != -1) {\\n            weight += edges[e][2]\\n            union(edges[e][0], edges[e][1], parent)\\n        }\\n        for (i in edges.indices) {\\n            if (i == block) continue\\n            if (findParent(edges[i][0], parent) == findParent(edges[i][1], parent)) continue\\n            union(edges[i][0], edges[i][1], parent)\\n            weight += edges[i][2]\\n        }\\n        for (i in 0 until n) if (findParent(i, parent) != findParent(0, parent)) return Int.MAX_VALUE\\n        return weight\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930310,
                "title": "python-3-beats-edirotial-in-time-two-criteria-o-e-2",
                "content": "# Intuition\\nWe need to find an approach to decide whether edge is critical, pseudo-critical or neither of them\\n\\n# Approach\\n1. According to Kruskal\\'s algorithm if edge is <ins>_unused_ AND _has minimum weight_ AND  _connects two disjoint sets_</ins> **[1]** then there is MST (or MSTs) which includes this edge (remember, graph might have several MSTs \\u2014 otherwise this problem wouldn\\'t make sense). Since this edge is a part of some MST then this edge is critical or pseudo-critical. So this step helps us to filter out all edges which are neither critical or pseudo-critical (they don\\'t satisfy criteria **[1]**)\\n2. It remains only to decide whether edge is critical or pseudo-critical for each edge which satisfies criteria **[1]**. And there is another nice criteria: the edge with weight $w$ which connects two disjoint sets $A$ and $B$ is pseudo-critical if and only if <ins>_there is another edge with the same weight $w$ which connects the same two disjoint sets $A$ and $B$_ OR _using other edges of weight $w$ it\\'s possible to connect $A$ and $B$_</ins> **[2]**. Actually the second condition includes the first one, but it\\'s easier to comperehend and implement it this way.\\n\\nTo sum up, \\n* If (criteria **[1]**):\\n  * if (criteria **[2]**):\\n    $\\\\rightarrow$ pseudo-critical\\n  * else:\\n    $\\\\rightarrow$ critical\\n* else:\\n  $\\\\rightarrow$ none\\n\\n# Complexity\\n- Time complexity: still $O(E^2)$ in the worst case (but actually works faster in average and at least beats editorial 92ms vs 1124ms)\\n\\n- Space complexity: $O(E)$\\n\\n# Code\\n```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.node2root = {i:i for i in range(n)}\\n        self.node2rank = {i:0 for i in range(n)}\\n    \\n    def find(self, node):\\n        if self.node2root[node] != node:\\n            self.node2root[node] = self.find(self.node2root[node])\\n        return self.node2root[node]\\n    \\n    def union(self, node1, node2):\\n        root1 = self.find(node1)\\n        root2 = self.find(node2)\\n        if root1 == root2:\\n            return False\\n        rank1 = self.node2rank[root1]\\n        rank2 = self.node2rank[root2]\\n        if rank1 <= rank2:\\n            self.node2root[root1] = root2\\n            self.node2rank[root2] += (rank1 == rank2)\\n        else:\\n            self.node2root[root2] = root1\\n        return True\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ds = DisjointSet(n)\\n        critical = []\\n        pseudo_critical = []\\n\\n        Edge = namedtuple(\\'Edge\\', [\\'ind\\', \\'src\\', \\'dst\\', \\'weight\\'])\\n        sorted_edges = [Edge(i, *edge) for i, edge in enumerate(edges)]\\n        sorted_edges.sort(key=lambda e: e.weight)\\n        for weight, same_weight_edges in itertools.groupby(sorted_edges, key=lambda e: e.weight):\\n            graph = defaultdict(set)\\n            etype2edges = defaultdict(list)\\n            for edge_ind, s, d, w in same_weight_edges:\\n                root1 = ds.find(s)\\n                root2 = ds.find(d)\\n                if root1 != root2:  # criteria 1\\n                    graph[root1].add(root2)\\n                    graph[root2].add(root1)\\n                    etype = f\\'{min(root1, root2)}<->{max(root1, root2)}\\'\\n                    etype2edges[etype].append(edge_ind)\\n            for etype, interchangeable_edges in etype2edges.items():\\n                root1, root2 = map(int, etype.split(\\'<->\\'))\\n                if len(interchangeable_edges) > 1 or self.edge_in_cycle(root1, root2, graph):  # criteria 2\\n                    for edge in interchangeable_edges:\\n                        pseudo_critical.append(edge)\\n                else:\\n                    critical.append(interchangeable_edges[0])\\n                ds.union(root1, root2)\\n        return [critical, pseudo_critical]\\n\\n    def edge_in_cycle(self, src, dst, graph):\\n        graph[src].remove(dst)\\n        graph[dst].remove(src)\\n        still_has_path = self.find(src, dst, graph, set())\\n        graph[src].add(dst)\\n        graph[dst].add(src)\\n        return still_has_path\\n\\n    def find(self, node, target, graph, seen):\\n        if node == target:\\n            return True\\n        if node in seen:\\n            return False\\n        seen.add(node)\\n        for neigh in graph[node]:\\n            if self.find(neigh, target, graph, seen):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.node2root = {i:i for i in range(n)}\\n        self.node2rank = {i:0 for i in range(n)}\\n    \\n    def find(self, node):\\n        if self.node2root[node] != node:\\n            self.node2root[node] = self.find(self.node2root[node])\\n        return self.node2root[node]\\n    \\n    def union(self, node1, node2):\\n        root1 = self.find(node1)\\n        root2 = self.find(node2)\\n        if root1 == root2:\\n            return False\\n        rank1 = self.node2rank[root1]\\n        rank2 = self.node2rank[root2]\\n        if rank1 <= rank2:\\n            self.node2root[root1] = root2\\n            self.node2rank[root2] += (rank1 == rank2)\\n        else:\\n            self.node2root[root2] = root1\\n        return True\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        ds = DisjointSet(n)\\n        critical = []\\n        pseudo_critical = []\\n\\n        Edge = namedtuple(\\'Edge\\', [\\'ind\\', \\'src\\', \\'dst\\', \\'weight\\'])\\n        sorted_edges = [Edge(i, *edge) for i, edge in enumerate(edges)]\\n        sorted_edges.sort(key=lambda e: e.weight)\\n        for weight, same_weight_edges in itertools.groupby(sorted_edges, key=lambda e: e.weight):\\n            graph = defaultdict(set)\\n            etype2edges = defaultdict(list)\\n            for edge_ind, s, d, w in same_weight_edges:\\n                root1 = ds.find(s)\\n                root2 = ds.find(d)\\n                if root1 != root2:  # criteria 1\\n                    graph[root1].add(root2)\\n                    graph[root2].add(root1)\\n                    etype = f\\'{min(root1, root2)}<->{max(root1, root2)}\\'\\n                    etype2edges[etype].append(edge_ind)\\n            for etype, interchangeable_edges in etype2edges.items():\\n                root1, root2 = map(int, etype.split(\\'<->\\'))\\n                if len(interchangeable_edges) > 1 or self.edge_in_cycle(root1, root2, graph):  # criteria 2\\n                    for edge in interchangeable_edges:\\n                        pseudo_critical.append(edge)\\n                else:\\n                    critical.append(interchangeable_edges[0])\\n                ds.union(root1, root2)\\n        return [critical, pseudo_critical]\\n\\n    def edge_in_cycle(self, src, dst, graph):\\n        graph[src].remove(dst)\\n        graph[dst].remove(src)\\n        still_has_path = self.find(src, dst, graph, set())\\n        graph[src].add(dst)\\n        graph[dst].add(src)\\n        return still_has_path\\n\\n    def find(self, node, target, graph, seen):\\n        if node == target:\\n            return True\\n        if node in seen:\\n            return False\\n        seen.add(node)\\n        for neigh in graph[node]:\\n            if self.find(neigh, target, graph, seen):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930041,
                "title": "easy-to-understand-c-kruskal-s-mst",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>p1,vector<int>p2){\\n        return p1[2]<p2[2];\\n    }\\n    int find(int i,vector<int>&parent){\\n        if (parent[i] == -1)\\n            return i;\\n \\n        return parent[i] = find(parent[i],parent);\\n    }\\n    void unite(int x, int y,vector<int>&parent,vector<int>&rank){\\n        int s1 = find(x,parent);\\n        int s2 = find(y,parent);\\n \\n        if (s1 != s2) {\\n            if (rank[s1] < rank[s2]) {\\n                parent[s1] = s2;\\n            }\\n            else if (rank[s1] > rank[s2]) {\\n                parent[s2] = s1;\\n            }\\n            else {\\n                parent[s2] = s1;\\n                rank[s1] += 1;\\n            }\\n        }\\n    }\\n    void kruskal(int n,vector<vector<int>>edges,int &ans,int temp=-1,int src =-1,int dest=-1){\\n        \\n        vector<int>parent(n,-1);\\n        vector<int>rank(n,1);\\n        \\n        if(temp!=-1){\\n            ans+=edges[temp][2];\\n            unite(edges[temp][0],edges[temp][1],parent,rank);\\n        }\\n\\n        for(auto it:edges){\\n            int x = it[0];\\n            int y = it[1];\\n            int w = it[2];\\n            int idx = it[3];\\n\\n            if(x==src and y==dest) continue;\\n\\n            if(find(x,parent) != find(y,parent)){\\n                unite(x,y,parent,rank);\\n                ans+=w;\\n            }\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            if(find(i,parent)!=find(0,parent)) ans= INT_MAX;\\n        }\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n\\n        int weig = 0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(),edges.end(),cmp);\\n\\n        kruskal(n,edges,weig);\\n\\n        vector<int>ans1;\\n        vector<int>ans2;\\n\\n        for(int i=0;i<edges.size();i++){\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            int curr_weig =0;\\n\\n            kruskal(n,edges,curr_weig,-1,src,dest);\\n\\n            if(curr_weig>weig){\\n                ans1.push_back(edges[i][3]);\\n            }\\n            else{\\n                curr_weig =0;\\n                kruskal(n,edges,curr_weig,i,src,dest);\\n                if(curr_weig==weig){\\n                    ans2.push_back(edges[i][3]);\\n                }\\n            }\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>p1,vector<int>p2){\\n        return p1[2]<p2[2];\\n    }\\n    int find(int i,vector<int>&parent){\\n        if (parent[i] == -1)\\n            return i;\\n \\n        return parent[i] = find(parent[i],parent);\\n    }\\n    void unite(int x, int y,vector<int>&parent,vector<int>&rank){\\n        int s1 = find(x,parent);\\n        int s2 = find(y,parent);\\n \\n        if (s1 != s2) {\\n            if (rank[s1] < rank[s2]) {\\n                parent[s1] = s2;\\n            }\\n            else if (rank[s1] > rank[s2]) {\\n                parent[s2] = s1;\\n            }\\n            else {\\n                parent[s2] = s1;\\n                rank[s1] += 1;\\n            }\\n        }\\n    }\\n    void kruskal(int n,vector<vector<int>>edges,int &ans,int temp=-1,int src =-1,int dest=-1){\\n        \\n        vector<int>parent(n,-1);\\n        vector<int>rank(n,1);\\n        \\n        if(temp!=-1){\\n            ans+=edges[temp][2];\\n            unite(edges[temp][0],edges[temp][1],parent,rank);\\n        }\\n\\n        for(auto it:edges){\\n            int x = it[0];\\n            int y = it[1];\\n            int w = it[2];\\n            int idx = it[3];\\n\\n            if(x==src and y==dest) continue;\\n\\n            if(find(x,parent) != find(y,parent)){\\n                unite(x,y,parent,rank);\\n                ans+=w;\\n            }\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            if(find(i,parent)!=find(0,parent)) ans= INT_MAX;\\n        }\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n\\n        int weig = 0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(),edges.end(),cmp);\\n\\n        kruskal(n,edges,weig);\\n\\n        vector<int>ans1;\\n        vector<int>ans2;\\n\\n        for(int i=0;i<edges.size();i++){\\n            int src = edges[i][0];\\n            int dest = edges[i][1];\\n            int curr_weig =0;\\n\\n            kruskal(n,edges,curr_weig,-1,src,dest);\\n\\n            if(curr_weig>weig){\\n                ans1.push_back(edges[i][3]);\\n            }\\n            else{\\n                curr_weig =0;\\n                kruskal(n,edges,curr_weig,i,src,dest);\\n                if(curr_weig==weig){\\n                    ans2.push_back(edges[i][3]);\\n                }\\n            }\\n        }\\n        return {ans1,ans2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929783,
                "title": "1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> fa;\\n    int n;\\n    int find(int x) {\\n        return fa[x]==x ? x : fa[x]=find(fa[x]);\\n    }\\n    \\n    int krus(vector<vector<int>>& e, int ban, int force) {\\n        int ans = 0;\\n        fa = vector<int>(n);\\n        iota(fa.begin(), fa.end(), 0);\\n        int cc = n;\\n        if (force >= 0) {\\n            fa[e[force][0]] = e[force][1];\\n            ans += e[force][2];\\n            --cc;\\n        }\\n        for (int j=0; j<e.size(); ++j) \\n            if (j != ban) {\\n                int fx = find(e[j][0]), fy = find(e[j][1]);\\n                if (fx != fy) {\\n                    fa[fx] = fy;\\n                    ans += e[j][2];\\n                    --cc;\\n                }\\n            }\\n        return cc==1 ? ans : INT_MAX;\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n_, vector<vector<int>>& eg) {\\n        n = n_;\\n        for (int i=0; i<eg.size(); ++i)\\n            eg[i].push_back(i);\\n        sort(eg.begin(), eg.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[2] < b[2]; \\n        });\\n\\n        int mst = krus(eg, -1, -1);\\n        vector<int> ce, pce;\\n        for (int i=0; i<eg.size(); ++i) {\\n            int m1 = krus(eg, i, -1);\\n            if (m1 > mst)\\n                ce.push_back(eg[i][3]);\\n            else {\\n                int m2 = krus(eg, -1, i);\\n                if (m2==mst)\\n                    pce.push_back(eg[i][3]);\\n            }\\n            \\n        }\\n        return {ce, pce};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> fa;\\n    int n;\\n    int find(int x) {\\n        return fa[x]==x ? x : fa[x]=find(fa[x]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3929625,
                "title": "full-explanation",
                "content": "- Intuition\\n\\n- Minimum Spanning Tree (MST):\\n\\n    The code aims to identify critical and pseudo-critical edges in a graph while considering the Minimum Spanning Tree (MST).\\n        Union-Find Data Structure:\\n\\n-  The UnionFind class helps manage disjoint sets efficiently. It\\'s used to track connected components and identify potential cycles when adding edges.\\n-         MST Calculation:\\nThe MST function calculates the MST weight by iteratively adding safe edges that don\\'t create cycles. It utilizes the UnionFind structure for efficient connectivity checks.\\n\\n- Edge Sorting:\\n    Edges are sorted by weight to process them in increasing order, crucial for MST construction.\\n- Critical and Pseudo-Critical Edges:\\nFor each edge, two conditions are checked:\\nIf adding the edge increases the MST weight, it\\'s marked as critical.\\nIf adding the edge maintains the MST weight, it\\'s marked as pseudo-critical.\\nResults:\\nIdentified critical and pseudo-critical edges are returned as separate lists of edge indices.\\n\\n\\n- Approach\\n- Step1.\\n    Union-Find Setup:\\n    Initialize the UnionFind data structure to track connected components efficiently.\\n\\nStep2.\\n- Calculate Baseline MST:\\nCalculate the weight of the Minimum Spanning Tree (MST) using all edges. Store this as the baseline MST weight.\\n\\nStep3.\\n- Sort Edges:\\nAttach edge indices and sort the edges based on weight. This allows us to process edges in increasing weight order.\\n\\nIdentify Critical and Pseudo-Critical Edges:\\nIterate through the sorted edges:\\nIf adding the edge increases the MST weight beyond the baseline, mark it as critical.\\nIf adding the edge maintains the same MST weight as the baseline, mark it as pseudo-critical.\\nReturn Results:\\nReturn the lists of critical and pseudo-critical edge indices.\\nComplexity\\n\\n- Time complexity:\\nThe time complexity of the code is approximately O(E * log E), where E is the number of edges in the graph.\\n\\n- Space complexity:\\nThe space complexity of the code is approximately O(E + n), where E is the number of edges and n is the number of vertices.\\n\\n# Code\\n```\\n// UnionFind class for implementing disjoint-set data structure\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    // Constructor to initialize parent array\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Each element is initially its own parent\\n        }\\n    }\\n\\n    // Find operation with path compression\\n    int findParent(int p) {\\n        // If the current element is its own parent, return it\\n        // Otherwise, recursively find and update the parent, then return\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]);\\n    }\\n\\n    // Union operation to merge two sets by updating parent\\n    void Union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv; // Make one element\\'s parent point to the other\\'s parent\\n    }\\n};\\n\\n// Solution class containing the main algorithm\\nclass Solution {\\nprivate:\\n    // Function to calculate the Minimum Spanning Tree weight with an optional excluded edge\\n    int MST(int &n, vector<vector<int>> &edges, int block, int e) {\\n        UnionFind uf(n);\\n        int w = 0;\\n\\n        // Include the excluded edge if specified\\n        if (e != -1) {\\n            w += edges[e][2]; // Add the weight of the excluded edge\\n            uf.Union(edges[e][0], edges[e][1]); // Merge the vertices of the excluded edge\\n        }\\n\\n        // Iterate through edges and build the MST\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block) continue; // Skip the blocked edge\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) continue; // Skip if in same set\\n\\n            uf.Union(edges[i][0], edges[i][1]); // Merge vertices of the current edge\\n            w += edges[i][2]; // Add the weight of the current edge to the MST weight\\n        }\\n\\n        // Check if all vertices are in the same set (MST is connected)\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0)) return INT_MAX; // Not connected, return a large value\\n        }\\n\\n        return w; // Return the weight of the MST\\n    }\\n\\npublic:\\n    // Comparator function for sorting edges based on weight\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2]; // Compare edges based on weight\\n    }\\n\\n    // Main function to find critical and pseudo-critical edges\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges) {\\n        vector<int> c, psc;\\n\\n        // Attach edge index to each edge for identification after sorting\\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n\\n        // Sort the edges in ascending order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n\\n        // Calculate the weight of the minimum spanning tree (MST)\\n        int mst = MST(n, edges, -1, -1);\\n\\n        // Iterate through edges to find critical and pseudo-critical edges\\n        for (int i = 0; i < edges.size(); i++) {\\n            // Check if adding the edge would result in a lower MST weight (critical edge)\\n            if (mst < MST(n, edges, i, -1)) {\\n                c.push_back(edges[i][3]); // Add the edge index to the critical list\\n            }\\n            // Check if the edge can be part of the MST with the same weight (pseudo-critical edge)\\n            else if (mst == MST(n, edges, -1, i)) {\\n                psc.push_back(edges[i][3]); // Add the edge index to the pseudo-critical list\\n            }\\n        }\\n\\n        // Return the lists of critical and pseudo-critical edges\\n        return {c, psc};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\n// UnionFind class for implementing disjoint-set data structure\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    // Constructor to initialize parent array\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Each element is initially its own parent\\n        }\\n    }\\n\\n    // Find operation with path compression\\n    int findParent(int p) {\\n        // If the current element is its own parent, return it\\n        // Otherwise, recursively find and update the parent, then return\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]);\\n    }\\n\\n    // Union operation to merge two sets by updating parent\\n    void Union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv; // Make one element\\'s parent point to the other\\'s parent\\n    }\\n};\\n\\n// Solution class containing the main algorithm\\nclass Solution {\\nprivate:\\n    // Function to calculate the Minimum Spanning Tree weight with an optional excluded edge\\n    int MST(int &n, vector<vector<int>> &edges, int block, int e) {\\n        UnionFind uf(n);\\n        int w = 0;\\n\\n        // Include the excluded edge if specified\\n        if (e != -1) {\\n            w += edges[e][2]; // Add the weight of the excluded edge\\n            uf.Union(edges[e][0], edges[e][1]); // Merge the vertices of the excluded edge\\n        }\\n\\n        // Iterate through edges and build the MST\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block) continue; // Skip the blocked edge\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) continue; // Skip if in same set\\n\\n            uf.Union(edges[i][0], edges[i][1]); // Merge vertices of the current edge\\n            w += edges[i][2]; // Add the weight of the current edge to the MST weight\\n        }\\n\\n        // Check if all vertices are in the same set (MST is connected)\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0)) return INT_MAX; // Not connected, return a large value\\n        }\\n\\n        return w; // Return the weight of the MST\\n    }\\n\\npublic:\\n    // Comparator function for sorting edges based on weight\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2]; // Compare edges based on weight\\n    }\\n\\n    // Main function to find critical and pseudo-critical edges\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges) {\\n        vector<int> c, psc;\\n\\n        // Attach edge index to each edge for identification after sorting\\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n\\n        // Sort the edges in ascending order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n\\n        // Calculate the weight of the minimum spanning tree (MST)\\n        int mst = MST(n, edges, -1, -1);\\n\\n        // Iterate through edges to find critical and pseudo-critical edges\\n        for (int i = 0; i < edges.size(); i++) {\\n            // Check if adding the edge would result in a lower MST weight (critical edge)\\n            if (mst < MST(n, edges, i, -1)) {\\n                c.push_back(edges[i][3]); // Add the edge index to the critical list\\n            }\\n            // Check if the edge can be part of the MST with the same weight (pseudo-critical edge)\\n            else if (mst == MST(n, edges, -1, i)) {\\n                psc.push_back(edges[i][3]); // Add the edge index to the pseudo-critical list\\n            }\\n        }\\n\\n        // Return the lists of critical and pseudo-critical edges\\n        return {c, psc};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929593,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let parent = new Array(n);\\n    let size = new Array(n);\\n    const critical = [];\\n    const pseudo_critical = [];\\n    for(let i = 0; i<edges.length; i++) edges[i].push(i);\\n    function make_set(){\\n        for(let i = 0; i<n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    const find = function (x) {\\n        if(parent[x] === x) return x;\\n        return find(parent[x]);\\n    }\\n    const union = function (a,b){\\n        a = find(a);\\n        b = find(b);\\n        if(a === b) return false;\\n        if(size[a] > size[b]){\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }else{\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        return true;\\n    }\\n    const getMST = function (blockEdge,preEdge){\\n        // initialize disjoint set\\n        make_set();\\n        //\\n        let weight = 0;\\n        if(preEdge != -1){\\n            weight += edges[preEdge][2];\\n            union(edges[preEdge][0], edges[preEdge][1]);\\n        }\\n        for(let i = 0; i<edges.length; i++){\\n            if(i===blockEdge) continue;\\n            if(union(edges[i][0],edges[i][1])) weight += edges[i][2];\\n        }\\n        // check whether we can form mst or not \\n        for(let i = 0; i<n; i++){\\n            if(find(i) != find(0)) return Number.MAX_SAFE_INTEGER;\\n        }\\n        return weight;\\n    };\\n    edges.sort( (a,b) => {return a[2]-b[2]});\\n    const oriMST = getMST(-1,-1);\\n    for(let i = 0; i<edges.length; i++){\\n        if(oriMST < getMST(i,-1)) {\\n            critical.push(edges[i][3]);\\n        }\\n        else if(oriMST === getMST(-1,i)) {\\n            pseudo_critical.push(edges[i][3]);\\n        }\\n    }\\n    return [critical,pseudo_critical];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number[][]}\\n */\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n    let parent = new Array(n);\\n    let size = new Array(n);\\n    const critical = [];\\n    const pseudo_critical = [];\\n    for(let i = 0; i<edges.length; i++) edges[i].push(i);\\n    function make_set(){\\n        for(let i = 0; i<n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    const find = function (x) {\\n        if(parent[x] === x) return x;\\n        return find(parent[x]);\\n    }\\n    const union = function (a,b){\\n        a = find(a);\\n        b = find(b);\\n        if(a === b) return false;\\n        if(size[a] > size[b]){\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }else{\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        return true;\\n    }\\n    const getMST = function (blockEdge,preEdge){\\n        // initialize disjoint set\\n        make_set();\\n        //\\n        let weight = 0;\\n        if(preEdge != -1){\\n            weight += edges[preEdge][2];\\n            union(edges[preEdge][0], edges[preEdge][1]);\\n        }\\n        for(let i = 0; i<edges.length; i++){\\n            if(i===blockEdge) continue;\\n            if(union(edges[i][0],edges[i][1])) weight += edges[i][2];\\n        }\\n        // check whether we can form mst or not \\n        for(let i = 0; i<n; i++){\\n            if(find(i) != find(0)) return Number.MAX_SAFE_INTEGER;\\n        }\\n        return weight;\\n    };\\n    edges.sort( (a,b) => {return a[2]-b[2]});\\n    const oriMST = getMST(-1,-1);\\n    for(let i = 0; i<edges.length; i++){\\n        if(oriMST < getMST(i,-1)) {\\n            critical.push(edges[i][3]);\\n        }\\n        else if(oriMST === getMST(-1,i)) {\\n            pseudo_critical.push(edges[i][3]);\\n        }\\n    }\\n    return [critical,pseudo_critical];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929529,
                "title": "java-19",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Add index to edges for tracking\\n        int m = edges.length;\\n        int[][] newEdges = new int[m][4];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                newEdges[i][j] = edges[i][j];\\n            }\\n            newEdges[i][3] = i;\\n        }\\n\\n        // Sort edges based on weight\\n        Arrays.sort(newEdges, Comparator.comparingInt(edge -> edge[2]));\\n\\n        // Find MST weight using union-find\\n        UnionFind ufStd = new UnionFind(n);\\n        int stdWeight = 0;\\n        for (int[] edge : newEdges) {\\n            if (ufStd.union(edge[0], edge[1])) {\\n                stdWeight += edge[2];\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < 2; i++) {\\n            result.add(new ArrayList<>());\\n        }\\n\\n        // Check each edge for critical and pseudo-critical\\n        for (int i = 0; i < m; i++) {\\n            // Ignore this edge and calculate MST weight\\n            UnionFind ufIgnore = new UnionFind(n);\\n            int ignoreWeight = 0;\\n            for (int j = 0; j < m; j++) {\\n                if (i != j && ufIgnore.union(newEdges[j][0], newEdges[j][1])) {\\n                    ignoreWeight += newEdges[j][2];\\n                }\\n            }\\n            // If the graph is disconnected or the total weight is greater, \\n            // the edge is critical\\n            if (ufIgnore.maxSize < n || ignoreWeight > stdWeight) {\\n                result.get(0).add(newEdges[i][3]);\\n            } else {\\n                // Force this edge and calculate MST weight\\n                UnionFind ufForce = new UnionFind(n);\\n                ufForce.union(newEdges[i][0], newEdges[i][1]);\\n                int forceWeight = newEdges[i][2];\\n                for (int j = 0; j < m; j++) {\\n                    if (i != j && ufForce.union(newEdges[j][0], newEdges[j][1])) {\\n                        forceWeight += newEdges[j][2];\\n                    }\\n                }\\n                // If total weight is the same, the edge is pseudo-critical\\n                if (forceWeight == stdWeight) {\\n                    result.get(1).add(newEdges[i][3]);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int maxSize;\\n\\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            maxSize = 1;\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x) {\\n            // Finds the root of x\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public boolean union(int x, int y) {\\n            // Connects x and y\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (size[rootX] < size[rootY]) {\\n                    int temp = rootX;\\n                    rootX = rootY;\\n                    rootY = temp;\\n                }\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n                maxSize = Math.max(maxSize, size[rootX]);\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n}//TC:O(m^2\\u22C5\\u03B1(n)), where m is the number of edges, n is the number of nodes and \\u03B1\\\\alpha\\u03B1 is the inverse Ackermann function; SC:O(m)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Add index to edges for tracking\\n        int m = edges.length;\\n        int[][] newEdges = new int[m][4];\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                newEdges[i][j] = edges[i][j];\\n            }\\n            newEdges[i][3] = i;\\n        }\\n\\n        // Sort edges based on weight\\n        Arrays.sort(newEdges, Comparator.comparingInt(edge -> edge[2]));\\n\\n        // Find MST weight using union-find\\n        UnionFind ufStd = new UnionFind(n);\\n        int stdWeight = 0;\\n        for (int[] edge : newEdges) {\\n            if (ufStd.union(edge[0], edge[1])) {\\n                stdWeight += edge[2];\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < 2; i++) {\\n            result.add(new ArrayList<>());\\n        }\\n\\n        // Check each edge for critical and pseudo-critical\\n        for (int i = 0; i < m; i++) {\\n            // Ignore this edge and calculate MST weight\\n            UnionFind ufIgnore = new UnionFind(n);\\n            int ignoreWeight = 0;\\n            for (int j = 0; j < m; j++) {\\n                if (i != j && ufIgnore.union(newEdges[j][0], newEdges[j][1])) {\\n                    ignoreWeight += newEdges[j][2];\\n                }\\n            }\\n            // If the graph is disconnected or the total weight is greater, \\n            // the edge is critical\\n            if (ufIgnore.maxSize < n || ignoreWeight > stdWeight) {\\n                result.get(0).add(newEdges[i][3]);\\n            } else {\\n                // Force this edge and calculate MST weight\\n                UnionFind ufForce = new UnionFind(n);\\n                ufForce.union(newEdges[i][0], newEdges[i][1]);\\n                int forceWeight = newEdges[i][2];\\n                for (int j = 0; j < m; j++) {\\n                    if (i != j && ufForce.union(newEdges[j][0], newEdges[j][1])) {\\n                        forceWeight += newEdges[j][2];\\n                    }\\n                }\\n                // If total weight is the same, the edge is pseudo-critical\\n                if (forceWeight == stdWeight) {\\n                    result.get(1).add(newEdges[i][3]);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    class UnionFind {\\n        int[] parent;\\n        int[] size;\\n        int maxSize;\\n\\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            maxSize = 1;\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x) {\\n            // Finds the root of x\\n            if (x != parent[x]) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n\\n        public boolean union(int x, int y) {\\n            // Connects x and y\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (size[rootX] < size[rootY]) {\\n                    int temp = rootX;\\n                    rootX = rootY;\\n                    rootY = temp;\\n                }\\n                parent[rootY] = rootX;\\n                size[rootX] += size[rootY];\\n                maxSize = Math.max(maxSize, size[rootX]);\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n}//TC:O(m^2\\u22C5\\u03B1(n)), where m is the number of edges, n is the number of nodes and \\u03B1\\\\alpha\\u03B1 is the inverse Ackermann function; SC:O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929437,
                "title": "tc-e-2-simple-beginner-friendly",
                "content": "TC: $$O(E^2)$$\\n# Code\\n```\\nclass Solution {\\n    class DSU {\\n        int[] arr=new int[100];\\n        DSU() {for(int i=0;i<100;arr[i]=i++);}\\n        int findParent(int a) {return (arr[a]==a)? a: (arr[a]=findParent(arr[a]));}\\n        void union(int a, int b) {arr[findParent(b)]=findParent(a);}\\n    }\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        HashMap<int[], Integer> map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++) map.put(edges[i],i);\\n        Arrays.sort(edges, (a,b)->a[2]-b[2]);\\n        int min_c=f(n, edges, null, null), c;\\n        ArrayList<ArrayList<Integer>> res=new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); res.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            if(f(n, edges, e, null) >min_c) res.get(0).add(map.get(e));\\n            else if(f(n, edges, null, e)==min_c) res.get(1).add(map.get(e));\\n        }\\n        return (List)res;\\n    }\\n    int f(int n, int[][] edges, int[] skip, int[] take) {\\n        DSU dsu = new DSU(); int c=0;\\n        if(take!=null) {\\n            dsu.union(take[0], take[1]);\\n            c+=take[2];\\n            n--;\\n        }\\n        for(int[] e: edges) {\\n            if(e!=skip && dsu.findParent(e[0])!=dsu.findParent(e[1])) {\\n                dsu.union(e[0], e[1]);\\n                c+=e[2];\\n                n--;\\n            }\\n        }\\n        return n==1? c:Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        int[] arr=new int[100];\\n        DSU() {for(int i=0;i<100;arr[i]=i++);}\\n        int findParent(int a) {return (arr[a]==a)? a: (arr[a]=findParent(arr[a]));}\\n        void union(int a, int b) {arr[findParent(b)]=findParent(a);}\\n    }\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        HashMap<int[], Integer> map=new HashMap<>();\\n        for(int i=0;i<edges.length;i++) map.put(edges[i],i);\\n        Arrays.sort(edges, (a,b)->a[2]-b[2]);\\n        int min_c=f(n, edges, null, null), c;\\n        ArrayList<ArrayList<Integer>> res=new ArrayList<>();\\n        res.add(new ArrayList<Integer>()); res.add(new ArrayList<Integer>());\\n        for(int[] e: edges) {\\n            if(f(n, edges, e, null) >min_c) res.get(0).add(map.get(e));\\n            else if(f(n, edges, null, e)==min_c) res.get(1).add(map.get(e));\\n        }\\n        return (List)res;\\n    }\\n    int f(int n, int[][] edges, int[] skip, int[] take) {\\n        DSU dsu = new DSU(); int c=0;\\n        if(take!=null) {\\n            dsu.union(take[0], take[1]);\\n            c+=take[2];\\n            n--;\\n        }\\n        for(int[] e: edges) {\\n            if(e!=skip && dsu.findParent(e[0])!=dsu.findParent(e[1])) {\\n                dsu.union(e[0], e[1]);\\n                c+=e[2];\\n                n--;\\n            }\\n        }\\n        return n==1? c:Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929411,
                "title": "java-union-finding-and-mst-solution-with-explanation",
                "content": "\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    \\n    int[][] inputEdges;  // Stores the input edges.\\n    int totalVertices;   // Total number of vertices in the graph.\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int numVertices, int[][] inputEdges) {\\n        this.inputEdges = inputEdges;\\n        this.totalVertices = numVertices;\\n        \\n        List<Integer> criticalEdges = new ArrayList<Integer>();      // Stores the indices of critical edges.\\n        List<Integer> pseudoCriticalEdges = new ArrayList<Integer>(); // Stores the indices of non-critical (pseudo-critical) edges.\\n        \\n        Map<int[], Integer> edgeToIndex = new HashMap<int[], Integer>();\\n        for (int i = 0; i < inputEdges.length; i++) {\\n            edgeToIndex.put(inputEdges[i], i);  // Mapping from edge array to its index.\\n        }\\n        \\n        Arrays.sort(inputEdges, (a, b) -> a[2] - b[2]);  // Sort the edges by weight.\\n        \\n        int minSpanningTreeWeight = findMinSpanningTreeWeight(0, -1);  // Calculate weight of the minimum spanning tree.\\n        \\n        for (int i = 0; i < inputEdges.length; i++) {\\n            int edgeIndex = edgeToIndex.get(inputEdges[i]);\\n            if (findMinSpanningTreeWeight(0, i) > minSpanningTreeWeight) {\\n                criticalEdges.add(edgeIndex);  // Add the edge to the critical list.\\n            } else if (findMinSpanningTreeWeight(i, -1) == minSpanningTreeWeight) {\\n                pseudoCriticalEdges.add(edgeIndex);  // Add the edge to the pseudo-critical list.\\n            }\\n        }\\n        \\n        return List.of(criticalEdges, pseudoCriticalEdges);\\n    }\\n    \\n    private int findMinSpanningTreeWeight(int startingEdge, int skipEdge) {\\n        UnionFind unionFind = new UnionFind(totalVertices);  // Create a new UnionFind structure.\\n        int totalCost = 0;\\n        \\n        if (skipEdge != 0) {\\n            unionFind.union(inputEdges[startingEdge][0], inputEdges[startingEdge][1]);\\n            totalCost += inputEdges[startingEdge][2];\\n        }\\n        \\n        for (int i = 0; i < inputEdges.length; i++) {\\n            if (i == skipEdge) continue;\\n            int[] edge = inputEdges[i];\\n            \\n            if (unionFind.find(edge[0]) != unionFind.find(edge[1])) {\\n                unionFind.union(edge[0], edge[1]);\\n                totalCost += edge[2];\\n            }\\n        }\\n        \\n        return unionFind.count == totalVertices - 1 ? totalCost : Integer.MAX_VALUE;\\n    }\\n    \\n    class UnionFind {\\n        \\n        int[] parent;\\n        int count;\\n        \\n        public UnionFind(int numVertices) {\\n            this.parent = new int[numVertices];\\n            this.count = 0;\\n            for (int i = 0; i < numVertices; i++) {\\n                this.parent[i] = i;  // Initialize each vertex as its own parent.\\n            }\\n        }\\n        \\n        public void union(int vertexA, int vertexB) {\\n            this.count++;\\n            vertexA = find(vertexA);\\n            vertexB = find(vertexB);\\n            parent[vertexA] = vertexB;  // Connect vertexA\\'s parent to vertexB.\\n        }\\n        \\n        public int find(int vertex) {\\n            while (parent[vertex] != vertex) {\\n                vertex = parent[vertex];  // Traverse up the parent chain.\\n            }\\n            return vertex;  // Return the ultimate parent.\\n        }\\n    }\\n}\\n\\n```\\n# If you found my solution helpful and informative, I kindly invite you to consider leaving an upvote. Your support is greatly appreciated!",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    \\n    int[][] inputEdges;  // Stores the input edges.\\n    int totalVertices;   // Total number of vertices in the graph.\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int numVertices, int[][] inputEdges) {\\n        this.inputEdges = inputEdges;\\n        this.totalVertices = numVertices;\\n        \\n        List<Integer> criticalEdges = new ArrayList<Integer>();      // Stores the indices of critical edges.\\n        List<Integer> pseudoCriticalEdges = new ArrayList<Integer>(); // Stores the indices of non-critical (pseudo-critical) edges.\\n        \\n        Map<int[], Integer> edgeToIndex = new HashMap<int[], Integer>();\\n        for (int i = 0; i < inputEdges.length; i++) {\\n            edgeToIndex.put(inputEdges[i], i);  // Mapping from edge array to its index.\\n        }\\n        \\n        Arrays.sort(inputEdges, (a, b) -> a[2] - b[2]);  // Sort the edges by weight.\\n        \\n        int minSpanningTreeWeight = findMinSpanningTreeWeight(0, -1);  // Calculate weight of the minimum spanning tree.\\n        \\n        for (int i = 0; i < inputEdges.length; i++) {\\n            int edgeIndex = edgeToIndex.get(inputEdges[i]);\\n            if (findMinSpanningTreeWeight(0, i) > minSpanningTreeWeight) {\\n                criticalEdges.add(edgeIndex);  // Add the edge to the critical list.\\n            } else if (findMinSpanningTreeWeight(i, -1) == minSpanningTreeWeight) {\\n                pseudoCriticalEdges.add(edgeIndex);  // Add the edge to the pseudo-critical list.\\n            }\\n        }\\n        \\n        return List.of(criticalEdges, pseudoCriticalEdges);\\n    }\\n    \\n    private int findMinSpanningTreeWeight(int startingEdge, int skipEdge) {\\n        UnionFind unionFind = new UnionFind(totalVertices);  // Create a new UnionFind structure.\\n        int totalCost = 0;\\n        \\n        if (skipEdge != 0) {\\n            unionFind.union(inputEdges[startingEdge][0], inputEdges[startingEdge][1]);\\n            totalCost += inputEdges[startingEdge][2];\\n        }\\n        \\n        for (int i = 0; i < inputEdges.length; i++) {\\n            if (i == skipEdge) continue;\\n            int[] edge = inputEdges[i];\\n            \\n            if (unionFind.find(edge[0]) != unionFind.find(edge[1])) {\\n                unionFind.union(edge[0], edge[1]);\\n                totalCost += edge[2];\\n            }\\n        }\\n        \\n        return unionFind.count == totalVertices - 1 ? totalCost : Integer.MAX_VALUE;\\n    }\\n    \\n    class UnionFind {\\n        \\n        int[] parent;\\n        int count;\\n        \\n        public UnionFind(int numVertices) {\\n            this.parent = new int[numVertices];\\n            this.count = 0;\\n            for (int i = 0; i < numVertices; i++) {\\n                this.parent[i] = i;  // Initialize each vertex as its own parent.\\n            }\\n        }\\n        \\n        public void union(int vertexA, int vertexB) {\\n            this.count++;\\n            vertexA = find(vertexA);\\n            vertexB = find(vertexB);\\n            parent[vertexA] = vertexB;  // Connect vertexA\\'s parent to vertexB.\\n        }\\n        \\n        public int find(int vertex) {\\n            while (parent[vertex] != vertex) {\\n                vertex = parent[vertex];  // Traverse up the parent chain.\\n            }\\n            return vertex;  // Return the ultimate parent.\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929385,
                "title": "easy-and-optimal-approach-mst-sorting-c-code",
                "content": "# Intuition\\n- Minimum Spanning Tree (MST):\\nThe code aims to identify critical and pseudo-critical edges in a graph while considering the Minimum Spanning Tree (MST).\\n- Union-Find Data Structure:\\nThe UnionFind class helps manage disjoint sets efficiently. It\\'s used to track connected components and identify potential cycles when adding edges.\\n- MST Calculation:\\nThe MST function calculates the MST weight by iteratively adding safe edges that don\\'t create cycles. It utilizes the UnionFind structure for efficient connectivity checks.\\nEdge Sorting:\\n- Edges are sorted by weight to process them in increasing order, crucial for MST construction.\\n- Critical and Pseudo-Critical Edges:\\nFor each edge, two conditions are checked:\\n1. If adding the edge increases the MST weight, it\\'s marked as critical.\\n1. If adding the edge maintains the MST weight, it\\'s marked as pseudo-critical.\\n- Results:\\nIdentified critical and pseudo-critical edges are returned as separate lists of edge indices.\\n\\n# Approach\\n- Union-Find Setup:\\nInitialize the UnionFind data structure to track connected components efficiently.\\n- Calculate Baseline MST:\\nCalculate the weight of the Minimum Spanning Tree (MST) using all edges. Store this as the baseline MST weight.\\n- Sort Edges:\\nAttach edge indices and sort the edges based on weight. This allows us to process edges in increasing weight order.\\n- Identify Critical and Pseudo-Critical Edges:\\nIterate through the sorted edges:\\n1. If adding the edge increases the MST weight beyond the baseline, mark it as critical.\\n1. If adding the edge maintains the same MST weight as the baseline, mark it as pseudo-critical.\\n- Return Results:\\nReturn the lists of critical and pseudo-critical edge indices.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is approximately O(E * log E), where E is the number of edges in the graph.\\n\\n- Space complexity:\\nThe space complexity of the code is approximately O(E + n), where E is the number of edges and n is the number of vertices.\\n\\n# Code\\n```\\n// UnionFind class for implementing disjoint-set data structure\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    // Constructor to initialize parent array\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Each element is initially its own parent\\n        }\\n    }\\n\\n    // Find operation with path compression\\n    int findParent(int p) {\\n        // If the current element is its own parent, return it\\n        // Otherwise, recursively find and update the parent, then return\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]);\\n    }\\n\\n    // Union operation to merge two sets by updating parent\\n    void Union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv; // Make one element\\'s parent point to the other\\'s parent\\n    }\\n};\\n\\n// Solution class containing the main algorithm\\nclass Solution {\\nprivate:\\n    // Function to calculate the Minimum Spanning Tree weight with an optional excluded edge\\n    int MST(int &n, vector<vector<int>> &edges, int block, int e) {\\n        UnionFind uf(n);\\n        int w = 0;\\n\\n        // Include the excluded edge if specified\\n        if (e != -1) {\\n            w += edges[e][2]; // Add the weight of the excluded edge\\n            uf.Union(edges[e][0], edges[e][1]); // Merge the vertices of the excluded edge\\n        }\\n\\n        // Iterate through edges and build the MST\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block) continue; // Skip the blocked edge\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) continue; // Skip if in same set\\n\\n            uf.Union(edges[i][0], edges[i][1]); // Merge vertices of the current edge\\n            w += edges[i][2]; // Add the weight of the current edge to the MST weight\\n        }\\n\\n        // Check if all vertices are in the same set (MST is connected)\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0)) return INT_MAX; // Not connected, return a large value\\n        }\\n\\n        return w; // Return the weight of the MST\\n    }\\n\\npublic:\\n    // Comparator function for sorting edges based on weight\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2]; // Compare edges based on weight\\n    }\\n\\n    // Main function to find critical and pseudo-critical edges\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges) {\\n        vector<int> c, psc;\\n\\n        // Attach edge index to each edge for identification after sorting\\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n\\n        // Sort the edges in ascending order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n\\n        // Calculate the weight of the minimum spanning tree (MST)\\n        int mst = MST(n, edges, -1, -1);\\n\\n        // Iterate through edges to find critical and pseudo-critical edges\\n        for (int i = 0; i < edges.size(); i++) {\\n            // Check if adding the edge would result in a lower MST weight (critical edge)\\n            if (mst < MST(n, edges, i, -1)) {\\n                c.push_back(edges[i][3]); // Add the edge index to the critical list\\n            }\\n            // Check if the edge can be part of the MST with the same weight (pseudo-critical edge)\\n            else if (mst == MST(n, edges, -1, i)) {\\n                psc.push_back(edges[i][3]); // Add the edge index to the pseudo-critical list\\n            }\\n        }\\n\\n        // Return the lists of critical and pseudo-critical edges\\n        return {c, psc};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\n// UnionFind class for implementing disjoint-set data structure\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    // Constructor to initialize parent array\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // Each element is initially its own parent\\n        }\\n    }\\n\\n    // Find operation with path compression\\n    int findParent(int p) {\\n        // If the current element is its own parent, return it\\n        // Otherwise, recursively find and update the parent, then return\\n        return parent[p] == p ? p : parent[p] = findParent(parent[p]);\\n    }\\n\\n    // Union operation to merge two sets by updating parent\\n    void Union(int u, int v) {\\n        int pu = findParent(u), pv = findParent(v);\\n        parent[pu] = pv; // Make one element\\'s parent point to the other\\'s parent\\n    }\\n};\\n\\n// Solution class containing the main algorithm\\nclass Solution {\\nprivate:\\n    // Function to calculate the Minimum Spanning Tree weight with an optional excluded edge\\n    int MST(int &n, vector<vector<int>> &edges, int block, int e) {\\n        UnionFind uf(n);\\n        int w = 0;\\n\\n        // Include the excluded edge if specified\\n        if (e != -1) {\\n            w += edges[e][2]; // Add the weight of the excluded edge\\n            uf.Union(edges[e][0], edges[e][1]); // Merge the vertices of the excluded edge\\n        }\\n\\n        // Iterate through edges and build the MST\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (i == block) continue; // Skip the blocked edge\\n            if (uf.findParent(edges[i][0]) == uf.findParent(edges[i][1])) continue; // Skip if in same set\\n\\n            uf.Union(edges[i][0], edges[i][1]); // Merge vertices of the current edge\\n            w += edges[i][2]; // Add the weight of the current edge to the MST weight\\n        }\\n\\n        // Check if all vertices are in the same set (MST is connected)\\n        for (int i = 0; i < n; i++) {\\n            if (uf.findParent(i) != uf.findParent(0)) return INT_MAX; // Not connected, return a large value\\n        }\\n\\n        return w; // Return the weight of the MST\\n    }\\n\\npublic:\\n    // Comparator function for sorting edges based on weight\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2]; // Compare edges based on weight\\n    }\\n\\n    // Main function to find critical and pseudo-critical edges\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges) {\\n        vector<int> c, psc;\\n\\n        // Attach edge index to each edge for identification after sorting\\n        for (int i = 0; i < edges.size(); i++) {\\n            edges[i].push_back(i);\\n        }\\n\\n        // Sort the edges in ascending order of weight\\n        sort(edges.begin(), edges.end(), cmp);\\n\\n        // Calculate the weight of the minimum spanning tree (MST)\\n        int mst = MST(n, edges, -1, -1);\\n\\n        // Iterate through edges to find critical and pseudo-critical edges\\n        for (int i = 0; i < edges.size(); i++) {\\n            // Check if adding the edge would result in a lower MST weight (critical edge)\\n            if (mst < MST(n, edges, i, -1)) {\\n                c.push_back(edges[i][3]); // Add the edge index to the critical list\\n            }\\n            // Check if the edge can be part of the MST with the same weight (pseudo-critical edge)\\n            else if (mst == MST(n, edges, -1, i)) {\\n                psc.push_back(edges[i][3]); // Add the edge index to the pseudo-critical list\\n            }\\n        }\\n\\n        // Return the lists of critical and pseudo-critical edges\\n        return {c, psc};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929373,
                "title": "python-easy-to-understand-fastest-optimal-solution",
                "content": "# Python | Easy to Understand | Fastest | Optimal Solution\\n```\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UnionFindSet:\\n    def __init__(self, n=0):\\n        self.parents = {}\\n        self.ranks = {}\\n        self.count = 0\\n        for i in range(n):\\n            self.add(i)\\n\\n    def add(self, p):\\n        self.parents[p] = p\\n        self.ranks[p] = 1\\n        self.count += 1\\n\\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: \\n            return False\\n        if self.ranks[pu] < self.ranks[pv]:\\n            self.parents[pu] = pv\\n        elif self.ranks[pu] > self.ranks[pv]:\\n            self.parents[pv] = pu\\n        else:        \\n            self.parents[pv] = pu\\n            self.ranks[pu] += 1\\n        self.count -= 1\\n        return True\\n    \\n# UnionFind + Kruskal + Enumerate edges\\n# O(ElogE + E^2 + E^2)\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        # sort edges in asc order based on weight\\n        edges = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]\\n        edges.sort(key=lambda x: x[2])\\n        \\n        # do not use this edge\\n        def find_mst_without_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            ans = 0\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # need to use this edge\\n        def find_mst_with_this_edge(edge_idx):\\n            union_find_set = UnionFindSet(n)\\n            # use this edge first\\n            u0, v0, w0, _ = edges[edge_idx]\\n            ans = w0\\n            union_find_set.union(u0, v0)\\n            for i, (u, v, w, _) in enumerate(edges):\\n                # do not use this edge\\n                if i == edge_idx:\\n                    continue\\n                if union_find_set.union(u, v):\\n                    ans += w\\n            parent = union_find_set.find(0)\\n            return ans if all(union_find_set.find(i) == parent for i in range(n)) else inf\\n        \\n        # normal MST total weight\\n        base = find_mst_without_this_edge(-1)\\n        cri, p_cri = set(), set()\\n        for i in range(len(edges)):\\n            wgt_excl = find_mst_without_this_edge(i)\\n            # if not included, MST total weight would increase\\n            if wgt_excl > base:\\n                cri.add(edges[i][3])\\n            else:\\n                wgt_incl = find_mst_with_this_edge(i)\\n                # with this edge, MST total weight doesn\\'t change\\n                if wgt_incl == base:\\n                    p_cri.add(edges[i][3])\\n    \\n        return [cri, p_cri]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929284,
                "title": "c-solution-using-kruskals-algo",
                "content": "# Complexity\\n- Time complexity:\\n$$O(m^2 alpha(n))$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int parent[101];\\n    int rank[101];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n\\n    int findParent(int n){\\n        if(parent[n] == n)\\n            return n;\\n        \\n        return parent[n] = findParent(parent[n]);\\n    }\\n\\n    void unionDSU(int a, int b){\\n        int para = findParent(a);\\n        int parb = findParent(b);\\n        if(para == parb)\\n            return;;\\n        \\n        int ranka = rank[para];\\n        int rankb = rank[parb];\\n        \\n        if(ranka > rankb)\\n            parent[parb] = para;\\n        else if(rankb > ranka)\\n            parent[para] = parb;\\n        else{\\n            parent[para] = parb;\\n            rank[parb]+=1;\\n        }\\n    }\\n\\npublic:\\n    int makeMST(vector<vector<int>>&edges, int index, int n){\\n        dsu(n);\\n        int res = 0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(i == index)\\n                continue;\\n            \\n            int para = findParent(edges[i][0]);\\n            int parb = findParent(edges[i][1]);\\n            if(para!=parb){\\n                res+=edges[i][2];\\n                unionDSU(edges[i][0], edges[i][1]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int makeMSTwithIndex(vector<vector<int>>&edges, int index, int n){\\n        dsu(n);\\n        int res = edges[index][2];\\n\\n        unionDSU(edges[index][0], edges[index][1]);\\n\\n        for(int i=0;i<edges.size();i++){\\n            int para = findParent(edges[i][0]);\\n            int parb = findParent(edges[i][1]);\\n            if(para!=parb){\\n                res+=edges[i][2];\\n                unionDSU(edges[i][0], edges[i][1]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void dfs(vector<pair<int, int>>adj[], int node, vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto it: adj[node]){\\n            if(vis[it.first] == 0)\\n                dfs(adj, it.first, vis);\\n        }\\n    }\\n\\n    vector<vector<int>>criticalnpseudoCritical(vector<vector<int>>&edges, int n){\\n        int minWtMST = makeMST(edges, -1, n);\\n\\n        vector<vector<int>>res;\\n        vector<int>critical;\\n        vector<int>pseudoCritical;\\n\\n        for(int i=0;i<edges.size();i++){\\n            vector<pair<int, int>>adj[n];\\n            for(int j=0;j<edges.size();j++){\\n                if(i == j) continue;\\n                int a = edges[j][0];\\n                int b = edges[j][1];\\n                int wt = edges[j][2];\\n\\n                adj[a].push_back({b, wt});\\n                adj[b].push_back({a, wt});\\n            }\\n            int compCount = 0;\\n            vector<int>vis(n, 0);\\n\\n            for(int j=0;j<n;j++){\\n                if(!vis[j]){\\n                    ++compCount;\\n                    dfs(adj, j, vis);\\n                }\\n            }\\n\\n            if(compCount > 1){\\n                critical.push_back(edges[i][3]);\\n                continue;\\n            }\\n            \\n            int val = makeMST(edges, i, n);\\n            int val2 = makeMSTwithIndex(edges, i, n);\\n\\n            if(val > minWtMST){\\n                critical.push_back(edges[i][3]);\\n            }\\n            if(val == val2){\\n                pseudoCritical.push_back(edges[i][3]);\\n            }\\n        }\\n\\n        res.push_back(critical);\\n        res.push_back(pseudoCritical);\\n\\n        return res;\\n\\n    }\\n\\n    static bool comp(vector<int>a, vector<int>b){\\n        return a[2] < b[2];\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), comp);\\n        return criticalnpseudoCritical(edges, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int parent[101];\\n    int rank[101];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            rank[i] = 0;\\n        }\\n    }\\n\\n    int findParent(int n){\\n        if(parent[n] == n)\\n            return n;\\n        \\n        return parent[n] = findParent(parent[n]);\\n    }\\n\\n    void unionDSU(int a, int b){\\n        int para = findParent(a);\\n        int parb = findParent(b);\\n        if(para == parb)\\n            return;;\\n        \\n        int ranka = rank[para];\\n        int rankb = rank[parb];\\n        \\n        if(ranka > rankb)\\n            parent[parb] = para;\\n        else if(rankb > ranka)\\n            parent[para] = parb;\\n        else{\\n            parent[para] = parb;\\n            rank[parb]+=1;\\n        }\\n    }\\n\\npublic:\\n    int makeMST(vector<vector<int>>&edges, int index, int n){\\n        dsu(n);\\n        int res = 0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            if(i == index)\\n                continue;\\n            \\n            int para = findParent(edges[i][0]);\\n            int parb = findParent(edges[i][1]);\\n            if(para!=parb){\\n                res+=edges[i][2];\\n                unionDSU(edges[i][0], edges[i][1]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int makeMSTwithIndex(vector<vector<int>>&edges, int index, int n){\\n        dsu(n);\\n        int res = edges[index][2];\\n\\n        unionDSU(edges[index][0], edges[index][1]);\\n\\n        for(int i=0;i<edges.size();i++){\\n            int para = findParent(edges[i][0]);\\n            int parb = findParent(edges[i][1]);\\n            if(para!=parb){\\n                res+=edges[i][2];\\n                unionDSU(edges[i][0], edges[i][1]);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void dfs(vector<pair<int, int>>adj[], int node, vector<int>&vis){\\n        vis[node] = 1;\\n        for(auto it: adj[node]){\\n            if(vis[it.first] == 0)\\n                dfs(adj, it.first, vis);\\n        }\\n    }\\n\\n    vector<vector<int>>criticalnpseudoCritical(vector<vector<int>>&edges, int n){\\n        int minWtMST = makeMST(edges, -1, n);\\n\\n        vector<vector<int>>res;\\n        vector<int>critical;\\n        vector<int>pseudoCritical;\\n\\n        for(int i=0;i<edges.size();i++){\\n            vector<pair<int, int>>adj[n];\\n            for(int j=0;j<edges.size();j++){\\n                if(i == j) continue;\\n                int a = edges[j][0];\\n                int b = edges[j][1];\\n                int wt = edges[j][2];\\n\\n                adj[a].push_back({b, wt});\\n                adj[b].push_back({a, wt});\\n            }\\n            int compCount = 0;\\n            vector<int>vis(n, 0);\\n\\n            for(int j=0;j<n;j++){\\n                if(!vis[j]){\\n                    ++compCount;\\n                    dfs(adj, j, vis);\\n                }\\n            }\\n\\n            if(compCount > 1){\\n                critical.push_back(edges[i][3]);\\n                continue;\\n            }\\n            \\n            int val = makeMST(edges, i, n);\\n            int val2 = makeMSTwithIndex(edges, i, n);\\n\\n            if(val > minWtMST){\\n                critical.push_back(edges[i][3]);\\n            }\\n            if(val == val2){\\n                pseudoCritical.push_back(edges[i][3]);\\n            }\\n        }\\n\\n        res.push_back(critical);\\n        res.push_back(pseudoCritical);\\n\\n        return res;\\n\\n    }\\n\\n    static bool comp(vector<int>a, vector<int>b){\\n        return a[2] < b[2];\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), comp);\\n        return criticalnpseudoCritical(edges, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929180,
                "title": "prim-s-algo-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrim\\'s algo\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def prim(edges, forced_edge=None):\\n            visited = [False] * n\\n            edge_list = [[] for _ in range(n)]\\n            for i, (u, v, w) in enumerate(edges):\\n                edge_list[u].append((v, w, i))\\n                edge_list[v].append((u, w, i))\\n\\n            weight = 0\\n            pq = []\\n\\n            if forced_edge is not None:\\n                u, v, w = edges[forced_edge]\\n                visited[u] = True\\n                visited[v] = True\\n                weight += w\\n                for nxt, w, idx in edge_list[u]:\\n                    heapq.heappush(pq, (w, nxt, idx))\\n                for nxt, w, idx in edge_list[v]:\\n                    heapq.heappush(pq, (w, nxt, idx))\\n            else:\\n                heapq.heappush(pq, (0, 0, -1))\\n\\n            while pq:\\n                w, v, idx = heapq.heappop(pq)\\n                if not visited[v]:\\n                    visited[v] = True\\n                    weight += w\\n                    for nxt, nxt_w, nxt_idx in edge_list[v]:\\n                        if not visited[nxt]:\\n                            heapq.heappush(pq, (nxt_w, nxt, nxt_idx))\\n\\n            if sum(visited) != n:  # Not all vertices were visited\\n                return float(\\'inf\\')\\n\\n            return weight\\n\\n        # Find the weight of the original MST\\n        mst_weight = prim(edges)\\n\\n        criticals, pseudo_criticals = [], []\\n\\n        # Check for critical edges\\n        for i in range(len(edges)):\\n            new_weight = prim(edges[:i] + edges[i+1:])\\n            if new_weight > mst_weight:\\n                criticals.append(i)\\n\\n        # Check for pseudo-critical edges\\n        for i in range(len(edges)):\\n            if i not in criticals:\\n                new_weight = prim(edges, i)\\n                if new_weight == mst_weight:\\n                    pseudo_criticals.append(i)\\n\\n        return [criticals, pseudo_criticals]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def prim(edges, forced_edge=None):\\n            visited = [False] * n\\n            edge_list = [[] for _ in range(n)]\\n            for i, (u, v, w) in enumerate(edges):\\n                edge_list[u].append((v, w, i))\\n                edge_list[v].append((u, w, i))\\n\\n            weight = 0\\n            pq = []\\n\\n            if forced_edge is not None:\\n                u, v, w = edges[forced_edge]\\n                visited[u] = True\\n                visited[v] = True\\n                weight += w\\n                for nxt, w, idx in edge_list[u]:\\n                    heapq.heappush(pq, (w, nxt, idx))\\n                for nxt, w, idx in edge_list[v]:\\n                    heapq.heappush(pq, (w, nxt, idx))\\n            else:\\n                heapq.heappush(pq, (0, 0, -1))\\n\\n            while pq:\\n                w, v, idx = heapq.heappop(pq)\\n                if not visited[v]:\\n                    visited[v] = True\\n                    weight += w\\n                    for nxt, nxt_w, nxt_idx in edge_list[v]:\\n                        if not visited[nxt]:\\n                            heapq.heappush(pq, (nxt_w, nxt, nxt_idx))\\n\\n            if sum(visited) != n:  # Not all vertices were visited\\n                return float(\\'inf\\')\\n\\n            return weight\\n\\n        # Find the weight of the original MST\\n        mst_weight = prim(edges)\\n\\n        criticals, pseudo_criticals = [], []\\n\\n        # Check for critical edges\\n        for i in range(len(edges)):\\n            new_weight = prim(edges[:i] + edges[i+1:])\\n            if new_weight > mst_weight:\\n                criticals.append(i)\\n\\n        # Check for pseudo-critical edges\\n        for i in range(len(edges)):\\n            if i not in criticals:\\n                new_weight = prim(edges, i)\\n                if new_weight == mst_weight:\\n                    pseudo_criticals.append(i)\\n\\n        return [criticals, pseudo_criticals]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929000,
                "title": "daily-leetcoding-challenge-august-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Kruskal's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3860909,
                "title": "python-kruskal-union-find-very-detailed-explained",
                "content": "Spent 2 hours solving this problem, but I think the logic is pretty simple. I will use an example to demonstrate.\\nWe basically only need to figure out these:\\n1. We need to use Kruskal to find out the min_cost of forming this minimal spanning tree\\n2. Then we will use a for loop to delete edge one by one, in total of len(edges) {NOT IN TOTAL OF N}, to check critical edges and pseudo-critical edges \\nHow do we do this?\\nWe use Kruskal again to calculate the new cost if we do not use this edge\\nAt this point, there will only be two result: \\nif the new_cost is larger than min_cost\\nor the new_cost  == min_cost\\nNo way the new cost is smaller because we already calculated the MST cost.\\n\\nLogic Point: \\n1. Anytime we delete an edge and the result is larger than min_cost or it cannot connect all nodes, We know it is a critical edge\\n2. THIS is the most important Corner Case: if we delete one edge and the new_cost == min_cost, there could be two possibilities:\\nOne: We deleted an edge, but the new graph formed by using another path and it worked.\\nSecond: Or we deleted an edge that we never need it in any path of MST.\\n\\nFor example, if we have 5 nodes, with distance of \\nNode1- Node2:  1 Meter\\nNode2-Node3: 1 M\\nN3-N4: 1M\\nN4-N5: 1M\\nN1-N5: 6M\\nwe never need to use this N1-N5 edge\\n\\nHow do we know if we never need this edge?\\nSo, after we see the new_cost == min_cost, we need to do a new calculation. We will forcely use this edge and see if the new_cost is still == min_cost. If the new_cost is larger than min_cost, it means this edge was never needed in the MST. \\nOnly if we use this edge and the new_cost of MST is still the same as min_cost, we know this is a pseudo-critical edges(We can choose to use it to form the MST, or we can choose not to use it).\\n\\nOriginal Version with two function one to calculate kruskal, one to calculate Kruskal with forcely used edge\\n\\n\\tclass Solution:\\n\\t\\tdef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\tdef kruskal(n, graph):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\tres= 0\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tdef kruskal2(n, graph, check):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\ta, b, d = check\\n\\t\\t\\t\\tp[find(a)] = find(b)\\n\\t\\t\\t\\tres= d\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tmin_cost= kruskal(n, edges)\\n\\t\\t\\tres = [[],[]]\\n\\n\\t\\t\\tfor i in range(len(edges)):\\n\\t\\t\\t\\tcheck = edges[i]\\n\\t\\t\\t\\ttmp = edges[:i] + edges[i+1:]\\n\\t\\t\\t\\tnew_res = kruskal(n, tmp)\\n\\t\\t\\t\\tif new_res > min_cost:\\n\\t\\t\\t\\t\\tres[0].append(i)\\n\\t\\t\\t\\telif kruskal2(n, tmp, check) == min_cost:\\n\\t\\t\\t\\t\\tres[1].append(i)\\n\\t\\t\\treturn res\\n\\nAnd an Optimized Version:\\n\\n\\tclass Solution:\\n\\t\\tdef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:        \\n\\t\\t\\tdef kruskal(n, graph, check = None):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\tres= 0\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tif check:\\n\\t\\t\\t\\t\\ta, b, d = check\\n\\t\\t\\t\\t\\tp[find(a)] = find(b)\\n\\t\\t\\t\\t\\tres= d\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tmin_cost= kruskal(n, edges)\\n\\t\\t\\tres = [[],[]]\\n\\n\\t\\t\\tfor i in range(len(edges)):\\n\\t\\t\\t\\tcheck = edges[i]\\n\\t\\t\\t\\ttmp = edges[:i] + edges[i+1:]\\n\\t\\t\\t\\tif kruskal(n, tmp)> min_cost:\\n\\t\\t\\t\\t\\tres[0].append(i)\\n\\t\\t\\t\\telif kruskal(n, tmp, check) == min_cost:\\n\\t\\t\\t\\t\\tres[1].append(i)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "Spent 2 hours solving this problem, but I think the logic is pretty simple. I will use an example to demonstrate.\\nWe basically only need to figure out these:\\n1. We need to use Kruskal to find out the min_cost of forming this minimal spanning tree\\n2. Then we will use a for loop to delete edge one by one, in total of len(edges) {NOT IN TOTAL OF N}, to check critical edges and pseudo-critical edges \\nHow do we do this?\\nWe use Kruskal again to calculate the new cost if we do not use this edge\\nAt this point, there will only be two result: \\nif the new_cost is larger than min_cost\\nor the new_cost  == min_cost\\nNo way the new cost is smaller because we already calculated the MST cost.\\n\\nLogic Point: \\n1. Anytime we delete an edge and the result is larger than min_cost or it cannot connect all nodes, We know it is a critical edge\\n2. THIS is the most important Corner Case: if we delete one edge and the new_cost == min_cost, there could be two possibilities:\\nOne: We deleted an edge, but the new graph formed by using another path and it worked.\\nSecond: Or we deleted an edge that we never need it in any path of MST.\\n\\nFor example, if we have 5 nodes, with distance of \\nNode1- Node2:  1 Meter\\nNode2-Node3: 1 M\\nN3-N4: 1M\\nN4-N5: 1M\\nN1-N5: 6M\\nwe never need to use this N1-N5 edge\\n\\nHow do we know if we never need this edge?\\nSo, after we see the new_cost == min_cost, we need to do a new calculation. We will forcely use this edge and see if the new_cost is still == min_cost. If the new_cost is larger than min_cost, it means this edge was never needed in the MST. \\nOnly if we use this edge and the new_cost of MST is still the same as min_cost, we know this is a pseudo-critical edges(We can choose to use it to form the MST, or we can choose not to use it).\\n\\nOriginal Version with two function one to calculate kruskal, one to calculate Kruskal with forcely used edge\\n\\n\\tclass Solution:\\n\\t\\tdef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\tdef kruskal(n, graph):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\tres= 0\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tdef kruskal2(n, graph, check):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\ta, b, d = check\\n\\t\\t\\t\\tp[find(a)] = find(b)\\n\\t\\t\\t\\tres= d\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tmin_cost= kruskal(n, edges)\\n\\t\\t\\tres = [[],[]]\\n\\n\\t\\t\\tfor i in range(len(edges)):\\n\\t\\t\\t\\tcheck = edges[i]\\n\\t\\t\\t\\ttmp = edges[:i] + edges[i+1:]\\n\\t\\t\\t\\tnew_res = kruskal(n, tmp)\\n\\t\\t\\t\\tif new_res > min_cost:\\n\\t\\t\\t\\t\\tres[0].append(i)\\n\\t\\t\\t\\telif kruskal2(n, tmp, check) == min_cost:\\n\\t\\t\\t\\t\\tres[1].append(i)\\n\\t\\t\\treturn res\\n\\nAnd an Optimized Version:\\n\\n\\tclass Solution:\\n\\t\\tdef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:        \\n\\t\\t\\tdef kruskal(n, graph, check = None):\\n\\t\\t\\t\\tp = [i for i in range(n)]\\n\\t\\t\\t\\tdef find(i):\\n\\t\\t\\t\\t\\tif p[i] != i:\\n\\t\\t\\t\\t\\t\\tp[i] = find(p[i])\\n\\t\\t\\t\\t\\treturn p[i]\\n\\t\\t\\t\\tg = sorted(graph, key = lambda x:x[2])\\n\\t\\t\\t\\tres= 0\\n\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\tif check:\\n\\t\\t\\t\\t\\ta, b, d = check\\n\\t\\t\\t\\t\\tp[find(a)] = find(b)\\n\\t\\t\\t\\t\\tres= d\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\tfor i, j, dist in g:\\n\\t\\t\\t\\t\\tif find(i) != find(j):\\n\\t\\t\\t\\t\\t\\tp[find(i)] = find(j)\\n\\t\\t\\t\\t\\t\\tres += dist\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count == n - 1:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn res if count == n-1 else float(\"inf\")\\n\\n\\t\\t\\tmin_cost= kruskal(n, edges)\\n\\t\\t\\tres = [[],[]]\\n\\n\\t\\t\\tfor i in range(len(edges)):\\n\\t\\t\\t\\tcheck = edges[i]\\n\\t\\t\\t\\ttmp = edges[:i] + edges[i+1:]\\n\\t\\t\\t\\tif kruskal(n, tmp)> min_cost:\\n\\t\\t\\t\\t\\tres[0].append(i)\\n\\t\\t\\t\\telif kruskal(n, tmp, check) == min_cost:\\n\\t\\t\\t\\t\\tres[1].append(i)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 3799657,
                "title": "mst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Critical edges` : `on excluding this edge(u,v) the mst sum will increase`\\n\\n`Pseudo Critcal edges` : `on including this edge(u,v) the mst sum will not affect`\\n\\n`1.` Find MST sum using standard Kruskal\\'s Algorithm\\n`2.` Iterate on every edges and try to exclude that edges and check if the mst sum decrease or increase. If MST sum increase and all the vertex are in the same component then it\\'s critcal edges or if all the vertex are not in same component then it\\'s also critcal edges.\\n * `we can check if all the vertex in the same component by storing their parents or if the mst sum decerases then it\\'s it siginifies that all the vertex are not in the same component. (check 2nd code block for more clear understanding)`\\n\\n`3.` Iterate on every edge again and try to iclude this edge and if MST sum is same as intial then it\\'s pseudo critical edges.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* `Kruskal Algorithm`: Sort the edges in increasing order according to their weights and use dsu to include edges and on including the particular edges if we get cycle then ignore this edge.\\n\\n# Two approach\\n```C++ []\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        // custom merging\\n        void merge(){\\n         \\n        }\\n        int getsize(int n){\\n         return size[n];\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    int kruskal(vector<vector<int>>&edges,int n,pair<pair<int,int>,int> include,int ignore=-1){\\n        DSU ds(n);\\n        int mst = 0;\\n        if(include.second != -1){\\n            ds.unionS(include.first.first,include.first.second);\\n            mst += include.second;\\n        }\\n        for(auto&e: edges){\\n            int u = e[0], v = e[1], wt = e[2], id = e[3];\\n            if(id == ignore) continue;\\n            if(ds.find(u) != ds.find(v)){\\n                mst += wt;\\n                ds.unionS(u,v);\\n            }\\n        }\\n        int cc = ds.find(0);\\n        for(int i=1; i<n; ++i){\\n            if(ds.find(i) != cc) return 1e9;\\n        }\\n        return mst;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = size(edges);\\n        for(int i=0; i<m; ++i) edges[i].push_back(i);\\n        sort(begin(edges),end(edges),[](auto&a,auto&b){return a[2] < b[2];});\\n\\n        vector<int> critical, pseudocritical;\\n        unordered_set<int> critcalset;\\n\\n        int mst = kruskal(edges,n,{{-1,-1},-1});\\n\\n        for(auto&e: edges){\\n            int x = kruskal(edges,n,{{-1,-1},-1},e[3]);\\n            if(x > mst){\\n                critical.push_back(e[3]);\\n                critcalset.insert(e[3]);\\n            }\\n        }\\n\\n        for(auto&e: edges){\\n            pair<pair<int,int>,int> p = {{e[0],e[1]},e[2]};\\n            int x = kruskal(edges,n,p);\\n            if(x == mst && !critcalset.count(e[3])) pseudocritical.push_back(e[3]);\\n        }\\n        \\n        return {critical,pseudocritical};\\n    }\\n};\\n```\\n```C++ []\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        // custom merging\\n        void merge(){\\n         \\n        }\\n        int getsize(int n){\\n         return size[n];\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    int mstsum = 0;\\n    int kruskal(vector<vector<int>>&edges,int n,pair<pair<int,int>,int> include,int ignore=-1){\\n        DSU ds(n);\\n        int mst = 0;\\n        if(include.second != -1){\\n            ds.unionS(include.first.first,include.first.second);\\n            mst += include.second;\\n        }\\n        for(auto&e: edges){\\n            int u = e[0], v = e[1], wt = e[2], id = e[3];\\n            if(id == ignore) continue;\\n            if(ds.find(u) != ds.find(v)){\\n                mst += wt;\\n                ds.unionS(u,v);\\n            }\\n        }\\n        if(mst < mstsum) return 1e9;\\n        return mst;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = size(edges);\\n        for(int i=0; i<m; ++i) edges[i].push_back(i);\\n        sort(begin(edges),end(edges),[](auto&a,auto&b){return a[2] < b[2];});\\n\\n        vector<int> critical, pseudocritical;\\n        unordered_set<int> critcalset;\\n \\n        int mst = kruskal(edges,n,{{-1,-1},-1});\\n        mstsum = mst;\\n\\n        for(auto&e: edges){\\n            int x = kruskal(edges,n,{{-1,-1},-1},e[3]);\\n            if(x > mst){\\n                critical.push_back(e[3]);\\n                critcalset.insert(e[3]);\\n            }\\n        }\\n\\n        for(auto&e: edges){\\n            pair<pair<int,int>,int> p = {{e[0],e[1]},e[2]};\\n            int x = kruskal(edges,n,p);\\n            if(x == mst && !critcalset.count(e[3])) pseudocritical.push_back(e[3]);\\n        }\\n\\n        return {critical,pseudocritical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```C++ []\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        // custom merging\\n        void merge(){\\n         \\n        }\\n        int getsize(int n){\\n         return size[n];\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    int kruskal(vector<vector<int>>&edges,int n,pair<pair<int,int>,int> include,int ignore=-1){\\n        DSU ds(n);\\n        int mst = 0;\\n        if(include.second != -1){\\n            ds.unionS(include.first.first,include.first.second);\\n            mst += include.second;\\n        }\\n        for(auto&e: edges){\\n            int u = e[0], v = e[1], wt = e[2], id = e[3];\\n            if(id == ignore) continue;\\n            if(ds.find(u) != ds.find(v)){\\n                mst += wt;\\n                ds.unionS(u,v);\\n            }\\n        }\\n        int cc = ds.find(0);\\n        for(int i=1; i<n; ++i){\\n            if(ds.find(i) != cc) return 1e9;\\n        }\\n        return mst;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = size(edges);\\n        for(int i=0; i<m; ++i) edges[i].push_back(i);\\n        sort(begin(edges),end(edges),[](auto&a,auto&b){return a[2] < b[2];});\\n\\n        vector<int> critical, pseudocritical;\\n        unordered_set<int> critcalset;\\n\\n        int mst = kruskal(edges,n,{{-1,-1},-1});\\n\\n        for(auto&e: edges){\\n            int x = kruskal(edges,n,{{-1,-1},-1},e[3]);\\n            if(x > mst){\\n                critical.push_back(e[3]);\\n                critcalset.insert(e[3]);\\n            }\\n        }\\n\\n        for(auto&e: edges){\\n            pair<pair<int,int>,int> p = {{e[0],e[1]},e[2]};\\n            int x = kruskal(edges,n,p);\\n            if(x == mst && !critcalset.count(e[3])) pseudocritical.push_back(e[3]);\\n        }\\n        \\n        return {critical,pseudocritical};\\n    }\\n};\\n```\n```C++ []\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        // custom merging\\n        void merge(){\\n         \\n        }\\n        int getsize(int n){\\n         return size[n];\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    int mstsum = 0;\\n    int kruskal(vector<vector<int>>&edges,int n,pair<pair<int,int>,int> include,int ignore=-1){\\n        DSU ds(n);\\n        int mst = 0;\\n        if(include.second != -1){\\n            ds.unionS(include.first.first,include.first.second);\\n            mst += include.second;\\n        }\\n        for(auto&e: edges){\\n            int u = e[0], v = e[1], wt = e[2], id = e[3];\\n            if(id == ignore) continue;\\n            if(ds.find(u) != ds.find(v)){\\n                mst += wt;\\n                ds.unionS(u,v);\\n            }\\n        }\\n        if(mst < mstsum) return 1e9;\\n        return mst;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        int m = size(edges);\\n        for(int i=0; i<m; ++i) edges[i].push_back(i);\\n        sort(begin(edges),end(edges),[](auto&a,auto&b){return a[2] < b[2];});\\n\\n        vector<int> critical, pseudocritical;\\n        unordered_set<int> critcalset;\\n \\n        int mst = kruskal(edges,n,{{-1,-1},-1});\\n        mstsum = mst;\\n\\n        for(auto&e: edges){\\n            int x = kruskal(edges,n,{{-1,-1},-1},e[3]);\\n            if(x > mst){\\n                critical.push_back(e[3]);\\n                critcalset.insert(e[3]);\\n            }\\n        }\\n\\n        for(auto&e: edges){\\n            pair<pair<int,int>,int> p = {{e[0],e[1]},e[2]};\\n            int x = kruskal(edges,n,p);\\n            if(x == mst && !critcalset.count(e[3])) pseudocritical.push_back(e[3]);\\n        }\\n\\n        return {critical,pseudocritical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613346,
                "title": "dsu-mst-algorithm-c",
                "content": "# Intuition\\nFor each edge, compare the MST weight achieved after removing that edge and fixing that edge.\\n**Critical Edge:** The ones, for which the MST achieved after removal is more weighted or not possible. They would be a part of each and every Spanning Tree possiple from that graph.\\n \\n**Pseudo-Critical Edge:** The ones, for which the MST achieved after fixing gives same weight. They are the alternative connections that would lead also lead to a Minimum Spannig Tree. \\n\\n# Approach\\nLet, \\n    **min_MST =** weight recieved without removing of fixing any edges\\n    **weight_after_removing =** weight recieved if we skip this edge\\n    **weight_if_fixed =** weight recieved if we fix this edge in MST\\n\\nHence we can check if an Edge is Critical if:\\n```\\nIf (weight_after_removing > min_MST)\\n```\\nAn Edge is pseudo-Critical if:\\n```\\nIf (weight_if_fixed == min_MST)\\n```\\n\\nHence,\\n```\\nfor(edge : edges){\\n    int wt_after_removing = getMSTweight(skiping this edge);\\n    int wt_if_added = getMSTweight(fixing this edge);\\n    \\n    if(wt_after_removing > min_wt) critical.push_back(i);\\n    else if(wt_if_added == min_wt) Pcritical.push_back(i);\\n}\\n``` \\n\\n# Complexity\\n- Time complexity: $$O(E*E + Elog(E))$$\\n\\n- Space complexity: $$O(E)$$\\n- Auxiliary space: $$O(V)$$\\n\\n# Code\\n```\\nclass DSU{\\n    vector<int> rank;\\n    vector<int> par;\\n    int find(int x){\\n        if(x == par[x]) return par[x];\\n        return par[x] = find(par[x]);\\n    }\\n\\n    bool unite(int x, int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return false;\\n\\n        if(rank[x] < rank[y]){ par[x] = y; }\\n        else if(rank[x] > rank[y]){ par[y] = x; }\\n        else{\\n            ++rank[x]; par[y] = x;\\n        }\\n        return true;\\n    }\\n    public:\\n    DSU(int n){\\n        rank.resize(n+1, 0);\\n        par.resize(n+1, 0);\\n    }\\n\\n    int getMSTweight(int n, vector<vector<int>>& ed, int e_focused, bool to_be_fixed){\\n        int MST_wt = 0;\\n        for(int i=0; i<=n; ++i){ \\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n        if(to_be_fixed){\\n            for(int i=0; i<ed.size(); ++i){\\n                if(ed[i][3] == e_focused){\\n                    if(unite(ed[i][0], ed[i][1])){\\n                        MST_wt += ed[i][2];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<ed.size(); ++i){\\n            if(ed[i][3] == e_focused) continue;\\n            else{\\n                if(unite(ed[i][0], ed[i][1])){\\n                    MST_wt += ed[i][2];\\n                }\\n            }\\n        }\\n        int rt = find(0);\\n        // If all edges do not have a common par -> Not possible to make MST\\n        for(int i=1; i<n; ++i) if(find(i) != rt) return 1e8;\\n        return MST_wt;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        DSU* g = new DSU(n);\\n\\n        for(int i=0; i<edges.size(); ++i){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b){\\n            return a[2] < b[2];\\n        });\\n\\n        int min_wt = g->getMSTweight(n, edges, -1, false);\\n        // cout<<min_wt<<endl;\\n\\n        for(int i=0; i<edges.size(); ++i){\\n            int wt_after_removing = g->getMSTweight(n, edges, i, false);\\n            int wt_if_added = g->getMSTweight(n, edges, i, true);\\n            // cout<<\"wt aft removing\"<<\" \"<<i<<\" = \"<<wt_after_removing<<\",\"<<wt_if_added<<endl;\\n            if(wt_after_removing > min_wt){\\n                ans[0].push_back(i);\\n            }\\n            else if(wt_if_added == min_wt){\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nIf (weight_after_removing > min_MST)\\n```\n```\\nIf (weight_if_fixed == min_MST)\\n```\n```\\nfor(edge : edges){\\n    int wt_after_removing = getMSTweight(skiping this edge);\\n    int wt_if_added = getMSTweight(fixing this edge);\\n    \\n    if(wt_after_removing > min_wt) critical.push_back(i);\\n    else if(wt_if_added == min_wt) Pcritical.push_back(i);\\n}\\n```\n```\\nclass DSU{\\n    vector<int> rank;\\n    vector<int> par;\\n    int find(int x){\\n        if(x == par[x]) return par[x];\\n        return par[x] = find(par[x]);\\n    }\\n\\n    bool unite(int x, int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return false;\\n\\n        if(rank[x] < rank[y]){ par[x] = y; }\\n        else if(rank[x] > rank[y]){ par[y] = x; }\\n        else{\\n            ++rank[x]; par[y] = x;\\n        }\\n        return true;\\n    }\\n    public:\\n    DSU(int n){\\n        rank.resize(n+1, 0);\\n        par.resize(n+1, 0);\\n    }\\n\\n    int getMSTweight(int n, vector<vector<int>>& ed, int e_focused, bool to_be_fixed){\\n        int MST_wt = 0;\\n        for(int i=0; i<=n; ++i){ \\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n        if(to_be_fixed){\\n            for(int i=0; i<ed.size(); ++i){\\n                if(ed[i][3] == e_focused){\\n                    if(unite(ed[i][0], ed[i][1])){\\n                        MST_wt += ed[i][2];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<ed.size(); ++i){\\n            if(ed[i][3] == e_focused) continue;\\n            else{\\n                if(unite(ed[i][0], ed[i][1])){\\n                    MST_wt += ed[i][2];\\n                }\\n            }\\n        }\\n        int rt = find(0);\\n        // If all edges do not have a common par -> Not possible to make MST\\n        for(int i=1; i<n; ++i) if(find(i) != rt) return 1e8;\\n        return MST_wt;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        DSU* g = new DSU(n);\\n\\n        for(int i=0; i<edges.size(); ++i){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b){\\n            return a[2] < b[2];\\n        });\\n\\n        int min_wt = g->getMSTweight(n, edges, -1, false);\\n        // cout<<min_wt<<endl;\\n\\n        for(int i=0; i<edges.size(); ++i){\\n            int wt_after_removing = g->getMSTweight(n, edges, i, false);\\n            int wt_if_added = g->getMSTweight(n, edges, i, true);\\n            // cout<<\"wt aft removing\"<<\" \"<<i<<\" = \"<<wt_after_removing<<\",\"<<wt_if_added<<endl;\\n            if(wt_after_removing > min_wt){\\n                ans[0].push_back(i);\\n            }\\n            else if(wt_if_added == min_wt){\\n                ans[1].push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3538818,
                "title": "golang-kruskal-dsu-with-comments",
                "content": "\\n![Screenshot](https://assets.leetcode.com/users/images/0a354c1f-81f4-4624-a5c7-c2987e7231e3_1684421920.6242251.png)\\n\\n```golang []\\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\\n    // Save initial indexes before sorting\\n    for i := range edges { edges[i] = append(edges[i], i) }\\n\\n    // Sort by weight for using it in Kruskal algo\\n    sort.Slice(edges, func(i, j int) bool { return edges[i][2] < edges[j][2] })\\n\\n    // Reusable DSU struct\\n    dsu := newDSU(n)\\n    \\n    // Find the weight of MST using all edges\\n    mstWeight := findMstWeight(n, edges, nil, &dsu)\\n    critical, pseudoCritical := []int{}, []int{}\\n\\n    // Iterate through all edges\\n    for _, edge := range edges {\\n        // Force to use this edge\\n        if findMstWeight(n, edges, edge, &dsu) > mstWeight {\\n            // This edge is not part of any mst\\n            continue\\n        }\\n\\n        // Make this edge weight 0, so the algo skips it\\n        edgeWeight := edge[2]\\n        edge[2] = 0\\n\\n        if findMstWeight(n, edges, nil, &dsu) == mstWeight {\\n            // A part of some msts, but not all, because found\\n            // another path without this edge but the same weight \\n            pseudoCritical = append(pseudoCritical, edge[3])\\n        } else {\\n            // It\\'s greater than mstWeight or equal to -1:\\n            // A part of all possible msts, otherwise the algo\\n            // would have found another path with the same weight \\n            critical = append(critical, edge[3])\\n        }\\n\\n        // Revert the weight change\\n        edge[2] = edgeWeight\\n    }\\n\\n    return [][]int{critical, pseudoCritical}\\n}\\n\\n//////////////////\\n// Kruskal algo //\\n//////////////////\\nfunc findMstWeight(n int, edges [][]int, forcedEdge []int, dsu *DSU) int {\\n    // Reuse the same dsu instead of creating a new one (for memory optimisation)\\n    dsu.Reset()\\n    mstWeight := 0\\n\\n    if forcedEdge != nil {\\n        dsu.Union(forcedEdge[0], forcedEdge[1])\\n        mstWeight += forcedEdge[2]\\n    }\\n\\n    for ei := 0; ei < len(edges) && dsu.isles > 1; ei++ {\\n        u, v, weight := edges[ei][0], edges[ei][1], edges[ei][2]\\n        if weight == 0 { continue } // Skip with weight 0\\n        if dsu.Connected(u, v) { continue } // Sets were already connected, avoid cycles\\n        dsu.Union(u, v)\\n        mstWeight += weight\\n    }\\n    return mstWeight\\n}\\n\\n////////////////////////////////\\n// DSU implementation with    //\\n// ranks and path compression //\\n////////////////////////////////\\ntype DSU struct {\\n    parent, rank []int\\n    n, isles int\\n}\\nfunc newDSU(n int) DSU {\\n    dsu := DSU{make([]int, n), make([]int, n), n, n}\\n    dsu.Reset()\\n    return dsu\\n}\\nfunc (dsu *DSU) Reset() {\\n    dsu.isles = dsu.n\\n    for i := range dsu.parent {\\n        dsu.parent[i] = i\\n        dsu.rank[i] = 0\\n    }\\n}\\nfunc (dsu *DSU) Find(i int) int {\\n    if i != dsu.parent[i] {\\n        dsu.parent[i] = dsu.Find(dsu.parent[i])\\n    }\\n    return dsu.parent[i]\\n}\\nfunc (dsu *DSU) Connected(i, j int) bool {\\n    return dsu.Find(i) == dsu.Find(j)\\n}\\nfunc (dsu *DSU) Union(i, j int) {\\n    ip, jp := dsu.Find(i), dsu.Find(j)\\n    if ip == jp { return }\\n    if dsu.rank[ip] < dsu.rank[jp] {\\n        dsu.parent[ip] = jp\\n    } else if dsu.rank[jp] < dsu.rank[ip] {\\n        dsu.parent[jp] = ip\\n    } else {\\n        dsu.parent[jp] = ip\\n        dsu.rank[ip]++\\n    }\\n    dsu.isles--\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```golang []\\nfunc findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\\n    // Save initial indexes before sorting\\n    for i := range edges { edges[i] = append(edges[i], i) }\\n\\n    // Sort by weight for using it in Kruskal algo\\n    sort.Slice(edges, func(i, j int) bool { return edges[i][2] < edges[j][2] })\\n\\n    // Reusable DSU struct\\n    dsu := newDSU(n)\\n    \\n    // Find the weight of MST using all edges\\n    mstWeight := findMstWeight(n, edges, nil, &dsu)\\n    critical, pseudoCritical := []int{}, []int{}\\n\\n    // Iterate through all edges\\n    for _, edge := range edges {\\n        // Force to use this edge\\n        if findMstWeight(n, edges, edge, &dsu) > mstWeight {\\n            // This edge is not part of any mst\\n            continue\\n        }\\n\\n        // Make this edge weight 0, so the algo skips it\\n        edgeWeight := edge[2]\\n        edge[2] = 0\\n\\n        if findMstWeight(n, edges, nil, &dsu) == mstWeight {\\n            // A part of some msts, but not all, because found\\n            // another path without this edge but the same weight \\n            pseudoCritical = append(pseudoCritical, edge[3])\\n        } else {\\n            // It\\'s greater than mstWeight or equal to -1:\\n            // A part of all possible msts, otherwise the algo\\n            // would have found another path with the same weight \\n            critical = append(critical, edge[3])\\n        }\\n\\n        // Revert the weight change\\n        edge[2] = edgeWeight\\n    }\\n\\n    return [][]int{critical, pseudoCritical}\\n}\\n\\n//////////////////\\n// Kruskal algo //\\n//////////////////\\nfunc findMstWeight(n int, edges [][]int, forcedEdge []int, dsu *DSU) int {\\n    // Reuse the same dsu instead of creating a new one (for memory optimisation)\\n    dsu.Reset()\\n    mstWeight := 0\\n\\n    if forcedEdge != nil {\\n        dsu.Union(forcedEdge[0], forcedEdge[1])\\n        mstWeight += forcedEdge[2]\\n    }\\n\\n    for ei := 0; ei < len(edges) && dsu.isles > 1; ei++ {\\n        u, v, weight := edges[ei][0], edges[ei][1], edges[ei][2]\\n        if weight == 0 { continue } // Skip with weight 0\\n        if dsu.Connected(u, v) { continue } // Sets were already connected, avoid cycles\\n        dsu.Union(u, v)\\n        mstWeight += weight\\n    }\\n    return mstWeight\\n}\\n\\n////////////////////////////////\\n// DSU implementation with    //\\n// ranks and path compression //\\n////////////////////////////////\\ntype DSU struct {\\n    parent, rank []int\\n    n, isles int\\n}\\nfunc newDSU(n int) DSU {\\n    dsu := DSU{make([]int, n), make([]int, n), n, n}\\n    dsu.Reset()\\n    return dsu\\n}\\nfunc (dsu *DSU) Reset() {\\n    dsu.isles = dsu.n\\n    for i := range dsu.parent {\\n        dsu.parent[i] = i\\n        dsu.rank[i] = 0\\n    }\\n}\\nfunc (dsu *DSU) Find(i int) int {\\n    if i != dsu.parent[i] {\\n        dsu.parent[i] = dsu.Find(dsu.parent[i])\\n    }\\n    return dsu.parent[i]\\n}\\nfunc (dsu *DSU) Connected(i, j int) bool {\\n    return dsu.Find(i) == dsu.Find(j)\\n}\\nfunc (dsu *DSU) Union(i, j int) {\\n    ip, jp := dsu.Find(i), dsu.Find(j)\\n    if ip == jp { return }\\n    if dsu.rank[ip] < dsu.rank[jp] {\\n        dsu.parent[ip] = jp\\n    } else if dsu.rank[jp] < dsu.rank[ip] {\\n        dsu.parent[jp] = ip\\n    } else {\\n        dsu.parent[jp] = ip\\n        dsu.rank[ip]++\\n    }\\n    dsu.isles--\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333551,
                "title": "dsu-c",
                "content": "In this question we just need to try out finding all the msts by including and excluding a edge if excluding edge cost is greater  to the original cost of mst then it is critical edge or if including an edge cost is equal to original cost than it is psuedocritical edge,\\nbut we just need to be a careful when mst have not n-1 edges, it means we remove an edge that will necessary be a part of all the msts\\naccording to the question it will be an critical edge.\\n\\n# Code\\n```\\nbool sort_by_sec(const vector<int> &a,const vector<int>&b){\\n        return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    int find_parent(int u,vector<int> &parent){\\n        if(u==parent[u]) return u;\\n        return find_parent(parent[u],parent);\\n    }\\n    void union1(int u,int v,vector<int>&parent){\\n        int pu=find_parent(u,parent);\\n        int pv=find_parent(v,parent);\\n        if(pu!=pv){\\n              parent[pu]=pv;\\n        }\\n    }\\n   \\n    int MST(vector<vector<int>> &edges,int n,vector<int>&include,vector<int>&exclude){\\n        vector<int>parent(n);\\n        int calc_edes=0;\\n        for(int i=0;i<n;i++) parent[i]=i;\\n            int cost=0;\\n            if(include.size()!=0){\\n                int pu=find_parent(include[0],parent);\\n                int pv=find_parent(include[1],parent);\\n                union1(pu,pv,parent);\\n                cost+=include[2];\\n                calc_edes+=1;\\n            }\\n             for(auto it:edges){\\n                if(include.size()!=0 && it==include) continue;\\n                if(exclude.size()!=0 && it==exclude) continue;\\n                 int pu=find_parent(it[0],parent);\\n                int pv=find_parent(it[1],parent);\\n                if(pu!=pv){\\n                union1(pu,pv,parent);\\n                cost+=it[2];\\n                calc_edes+=1;\\n                }\\n             }\\n             return calc_edes==n-1 ? cost:INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {   \\n        \\n        \\n        vector<vector<int>> originalEdges;\\n        for(auto edge : edges) {\\n            vector<int> originalEdge{edge[0], edge[1], edge[2]};\\n            originalEdges.push_back(originalEdge);\\n        }\\n        sort(edges.begin(),edges.end(),sort_by_sec);\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int mst=MST(edges,n,temp,temp);\\n        // cout<<mst<<endl;\\n        // int c=0;\\n        vector<int> critical;\\n        vector<int> pseudpcritical;\\n        for(int edge=0;edge<edges.size();edge++){\\n            int exclude_cost=MST(edges,n,temp,originalEdges[edge]);\\n            int include_cost=MST(edges,n,originalEdges[edge],temp);\\n            if(exclude_cost>mst){\\n                critical.push_back(edge);\\n            }\\n            else if(include_cost==mst){\\n                pseudpcritical.push_back(edge);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pseudpcritical);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool sort_by_sec(const vector<int> &a,const vector<int>&b){\\n        return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    int find_parent(int u,vector<int> &parent){\\n        if(u==parent[u]) return u;\\n        return find_parent(parent[u],parent);\\n    }\\n    void union1(int u,int v,vector<int>&parent){\\n        int pu=find_parent(u,parent);\\n        int pv=find_parent(v,parent);\\n        if(pu!=pv){\\n              parent[pu]=pv;\\n        }\\n    }\\n   \\n    int MST(vector<vector<int>> &edges,int n,vector<int>&include,vector<int>&exclude){\\n        vector<int>parent(n);\\n        int calc_edes=0;\\n        for(int i=0;i<n;i++) parent[i]=i;\\n            int cost=0;\\n            if(include.size()!=0){\\n                int pu=find_parent(include[0],parent);\\n                int pv=find_parent(include[1],parent);\\n                union1(pu,pv,parent);\\n                cost+=include[2];\\n                calc_edes+=1;\\n            }\\n             for(auto it:edges){\\n                if(include.size()!=0 && it==include) continue;\\n                if(exclude.size()!=0 && it==exclude) continue;\\n                 int pu=find_parent(it[0],parent);\\n                int pv=find_parent(it[1],parent);\\n                if(pu!=pv){\\n                union1(pu,pv,parent);\\n                cost+=it[2];\\n                calc_edes+=1;\\n                }\\n             }\\n             return calc_edes==n-1 ? cost:INT_MAX;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {   \\n        \\n        \\n        vector<vector<int>> originalEdges;\\n        for(auto edge : edges) {\\n            vector<int> originalEdge{edge[0], edge[1], edge[2]};\\n            originalEdges.push_back(originalEdge);\\n        }\\n        sort(edges.begin(),edges.end(),sort_by_sec);\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        int mst=MST(edges,n,temp,temp);\\n        // cout<<mst<<endl;\\n        // int c=0;\\n        vector<int> critical;\\n        vector<int> pseudpcritical;\\n        for(int edge=0;edge<edges.size();edge++){\\n            int exclude_cost=MST(edges,n,temp,originalEdges[edge]);\\n            int include_cost=MST(edges,n,originalEdges[edge],temp);\\n            if(exclude_cost>mst){\\n                critical.push_back(edge);\\n            }\\n            else if(include_cost==mst){\\n                pseudpcritical.push_back(edge);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pseudpcritical);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3331250,
                "title": "c-unionfind",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        \\n        int mst=CreateMST(n,edges,-1,-1);\\n        List<IList<int>> res=new List<IList<int>>();\\n        \\n        res.Add(new List<int>());\\n        res.Add(new List<int>());\\n        \\n        for(int i=0;i<edges.Length;i++)\\n        {\\n            int sum=CreateMST(n,edges,-1,i);\\n            if(sum>mst)\\n                res[0].Add(i);\\n            else {\\n                sum=CreateMST(n,edges,i,-1);\\n                if(sum<=mst)\\n                    res[1].Add(i);\\n                \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    int CreateMST(int n, int[][] edges, int included, int excluded)\\n    {\\n        \\n        UF uf = new UF(n);\\n        \\n        int cnt=0;\\n        int sum=0;\\n\\n        PriorityQueue<int,int> pq=new PriorityQueue<int,int>();\\n        if(included>=0){\\n            uf.union(edges[included][0],edges[included][1]);\\n            cnt++;\\n            sum=edges[included][2];\\n        }\\n        \\n        for(int i=0;i<edges.Length;i++)\\n            if(i!=excluded)\\n                pq.Enqueue(i,edges[i][2]);\\n        \\n        while(pq.Count>0 && cnt<n-1)\\n        {\\n            int e=pq.Dequeue();\\n            if(uf.find(edges[e][0]) != uf.find(edges[e][1]))\\n            {\\n                uf.union(edges[e][0],edges[e][1]);\\n                sum+=edges[e][2];\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt<n-1)\\n            return int.MaxValue;\\n        \\n        return sum;\\n    }\\n    \\n}\\n\\npublic class UF\\n{\\n    int[] parent;\\n    \\n    public UF(int size)\\n    {\\n        parent=Enumerable.Range(0,size).ToArray();\\n\\n        \\n    }\\n    \\n    public int find(int node)\\n    {\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n        \\n    }\\n    \\n    public void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return;\\n        \\n        parent[pi]=pj;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        \\n        int mst=CreateMST(n,edges,-1,-1);\\n        List<IList<int>> res=new List<IList<int>>();\\n        \\n        res.Add(new List<int>());\\n        res.Add(new List<int>());\\n        \\n        for(int i=0;i<edges.Length;i++)\\n        {\\n            int sum=CreateMST(n,edges,-1,i);\\n            if(sum>mst)\\n                res[0].Add(i);\\n            else {\\n                sum=CreateMST(n,edges,i,-1);\\n                if(sum<=mst)\\n                    res[1].Add(i);\\n                \\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    int CreateMST(int n, int[][] edges, int included, int excluded)\\n    {\\n        \\n        UF uf = new UF(n);\\n        \\n        int cnt=0;\\n        int sum=0;\\n\\n        PriorityQueue<int,int> pq=new PriorityQueue<int,int>();\\n        if(included>=0){\\n            uf.union(edges[included][0],edges[included][1]);\\n            cnt++;\\n            sum=edges[included][2];\\n        }\\n        \\n        for(int i=0;i<edges.Length;i++)\\n            if(i!=excluded)\\n                pq.Enqueue(i,edges[i][2]);\\n        \\n        while(pq.Count>0 && cnt<n-1)\\n        {\\n            int e=pq.Dequeue();\\n            if(uf.find(edges[e][0]) != uf.find(edges[e][1]))\\n            {\\n                uf.union(edges[e][0],edges[e][1]);\\n                sum+=edges[e][2];\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt<n-1)\\n            return int.MaxValue;\\n        \\n        return sum;\\n    }\\n    \\n}\\n\\npublic class UF\\n{\\n    int[] parent;\\n    \\n    public UF(int size)\\n    {\\n        parent=Enumerable.Range(0,size).ToArray();\\n\\n        \\n    }\\n    \\n    public int find(int node)\\n    {\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n        \\n    }\\n    \\n    public void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return;\\n        \\n        parent[pi]=pj;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106764,
                "title": "c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to use Kruskal\\'s algorithm to determine the minimum spanning tree for the given graph. We can get the critical and pseudo-critical edges by removing and adding edges one by one and comparing the cost of the minimum spanning tree with the original cost.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use Kruskal\\'s algorithm to find the minimum spanning tree. We can then remove and add the edges one by one and compare the cost of the minimum spanning tree with the original cost. If the cost is higher than the original cost, then the edge is a critical edge. If the cost is the same as the original cost, then the edge is a pseudo-critical edge.\\n# Complexity\\n- Time complexity: $$O(ElogE)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E + V) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        int m = edges.size();\\n        for (int i = 0; i < m; ++i) edges[i].push_back(i);\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int value = kruskal(n, edges);\\n        for (int i = 0; i < m; ++i) {\\n            if (kruskal(n, edges, i) > value) ans[0].push_back(edges[i][3]);\\n            else if (kruskal(n, edges, -1, i) == value) ans[1].push_back(edges[i][3]);\\n        }\\n        return ans;\\n    }\\n    int kruskal(int n, vector<vector<int>>& edges, int skip = -1, int include = -1) {\\n        vector<int> f(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n        function<int(int)> find = [&](int x) {\\n            return f[x] == x ? x : f[x] = find(f[x]);\\n        };\\n        int ans = 0, count = 0;\\n        if (include != -1) {\\n            auto& e = edges[include];\\n            ans += e[2];\\n            f[find(e[0])] = find(e[1]);\\n            ++count;\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == skip) continue;\\n            auto& e = edges[i];\\n            int x = find(e[0]), y = find(e[1]);\\n            if (x != y) {\\n                f[x] = y;\\n                ans += e[2];\\n                if (++count == n - 1) break;\\n            }\\n        }\\n        return count == n - 1 ? ans : INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        int m = edges.size();\\n        for (int i = 0; i < m; ++i) edges[i].push_back(i);\\n        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        int value = kruskal(n, edges);\\n        for (int i = 0; i < m; ++i) {\\n            if (kruskal(n, edges, i) > value) ans[0].push_back(edges[i][3]);\\n            else if (kruskal(n, edges, -1, i) == value) ans[1].push_back(edges[i][3]);\\n        }\\n        return ans;\\n    }\\n    int kruskal(int n, vector<vector<int>>& edges, int skip = -1, int include = -1) {\\n        vector<int> f(n);\\n        for (int i = 0; i < n; ++i) f[i] = i;\\n        function<int(int)> find = [&](int x) {\\n            return f[x] == x ? x : f[x] = find(f[x]);\\n        };\\n        int ans = 0, count = 0;\\n        if (include != -1) {\\n            auto& e = edges[include];\\n            ans += e[2];\\n            f[find(e[0])] = find(e[1]);\\n            ++count;\\n        }\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (i == skip) continue;\\n            auto& e = edges[i];\\n            int x = find(e[0]), y = find(e[1]);\\n            if (x != y) {\\n                f[x] = y;\\n                ans += e[2];\\n                if (++count == n - 1) break;\\n            }\\n        }\\n        return count == n - 1 ? ans : INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103705,
                "title": "kruskal-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Comparator<int[]> myComp = new MyComp();\\n        PriorityQueue<int[]> pq;\\n        UnionFind u;\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> pseudocritical = new ArrayList<>();\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> noncritical = new ArrayList<>();\\n\\n        pq = new PriorityQueue<>(myComp);\\n        u = new UnionFind(n);\\n\\n        for (int i=0;i<edges.length;i++){\\n            pq.add(edges[i]);\\n        }\\n\\n        int minSum = MST(pq,u);\\n\\n\\n        for (int i=0;i<edges.length;i++){\\n            pq = new PriorityQueue<>(myComp);\\n            u = new UnionFind(n);\\n\\n            for (int j=0;j<edges.length;j++){\\n                if (j != i){\\n                    pq.add(edges[j]);\\n                }\\n            }\\n\\n            int sum = MST(pq,u);\\n            if (sum != minSum){\\n                critical.add(i);\\n            } \\n        }              \\n\\n        for (int i=0;i<edges.length;i++){\\n            pq = new PriorityQueue<>(myComp);\\n            u = new UnionFind(n);\\n            int adder = 0;\\n\\n            for (int j=0;j<edges.length;j++){\\n                if (j == i){\\n                    int[] e = new int[3];\\n                    e[0] = edges[j][0];\\n                    e[1] = edges[j][1];\\n                    adder = edges[j][2];\\n                    e[2] = 0;\\n                    pq.add(e);\\n                    continue;\\n                }\\n                pq.add(edges[j]);\\n            }\\n\\n            int sum = MST(pq,u) + adder;\\n            if (sum != minSum){\\n                noncritical.add(i);\\n            } \\n        }\\n\\n        for (int i=0;i<edges.length;i++){\\n            if (!critical.contains(i) && !noncritical.contains(i)){\\n                pseudocritical.add(i);\\n            }\\n        }\\n                            \\n        result.add(critical);\\n        result.add(pseudocritical);\\n\\n        return result;\\n    }\\n\\n    int MST(PriorityQueue<int[]> pq, UnionFind u){\\n        int sum = 0;\\n        while (!pq.isEmpty()){\\n            int[] e = pq.remove();\\n            int v1 = e[0];\\n            int v2 = e[1];\\n            int w = e[2];\\n\\n            if (!u.isConnected(v1,v2)){\\n                u.unite(v1,v2);\\n                sum += w;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    class MyComp implements Comparator<int[]> {\\n        public int compare(int[] e1, int[] e2){\\n            return (e1[2]-e2[2]);\\n        }\\n    }\\n\\n    class UnionFind {\\n        int[] _id; \\n        int[] rank;\\n\\n        UnionFind(int n){\\n            _id = new int[n];\\n            rank = new int[n];\\n            for (int i=0;i<n;i++){\\n                _id[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        int root(int p){\\n            while (p != _id[p]){\\n                _id[p] = _id[_id[p]];\\n                p = _id[p];\\n            }\\n\\n            return p;\\n        }\\n\\n        boolean isConnected(int p,int q){\\n            return (root(p) == root(q));\\n        }\\n\\n        void unite(int p, int q){\\n            if (rank[root(p)] > rank[root(q)]){\\n                _id[root(q)] = root(p);\\n            } else if (rank[q] > rank[p]){\\n                _id[root(p)] = root(q);\\n            } else {\\n                _id[root(q)] = root(p);\\n                rank[root(p)] +=1;\\n            }      \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Comparator<int[]> myComp = new MyComp();\\n        PriorityQueue<int[]> pq;\\n        UnionFind u;\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> pseudocritical = new ArrayList<>();\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> noncritical = new ArrayList<>();\\n\\n        pq = new PriorityQueue<>(myComp);\\n        u = new UnionFind(n);\\n\\n        for (int i=0;i<edges.length;i++){\\n            pq.add(edges[i]);\\n        }\\n\\n        int minSum = MST(pq,u);\\n\\n\\n        for (int i=0;i<edges.length;i++){\\n            pq = new PriorityQueue<>(myComp);\\n            u = new UnionFind(n);\\n\\n            for (int j=0;j<edges.length;j++){\\n                if (j != i){\\n                    pq.add(edges[j]);\\n                }\\n            }\\n\\n            int sum = MST(pq,u);\\n            if (sum != minSum){\\n                critical.add(i);\\n            } \\n        }              \\n\\n        for (int i=0;i<edges.length;i++){\\n            pq = new PriorityQueue<>(myComp);\\n            u = new UnionFind(n);\\n            int adder = 0;\\n\\n            for (int j=0;j<edges.length;j++){\\n                if (j == i){\\n                    int[] e = new int[3];\\n                    e[0] = edges[j][0];\\n                    e[1] = edges[j][1];\\n                    adder = edges[j][2];\\n                    e[2] = 0;\\n                    pq.add(e);\\n                    continue;\\n                }\\n                pq.add(edges[j]);\\n            }\\n\\n            int sum = MST(pq,u) + adder;\\n            if (sum != minSum){\\n                noncritical.add(i);\\n            } \\n        }\\n\\n        for (int i=0;i<edges.length;i++){\\n            if (!critical.contains(i) && !noncritical.contains(i)){\\n                pseudocritical.add(i);\\n            }\\n        }\\n                            \\n        result.add(critical);\\n        result.add(pseudocritical);\\n\\n        return result;\\n    }\\n\\n    int MST(PriorityQueue<int[]> pq, UnionFind u){\\n        int sum = 0;\\n        while (!pq.isEmpty()){\\n            int[] e = pq.remove();\\n            int v1 = e[0];\\n            int v2 = e[1];\\n            int w = e[2];\\n\\n            if (!u.isConnected(v1,v2)){\\n                u.unite(v1,v2);\\n                sum += w;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    class MyComp implements Comparator<int[]> {\\n        public int compare(int[] e1, int[] e2){\\n            return (e1[2]-e2[2]);\\n        }\\n    }\\n\\n    class UnionFind {\\n        int[] _id; \\n        int[] rank;\\n\\n        UnionFind(int n){\\n            _id = new int[n];\\n            rank = new int[n];\\n            for (int i=0;i<n;i++){\\n                _id[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        int root(int p){\\n            while (p != _id[p]){\\n                _id[p] = _id[_id[p]];\\n                p = _id[p];\\n            }\\n\\n            return p;\\n        }\\n\\n        boolean isConnected(int p,int q){\\n            return (root(p) == root(q));\\n        }\\n\\n        void unite(int p, int q){\\n            if (rank[root(p)] > rank[root(q)]){\\n                _id[root(q)] = root(p);\\n            } else if (rank[q] > rank[p]){\\n                _id[root(p)] = root(q);\\n            } else {\\n                _id[root(q)] = root(p);\\n                rank[root(p)] +=1;\\n            }      \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089900,
                "title": "python-simple-mst-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU:\\n    def __init__(self,n):\\n        self.dict1 = list(range(n))\\n\\n    def find(self, x):\\n        if x != self.dict1[x]:\\n            self.dict1[x] = self.find(self.dict1[x])\\n        return self.dict1[x]\\n\\n    def union(self, x, y):\\n        a, b = self.find(x), self.find(y)\\n\\n        if a == b:\\n            return False\\n        else:\\n            self.dict1[b] = a\\n            return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        edges = sorted([(w,u,v,i)for i, (u,v,w) in enumerate(edges)])\\n        ans1, ans2 = [], []\\n\\n        for w1,u1,v1,i in edges:\\n            d1, d2 = DSU(n), DSU(n)\\n            d1.union(u1,v1)\\n            t1, t2 = w1, 0\\n            for w2,u2,v2,j in edges:\\n                if i == j: continue\\n                if d1.union(u2,v2): t1 += w2\\n                if d2.union(u2,v2): t2 += w2\\n\\n            if t1 == t2:\\n                ans1.append(i)\\n            elif t1 < t2 or d2.union(u1,v1):\\n                ans2.append(i)\\n\\n        return ans2, ans1\\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self,n):\\n        self.dict1 = list(range(n))\\n\\n    def find(self, x):\\n        if x != self.dict1[x]:\\n            self.dict1[x] = self.find(self.dict1[x])\\n        return self.dict1[x]\\n\\n    def union(self, x, y):\\n        a, b = self.find(x), self.find(y)\\n\\n        if a == b:\\n            return False\\n        else:\\n            self.dict1[b] = a\\n            return True\\n\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        edges = sorted([(w,u,v,i)for i, (u,v,w) in enumerate(edges)])\\n        ans1, ans2 = [], []\\n\\n        for w1,u1,v1,i in edges:\\n            d1, d2 = DSU(n), DSU(n)\\n            d1.union(u1,v1)\\n            t1, t2 = w1, 0\\n            for w2,u2,v2,j in edges:\\n                if i == j: continue\\n                if d1.union(u2,v2): t1 += w2\\n                if d2.union(u2,v2): t2 += w2\\n\\n            if t1 == t2:\\n                ans1.append(i)\\n            elif t1 < t2 or d2.union(u1,v1):\\n                ans2.append(i)\\n\\n        return ans2, ans1\\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466828,
                "title": "c-modified-kruskal-algo-with-explanation",
                "content": "\\tclass DSU{\\n\\t\\tvector<int> parent,size;\\n\\n\\t\\tpublic:\\n\\t\\tDSU(int n){\\n\\t\\t\\tparent.resize(n);\\n\\t\\t\\tsize.resize(n,1);\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t\\tparent[i]= i;\\n\\t\\t}\\n\\n\\t\\tint findParent(int x){\\n\\t\\t\\tif(x == parent[x])\\n\\t\\t\\t\\treturn x;\\n\\t\\t\\treturn parent[x]= findParent(parent[x]);\\n\\t\\t}\\n\\n\\t\\tvoid unite(int small, int large){\\n\\t\\t\\tsmall = findParent(small);\\n\\t\\t\\tlarge = findParent(large);\\n\\t\\t\\tif(small == large)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(size[small] > size[large])\\n\\t\\t\\t\\tswap(small,large);\\n\\n\\t\\t\\tsize[large] += size[small];\\n\\t\\t\\tparent[small]= large;\\n\\t\\t}\\n\\t};\\n\\n\\t// comparator\\n\\tbool comp(vector<int> &v1, vector<int> &v2){\\n\\t\\treturn v1[2]< v2[2];\\n\\t}\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\t// spanning tree\\n\\t\\tint kruskal(int n, int i, bool exclude, vector<vector<int>> &edges){\\n\\t\\t\\tDSU dsu(n);\\n\\t\\t\\tint mst= 0;\\n\\t\\t\\tint e= 0;\\n\\t\\t\\tif(!exclude){\\n\\t\\t\\t\\tdsu.unite(edges[i][0],edges[i][1]);\\n\\t\\t\\t\\tmst += edges[i][2];\\n\\t\\t\\t\\te=1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=0; j<edges.size(); j++){\\n\\t\\t\\t\\tif(e == n-1)\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif(exclude && j==i) continue;\\n\\t\\t\\t\\tif(dsu.findParent(edges[j][0])== dsu.findParent(edges[j][1])) continue;\\n\\n\\t\\t\\t\\tdsu.unite(edges[j][0], edges[j][1]);\\n\\t\\t\\t\\tmst += edges[j][2];\\n\\t\\t\\t\\te++;\\n\\n\\t\\t\\t}        \\n\\t\\t\\tif(e != n-1)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\treturn mst;\\n\\n\\t\\t}\\n\\n\\n\\t\\tvector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n\\n\\t\\t\\tunordered_map<string, int> index;\\n\\t\\t\\tfor(int i=0; i<edges.size(); i++){\\n\\t\\t\\t\\tstring key = to_string(edges[i][0])+\\',\\'+to_string(edges[i][1])+\\',\\'+to_string(edges[i][2]);\\n\\t\\t\\t\\tindex[key]=i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(edges.begin(), edges.end(), comp);\\n\\t\\t\\tint minMST = kruskal(n,0,false,edges);\\n\\t\\t\\t// kruskal(n,index , exclude index ?, sorted edges)\\n\\n\\t\\t\\tvector<int> critical, pseudo;\\n\\t\\t\\t// exclude an edge and check mst value\\n\\t\\t\\t// if(new mst > minMST) critical\\n\\t\\t\\t// if(new mst == minMST) \\n\\t\\t\\t// we\\'ve to check whether this removed edges is part of some mst ?\\n\\t\\t\\t// ie. this edges is part of some MST which gives minMST, and if we remove this edges also\\n\\t\\t\\t// we\\'re geting mas == minMST\\n\\n\\t\\t\\tfor(int i=0; i<edges.size(); i++){\\n\\t\\t\\t\\tint newMST = kruskal(n,i,true,edges);\\n\\n\\tstring key = to_string(edges[i][0])+\\',\\'+to_string(edges[i][1])+\\',\\'+to_string(edges[i][2]);\\n\\n\\t\\t\\t\\tif(newMST > minMST || newMST== -1)\\n\\t\\t\\t\\t\\tcritical.push_back(index[key]);\\n\\t\\t\\t\\telse if(newMST == minMST){\\n\\t\\t\\t\\t\\t// add this edges forcefully and check whether it\\'s part of some mst giving minMST\\n\\t\\t\\t\\t\\tint forcedMST = kruskal(n,i,false,edges);\\n\\t\\t\\t\\t\\tif(forcedMST == minMST)\\n\\t\\t\\t\\t\\t\\tpseudo.push_back(index[key]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\tans.push_back(critical);\\n\\t\\t\\tans.push_back(pseudo);\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\t// spanning tree\\n\\t\\tint kruskal(int n, int i, bool exclude, vector<vector<int>> &edges){\\n\\t\\t\\tDSU dsu(n);\\n\\t\\t\\tint mst= 0;\\n\\t\\t\\tint e= 0;\\n\\t\\t\\tif(!exclude){\\n\\t\\t\\t\\tdsu.unite(edges[i][0],edges[i][1]);\\n\\t\\t\\t\\tmst += edges[i][2];\\n\\t\\t\\t\\te=1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2428494,
                "title": "c-using-kruskal-solution",
                "content": "Found this problem really hard to solve, here is my solution. \\nHope you like it. \\n```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    int Mst(int n, vector<vector<int>>& edges, int indexToBeLeft, int edgeCount, int cost){\\n        for(int edgeIndex = 0; edgeIndex < edges.size(); edgeIndex++){\\n            if(edgeIndex == indexToBeLeft){\\n                continue;\\n            }\\n            int parent = findParent(edges[edgeIndex][0]);\\n            int child = findParent(edges[edgeIndex][1]);\\n            if(parent == child){\\n                continue;\\n            }\\n            p[child] = parent;\\n            edgeCount++;\\n            cost += edges[edgeIndex][2];\\n        }\\n        \\n        return edgeCount != n-1 ? INT_MAX : cost;\\n    }\\n    \\n    int findParent(int child){\\n        if(p[child] == -1){\\n            return child;\\n        }\\n        return p[child] = findParent(p[child]);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pCritical;\\n        p.resize(102);\\n        for(int i = 0; i < 102; i++){\\n            p[i] = -1;\\n        }\\n        map<pair<pair<int,int>,int>,int> prevIndexes;\\n        map<int,int> locateIndexes;\\n        for(int i = 0; i < edges.size(); i++){\\n            prevIndexes[{{edges[i][0], edges[i][1]}, edges[i][2]}] = i; \\n        }\\n        sort(edges.begin(), edges.end(), [](auto &v1, auto &v2){\\n            return v1[2] < v2[2];\\n        });\\n        for(int i = 0; i < edges.size(); i++){\\n            locateIndexes[i] = prevIndexes[{{edges[i][0], edges[i][1]}, edges[i][2]}]; \\n        }\\n        \\n        int minSpammingTreeCost = Mst(n, edges, -1, 0, 0);\\n        for(int i = 0; i < edges.size(); i++){\\n            for(int j = 0; j <= 101; j++){\\n                p[j] = -1;\\n            }\\n            p[edges[i][1]] = edges[i][0];\\n            int treeCost = Mst(n, edges, -1, 1, edges[i][2]);\\n            if(treeCost == minSpammingTreeCost){\\n                for(int j = 0; j <= 101; j++){\\n                    p[j] = -1;\\n                }\\n                treeCost = Mst(n, edges, i, 0, 0);\\n                if(treeCost > minSpammingTreeCost){\\n                    critical.push_back(locateIndexes[i]);\\n                }\\n                else{\\n                    pCritical.push_back(locateIndexes[i]);\\n                }\\n            }\\n        }\\n        return {critical, pCritical};\\n    }\\n};\\n```\\n\\nAlthough i made solution clear through naming of variables and their usage. But if you have any doubt, feel free to ask in comment section.",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    int Mst(int n, vector<vector<int>>& edges, int indexToBeLeft, int edgeCount, int cost){\\n        for(int edgeIndex = 0; edgeIndex < edges.size(); edgeIndex++){\\n            if(edgeIndex == indexToBeLeft){\\n                continue;\\n            }\\n            int parent = findParent(edges[edgeIndex][0]);\\n            int child = findParent(edges[edgeIndex][1]);\\n            if(parent == child){\\n                continue;\\n            }\\n            p[child] = parent;\\n            edgeCount++;\\n            cost += edges[edgeIndex][2];\\n        }\\n        \\n        return edgeCount != n-1 ? INT_MAX : cost;\\n    }\\n    \\n    int findParent(int child){\\n        if(p[child] == -1){\\n            return child;\\n        }\\n        return p[child] = findParent(p[child]);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pCritical;\\n        p.resize(102);\\n        for(int i = 0; i < 102; i++){\\n            p[i] = -1;\\n        }\\n        map<pair<pair<int,int>,int>,int> prevIndexes;\\n        map<int,int> locateIndexes;\\n        for(int i = 0; i < edges.size(); i++){\\n            prevIndexes[{{edges[i][0], edges[i][1]}, edges[i][2]}] = i; \\n        }\\n        sort(edges.begin(), edges.end(), [](auto &v1, auto &v2){\\n            return v1[2] < v2[2];\\n        });\\n        for(int i = 0; i < edges.size(); i++){\\n            locateIndexes[i] = prevIndexes[{{edges[i][0], edges[i][1]}, edges[i][2]}]; \\n        }\\n        \\n        int minSpammingTreeCost = Mst(n, edges, -1, 0, 0);\\n        for(int i = 0; i < edges.size(); i++){\\n            for(int j = 0; j <= 101; j++){\\n                p[j] = -1;\\n            }\\n            p[edges[i][1]] = edges[i][0];\\n            int treeCost = Mst(n, edges, -1, 1, edges[i][2]);\\n            if(treeCost == minSpammingTreeCost){\\n                for(int j = 0; j <= 101; j++){\\n                    p[j] = -1;\\n                }\\n                treeCost = Mst(n, edges, i, 0, 0);\\n                if(treeCost > minSpammingTreeCost){\\n                    critical.push_back(locateIndexes[i]);\\n                }\\n                else{\\n                    pCritical.push_back(locateIndexes[i]);\\n                }\\n            }\\n        }\\n        return {critical, pCritical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373578,
                "title": "java-dsu-unionfind-mst-long-code-but-easy",
                "content": "```\\nclass Solution {\\n    static class UnionFind{\\n        int[]parent;\\n        int[]rank;\\n        int comp = 0;\\n        UnionFind(int n){\\n            parent = new int[n];\\n            rank = new int[n];\\n            comp = n;\\n            for(int i=0;i<n;i++){\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n        }\\n        \\n        int find(int x){\\n            if(parent[x] == x){\\n                return x;\\n            }else{\\n                parent[x] = find(parent[x]);\\n                return parent[x];\\n            }\\n        }\\n        \\n        boolean union(int X,int Y){\\n            int x = find(X);\\n            int y = find(Y);\\n            if(x == y){\\n                return false;\\n            }\\n            \\n            if(rank[x] < rank[y]){\\n                parent[x] = y;\\n            }else if(rank[y] < rank[x]){\\n                parent[y] = x;\\n            }else{\\n                parent[y] = x;\\n                rank[x]++;\\n            }\\n            comp--;\\n            return true;\\n        }\\n        \\n        boolean isConnected(){\\n            return comp == 1;\\n        }\\n        \\n    }\\n    \\n    static class Edge implements Comparable<Edge>{\\n        int u;\\n        int v;\\n        int wt;\\n        Edge(int u,int v,int wt){\\n            this.u = u;\\n            this.v = v;\\n            this.wt = wt;\\n        }\\n        public int compareTo(Edge o){\\n            return this.wt - o.wt;\\n        } \\n    }\\n    public int buildMST(int n,int[][]edges,int[]edgeSkip,int[]edgePick){\\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\\n        \\n        for(int[]edge : edges){\\n            if(edge == edgeSkip){\\n                continue;\\n            }else if(edge == edgePick){\\n                continue;\\n            }\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            pq.add(new Edge(u,v,wt));\\n        }\\n        \\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        \\n        if(edgePick != null){\\n            uf.union(edgePick[0],edgePick[1]);\\n            cost += edgePick[2];\\n        }\\n        while(pq.size() > 0){\\n            Edge rem = pq.remove();\\n            if(uf.union(rem.u,rem.v) == true){\\n                cost += rem.wt;\\n            }\\n        }\\n        \\n        if(uf.isConnected() == true){\\n            return cost;\\n        }else{\\n            return Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost = buildMST(n,edges,null,null);\\n        \\n        ArrayList<Integer> critical = new ArrayList<>();\\n        ArrayList<Integer> pcritical = new ArrayList<>();\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int []edge = edges[i];\\n            \\n            int mstCostWithoutEdge = buildMST(n,edges,edge,null);\\n            if(mstCostWithoutEdge > mstCost){\\n                critical.add(i);        //Critical edge index\\n            }else{\\n                int mstCostWithEdge = buildMST(n,edges,null,edge);\\n                if(mstCostWithEdge > mstCost){\\n                    //redundant\\n                }else{\\n                    pcritical.add(i);   //pseduo critical edge index\\n                }\\n            }\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(critical);\\n        res.add(pcritical);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    static class UnionFind{\\n        int[]parent;\\n        int[]rank;\\n        int comp = 0;\\n        UnionFind(int n){\\n            parent = new int[n];\\n            rank = new int[n];\\n            comp = n;\\n            for(int i=0;i<n;i++){\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n        }\\n        \\n        int find(int x){\\n            if(parent[x] == x){\\n                return x;\\n            }else{\\n                parent[x] = find(parent[x]);\\n                return parent[x];\\n            }\\n        }\\n        \\n        boolean union(int X,int Y){\\n            int x = find(X);\\n            int y = find(Y);\\n            if(x == y){\\n                return false;\\n            }\\n            \\n            if(rank[x] < rank[y]){\\n                parent[x] = y;\\n            }else if(rank[y] < rank[x]){\\n                parent[y] = x;\\n            }else{\\n                parent[y] = x;\\n                rank[x]++;\\n            }\\n            comp--;\\n            return true;\\n        }\\n        \\n        boolean isConnected(){\\n            return comp == 1;\\n        }\\n        \\n    }\\n    \\n    static class Edge implements Comparable<Edge>{\\n        int u;\\n        int v;\\n        int wt;\\n        Edge(int u,int v,int wt){\\n            this.u = u;\\n            this.v = v;\\n            this.wt = wt;\\n        }\\n        public int compareTo(Edge o){\\n            return this.wt - o.wt;\\n        } \\n    }\\n    public int buildMST(int n,int[][]edges,int[]edgeSkip,int[]edgePick){\\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\\n        \\n        for(int[]edge : edges){\\n            if(edge == edgeSkip){\\n                continue;\\n            }else if(edge == edgePick){\\n                continue;\\n            }\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            pq.add(new Edge(u,v,wt));\\n        }\\n        \\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0;\\n        \\n        if(edgePick != null){\\n            uf.union(edgePick[0],edgePick[1]);\\n            cost += edgePick[2];\\n        }\\n        while(pq.size() > 0){\\n            Edge rem = pq.remove();\\n            if(uf.union(rem.u,rem.v) == true){\\n                cost += rem.wt;\\n            }\\n        }\\n        \\n        if(uf.isConnected() == true){\\n            return cost;\\n        }else{\\n            return Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        int mstCost = buildMST(n,edges,null,null);\\n        \\n        ArrayList<Integer> critical = new ArrayList<>();\\n        ArrayList<Integer> pcritical = new ArrayList<>();\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int []edge = edges[i];\\n            \\n            int mstCostWithoutEdge = buildMST(n,edges,edge,null);\\n            if(mstCostWithoutEdge > mstCost){\\n                critical.add(i);        //Critical edge index\\n            }else{\\n                int mstCostWithEdge = buildMST(n,edges,null,edge);\\n                if(mstCostWithEdge > mstCost){\\n                    //redundant\\n                }else{\\n                    pcritical.add(i);   //pseduo critical edge index\\n                }\\n            }\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(critical);\\n        res.add(pcritical);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349415,
                "title": "intuitive-mst-kruskal",
                "content": "```\\nclass Solution {\\n       struct node{\\n        int u,v,wt;\\n    \\n    node(int first,int second,int weight)\\n    {\\n        u=first;\\n        v=second;\\n        wt=weight;\\n    }\\n   };\\npublic:\\n bool static comp(pair<int,node> a,pair<int,node> b)\\n{\\n    return a.second.wt<b.second.wt;\\n}\\nint findpar(int node, vector<int> &parent)\\n{\\n    if(node==parent[node])\\n        return node;\\n    return parent[node]=findpar(parent[node],parent);\\n}\\nvoid unionn(int u,int v,vector<int> &parent,vector<int> &rank)\\n{\\n    u=findpar(u,parent);\\n    v=findpar(v,parent);\\n    \\n    if(rank[u]<rank[v])\\n        parent[u]=v;\\n    else if(rank[v]<rank[u])\\n        parent[v]=u;\\n    else\\n    {\\n        parent[v]=u;\\n        rank[u]++;\\n    }\\n}\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edge) {\\n       \\n         vector<pair<int,node>>edges;\\n        int i=0;\\n        for(auto it:edge){\\n            edges.push_back({i++,node(it[0],it[1],it[2])});\\n        }\\n         sort(edges.begin(),edges.end(),comp);\\n       vector<int> parent(n);\\n       vector<int> rank(n,0);\\n    \\n    for(int i=0;i<n;i++) \\n        parent[i]=i;\\n    \\n    int cost=0;\\n\\t\\n    for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent))\\n        {\\n            cost+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }\\n        \\n        vector<int>cri;\\n        vector<int>ncri;\\n        \\n       // Now we will iterate on every edge and check wheater it is critical or not\\n        for(int i=0;i<edge.size();i++){\\n            vector<int> parent(n);\\n             for(int j=0;j<n;j++) \\n              parent[j]=j;\\n            vector<int> rank(n,0);\\n            int curr=0;\\n           \\n            for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent) )\\n        {\\n            // Not taking the ith edge to find the critical\\n            if(it.first==i){\\n                continue;\\n            }\\n            curr+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }      \\n            \\n            if(curr!=cost){\\n                cri.push_back(i);\\n            }\\n            \\n        }\\n        for(int i=0;i<edge.size();i++){\\n            vector<int> parent(n);\\n             for(int j=0;j<n;j++) \\n              parent[j]=j;\\n            vector<int> rank(n,0);\\n            int curr=0;\\n           if(find(cri.begin(),cri.end(),i)==cri.end()){\\n\\t\\t   // Add the edge if it is not critical and check id we are getting same MST cost\\n               curr+=edge[i][2];\\n              unionn(edge[i][0],edge[i][1],parent,rank); \\n           }\\n            for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent) )\\n        {\\n          \\n            curr+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }      \\n            \\n            if(curr==cost && find(cri.begin(),cri.end(),i)==cri.end()){\\n                ncri.push_back(i);\\n            }\\n            \\n        }\\n        \\n        \\n        return {cri,ncri};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       struct node{\\n        int u,v,wt;\\n    \\n    node(int first,int second,int weight)\\n    {\\n        u=first;\\n        v=second;\\n        wt=weight;\\n    }\\n   };\\npublic:\\n bool static comp(pair<int,node> a,pair<int,node> b)\\n{\\n    return a.second.wt<b.second.wt;\\n}\\nint findpar(int node, vector<int> &parent)\\n{\\n    if(node==parent[node])\\n        return node;\\n    return parent[node]=findpar(parent[node],parent);\\n}\\nvoid unionn(int u,int v,vector<int> &parent,vector<int> &rank)\\n{\\n    u=findpar(u,parent);\\n    v=findpar(v,parent);\\n    \\n    if(rank[u]<rank[v])\\n        parent[u]=v;\\n    else if(rank[v]<rank[u])\\n        parent[v]=u;\\n    else\\n    {\\n        parent[v]=u;\\n        rank[u]++;\\n    }\\n}\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edge) {\\n       \\n         vector<pair<int,node>>edges;\\n        int i=0;\\n        for(auto it:edge){\\n            edges.push_back({i++,node(it[0],it[1],it[2])});\\n        }\\n         sort(edges.begin(),edges.end(),comp);\\n       vector<int> parent(n);\\n       vector<int> rank(n,0);\\n    \\n    for(int i=0;i<n;i++) \\n        parent[i]=i;\\n    \\n    int cost=0;\\n\\t\\n    for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent))\\n        {\\n            cost+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }\\n        \\n        vector<int>cri;\\n        vector<int>ncri;\\n        \\n       // Now we will iterate on every edge and check wheater it is critical or not\\n        for(int i=0;i<edge.size();i++){\\n            vector<int> parent(n);\\n             for(int j=0;j<n;j++) \\n              parent[j]=j;\\n            vector<int> rank(n,0);\\n            int curr=0;\\n           \\n            for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent) )\\n        {\\n            // Not taking the ith edge to find the critical\\n            if(it.first==i){\\n                continue;\\n            }\\n            curr+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }      \\n            \\n            if(curr!=cost){\\n                cri.push_back(i);\\n            }\\n            \\n        }\\n        for(int i=0;i<edge.size();i++){\\n            vector<int> parent(n);\\n             for(int j=0;j<n;j++) \\n              parent[j]=j;\\n            vector<int> rank(n,0);\\n            int curr=0;\\n           if(find(cri.begin(),cri.end(),i)==cri.end()){\\n\\t\\t   // Add the edge if it is not critical and check id we are getting same MST cost\\n               curr+=edge[i][2];\\n              unionn(edge[i][0],edge[i][1],parent,rank); \\n           }\\n            for(auto it:edges)\\n    {\\n        if(findpar(it.second.v,parent)!=findpar(it.second.u,parent) )\\n        {\\n          \\n            curr+=it.second.wt;\\n            unionn(it.second.u,it.second.v,parent,rank);\\n        }\\n    }      \\n            \\n            if(curr==cost && find(cri.begin(),cri.end(),i)==cri.end()){\\n                ncri.push_back(i);\\n            }\\n            \\n        }\\n        \\n        \\n        return {cri,ncri};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317553,
                "title": "c-simple-solution-dsu-sorting-mst-union-find",
                "content": "```\\nbool cmp(vector<int>&a, vector<int>&b){\\n    return a[2] < b[2];\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int MST(int n, vector<vector<int>>&edges, int exc, int edgecnt, int cost){\\n        \\n        for(auto&ed: edges){\\n            if(ed[3] == exc) continue;\\n            int p1 = parent(ed[0]);\\n            int p2 = parent(ed[1]);\\n            \\n            if(p1 == p2) continue;\\n            \\n            int minx = min(p1, p2);\\n            edgecnt++;\\n            dsu[p1] = dsu[p2] = minx;\\n            cost += ed[2];\\n        }\\n        return (edgecnt == n-1)?cost:INT_MAX;\\n        \\n    }\\n    \\n    \\n    int dsu[101] = {};\\n    \\n    int parent(int n){\\n        if(dsu[n] == n) return n;\\n        return dsu[n] = parent(dsu[n]);\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>&e){\\n        vector<vector<int>> edges;\\n        \\n        for(int i=0;i<e.size();i++){\\n            e[i].push_back(i);\\n            edges.push_back(e[i]);\\n            e[i].pop_back();\\n        }\\n        \\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        vector<int> critical, pcritical;\\n        \\n        for(int j=0;j<101;j++) dsu[j] = j;\\n        int mstc = MST(n, edges, -1, 0, 0);\\n        \\n        for(int i=0;i<e.size();i++){\\n            \\n            for(int j=0;j<101;j++) dsu[j] = j;\\n            \\n            int minedge = min(e[i][0], e[i][1]);\\n            \\n            dsu[e[i][0]] = dsu[e[i][1]] = minedge;\\n            \\n            int tc = MST(n, edges, -1, 1, e[i][2]);\\n            \\n            if(tc == mstc){\\n                for(int j=0;j<101;j++) dsu[j] = j;\\n                tc = MST(n, edges, i, 0, 0);\\n                if(tc > mstc) critical.push_back(i);\\n                else pcritical.push_back(i);\\n            }\\n            \\n        }\\n        \\n        return {critical, pcritical};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nbool cmp(vector<int>&a, vector<int>&b){\\n    return a[2] < b[2];\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    int MST(int n, vector<vector<int>>&edges, int exc, int edgecnt, int cost){\\n        \\n        for(auto&ed: edges){\\n            if(ed[3] == exc) continue;\\n            int p1 = parent(ed[0]);\\n            int p2 = parent(ed[1]);\\n            \\n            if(p1 == p2) continue;\\n            \\n            int minx = min(p1, p2);\\n            edgecnt++;\\n            dsu[p1] = dsu[p2] = minx;\\n            cost += ed[2];\\n        }\\n        return (edgecnt == n-1)?cost:INT_MAX;\\n        \\n    }\\n    \\n    \\n    int dsu[101] = {};\\n    \\n    int parent(int n){\\n        if(dsu[n] == n) return n;\\n        return dsu[n] = parent(dsu[n]);\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>&e){\\n        vector<vector<int>> edges;\\n        \\n        for(int i=0;i<e.size();i++){\\n            e[i].push_back(i);\\n            edges.push_back(e[i]);\\n            e[i].pop_back();\\n        }\\n        \\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        vector<int> critical, pcritical;\\n        \\n        for(int j=0;j<101;j++) dsu[j] = j;\\n        int mstc = MST(n, edges, -1, 0, 0);\\n        \\n        for(int i=0;i<e.size();i++){\\n            \\n            for(int j=0;j<101;j++) dsu[j] = j;\\n            \\n            int minedge = min(e[i][0], e[i][1]);\\n            \\n            dsu[e[i][0]] = dsu[e[i][1]] = minedge;\\n            \\n            int tc = MST(n, edges, -1, 1, e[i][2]);\\n            \\n            if(tc == mstc){\\n                for(int j=0;j<101;j++) dsu[j] = j;\\n                tc = MST(n, edges, i, 0, 0);\\n                if(tc > mstc) critical.push_back(i);\\n                else pcritical.push_back(i);\\n            }\\n            \\n        }\\n        \\n        return {critical, pcritical};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180493,
                "title": "c-using-kruskal-s-algorithm-minimum-spanning-tree-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        //Comp which sorts the edges based on their weight\\n        return a[2]<b[2];\\n    }\\n    void join(int i,int j,vector<int> &parent,vector<int> &rank)\\n    {\\n        i=findParent(i,parent);\\n        j=findParent(j,parent);\\n        if(rank[i]==rank[j])\\n        {\\n            parent[i]=j;\\n            rank[j]++;\\n        }\\n        else if(rank[i]>rank[j])\\n        {\\n            parent[j]=i;\\n        }\\n        else\\n        {\\n            parent[i]=j;\\n        }\\n    }\\n    int findParent(int i,vector<int> &parent)\\n    {\\n        if(parent[i]==i)\\n        return i;\\n        \\n        return parent[i]=findParent(parent[i],parent);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        int z=edges.size();\\n        vector<bool> isPartOfMST(z,false);\\n        \\n        //Pushing the indexes of each edges\\n        for(int i=0;i<z;i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        //sorting wrt cost\\n        sort(edges.begin(),edges.end(),comp);\\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        int c=0;\\n        int size=0;\\n        // Making the First MST\\n        for(int i=0;i<z;i++)\\n        {\\n            if(c==n-1)\\n            break;\\n            if(findParent(edges[i][0],parent)!=findParent(edges[i][1],parent))\\n            {\\n                size+=edges[i][2];\\n                join(edges[i][0],edges[i][1],parent,rank);\\n                isPartOfMST[edges[i][3]]=true;\\n                c++;\\n            }\\n        }\\n        //Storing the cost of the MST in size\\n        // cout<<size<<endl;\\n        vector<int> v;\\n        for(int i=0;i<z;i++)\\n        {\\n            vector<int> par(n),ra(n,0);\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                   par[i]=i;    \\n            }\\n            int c=0;\\n            int sz=0;\\n            vector<bool> temp(z,false);\\n            for(int j=0;j<z;j++)\\n            {\\n                // Applying Kruskal\\'s Algo while not considering the ith edge\\n                if(i==j)\\n                {\\n                    continue;\\n                }\\n                if(c==n-1)\\n                break;\\n                if(findParent(edges[j][0],par)!=findParent(edges[j][1],par))\\n                {\\n                    join(edges[j][0],edges[j][1],par,ra);\\n                    sz+=edges[j][2];\\n                    c++;\\n                    temp[edges[j][3]]=true;\\n                    // Using temp to find all those edges which are part of at least one MST\\n                }\\n            }\\n            // cout<<sz<<endl;\\n            if(sz==size)\\n            {\\n                // if(sz==size)\\n                for(int k=0;k<z;k++)\\n                {\\n                    if(temp[k])\\n                    isPartOfMST[k]=true;\\n                }\\n            }\\n            else\\n            {\\n                // v stores the indices of the critical edges\\n                v.push_back(edges[i][3]);\\n            }\\n        }\\n        // pseudo stores the pseudo critical edges\\n        vector<int> pseudo;\\n        for(int i=0;i<z;i++)\\n        {\\n            if(!isPartOfMST[edges[i][3]])\\n            {\\n                // Making MSTs considering those edges which are still not part of some MST. To include all those cases which might have missed otherwise\\n                vector<int> pa(n),r(n,0);\\n            \\n                for(int i=0;i<n;i++)\\n                {\\n                       pa[i]=i;    \\n                }\\n                int c=1;\\n                int sz=edges[i][2];\\n                join(edges[i][0],edges[i][1],pa,r); \\n                for(int j=0;j<z;j++)\\n                {\\n                    if(j==i)\\n                    continue;\\n                    \\n                    if(c==n-1)\\n                    break;\\n                    if(findParent(edges[j][0],pa)!=findParent(edges[j][1],pa))\\n                    {\\n                         join(edges[j][0],edges[j][1],pa,r);\\n                         sz+=edges[j][2];\\n                         c++;\\n                    }\\n                }\\n                if(sz==size)\\n                {\\n                    //We include those cases as pseudo critcal considering which we can build a ST with size equal to MST\\n                    pseudo.push_back(edges[i][3]);\\n                }\\n            }\\n        }\\n        ans.push_back(v);\\n        for(int i=0;i<v.size();i++)\\n        {\\n            // All critical edges aren\\'t pseudocritical edges so we turn those false, here\\n            isPartOfMST[v[i]]=false;\\n        }\\n        \\n        for(int i=0;i<z;i++)\\n        {\\n            if(isPartOfMST[i])\\n            {\\n                //all edges which are part of MST but are not critical are actually pseudo critical edges\\n                pseudo.push_back(i);\\n            }\\n        }\\n        ans.push_back(pseudo);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static comp(vector<int> &a,vector<int> &b)\\n    {\\n        //Comp which sorts the edges based on their weight\\n        return a[2]<b[2];\\n    }\\n    void join(int i,int j,vector<int> &parent,vector<int> &rank)\\n    {\\n        i=findParent(i,parent);\\n        j=findParent(j,parent);\\n        if(rank[i]==rank[j])\\n        {\\n            parent[i]=j;\\n            rank[j]++;\\n        }\\n        else if(rank[i]>rank[j])\\n        {\\n            parent[j]=i;\\n        }\\n        else\\n        {\\n            parent[i]=j;\\n        }\\n    }\\n    int findParent(int i,vector<int> &parent)\\n    {\\n        if(parent[i]==i)\\n        return i;\\n        \\n        return parent[i]=findParent(parent[i],parent);\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        int z=edges.size();\\n        vector<bool> isPartOfMST(z,false);\\n        \\n        //Pushing the indexes of each edges\\n        for(int i=0;i<z;i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        //sorting wrt cost\\n        sort(edges.begin(),edges.end(),comp);\\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        int c=0;\\n        int size=0;\\n        // Making the First MST\\n        for(int i=0;i<z;i++)\\n        {\\n            if(c==n-1)\\n            break;\\n            if(findParent(edges[i][0],parent)!=findParent(edges[i][1],parent))\\n            {\\n                size+=edges[i][2];\\n                join(edges[i][0],edges[i][1],parent,rank);\\n                isPartOfMST[edges[i][3]]=true;\\n                c++;\\n            }\\n        }\\n        //Storing the cost of the MST in size\\n        // cout<<size<<endl;\\n        vector<int> v;\\n        for(int i=0;i<z;i++)\\n        {\\n            vector<int> par(n),ra(n,0);\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                   par[i]=i;    \\n            }\\n            int c=0;\\n            int sz=0;\\n            vector<bool> temp(z,false);\\n            for(int j=0;j<z;j++)\\n            {\\n                // Applying Kruskal\\'s Algo while not considering the ith edge\\n                if(i==j)\\n                {\\n                    continue;\\n                }\\n                if(c==n-1)\\n                break;\\n                if(findParent(edges[j][0],par)!=findParent(edges[j][1],par))\\n                {\\n                    join(edges[j][0],edges[j][1],par,ra);\\n                    sz+=edges[j][2];\\n                    c++;\\n                    temp[edges[j][3]]=true;\\n                    // Using temp to find all those edges which are part of at least one MST\\n                }\\n            }\\n            // cout<<sz<<endl;\\n            if(sz==size)\\n            {\\n                // if(sz==size)\\n                for(int k=0;k<z;k++)\\n                {\\n                    if(temp[k])\\n                    isPartOfMST[k]=true;\\n                }\\n            }\\n            else\\n            {\\n                // v stores the indices of the critical edges\\n                v.push_back(edges[i][3]);\\n            }\\n        }\\n        // pseudo stores the pseudo critical edges\\n        vector<int> pseudo;\\n        for(int i=0;i<z;i++)\\n        {\\n            if(!isPartOfMST[edges[i][3]])\\n            {\\n                // Making MSTs considering those edges which are still not part of some MST. To include all those cases which might have missed otherwise\\n                vector<int> pa(n),r(n,0);\\n            \\n                for(int i=0;i<n;i++)\\n                {\\n                       pa[i]=i;    \\n                }\\n                int c=1;\\n                int sz=edges[i][2];\\n                join(edges[i][0],edges[i][1],pa,r); \\n                for(int j=0;j<z;j++)\\n                {\\n                    if(j==i)\\n                    continue;\\n                    \\n                    if(c==n-1)\\n                    break;\\n                    if(findParent(edges[j][0],pa)!=findParent(edges[j][1],pa))\\n                    {\\n                         join(edges[j][0],edges[j][1],pa,r);\\n                         sz+=edges[j][2];\\n                         c++;\\n                    }\\n                }\\n                if(sz==size)\\n                {\\n                    //We include those cases as pseudo critcal considering which we can build a ST with size equal to MST\\n                    pseudo.push_back(edges[i][3]);\\n                }\\n            }\\n        }\\n        ans.push_back(v);\\n        for(int i=0;i<v.size();i++)\\n        {\\n            // All critical edges aren\\'t pseudocritical edges so we turn those false, here\\n            isPartOfMST[v[i]]=false;\\n        }\\n        \\n        for(int i=0;i<z;i++)\\n        {\\n            if(isPartOfMST[i])\\n            {\\n                //all edges which are part of MST but are not critical are actually pseudo critical edges\\n                pseudo.push_back(i);\\n            }\\n        }\\n        ans.push_back(pseudo);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1984154,
                "title": "c-solution-union-find",
                "content": "```\\nclass dsu{\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    public:\\n    \\n    dsu(int n){\\n        parent.resize(n);\\n        iota(begin(parent), end(parent), 0);\\n        rank.resize(n, 1);\\n    }\\n    \\n    int findParent(int i){\\n        if(parent[i] != i){\\n            return findParent(parent[i]);\\n        }\\n        return i;\\n    }\\n    \\n    void Union(int x, int y){\\n        if(rank[x] < rank[y]){\\n            parent[y] = x;\\n        }\\n        else if(rank[x] > rank[y]){\\n            parent[x] = y;\\n        }\\n        else{\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int findCost(vector<vector<int>> edges, int n, vector<int> include, vector<int> exclude){     \\n        dsu parentCost(n);\\n        int count = 0;\\n        int i = 0;\\n        int parentMinCost = 0;\\n        \\n        if(include.size() != 0){\\n            int x = parentCost.findParent(include[0]);\\n            int y = parentCost.findParent(include[1]);\\n            parentMinCost += include[2];\\n            parentCost.Union(x, y);\\n            count++;\\n        }\\n        \\n        while(count != n - 1 and i < edges.size()){\\n            if(exclude.size() != 0 and edges[i] == exclude){\\n                i++;\\n                continue;\\n            }\\n            int x = parentCost.findParent(edges[i][0]);\\n            int y = parentCost.findParent(edges[i][1]);\\n            if(x != y){\\n                parentCost.Union(x, y);\\n                parentMinCost += edges[i][2];\\n                count++;\\n            }\\n            i++;\\n        }\\n        if(count == n - 1)\\n            return parentMinCost;\\n        \\n        return INT_MAX;\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i]] = i;\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [&](vector<int> &a, vector<int> &b){\\n            return a[2] < b[2];\\n        });\\n        vector<int> temp;\\n        \\n        int finalAns= findCost(edges, n, temp, temp);\\n        \\n        vector<int> ans1, ans2;;\\n        \\n        for(int i = 0; i < edges.size() ; i++){\\n            int cost1 = findCost(edges, n, temp, edges[i]);\\n            if(cost1 > finalAns){\\n                ans1.push_back(mp[edges[i]]);\\n            }\\n            else\\n            {\\n                int cost2 = findCost(edges, n, edges[i] , temp);\\n                if(cost2 == finalAns){\\n                    ans2.push_back(mp[edges[i]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return {ans1, ans2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass dsu{\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    public:\\n    \\n    dsu(int n){\\n        parent.resize(n);\\n        iota(begin(parent), end(parent), 0);\\n        rank.resize(n, 1);\\n    }\\n    \\n    int findParent(int i){\\n        if(parent[i] != i){\\n            return findParent(parent[i]);\\n        }\\n        return i;\\n    }\\n    \\n    void Union(int x, int y){\\n        if(rank[x] < rank[y]){\\n            parent[y] = x;\\n        }\\n        else if(rank[x] > rank[y]){\\n            parent[x] = y;\\n        }\\n        else{\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int findCost(vector<vector<int>> edges, int n, vector<int> include, vector<int> exclude){     \\n        dsu parentCost(n);\\n        int count = 0;\\n        int i = 0;\\n        int parentMinCost = 0;\\n        \\n        if(include.size() != 0){\\n            int x = parentCost.findParent(include[0]);\\n            int y = parentCost.findParent(include[1]);\\n            parentMinCost += include[2];\\n            parentCost.Union(x, y);\\n            count++;\\n        }\\n        \\n        while(count != n - 1 and i < edges.size()){\\n            if(exclude.size() != 0 and edges[i] == exclude){\\n                i++;\\n                continue;\\n            }\\n            int x = parentCost.findParent(edges[i][0]);\\n            int y = parentCost.findParent(edges[i][1]);\\n            if(x != y){\\n                parentCost.Union(x, y);\\n                parentMinCost += edges[i][2];\\n                count++;\\n            }\\n            i++;\\n        }\\n        if(count == n - 1)\\n            return parentMinCost;\\n        \\n        return INT_MAX;\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i]] = i;\\n        }\\n        \\n        sort(edges.begin(), edges.end(), [&](vector<int> &a, vector<int> &b){\\n            return a[2] < b[2];\\n        });\\n        vector<int> temp;\\n        \\n        int finalAns= findCost(edges, n, temp, temp);\\n        \\n        vector<int> ans1, ans2;;\\n        \\n        for(int i = 0; i < edges.size() ; i++){\\n            int cost1 = findCost(edges, n, temp, edges[i]);\\n            if(cost1 > finalAns){\\n                ans1.push_back(mp[edges[i]]);\\n            }\\n            else\\n            {\\n                int cost2 = findCost(edges, n, edges[i] , temp);\\n                if(cost2 == finalAns){\\n                    ans2.push_back(mp[edges[i]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return {ans1, ans2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962237,
                "title": "javascript-solution-kruskal-s-algorithm-with-union-find",
                "content": "```\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n\\n    // before sort the edges we use a simple trick for keep the original index after sorting\\n\\t\\n    for(let i = 0; i < edges.length; i++){\\n        edges[i].push(i)\\n    }\\n    // sort array edges in increasing order by weight\\n    edges.sort((a, b) => a[2] - b[2]);\\n\\t\\n    // find the weight of minimum spanning tree\\n\\t\\n    const MSTweight = findMSTweight(edges,n);\\n\\t\\n    // allocate two arrays for storing critical edges and pseudo edges\\n\\t\\n    let critical = [];\\n    let pseudo = [];\\n    // go through all edges and each step exclude one\\n    for(let j = 0;j < edges.length;j++){\\n        if(MSTweight < findMSTweight(edges, n,j)){\\n            critical.push(edges[j][3])\\n        }else if(MSTweight === findMSTweight(edges, n, -1,j)){\\n            pseudo.push(edges[j][3])\\n        }\\n    }\\n    return [critical, pseudo]\\n};\\n\\n// helper function for build MST and get min weight\\nfunction findMSTweight(edges, n, exclude = -1, included = -1){\\n    let weight = 0;\\n    const ds = new DisjointSets(n);\\n    if(included !== -1){\\n        let [src, dst, wgt,idx] = edges[included];\\n        if(ds.union(src, dst)){\\n            weight+= wgt;\\n        }\\n    }\\n    for(let k = 0; k < edges.length; k++){\\n        if(exclude === k){ \\n            continue;\\n        }\\n        let [src, dst, wgt, idx] = edges[k];\\n        if(ds.union(src, dst)){\\n            weight+= wgt;\\n        }\\n    }\\n    // so here the algorithm find the minimum weight for building MST\\n    // but the question is how to verify all vertices are connected\\n    for(let i = 0; i < n; i++) {\\n        if(ds.find(0) !== ds.find(i)){\\n            return Number.MAX_VALUE;\\n        }\\n    }\\n    return weight;\\n};\\n\\n// constructor function for build disjoint set\\n\\nfunction DisjointSets(n){\\n    this.parent = {};\\n    this.rank = {};\\n    for(let i = 0; i < n; i++){\\n        this.parent[i] = i;\\n        this.rank[i] = 0;\\n    }\\n    // utility function for find operation\\n    this.find = function (k){\\n        if(this.parent[k] == k){\\n            return k;\\n        }else{\\n            return this.parent[k] = this.find(this.parent[k]);\\n        }\\n    }\\n    // utiltiy function for union operation\\n    this.union = function (a,b){\\n        let x = this.find(a);\\n        let y = this.find(b);\\n        if(x == y){\\n            return false;\\n        }else if(this.rank[x] < this.rank[y]){\\n            this.parent[x] = y;\\n        }else if(this.rank[x] > this.rank[y]){\\n            this.parent[y] = x\\n        }else{\\n            this.parent[x] = y;\\n            this.rank[y] += 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\\n\\n    // before sort the edges we use a simple trick for keep the original index after sorting\\n\\t\\n    for(let i = 0; i < edges.length; i++){\\n        edges[i].push(i)\\n    }\\n    // sort array edges in increasing order by weight\\n    edges.sort((a, b) => a[2] - b[2]);\\n\\t\\n    // find the weight of minimum spanning tree\\n\\t\\n    const MSTweight = findMSTweight(edges,n);\\n\\t\\n    // allocate two arrays for storing critical edges and pseudo edges\\n\\t\\n    let critical = [];\\n    let pseudo = [];\\n    // go through all edges and each step exclude one\\n    for(let j = 0;j < edges.length;j++){\\n        if(MSTweight < findMSTweight(edges, n,j)){\\n            critical.push(edges[j][3])\\n        }else if(MSTweight === findMSTweight(edges, n, -1,j)){\\n            pseudo.push(edges[j][3])\\n        }\\n    }\\n    return [critical, pseudo]\\n};\\n\\n// helper function for build MST and get min weight\\nfunction findMSTweight(edges, n, exclude = -1, included = -1){\\n    let weight = 0;\\n    const ds = new DisjointSets(n);\\n    if(included !== -1){\\n        let [src, dst, wgt,idx] = edges[included];\\n        if(ds.union(src, dst)){\\n            weight+= wgt;\\n        }\\n    }\\n    for(let k = 0; k < edges.length; k++){\\n        if(exclude === k){ \\n            continue;\\n        }\\n        let [src, dst, wgt, idx] = edges[k];\\n        if(ds.union(src, dst)){\\n            weight+= wgt;\\n        }\\n    }\\n    // so here the algorithm find the minimum weight for building MST\\n    // but the question is how to verify all vertices are connected\\n    for(let i = 0; i < n; i++) {\\n        if(ds.find(0) !== ds.find(i)){\\n            return Number.MAX_VALUE;\\n        }\\n    }\\n    return weight;\\n};\\n\\n// constructor function for build disjoint set\\n\\nfunction DisjointSets(n){\\n    this.parent = {};\\n    this.rank = {};\\n    for(let i = 0; i < n; i++){\\n        this.parent[i] = i;\\n        this.rank[i] = 0;\\n    }\\n    // utility function for find operation\\n    this.find = function (k){\\n        if(this.parent[k] == k){\\n            return k;\\n        }else{\\n            return this.parent[k] = this.find(this.parent[k]);\\n        }\\n    }\\n    // utiltiy function for union operation\\n    this.union = function (a,b){\\n        let x = this.find(a);\\n        let y = this.find(b);\\n        if(x == y){\\n            return false;\\n        }else if(this.rank[x] < this.rank[y]){\\n            this.parent[x] = y;\\n        }else if(this.rank[x] > this.rank[y]){\\n            this.parent[y] = x\\n        }else{\\n            this.parent[x] = y;\\n            this.rank[y] += 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1457401,
                "title": "python-clean-o-e-2logv-and-o-ev-2-solutions-with-prim",
                "content": "__Solution 1__: Use Prim\\'s algorithm to compute the MST. Based on this value, we can take or remove a specific edge to check if it is critical or pseudo-critical. Prim\\'s algorithm runs in `O(V^2)` when using an adjacency list. We additionally need to loop over all edges. This brings the total time complexity to  `O(E*V^2)`.\\n```\\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    self.compute_graph(n, edges)\\n    ref = self.get_mst(n)\\n    critical, pseudo_critical = [], []\\n    for i, edge in enumerate(edges):\\n        # 1. take edge:\\n        if self.get_mst(n, init=edge) > ref:\\n            continue\\n        # 2. don\\'t take edge\\n        self.graph[edge[0]][edge[1]] = float(\\'inf\\')\\n        self.graph[edge[1]][edge[0]] = float(\\'inf\\')\\n        cost = self.get_mst(n)\\n        self.graph[edge[0]][edge[1]] = edge[2]\\n        self.graph[edge[1]][edge[0]] = edge[2]\\n        if cost > ref:\\n            critical.append(i)\\n        else:\\n            pseudo_critical.append(i)\\n    return [critical, pseudo_critical]\\n        \\ndef compute_graph(self, n, edges):\\n    self.graph = [[0]*n for _ in range(n)]\\n    for i,j,w in edges:\\n        self.graph[i][j] = w\\n        self.graph[j][i] = w\\n        \\ndef get_mst(self, n, init=None):\\n    mst = set()\\n    dist = [float(\\'inf\\')]*n\\n    cost = 0\\n    if init is not None:\\n        dist[init[1]] = 0\\n        dist[init[0]] = 0\\n        cost += init[2]\\n    else:\\n        dist[0] = 0\\n        \\n    for _ in range(n):\\n        # take node with lowest cost that does not belong to mst\\n        w_node = float(\\'inf\\')\\n        for i, w in enumerate(dist):\\n            if i not in mst and w < w_node:\\n                min_node, w_node = i, w\\n        \\n        # add to mst\\n        mst.add(min_node)\\n        cost += w_node\\n        \\n        # recompute distances\\n        for nn in range(n):\\n            if self.graph[min_node][nn] != 0 and nn not in mst:\\n                dist[nn] = min(dist[nn], self.graph[min_node][nn])\\n    return cost\\n```\\n__Solution 2__: We optimize the previous algorithm by using a heap to store the remaining vertices. Now we can fetch the one with the lowest cost in `O(logV)`. The overal time complexity is therefore `O(E^2*logV)`. Why is this faster? If you look at the constraints, you can see that the graph is rather sparse. Hence the  code underneath will be a lot faster (~9 times).\\n``` \\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    self.compute_graph(n, edges)\\n    ref, _ = self.get_mst(n)\\n    critical, pseudo_critical = [], []\\n    for i, edge in enumerate(edges):\\n        # 1. take edge:\\n        if self.get_mst(n, init=edge)[0] > ref:\\n            continue\\n        # 2. don\\'t take edge\\n        c, valid = self.get_mst(n, exclude=edge[:2])\\n        if c > ref or not valid:\\n            critical.append(i)\\n        else:\\n            pseudo_critical.append(i)\\n    return [critical, pseudo_critical]\\n    \\ndef compute_graph(self, n, edges):\\n    self.graph = defaultdict(list)\\n    for i,j,w in edges:\\n        self.graph[i].append((j,w))\\n        self.graph[j].append((i,w))\\n        \\ndef get_mst(self, n, init=None, exclude=[]):\\n    mst = set()\\n    dist = [float(\\'inf\\')]*n\\n    cost = 0\\n    if init is not None:\\n        q = [(0, init[0]), (0, init[1])]\\n        cost += init[2]\\n    else:\\n        q = [(0,0)]\\n    while q:\\n        min_w, min_node = heapq.heappop(q)\\n        if min_node in mst:\\n            continue\\n        mst.add(min_node)\\n        cost += min_w\\n        for nn in self.graph[min_node]:\\n            if not(min_node in exclude and nn[0] in exclude) and dist[nn[0]] > nn[1]:\\n                dist[nn[0]] = nn[1]\\n                heapq.heappush(q, (nn[1], nn[0]))\\n    return cost, len(mst) == n\\n```",
                "solutionTags": [],
                "code": "```\\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    self.compute_graph(n, edges)\\n    ref = self.get_mst(n)\\n    critical, pseudo_critical = [], []\\n    for i, edge in enumerate(edges):\\n        # 1. take edge:\\n        if self.get_mst(n, init=edge) > ref:\\n            continue\\n        # 2. don\\'t take edge\\n        self.graph[edge[0]][edge[1]] = float(\\'inf\\')\\n        self.graph[edge[1]][edge[0]] = float(\\'inf\\')\\n        cost = self.get_mst(n)\\n        self.graph[edge[0]][edge[1]] = edge[2]\\n        self.graph[edge[1]][edge[0]] = edge[2]\\n        if cost > ref:\\n            critical.append(i)\\n        else:\\n            pseudo_critical.append(i)\\n    return [critical, pseudo_critical]\\n        \\ndef compute_graph(self, n, edges):\\n    self.graph = [[0]*n for _ in range(n)]\\n    for i,j,w in edges:\\n        self.graph[i][j] = w\\n        self.graph[j][i] = w\\n        \\ndef get_mst(self, n, init=None):\\n    mst = set()\\n    dist = [float(\\'inf\\')]*n\\n    cost = 0\\n    if init is not None:\\n        dist[init[1]] = 0\\n        dist[init[0]] = 0\\n        cost += init[2]\\n    else:\\n        dist[0] = 0\\n        \\n    for _ in range(n):\\n        # take node with lowest cost that does not belong to mst\\n        w_node = float(\\'inf\\')\\n        for i, w in enumerate(dist):\\n            if i not in mst and w < w_node:\\n                min_node, w_node = i, w\\n        \\n        # add to mst\\n        mst.add(min_node)\\n        cost += w_node\\n        \\n        # recompute distances\\n        for nn in range(n):\\n            if self.graph[min_node][nn] != 0 and nn not in mst:\\n                dist[nn] = min(dist[nn], self.graph[min_node][nn])\\n    return cost\\n```\n``` \\ndef findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    self.compute_graph(n, edges)\\n    ref, _ = self.get_mst(n)\\n    critical, pseudo_critical = [], []\\n    for i, edge in enumerate(edges):\\n        # 1. take edge:\\n        if self.get_mst(n, init=edge)[0] > ref:\\n            continue\\n        # 2. don\\'t take edge\\n        c, valid = self.get_mst(n, exclude=edge[:2])\\n        if c > ref or not valid:\\n            critical.append(i)\\n        else:\\n            pseudo_critical.append(i)\\n    return [critical, pseudo_critical]\\n    \\ndef compute_graph(self, n, edges):\\n    self.graph = defaultdict(list)\\n    for i,j,w in edges:\\n        self.graph[i].append((j,w))\\n        self.graph[j].append((i,w))\\n        \\ndef get_mst(self, n, init=None, exclude=[]):\\n    mst = set()\\n    dist = [float(\\'inf\\')]*n\\n    cost = 0\\n    if init is not None:\\n        q = [(0, init[0]), (0, init[1])]\\n        cost += init[2]\\n    else:\\n        q = [(0,0)]\\n    while q:\\n        min_w, min_node = heapq.heappop(q)\\n        if min_node in mst:\\n            continue\\n        mst.add(min_node)\\n        cost += min_w\\n        for nn in self.graph[min_node]:\\n            if not(min_node in exclude and nn[0] in exclude) and dist[nn[0]] > nn[1]:\\n                dist[nn[0]] = nn[1]\\n                heapq.heappush(q, (nn[1], nn[0]))\\n    return cost, len(mst) == n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1289925,
                "title": "critical-and-pseudo-critical-edges-in-mst-java-kruskal-s-mst",
                "content": "***Java Code with Comments***\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> criticalEdges = new LinkedList<>();\\n        List<Integer> pseudoCriticalEdges = new LinkedList<>();\\n        HashMap<int[], Integer> edgeIndexMap = new HashMap<>();\\n        \\n\\t\\t// edgeIndexMap for identifying edge index later\\n        for (int i = 0; i < edges.length; i++){\\n            edgeIndexMap.put(edges[i], i);\\n        }\\n        \\n        Arrays.sort(edges, (edge1, edge2) -> Integer.compare(edge1[2], edge2[2]));\\n        \\n        int mstMinCost = getMSTMinCost(n, edges, null, null);\\n        for (int[] edge: edges) {\\n            int edgeIndex = edgeIndexMap.get(edge);\\n            int withoutCost = getMSTMinCost(n, edges, null, edge);\\n            if (withoutCost > mstMinCost) {\\n                criticalEdges.add(edgeIndex);\\n            }\\n            else {\\n                int withCost = getMSTMinCost(n, edges, edge, null);\\n                if (withCost == mstMinCost) {\\n                    pseudoCriticalEdges.add(edgeIndex);\\n                }\\n            }\\n        }\\n        \\n        return Arrays.asList(criticalEdges, pseudoCriticalEdges);\\n    }\\n    \\n\\t// get MST cost using Kruskal\\'s MST Algorithm\\n    private int getMSTMinCost(int vertices, int[][] edges, int[] includeEdge, int[] excludeEdge) {\\n        DisjointSetUnion dsu = new DisjointSetUnion(vertices);\\n        int minCost = 0;\\n        \\n        if (includeEdge != null) {\\n            dsu.union(includeEdge[0], includeEdge[1]);\\n            minCost += includeEdge[2];\\n        }\\n        \\n        for (int[] edge: edges) {\\n            if (dsu.getParent(edge[0]) == dsu.getParent(edge[1]) || \\n                (excludeEdge != null && edge[0] == excludeEdge[0] && edge[1] == excludeEdge[1]))\\n                continue;\\n            dsu.union(edge[0], edge[1]);\\n            minCost += edge[2];\\n        }\\n        \\n\\t\\t// if graph has more than 1 component, MST not possible\\n        return dsu.getComponentsCount() == 1 ? minCost : Integer.MAX_VALUE;\\n    }\\n}\\n\\n// class for performing disjoint set union/find operations\\nclass DisjointSetUnion {\\n    private int[] parent, rank;\\n    private int componentsCount;\\n    \\n    public DisjointSetUnion(int vertices) {\\n        parent = new int[vertices];\\n        rank = new int[vertices];\\n        componentsCount = vertices;\\n        \\n        for (int i = 0; i < vertices; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public void union(int node1, int node2) {\\n        int node1Parent = getParent(node1);\\n        int node2Parent = getParent(node2);\\n        \\n        if (node1Parent == node2Parent) {\\n            return;\\n        }\\n\\t\\t\\n        componentsCount--;   // decrement component count since here we combine 2 components\\n        if (rank[node1Parent] == rank[node2Parent]) {\\n            parent[node2Parent] = node1Parent;\\n            ++rank[node1Parent];\\n        }\\n        else if (rank[node1Parent] < rank[node2Parent]) {\\n            parent[node1Parent] = node2Parent;\\n        }\\n        else {\\n            parent[node2Parent] = node1Parent;\\n        }\\n    }\\n    \\n    public int getParent(int vertex) {\\n        if (parent[vertex] == vertex) {\\n            return vertex;\\n        }\\n        return parent[vertex] = getParent(parent[vertex]);   // path compression\\n    }\\n    \\n\\t// for fetching components count in the graph\\n    public int getComponentsCount() {\\n        return componentsCount;\\n    }\\n}\\n```\\n\\n**Analysis**\\n- Time Complexity: **O(e\\xB2)**\\n- Space Complexity: **O(e)**  ..  e = edges.length\\n",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> criticalEdges = new LinkedList<>();\\n        List<Integer> pseudoCriticalEdges = new LinkedList<>();\\n        HashMap<int[], Integer> edgeIndexMap = new HashMap<>();\\n        \\n\\t\\t// edgeIndexMap for identifying edge index later\\n        for (int i = 0; i < edges.length; i++){\\n            edgeIndexMap.put(edges[i], i);\\n        }\\n        \\n        Arrays.sort(edges, (edge1, edge2) -> Integer.compare(edge1[2], edge2[2]));\\n        \\n        int mstMinCost = getMSTMinCost(n, edges, null, null);\\n        for (int[] edge: edges) {\\n            int edgeIndex = edgeIndexMap.get(edge);\\n            int withoutCost = getMSTMinCost(n, edges, null, edge);\\n            if (withoutCost > mstMinCost) {\\n                criticalEdges.add(edgeIndex);\\n            }\\n            else {\\n                int withCost = getMSTMinCost(n, edges, edge, null);\\n                if (withCost == mstMinCost) {\\n                    pseudoCriticalEdges.add(edgeIndex);\\n                }\\n            }\\n        }\\n        \\n        return Arrays.asList(criticalEdges, pseudoCriticalEdges);\\n    }\\n    \\n\\t// get MST cost using Kruskal\\'s MST Algorithm\\n    private int getMSTMinCost(int vertices, int[][] edges, int[] includeEdge, int[] excludeEdge) {\\n        DisjointSetUnion dsu = new DisjointSetUnion(vertices);\\n        int minCost = 0;\\n        \\n        if (includeEdge != null) {\\n            dsu.union(includeEdge[0], includeEdge[1]);\\n            minCost += includeEdge[2];\\n        }\\n        \\n        for (int[] edge: edges) {\\n            if (dsu.getParent(edge[0]) == dsu.getParent(edge[1]) || \\n                (excludeEdge != null && edge[0] == excludeEdge[0] && edge[1] == excludeEdge[1]))\\n                continue;\\n            dsu.union(edge[0], edge[1]);\\n            minCost += edge[2];\\n        }\\n        \\n\\t\\t// if graph has more than 1 component, MST not possible\\n        return dsu.getComponentsCount() == 1 ? minCost : Integer.MAX_VALUE;\\n    }\\n}\\n\\n// class for performing disjoint set union/find operations\\nclass DisjointSetUnion {\\n    private int[] parent, rank;\\n    private int componentsCount;\\n    \\n    public DisjointSetUnion(int vertices) {\\n        parent = new int[vertices];\\n        rank = new int[vertices];\\n        componentsCount = vertices;\\n        \\n        for (int i = 0; i < vertices; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public void union(int node1, int node2) {\\n        int node1Parent = getParent(node1);\\n        int node2Parent = getParent(node2);\\n        \\n        if (node1Parent == node2Parent) {\\n            return;\\n        }\\n\\t\\t\\n        componentsCount--;   // decrement component count since here we combine 2 components\\n        if (rank[node1Parent] == rank[node2Parent]) {\\n            parent[node2Parent] = node1Parent;\\n            ++rank[node1Parent];\\n        }\\n        else if (rank[node1Parent] < rank[node2Parent]) {\\n            parent[node1Parent] = node2Parent;\\n        }\\n        else {\\n            parent[node2Parent] = node1Parent;\\n        }\\n    }\\n    \\n    public int getParent(int vertex) {\\n        if (parent[vertex] == vertex) {\\n            return vertex;\\n        }\\n        return parent[vertex] = getParent(parent[vertex]);   // path compression\\n    }\\n    \\n\\t// for fetching components count in the graph\\n    public int getComponentsCount() {\\n        return componentsCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906176,
                "title": "c-kruskal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define pii pair<int, int>\\n    \\n    vector<int> par;\\n    \\n    void initPar(){\\n        for(int i=0;i<par.size();i++) par[i] = i;\\n        return;\\n    }\\n    \\n    int findPar(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n    \\n    int findMST(vector<pii> &weights, vector<vector<int>>& edges, int avoid){\\n        int res = 0;\\n        \\n        for(auto w : weights){\\n            if(w.second == avoid) continue;\\n            int parX = findPar(edges[w.second][0]);\\n            int parY = findPar(edges[w.second][1]);\\n            \\n            if(parX == parY) continue;\\n            par[parY] = parX;\\n            res += w.first;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<pii> weights;\\n        int minCost = 0;\\n        \\n        par.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            weights.push_back({edges[i][2], i});\\n        }\\n        \\n        sort(weights.begin(), weights.end());\\n        \\n        // APPLY KRUSKAL TO FIND MST AND MIN_COST\\n        \\n        initPar();\\n        minCost = findMST(weights, edges, -1);\\n        vector<vector<int>> res(2);\\n        \\n        for(auto w : weights){\\n            initPar();\\n            int temp = findMST(weights, edges, w.second);\\n            if(findPar(edges[w.second][0]) != findPar(edges[w.second][1]) || temp > minCost){\\n                res[0].push_back(w.second);\\n                continue;\\n            }\\n             \\n            initPar();\\n            par[edges[w.second][0]] = edges[w.second][1];\\n            temp = w.first;\\n            temp += findMST(weights, edges, w.second);\\n            if(temp == minCost) res[1].push_back(w.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pii pair<int, int>\\n    \\n    vector<int> par;\\n    \\n    void initPar(){\\n        for(int i=0;i<par.size();i++) par[i] = i;\\n        return;\\n    }\\n    \\n    int findPar(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n    \\n    int findMST(vector<pii> &weights, vector<vector<int>>& edges, int avoid){\\n        int res = 0;\\n        \\n        for(auto w : weights){\\n            if(w.second == avoid) continue;\\n            int parX = findPar(edges[w.second][0]);\\n            int parY = findPar(edges[w.second][1]);\\n            \\n            if(parX == parY) continue;\\n            par[parY] = parX;\\n            res += w.first;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<pii> weights;\\n        int minCost = 0;\\n        \\n        par.resize(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            weights.push_back({edges[i][2], i});\\n        }\\n        \\n        sort(weights.begin(), weights.end());\\n        \\n        // APPLY KRUSKAL TO FIND MST AND MIN_COST\\n        \\n        initPar();\\n        minCost = findMST(weights, edges, -1);\\n        vector<vector<int>> res(2);\\n        \\n        for(auto w : weights){\\n            initPar();\\n            int temp = findMST(weights, edges, w.second);\\n            if(findPar(edges[w.second][0]) != findPar(edges[w.second][1]) || temp > minCost){\\n                res[0].push_back(w.second);\\n                continue;\\n            }\\n             \\n            initPar();\\n            par[edges[w.second][0]] = edges[w.second][1];\\n            temp = w.first;\\n            temp += findMST(weights, edges, w.second);\\n            if(temp == minCost) res[1].push_back(w.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855731,
                "title": "simple-java-solution-kruskal-algo",
                "content": "```\\nclass Solution {\\n    \\n    class Edge{\\n        int first;\\n        int second;\\n        int val;\\n        Edge(){}\\n        Edge(int first, int second, int val){\\n            this.first = first;\\n            this.second = second;\\n            this.val = val;\\n        }\\n        \\n        public String toString(){\\n            return \"[\"+first+\",\"+second+\",\"+val+\"]\";\\n        }\\n    }\\n    \\n    class Union{\\n        int[] arr;\\n        int n;\\n        Union(int n){\\n            this.n = n;\\n            arr = new int[n];\\n            for(int i=0;i<n;i++)\\n                arr[i] = i;\\n        }\\n        \\n        void union(int first, int second){\\n            int firstParent = find(first);\\n            int secondParent = find(second);\\n            \\n            arr[firstParent] = secondParent;\\n        }\\n        \\n        int find(int node){\\n            while(node!=arr[node]){\\n                node = arr[node];\\n            }\\n            return node;\\n        }\\n    }\\n    class Graph{\\n        int n;\\n        List<Edge> sortedEdges;\\n        \\n        Graph(int n){\\n            this.n = n;\\n            this.sortedEdges = new ArrayList<>();\\n        }\\n        \\n        void addEdge(int first, int second, int val){\\n            sortedEdges.add(new Edge(first, second, val));\\n        }\\n        \\n        void sortEdges(){\\n            Collections.sort(sortedEdges, new Comparator<Edge>(){\\n                public int compare(Edge a, Edge b){\\n                    return a.val - b.val;\\n                }\\n            });\\n        }\\n        \\n        int kruskalInclude(int start, int end, int val){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            union.union(start, end);\\n            result+= val;\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n        int kruskalExclude(int start, int end, int val){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                if(edge.first == start && edge.second == end && edge.val == val)\\n                    continue;\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n        int kruskal(){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n    }\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Graph graph = new Graph(n);\\n        \\n        for(int[] edge : edges){\\n            graph.addEdge(edge[0], edge[1], edge[2]);\\n        }\\n        \\n        graph.sortEdges();\\n        \\n        int original = graph.kruskal();\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int[] edge = edges[i];\\n            int weightByExludingAnEdge = graph.kruskalExclude(edge[0], edge[1], edge[2]);\\n\\n            if(original != weightByExludingAnEdge){\\n                result.get(0).add(i);        \\n            }\\n            else{\\n                int weightByIncudingAnEdge = graph.kruskalInclude(edge[0], edge[1], edge[2]);\\n                if(weightByIncudingAnEdge == original){\\n                    result.get(1).add(i);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Edge{\\n        int first;\\n        int second;\\n        int val;\\n        Edge(){}\\n        Edge(int first, int second, int val){\\n            this.first = first;\\n            this.second = second;\\n            this.val = val;\\n        }\\n        \\n        public String toString(){\\n            return \"[\"+first+\",\"+second+\",\"+val+\"]\";\\n        }\\n    }\\n    \\n    class Union{\\n        int[] arr;\\n        int n;\\n        Union(int n){\\n            this.n = n;\\n            arr = new int[n];\\n            for(int i=0;i<n;i++)\\n                arr[i] = i;\\n        }\\n        \\n        void union(int first, int second){\\n            int firstParent = find(first);\\n            int secondParent = find(second);\\n            \\n            arr[firstParent] = secondParent;\\n        }\\n        \\n        int find(int node){\\n            while(node!=arr[node]){\\n                node = arr[node];\\n            }\\n            return node;\\n        }\\n    }\\n    class Graph{\\n        int n;\\n        List<Edge> sortedEdges;\\n        \\n        Graph(int n){\\n            this.n = n;\\n            this.sortedEdges = new ArrayList<>();\\n        }\\n        \\n        void addEdge(int first, int second, int val){\\n            sortedEdges.add(new Edge(first, second, val));\\n        }\\n        \\n        void sortEdges(){\\n            Collections.sort(sortedEdges, new Comparator<Edge>(){\\n                public int compare(Edge a, Edge b){\\n                    return a.val - b.val;\\n                }\\n            });\\n        }\\n        \\n        int kruskalInclude(int start, int end, int val){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            union.union(start, end);\\n            result+= val;\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n        int kruskalExclude(int start, int end, int val){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                if(edge.first == start && edge.second == end && edge.val == val)\\n                    continue;\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n        int kruskal(){\\n            int visitedCount = 0;\\n            int result = 0;\\n            \\n            Union union = new Union(n);\\n            \\n            for(int i=0;i<sortedEdges.size();i++){\\n                Edge edge = sortedEdges.get(i);\\n                \\n                int firstParent = union.find(edge.first);\\n                int secondParent = union.find(edge.second);\\n                \\n                if(firstParent != secondParent){\\n                    result+=edge.val;\\n                    union.union(firstParent, secondParent);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n        \\n    }\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        Graph graph = new Graph(n);\\n        \\n        for(int[] edge : edges){\\n            graph.addEdge(edge[0], edge[1], edge[2]);\\n        }\\n        \\n        graph.sortEdges();\\n        \\n        int original = graph.kruskal();\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        \\n        for(int i=0;i<edges.length;i++){\\n            int[] edge = edges[i];\\n            int weightByExludingAnEdge = graph.kruskalExclude(edge[0], edge[1], edge[2]);\\n\\n            if(original != weightByExludingAnEdge){\\n                result.get(0).add(i);        \\n            }\\n            else{\\n                int weightByIncudingAnEdge = graph.kruskalInclude(edge[0], edge[1], edge[2]);\\n                if(weightByIncudingAnEdge == original){\\n                    result.get(1).add(i);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841280,
                "title": "c-brute-force-with-kruskal-140ms",
                "content": "Kruskal algorithm is a greedy algorithm which finds the MST of a weighted graph. It can be implemented by union find. Each time we add the valid edge with smallest weight into the MST. A valid edge is the edge that will not form a cycle.\\n\\nFirst use Kruskal algorithm to get the total weight of MST `min_cost`. \\nThen for each edge, try:\\n(1) Remove this edge and apply Kruskal to the rest. If the total weight is greater than `min_cost` or the graph cannot be connected, then the deleted edge is critical. We can continue with the next edge.\\n(2) Add this edge to MST first, and apply Kruskal to the rest edges. If the total weight is equal to `min_cost`, this edge is a pseudo-critical edge.\\n\\n```\\nclass Solution {\\n    typedef pair<int, int> PII;\\n    vector<int> pre;\\n    void initpre() {\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n    }\\n    int find(int root) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<PII> weights;\\n        vector<vector<int>> ret(2);\\n        for (int i = 0; i < edges.size(); i++) {\\n            weights.push_back({edges[i][2], i});\\n        }\\n        sort(weights.begin(), weights.end());\\n        pre.resize(n);\\n        initpre();\\n        int min_cost = 0;\\n        for (PII w : weights) {\\n            if (find(edges[w.second][0]) == find(edges[w.second][1])) continue;\\n            else {\\n                pre[find(edges[w.second][0])] = find(edges[w.second][1]);\\n                min_cost += w.first;\\n            }\\n        }\\n        int cost;\\n        for (int i = 0; i < weights.size(); i++) {\\n            initpre();\\n            cost = 0;\\n            for (int j = 0; j < weights.size(); j++) {\\n                if (i == j) continue;\\n                if (find(edges[weights[j].second][0]) == find(edges[weights[j].second][1])) continue;\\n                else {\\n                    pre[find(edges[weights[j].second][0])] = find(edges[weights[j].second][1]);\\n                    cost += weights[j].first;\\n                }\\n            }\\n            if (find(edges[weights[i].second][0]) != find(edges[weights[i].second][1]) || cost > min_cost) {\\n                ret[0].push_back(weights[i].second);\\n                continue;\\n            }\\n            initpre();\\n            pre[edges[weights[i].second][0]] = edges[weights[i].second][1];\\n            cost = weights[i].first;\\n            for (int j = 0; j < weights.size(); j++) {\\n                if (i == j) continue;\\n                if (find(edges[weights[j].second][0]) == find(edges[weights[j].second][1])) continue;\\n                else {\\n                    pre[find(edges[weights[j].second][0])] = find(edges[weights[j].second][1]);\\n                    cost += weights[j].first;\\n                }\\n            }\\n            if (cost == min_cost) ret[1].push_back(weights[i].second);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef pair<int, int> PII;\\n    vector<int> pre;\\n    void initpre() {\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n    }\\n    int find(int root) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<PII> weights;\\n        vector<vector<int>> ret(2);\\n        for (int i = 0; i < edges.size(); i++) {\\n            weights.push_back({edges[i][2], i});\\n        }\\n        sort(weights.begin(), weights.end());\\n        pre.resize(n);\\n        initpre();\\n        int min_cost = 0;\\n        for (PII w : weights) {\\n            if (find(edges[w.second][0]) == find(edges[w.second][1])) continue;\\n            else {\\n                pre[find(edges[w.second][0])] = find(edges[w.second][1]);\\n                min_cost += w.first;\\n            }\\n        }\\n        int cost;\\n        for (int i = 0; i < weights.size(); i++) {\\n            initpre();\\n            cost = 0;\\n            for (int j = 0; j < weights.size(); j++) {\\n                if (i == j) continue;\\n                if (find(edges[weights[j].second][0]) == find(edges[weights[j].second][1])) continue;\\n                else {\\n                    pre[find(edges[weights[j].second][0])] = find(edges[weights[j].second][1]);\\n                    cost += weights[j].first;\\n                }\\n            }\\n            if (find(edges[weights[i].second][0]) != find(edges[weights[i].second][1]) || cost > min_cost) {\\n                ret[0].push_back(weights[i].second);\\n                continue;\\n            }\\n            initpre();\\n            pre[edges[weights[i].second][0]] = edges[weights[i].second][1];\\n            cost = weights[i].first;\\n            for (int j = 0; j < weights.size(); j++) {\\n                if (i == j) continue;\\n                if (find(edges[weights[j].second][0]) == find(edges[weights[j].second][1])) continue;\\n                else {\\n                    pre[find(edges[weights[j].second][0])] = find(edges[weights[j].second][1]);\\n                    cost += weights[j].first;\\n                }\\n            }\\n            if (cost == min_cost) ret[1].push_back(weights[i].second);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786986,
                "title": "java-solution-using-union-find-and-kruskal-with-explanation",
                "content": "1> Calcuate cost of MST of given graph\\n2> Compute critical edges by fixing one edge and try to create MST without taking that edge. Calculate the cost. If new cost is more than cost computed in step 1, then the fixed edge is critical.\\nTrying to remove any one edge might break the tree into diconnected components, that case needs to be handled.\\nTry this for all edges.\\n3> Compute pseudo critical edge by fixing one edge ang try to create MST by including that edge. Calculate the cost. If new cost is same as the cost computed in step 1, then the fixed edge is pseudocritical.\\nTry this for all edges.\\n\\n```\\nclass Solution {\\n    \\n    int parent[];\\n    Set<Integer> set = new HashSet();\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edge) {\\n        \\n        int edges[][] = new int[edge.length][4];\\n        int mstCost = 0;\\n        parent = new int[n];\\n        List<Integer> list1 = new ArrayList();\\n        List<Integer> list2 = new ArrayList();\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        //copy the edges\\n        for(int i = 0; i < edges.length; i++){\\n            edges[i][0] = edge[i][0];\\n            edges[i][1] = edge[i][1];\\n            edges[i][2] = edge[i][2];\\n            edges[i][3] = i;\\n        }\\n        \\n        Arrays.sort(edges, new Comparator<int[]>(){\\n            public int compare(int a[], int b[]){\\n                return a[2] - b[2];\\n            }\\n        });\\n        \\n        //initialize parent array\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n    \\n        int cost = findMST(edges, n);\\n        mstCost = cost;\\n        //System.out.println(mstCost);\\n        \\n        //find critical\\n        for(int missing = 0; missing < edges.length; missing++){\\n            \\n            //initialize parent array\\n            for(int i = 0; i < n; i++)\\n                parent[i] = i;\\n\\n            int c = findCriticalMST(edges, n, missing);\\n            if(c != mstCost){\\n                list1.add(edges[missing][3]);\\n                set.add(edges[missing][3]);\\n            }\\n        }\\n        ans.add(list1);\\n        \\n        //find pseudo-critical\\n        for(int include = 0; include < edges.length; include++){\\n            //initialize parent array\\n            for(int i = 0; i < n; i++)\\n                parent[i] = i;\\n            int c = findPseudoMST(edges, n, edges[include]);\\n            \\n            if(c == mstCost && !set.contains(edges[include][3]))\\n                list2.add(edges[include][3]);\\n        }\\n        ans.add(list2);\\n        \\n        return ans;\\n    }\\n    \\n    public int findParent(int u){\\n        \\n        if(parent[u] == u)\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    \\n    public int findMST(int[][] edges, int n){\\n            \\n        int cost = 0, count = 0;\\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(count == n-1)\\n                break;\\n            \\n            int e[] = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            int pu = findParent(u);\\n            int pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n        if(count != n-1)\\n            cost = 1<<29;\\n        return cost;\\n    }\\n    \\n     public int findCriticalMST(int[][] edges, int n, int missing){\\n            \\n        int cost = 0, count = 0;\\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(i == missing)\\n                continue;\\n            \\n            if(count == n-1)\\n                break;\\n            \\n            int e[] = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            int pu = findParent(u);\\n            int pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n         if(count != n-1)\\n            cost = 1<<29;\\n        return cost;\\n    }\\n    \\n    public int findPseudoMST(int[][] edges, int n, int[] include){\\n       \\n        int cost = 0, count = 0, done = -1;\\n        \\n        int u = include[0];\\n        int v = include[1];\\n        done = include[3];\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu != pv){\\n            parent[pv] = pu;\\n            cost+=include[2];\\n            count++;\\n        }\\n        \\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(count == n-1)\\n                break;\\n            if(edges[i][3] == done)\\n                continue;\\n            \\n            int e[] = edges[i];\\n            u = e[0];\\n            v = e[1];\\n            pu = findParent(u);\\n            pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n        if(count != n-1)\\n            cost = 1<<29;\\n    \\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int parent[];\\n    Set<Integer> set = new HashSet();\\n    \\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edge) {\\n        \\n        int edges[][] = new int[edge.length][4];\\n        int mstCost = 0;\\n        parent = new int[n];\\n        List<Integer> list1 = new ArrayList();\\n        List<Integer> list2 = new ArrayList();\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        //copy the edges\\n        for(int i = 0; i < edges.length; i++){\\n            edges[i][0] = edge[i][0];\\n            edges[i][1] = edge[i][1];\\n            edges[i][2] = edge[i][2];\\n            edges[i][3] = i;\\n        }\\n        \\n        Arrays.sort(edges, new Comparator<int[]>(){\\n            public int compare(int a[], int b[]){\\n                return a[2] - b[2];\\n            }\\n        });\\n        \\n        //initialize parent array\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n    \\n        int cost = findMST(edges, n);\\n        mstCost = cost;\\n        //System.out.println(mstCost);\\n        \\n        //find critical\\n        for(int missing = 0; missing < edges.length; missing++){\\n            \\n            //initialize parent array\\n            for(int i = 0; i < n; i++)\\n                parent[i] = i;\\n\\n            int c = findCriticalMST(edges, n, missing);\\n            if(c != mstCost){\\n                list1.add(edges[missing][3]);\\n                set.add(edges[missing][3]);\\n            }\\n        }\\n        ans.add(list1);\\n        \\n        //find pseudo-critical\\n        for(int include = 0; include < edges.length; include++){\\n            //initialize parent array\\n            for(int i = 0; i < n; i++)\\n                parent[i] = i;\\n            int c = findPseudoMST(edges, n, edges[include]);\\n            \\n            if(c == mstCost && !set.contains(edges[include][3]))\\n                list2.add(edges[include][3]);\\n        }\\n        ans.add(list2);\\n        \\n        return ans;\\n    }\\n    \\n    public int findParent(int u){\\n        \\n        if(parent[u] == u)\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    \\n    public int findMST(int[][] edges, int n){\\n            \\n        int cost = 0, count = 0;\\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(count == n-1)\\n                break;\\n            \\n            int e[] = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            int pu = findParent(u);\\n            int pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n        if(count != n-1)\\n            cost = 1<<29;\\n        return cost;\\n    }\\n    \\n     public int findCriticalMST(int[][] edges, int n, int missing){\\n            \\n        int cost = 0, count = 0;\\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(i == missing)\\n                continue;\\n            \\n            if(count == n-1)\\n                break;\\n            \\n            int e[] = edges[i];\\n            int u = e[0];\\n            int v = e[1];\\n            int pu = findParent(u);\\n            int pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n         if(count != n-1)\\n            cost = 1<<29;\\n        return cost;\\n    }\\n    \\n    public int findPseudoMST(int[][] edges, int n, int[] include){\\n       \\n        int cost = 0, count = 0, done = -1;\\n        \\n        int u = include[0];\\n        int v = include[1];\\n        done = include[3];\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu != pv){\\n            parent[pv] = pu;\\n            cost+=include[2];\\n            count++;\\n        }\\n        \\n        //kushkal algo\\n        for(int i = 0; i < edges.length; i++){\\n            \\n            if(count == n-1)\\n                break;\\n            if(edges[i][3] == done)\\n                continue;\\n            \\n            int e[] = edges[i];\\n            u = e[0];\\n            v = e[1];\\n            pu = findParent(u);\\n            pv = findParent(v);\\n\\n            if(pu != pv){\\n                parent[pv] = pu;\\n                cost+=e[2];\\n                count++;\\n            }\\n        }\\n        if(count != n-1)\\n            cost = 1<<29;\\n    \\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785915,
                "title": "compact-python-code-with-union-find-and-kruskal-algorithm",
                "content": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find(par, x):\\n            if par[x] != x:\\n                par[x] = find(par, par[x])\\n            return par[x]\\n        \\n        def mst(edges, edge=None, isUse=False):\\n            par = {i:i for i in range(n)}\\n            mstweight = 0\\n            if edge and isUse:\\n                # first connect edge\\n                u,v,cost = edge\\n                par[u] = v\\n                mstweight += cost\\n                \\n            for u,v,cost in sorted(edges, key=lambda x:x[2]):\\n                if edge and [u,v,cost] == edge:\\n                    continue\\n                    \\n                ru, rv = find(par, u), find(par, v)\\n                if ru == rv:\\n                    continue\\n                par[ru] = rv # do not forgot this...\\n                mstweight += cost\\n            count = len(set([find(par, x) for x in par]))\\n            return mstweight if count == 1 else (2**31-1)\\n        bestmstweight = mst(edges)\\n        \\n        criticalList, noncritical = [], []\\n        \\n        for i in range(len(edges)):\\n            # remove edges[i] from edges and run mst algorithm again and check if the weight is larger, if larger, current edge is \"critical\"\\n            edges2 = edges[:i] + edges[i+1:]\\n            mstweight = mst(edges2, edges[i], isUse=False)\\n            \\n            if mstweight > bestmstweight:\\n                criticalList.append(i) # i is the index for current edge!\\n            else:\\n                # must use edges[i] and check if the result weight is same with the best weight, if yes, this is a noncritical!\\n                mstweight2 = mst(edges2, edges[i], isUse=True)\\n                if mstweight2 == bestmstweight:\\n                    noncritical.append(i)\\n        return [criticalList, noncritical]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        def find(par, x):\\n            if par[x] != x:\\n                par[x] = find(par, par[x])\\n            return par[x]\\n        \\n        def mst(edges, edge=None, isUse=False):\\n            par = {i:i for i in range(n)}\\n            mstweight = 0\\n            if edge and isUse:\\n                # first connect edge\\n                u,v,cost = edge\\n                par[u] = v\\n                mstweight += cost\\n                \\n            for u,v,cost in sorted(edges, key=lambda x:x[2]):\\n                if edge and [u,v,cost] == edge:\\n                    continue\\n                    \\n                ru, rv = find(par, u), find(par, v)\\n                if ru == rv:\\n                    continue\\n                par[ru] = rv # do not forgot this...\\n                mstweight += cost\\n            count = len(set([find(par, x) for x in par]))\\n            return mstweight if count == 1 else (2**31-1)\\n        bestmstweight = mst(edges)\\n        \\n        criticalList, noncritical = [], []\\n        \\n        for i in range(len(edges)):\\n            # remove edges[i] from edges and run mst algorithm again and check if the weight is larger, if larger, current edge is \"critical\"\\n            edges2 = edges[:i] + edges[i+1:]\\n            mstweight = mst(edges2, edges[i], isUse=False)\\n            \\n            if mstweight > bestmstweight:\\n                criticalList.append(i) # i is the index for current edge!\\n            else:\\n                # must use edges[i] and check if the result weight is same with the best weight, if yes, this is a noncritical!\\n                mstweight2 = mst(edges2, edges[i], isUse=True)\\n                if mstweight2 == bestmstweight:\\n                    noncritical.append(i)\\n        return [criticalList, noncritical]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700799,
                "title": "concise-java-solution-mst-union-find",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critcal = new ArrayList();\\n        List<Integer> pseudo = new ArrayList();\\n\\t\\t\\n        HashMap<int[],Integer> map = new HashMap();\\n         for(int i=0;i<edges.length;i++) map.put(edges[i],i);\\n\\t\\t \\n        Arrays.sort(edges,(e1,e2)->e1[2]-e2[2]);\\n        int min = minSpanningTree(edges,null,null,n);\\n        \\n        for(int i=0;i<edges.length;i++){\\n            if(minSpanningTree(edges,null,edges[i],n) > min)\\n                critcal.add(map.get(edges[i]));\\n            else{\\n                if(minSpanningTree(edges,edges[i],null,n) == min)\\n                  pseudo.add(map.get(edges[i]));  \\n            }\\n        }\\n        return Arrays.asList(critcal,pseudo);\\n     }\\n    \\n    public int minSpanningTree(int[][] edges, int[] incl, int[] excl, int n){\\n        int[] parent = new int[n];\\n        int cost = 0;\\n        int edge = 0;\\n        for(int i=0;i<n;i++) parent[i] = i;\\n        \\n        if(incl != null){\\n           int u = find(parent,incl[0]);\\n           int v =  find(parent,incl[1]);\\n            parent[v] = u;\\n            edge++;\\n            cost+= incl[2];\\n        }\\n        \\n        for(int i=0; i<edges.length; i++){\\n             if(excl == edges[i]) continue;\\n            int u = find(parent,edges[i][0]);\\n            int v = find(parent,edges[i][1]);\\n            \\n             if(u == v) continue;\\n            \\n             parent[v] = u;\\n             edge++;\\n             cost+=edges[i][2];\\n            if(edge == n-1) return cost;\\n        }\\n         return (edge == n-1) ? cost : Integer.MAX_VALUE;\\n    }\\n    \\n      public int find(int[] parent, int u){\\n          if(parent[u] == u) return u;\\n          return parent[u] = find(parent,parent[u]);\\n      }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> critcal = new ArrayList();\\n        List<Integer> pseudo = new ArrayList();\\n\\t\\t\\n        HashMap<int[],Integer> map = new HashMap();\\n         for(int i=0;i<edges.length;i++) map.put(edges[i],i);\\n\\t\\t \\n        Arrays.sort(edges,(e1,e2)->e1[2]-e2[2]);\\n        int min = minSpanningTree(edges,null,null,n);\\n        \\n        for(int i=0;i<edges.length;i++){\\n            if(minSpanningTree(edges,null,edges[i],n) > min)\\n                critcal.add(map.get(edges[i]));\\n            else{\\n                if(minSpanningTree(edges,edges[i],null,n) == min)\\n                  pseudo.add(map.get(edges[i]));  \\n            }\\n        }\\n        return Arrays.asList(critcal,pseudo);\\n     }\\n    \\n    public int minSpanningTree(int[][] edges, int[] incl, int[] excl, int n){\\n        int[] parent = new int[n];\\n        int cost = 0;\\n        int edge = 0;\\n        for(int i=0;i<n;i++) parent[i] = i;\\n        \\n        if(incl != null){\\n           int u = find(parent,incl[0]);\\n           int v =  find(parent,incl[1]);\\n            parent[v] = u;\\n            edge++;\\n            cost+= incl[2];\\n        }\\n        \\n        for(int i=0; i<edges.length; i++){\\n             if(excl == edges[i]) continue;\\n            int u = find(parent,edges[i][0]);\\n            int v = find(parent,edges[i][1]);\\n            \\n             if(u == v) continue;\\n            \\n             parent[v] = u;\\n             edge++;\\n             cost+=edges[i][2];\\n            if(edge == n-1) return cost;\\n        }\\n         return (edge == n-1) ? cost : Integer.MAX_VALUE;\\n    }\\n    \\n      public int find(int[] parent, int u){\\n          if(parent[u] == u) return u;\\n          return parent[u] = find(parent,parent[u]);\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699258,
                "title": "java-kruskal-cycle-detection",
                "content": "1. Use Kruskal to find all possible MSTs.\\n   * Normal Kruskal with one modification: When edge `A` creates a cycle and edge `A` has the same weight as edge `B` in the cycle. It means that  edge `B` can be replaced with edge `A` to create a different MST. Also it means that `A` and `B` are not a critical edges.\\n\\n2. When cycle detected: check, if the last edge `A`, that created cycle, has the same weigh as another edge `B` in the cycle, if so mark both as non critical.\\n   * Detect cycle with union-find.\\n\\n```\\nint[] roots;\\nMap<String, Integer> nonCrit = new HashMap<>();\\nMap<String, Integer> crit = new HashMap<>();\\nint[][] edgs;\\nSet<Integer>[] graph;\\n\\n@SuppressWarnings(\"unchecked\")\\npublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n\\tedgs = new int[edges.length][];\\n\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\tint[] e = edges[i];\\n\\t\\tpq.add(edgs[i] = new int[] { Math.min(e[0], e[1]), Math.max(e[0], e[1]), e[2], i });\\n\\t}\\n\\n\\troots = new int[n];\\n\\tgraph = new HashSet[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\troots[i] = i;\\n\\t\\tgraph[i] = new HashSet<>();\\n\\t}\\n\\n\\twhile (pq.size() > 0) {\\n\\t\\tint[] e = pq.poll();\\n\\t\\tint u = get(e[0]);\\n\\t\\tint v = get(e[1]);\\n\\n\\t\\tgraph[e[0]].add(e[1]);\\n\\t\\tgraph[e[1]].add(e[0]);\\n\\n\\t\\tif (u != v) {\\n\\t\\t\\tconnect(u, v);\\n\\t\\t\\tcrit.put(getKey(e), e[3]);\\n\\t\\t} else {\\n\\t\\t\\tdfs(-1, e[0], e, new Stack<>(), new boolean[n]);\\n\\t\\t\\tgraph[e[0]].remove(e[1]);\\n\\t\\t\\tgraph[e[1]].remove(e[0]);\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn Arrays.asList(new ArrayList<>(crit.values()), new ArrayList<>(nonCrit.values()));\\n}\\n\\nprivate String getKey(int[] e) {\\n\\treturn e[0] + \"_\" + e[1];\\n}\\n\\nprivate boolean dfs(int prev, int u, int[] lastEdge, Stack<int[]> stack, boolean[] visited) {\\n\\tif (visited[u]) {\\n\\t\\t// stack has the last edge and the start edge in the cycle, ignore them \\n\\t\\tint ignore = 2;\\n\\t\\twhile (ignore > 0) {\\n\\t\\t\\tint[] e = stack.pop();\\n\\t\\t\\tif (e[0] == u || e[1] == u) {\\n\\t\\t\\t\\tignore--;\\n\\t\\t\\t}\\n\\t\\t\\tString key = getKey(e);\\n\\t\\t\\tInteger val = crit.get(key);\\n\\t\\t\\tif (val != null && edgs[val][2] == lastEdge[2]) {\\n\\t\\t\\t\\tnonCrit.put(key, crit.get(key));\\n\\t\\t\\t\\tcrit.remove(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tInteger ncVal = nonCrit.get(key);\\n\\t\\t\\tif (ncVal != null && edgs[ncVal][2] == lastEdge[2]) {\\n\\t\\t\\t\\tnonCrit.put(getKey(lastEdge), lastEdge[3]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[u] = true;\\n\\tfor (int v : graph[u]) {\\n\\t\\tif (v != prev && v != u) {\\n\\t\\t\\tstack.add(new int[] { Math.min(u, v), Math.max(u, v) });\\n\\t\\t\\tif (!dfs(u, v, lastEdge, stack, visited)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\nprivate void connect(int u, int v) {\\n\\tint rU = get(u);\\n\\tint rV = get(v);\\n\\troots[rU] = rV;\\n}\\n\\nprivate int get(int u) {\\n\\tint orig = u;\\n\\twhile (u != roots[u]) {\\n\\t\\tu = roots[u];\\n\\t}\\n\\twhile (orig != roots[orig]) {\\n\\t\\tint tmp = roots[orig];\\n\\t\\troots[orig] = u;\\n\\t\\torig = tmp;\\n\\t}\\n\\n\\treturn u;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint[] roots;\\nMap<String, Integer> nonCrit = new HashMap<>();\\nMap<String, Integer> crit = new HashMap<>();\\nint[][] edgs;\\nSet<Integer>[] graph;\\n\\n@SuppressWarnings(\"unchecked\")\\npublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n\\tedgs = new int[edges.length][];\\n\\tfor (int i = 0; i < edges.length; i++) {\\n\\t\\tint[] e = edges[i];\\n\\t\\tpq.add(edgs[i] = new int[] { Math.min(e[0], e[1]), Math.max(e[0], e[1]), e[2], i });\\n\\t}\\n\\n\\troots = new int[n];\\n\\tgraph = new HashSet[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\troots[i] = i;\\n\\t\\tgraph[i] = new HashSet<>();\\n\\t}\\n\\n\\twhile (pq.size() > 0) {\\n\\t\\tint[] e = pq.poll();\\n\\t\\tint u = get(e[0]);\\n\\t\\tint v = get(e[1]);\\n\\n\\t\\tgraph[e[0]].add(e[1]);\\n\\t\\tgraph[e[1]].add(e[0]);\\n\\n\\t\\tif (u != v) {\\n\\t\\t\\tconnect(u, v);\\n\\t\\t\\tcrit.put(getKey(e), e[3]);\\n\\t\\t} else {\\n\\t\\t\\tdfs(-1, e[0], e, new Stack<>(), new boolean[n]);\\n\\t\\t\\tgraph[e[0]].remove(e[1]);\\n\\t\\t\\tgraph[e[1]].remove(e[0]);\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn Arrays.asList(new ArrayList<>(crit.values()), new ArrayList<>(nonCrit.values()));\\n}\\n\\nprivate String getKey(int[] e) {\\n\\treturn e[0] + \"_\" + e[1];\\n}\\n\\nprivate boolean dfs(int prev, int u, int[] lastEdge, Stack<int[]> stack, boolean[] visited) {\\n\\tif (visited[u]) {\\n\\t\\t// stack has the last edge and the start edge in the cycle, ignore them \\n\\t\\tint ignore = 2;\\n\\t\\twhile (ignore > 0) {\\n\\t\\t\\tint[] e = stack.pop();\\n\\t\\t\\tif (e[0] == u || e[1] == u) {\\n\\t\\t\\t\\tignore--;\\n\\t\\t\\t}\\n\\t\\t\\tString key = getKey(e);\\n\\t\\t\\tInteger val = crit.get(key);\\n\\t\\t\\tif (val != null && edgs[val][2] == lastEdge[2]) {\\n\\t\\t\\t\\tnonCrit.put(key, crit.get(key));\\n\\t\\t\\t\\tcrit.remove(key);\\n\\t\\t\\t}\\n\\n\\t\\t\\tInteger ncVal = nonCrit.get(key);\\n\\t\\t\\tif (ncVal != null && edgs[ncVal][2] == lastEdge[2]) {\\n\\t\\t\\t\\tnonCrit.put(getKey(lastEdge), lastEdge[3]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvisited[u] = true;\\n\\tfor (int v : graph[u]) {\\n\\t\\tif (v != prev && v != u) {\\n\\t\\t\\tstack.add(new int[] { Math.min(u, v), Math.max(u, v) });\\n\\t\\t\\tif (!dfs(u, v, lastEdge, stack, visited)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\nprivate void connect(int u, int v) {\\n\\tint rU = get(u);\\n\\tint rV = get(v);\\n\\troots[rU] = rV;\\n}\\n\\nprivate int get(int u) {\\n\\tint orig = u;\\n\\twhile (u != roots[u]) {\\n\\t\\tu = roots[u];\\n\\t}\\n\\twhile (orig != roots[orig]) {\\n\\t\\tint tmp = roots[orig];\\n\\t\\troots[orig] = u;\\n\\t\\torig = tmp;\\n\\t}\\n\\n\\treturn u;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698137,
                "title": "java-unionfind-kruskal-solution",
                "content": "\\tclass Solution {\\n\\t\\t\\n\\t\\t// Unionfind\\n\\t\\tint find(int u, int[] parent) {\\n\\t\\t\\twhile(parent[u]>=0)\\n\\t\\t\\t\\tu=parent[u];\\n\\t\\t\\treturn u;\\n\\t\\t}\\n\\t\\t// Kruskal algorithm\\n\\t\\tint MST(int[] parent, int[][] edges, int[][] e, int n, int init) {\\n\\t\\t\\tint edge=init;\\n\\t\\t\\tint curr=0;\\n\\t\\t\\tint minCost=0;\\n\\t\\t\\twhile(edge<n && curr<edges.length) {\\n\\t\\t\\t\\tint u=find(edges[e[curr][1]][0], parent);\\n\\t\\t\\t\\tint v=find(edges[e[curr][1]][1], parent);\\n\\t\\t\\t\\tif(v!=u){\\n\\t\\t\\t\\t\\tminCost+=e[curr][0];\\n\\t\\t\\t\\t\\tparent[u]=v;\\n\\t\\t\\t\\t\\t++edge;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t++curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn minCost;\\n\\t\\t}\\n    \\n\\t\\tpublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\t\\t\\tint[][] e=new int[edges.length][2];\\n\\t\\t\\tfor(int i=0; i<edges.length; i++) {\\n\\t\\t\\t\\te[i][0]=edges[i][2];\\n\\t\\t\\t\\te[i][1]=i;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tArrays.sort(e, (a,b)->a[0]-b[0]);\\n\\t\\t\\tint[] parent=new int[n];\\n\\t\\t\\tArrays.fill(parent, -1);\\n\\t\\t\\t// find the minimum cost\\n\\t\\t\\tint minCost=MST(parent, edges, e, n, 1);\\n\\t\\t\\tList<Integer> poss=new LinkedList<Integer>();\\n        \\n\\t\\t\\tfor(int i=0; i<e.length; i++) {\\n\\t\\t\\t\\tArrays.fill(parent, -1);\\n\\t\\t\\t\\tparent[edges[e[i][1]][0]]=edges[e[i][1]][1];\\n\\t\\t\\t\\tint val=MST(parent, edges, e, n, 2)+e[i][0];\\n\\t\\t\\t\\t// check\\n\\t\\t\\t\\tif(val==minCost)\\n\\t\\t\\t\\t\\tposs.add(e[i][1]);\\n\\t\\t\\t}\\n        \\n\\t\\t\\tList<List<Integer>> result=new ArrayList<List<Integer>>();\\n\\t\\t\\tresult.add(new ArrayList<Integer>());\\n\\t\\t\\tresult.add(new ArrayList<Integer>());\\n        \\n\\t\\t\\tfor(int i=0; i<poss.size(); i++) {\\n\\t\\t\\t\\tArrays.fill(parent, -1);\\n\\t\\t\\t\\tint cost=0;\\n\\t\\t\\t\\tint edge=0;\\n\\t\\t\\t\\tint m=poss.get(i);\\n\\t\\t\\t\\tfor(int j=0; j<poss.size(); j++) {\\n\\t\\t\\t\\t\\tif(i!=j) {\\n\\t\\t\\t\\t\\t\\tint node=poss.get(j);\\n\\t\\t\\t\\t\\t\\tint u=find(edges[node][0], parent);\\n\\t\\t\\t\\t\\t\\tint v=find(edges[node][1], parent);\\n\\t\\t\\t\\t\\t\\tif(u!=v) {\\n\\t\\t\\t\\t\\t\\t\\tparent[u]=v;\\n\\t\\t\\t\\t\\t\\t\\t++edge;\\n\\t\\t\\t\\t\\t\\t\\tcost+=edges[node][2];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\t// check whether the edge is a critical edge\\n\\t\\t\\t\\tif(edge<n-1 || cost>minCost)\\n\\t\\t\\t\\t\\tresult.get(0).add(m);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult.get(1).add(m);\\n\\t\\t\\t}\\n        \\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\t\\n\\t\\t// Unionfind\\n\\t\\tint find(int u, int[] parent) {\\n\\t\\t\\twhile(parent[u]>=0)\\n\\t\\t\\t\\tu=parent[u];\\n\\t\\t\\treturn u;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 697965,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\n    const int inf = 1234567890;\\n    int getf(vector<int>& f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    void make(vector<int> &f, vector<int> &num) {\\n        const int n = f.size();\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n    }\\n\\n    int mst(const vector<vector<int>>& edges, const vector<int> &ind, const int nume, vector<int> &f, vector<int>& num, int p) {\\n        int e = 0, w = 0;\\n        for (int i = 0; e < nume && i < ind.size(); ++i) {\\n            const int x = ind[i];\\n            if (x == p) continue;\\n            int xx = getf(f, edges[x][0]);\\n            int yy = getf(f, edges[x][1]);\\n            if (xx == yy) continue;\\n            ++e;\\n            if (num[xx] < num[yy]) {\\n                f[xx] = yy;\\n                num[yy] += num[xx];\\n            } else {\\n                f[yy] = xx;\\n                num[xx] += num[yy];\\n            }\\n            w += edges[x][2];\\n        }\\n        return e == nume ? w : inf;\\n    }\\n    \\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        const int m = edges.size();\\n        vector<int> ind(m);\\n        for (int i = 0; i < m; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int &x, const int &y) {\\n            return edges[x][2] < edges[y][2];\\n        });\\n        vector<int> f(n), num(n);\\n        make(f, num);\\n        const int w = mst(edges, ind, n - 1, f, num, -1);\\n        vector<vector<int>> r(2);\\n        for (int i = 0; i < m; ++i) {\\n            make(f, num);\\n            const int x = ind[i];\\n            const int may1 = mst(edges, ind, n - 1, f, num, x);\\n            if (may1 > w) {\\n                r[0].push_back(x);\\n            } else {\\n                make(f, num);\\n                f[edges[x][0]] = f[edges[x][1]];\\n                num[edges[x][1]] = 2;\\n                const int may2 = mst(edges, ind, n - 2, f, num, x) + edges[x][2];\\n                if (may2 == w) r[1].push_back(x);  \\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int inf = 1234567890;\\n    int getf(vector<int>& f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    void make(vector<int> &f, vector<int> &num) {\\n        const int n = f.size();\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n    }\\n\\n    int mst(const vector<vector<int>>& edges, const vector<int> &ind, const int nume, vector<int> &f, vector<int>& num, int p) {\\n        int e = 0, w = 0;\\n        for (int i = 0; e < nume && i < ind.size(); ++i) {\\n            const int x = ind[i];\\n            if (x == p) continue;\\n            int xx = getf(f, edges[x][0]);\\n            int yy = getf(f, edges[x][1]);\\n            if (xx == yy) continue;\\n            ++e;\\n            if (num[xx] < num[yy]) {\\n                f[xx] = yy;\\n                num[yy] += num[xx];\\n            } else {\\n                f[yy] = xx;\\n                num[xx] += num[yy];\\n            }\\n            w += edges[x][2];\\n        }\\n        return e == nume ? w : inf;\\n    }\\n    \\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        const int m = edges.size();\\n        vector<int> ind(m);\\n        for (int i = 0; i < m; ++i) {\\n            ind[i] = i;\\n        }\\n        sort(ind.begin(), ind.end(), [&](const int &x, const int &y) {\\n            return edges[x][2] < edges[y][2];\\n        });\\n        vector<int> f(n), num(n);\\n        make(f, num);\\n        const int w = mst(edges, ind, n - 1, f, num, -1);\\n        vector<vector<int>> r(2);\\n        for (int i = 0; i < m; ++i) {\\n            make(f, num);\\n            const int x = ind[i];\\n            const int may1 = mst(edges, ind, n - 1, f, num, x);\\n            if (may1 > w) {\\n                r[0].push_back(x);\\n            } else {\\n                make(f, num);\\n                f[edges[x][0]] = f[edges[x][1]];\\n                num[edges[x][1]] = 2;\\n                const int may2 = mst(edges, ind, n - 2, f, num, x) + edges[x][2];\\n                if (may2 == w) r[1].push_back(x);  \\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697959,
                "title": "python-kruskal-checking-every-edge",
                "content": "Sharing my python code after reading this solution: [C++ Solution, enumerating edges, with expalanation](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/697761/C++-Solution-enumerating-edges-with-expalanation)\\n\\nOne thing noticable is this graph is quite sparse: there is only at most 200 edges while there could be 100 vertices, which suggesting we use Kruskal algorithm.\\n\\nTime complexity:\\nSorting: O(E logE)\\nEach round of Kruskal after sorting: O(E \\u03B1(V)) \\u2248 O(E)   (Ref: [Kruskal\\'s algorithm - Wikipedia](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm#Complexity))\\nNumber of rounds of Kruskal: 2 * E\\nTotal: O(E^2 \\u03B1(V)) \\u2248 O(E^2) \\n\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.id = list(range(n))\\n        self.sz, self.count = [1] * n, n\\n\\n    def find(self, p):\\n        if self.id[p] != p: self.id[p] = self.find(self.id[p])\\n        return self.id[p]\\n    \\n    def union(self, p, q):\\n        i, j = self.find(p), self.find(q)\\n        if i == j: return\\n        if self.sz[i] < self.sz[j]:\\n            self.id[i] = j; self.sz[j] += self.sz[i]\\n        else:\\n            self.id[j] = i; self.sz[i] += self.sz[j]\\n        self.count -= 1\\n    \\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        se = sorted(enumerate(edges), key=lambda x: x[1][2])  # sorted edges\\n        def kruskal(pre_add, ban):  # pre-added edge and banned edge (sorted index). -1 means not adopting\\n            uf, totw = UnionFind(n), 0\\n            if pre_add >= 0:\\n                _, (u, v, w) = se[pre_add]\\n                uf.union(u, v)\\n                totw += w\\n                if uf.count == 1: return totw\\n            for i in range(len(edges)):\\n                if i == ban or i == pre_add: continue\\n                _, (u, v, w) = se[i]\\n                if uf.find(u) != uf.find(v):\\n                    uf.union(u, v)\\n                    totw += w\\n                    if uf.count == 1: break\\n            return totw if uf.count == 1 else 1000*1001\\n        MSTw = kruskal(-1, -1)  # normal weight of MST\\n        ans = [[],[]]\\n        for i in range(len(edges)):\\n            if kruskal(-1, i) > MSTw:  # banning ith edge (sorted index)\\n                ans[0].append(se[i][0])  # store the original index of edge\\n            elif kruskal(i, -1) == MSTw:  # pre-add ith edge (sorted index)\\n                ans[1].append(se[i][0])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.id = list(range(n))\\n        self.sz, self.count = [1] * n, n\\n\\n    def find(self, p):\\n        if self.id[p] != p: self.id[p] = self.find(self.id[p])\\n        return self.id[p]\\n    \\n    def union(self, p, q):\\n        i, j = self.find(p), self.find(q)\\n        if i == j: return\\n        if self.sz[i] < self.sz[j]:\\n            self.id[i] = j; self.sz[j] += self.sz[i]\\n        else:\\n            self.id[j] = i; self.sz[i] += self.sz[j]\\n        self.count -= 1\\n    \\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        se = sorted(enumerate(edges), key=lambda x: x[1][2])  # sorted edges\\n        def kruskal(pre_add, ban):  # pre-added edge and banned edge (sorted index). -1 means not adopting\\n            uf, totw = UnionFind(n), 0\\n            if pre_add >= 0:\\n                _, (u, v, w) = se[pre_add]\\n                uf.union(u, v)\\n                totw += w\\n                if uf.count == 1: return totw\\n            for i in range(len(edges)):\\n                if i == ban or i == pre_add: continue\\n                _, (u, v, w) = se[i]\\n                if uf.find(u) != uf.find(v):\\n                    uf.union(u, v)\\n                    totw += w\\n                    if uf.count == 1: break\\n            return totw if uf.count == 1 else 1000*1001\\n        MSTw = kruskal(-1, -1)  # normal weight of MST\\n        ans = [[],[]]\\n        for i in range(len(edges)):\\n            if kruskal(-1, i) > MSTw:  # banning ith edge (sorted index)\\n                ans[0].append(se[i][0])  # store the original index of edge\\n            elif kruskal(i, -1) == MSTw:  # pre-add ith edge (sorted index)\\n                ans[1].append(se[i][0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697784,
                "title": "python3-union-find-kruskal-bfs-without-enumerate",
                "content": "For the time complexity, maybe O(Elog(E)) \\uFF1FI\\'m not quite sure about that.\\n\\n```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        p_necessary, p_useful = [], []\\n\\n        # Union-Find, maintain the graph\\n        fathers = {i:i for i in range(n)}\\n        def get_father(t) :\\n            while not fathers[t] == fathers[fathers[t]] :\\n                fathers[t] = fathers[fathers[t]]\\n            return fathers[t]\\n\\n\\n        # based on Kruskal, from the lowest weight\\n        w2e = collections.defaultdict(lambda:[])\\n        for i, (s, e, w) in enumerate(edges) :\\n            w2e[w].append(sorted([s, e])+[i])\\n        # print(dict(w2e))\\n        w_list = sorted(w2e.keys())\\n        for wt in w_list :\\n            edge_list = w2e[wt]\\n            \\n            # build temporary graph based on the Union\\n            # degree dict: dus && p2es: point 2 edgeid\\n            new_edge_list = []\\n            dus = collections.defaultdict(lambda:0)\\n            p2es = collections.defaultdict(lambda:[])\\n            for s, e, ie in edge_list :\\n                fs, fe = get_father(s), get_father(e)\\n                # edges between connected points are useless\\n                if fs == fe :\\n                    continue\\n                dus[fs] += 1\\n                dus[fe] += 1\\n                p2es[fs].append(len(new_edge_list))\\n                p2es[fe].append(len(new_edge_list))\\n                new_edge_list.append([fs, fe, ie])\\n            edge_list = new_edge_list\\n            \\n            # print(fathers)\\n            # print(edge_list)\\n            # print(dict(dus))\\n            # print(dict(p2es))\\n            # print(\\'-\\')\\n    \\n            # DFS to find the necessary edges\\n            to_delete_e = [es for es in p2es.values() if len(es) == 1]\\n            to_delete_e = [e for es in to_delete_e for e in es]\\n            visited_edge_list_id = set(to_delete_e)\\n            while len(to_delete_e) > 0 :\\n                edge_list_id = to_delete_e.pop(0)\\n                fs, fe, ie = edge_list[edge_list_id]\\n                visited_edge_list_id.add(edge_list_id)\\n                dus[fs] -= 1\\n                dus[fe] -= 1\\n                for ttts in [fs, fe] :\\n                    if dus[ttts] == 1 :\\n                        for eid in p2es[ttts] :\\n                            if eid in visited_edge_list_id :\\n                                continue\\n                            to_delete_e.append(eid)\\n                            visited_edge_list_id.add(eid)\\n\\n            # refresh the answer, and add edges to the graph(U-F).\\n            for i, (s, e, ie) in enumerate(edge_list) :\\n                if i in visited_edge_list_id :\\n                    p_necessary.append(ie)\\n                else :\\n                    p_useful.append(ie)\\n                fs, fe = get_father(s), get_father(e)\\n                fathers[get_father(e)] = get_father(s)\\n            # print(p_necessary)\\n        return [p_necessary, p_useful]\\n            \\n            \\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        p_necessary, p_useful = [], []\\n\\n        # Union-Find, maintain the graph\\n        fathers = {i:i for i in range(n)}\\n        def get_father(t) :\\n            while not fathers[t] == fathers[fathers[t]] :\\n                fathers[t] = fathers[fathers[t]]\\n            return fathers[t]\\n\\n\\n        # based on Kruskal, from the lowest weight\\n        w2e = collections.defaultdict(lambda:[])\\n        for i, (s, e, w) in enumerate(edges) :\\n            w2e[w].append(sorted([s, e])+[i])\\n        # print(dict(w2e))\\n        w_list = sorted(w2e.keys())\\n        for wt in w_list :\\n            edge_list = w2e[wt]\\n            \\n            # build temporary graph based on the Union\\n            # degree dict: dus && p2es: point 2 edgeid\\n            new_edge_list = []\\n            dus = collections.defaultdict(lambda:0)\\n            p2es = collections.defaultdict(lambda:[])\\n            for s, e, ie in edge_list :\\n                fs, fe = get_father(s), get_father(e)\\n                # edges between connected points are useless\\n                if fs == fe :\\n                    continue\\n                dus[fs] += 1\\n                dus[fe] += 1\\n                p2es[fs].append(len(new_edge_list))\\n                p2es[fe].append(len(new_edge_list))\\n                new_edge_list.append([fs, fe, ie])\\n            edge_list = new_edge_list\\n            \\n            # print(fathers)\\n            # print(edge_list)\\n            # print(dict(dus))\\n            # print(dict(p2es))\\n            # print(\\'-\\')\\n    \\n            # DFS to find the necessary edges\\n            to_delete_e = [es for es in p2es.values() if len(es) == 1]\\n            to_delete_e = [e for es in to_delete_e for e in es]\\n            visited_edge_list_id = set(to_delete_e)\\n            while len(to_delete_e) > 0 :\\n                edge_list_id = to_delete_e.pop(0)\\n                fs, fe, ie = edge_list[edge_list_id]\\n                visited_edge_list_id.add(edge_list_id)\\n                dus[fs] -= 1\\n                dus[fe] -= 1\\n                for ttts in [fs, fe] :\\n                    if dus[ttts] == 1 :\\n                        for eid in p2es[ttts] :\\n                            if eid in visited_edge_list_id :\\n                                continue\\n                            to_delete_e.append(eid)\\n                            visited_edge_list_id.add(eid)\\n\\n            # refresh the answer, and add edges to the graph(U-F).\\n            for i, (s, e, ie) in enumerate(edge_list) :\\n                if i in visited_edge_list_id :\\n                    p_necessary.append(ie)\\n                else :\\n                    p_useful.append(ie)\\n                fs, fe = get_father(s), get_father(e)\\n                fathers[get_father(e)] = get_father(s)\\n            # print(p_necessary)\\n        return [p_necessary, p_useful]\\n            \\n            \\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4107266,
                "title": "typescript-kruskal-s-algorithm-time-o-nm-mlogm-space-o-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n**N** is # of nodes, **M** is # of edges.\\n\\n- Time complexity: O(NM + Mlog(M))\\n- Space complexity: O(M)\\n\\n# Code\\n```Typescript\\nfunction findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\\n    \\n    // n nodes need at least n - 1 edges\\n    const M = edges.length;\\n    if (M < n - 1) {\\n        return [[], []];\\n    }\\n\\n    // Add original index to each edge\\n    for (let i = 0; i < M; ++i) {\\n        edges[i].push(i);\\n    }\\n\\n    // Sort edges by weight ASC\\n    edges.sort((a, b) => a[2] - b[2]);\\n\\n    // Find initial MST\\n    let dsu = new DSU(n);\\n    const master: number[] = [];\\n    const map = new Map<number, number>();\\n    for (let i = 0, j = 1; j < n; ++i) {\\n        const edge = edges[i];\\n        if (!dsu.merge(edge[0], edge[1])) {\\n            continue;\\n        }\\n        ++j;\\n        const k = map.get(edge[2]) ?? i;\\n        map.set(edge[2], k + 1);\\n        edges[i] = edges[k];\\n        edges[k] = edge;\\n        master.push(k);\\n    }\\n\\n    // For each edge in the initial MST:\\n    const crits: number[] = [];\\n    const pseus = new Set<number>();\\n    for (let i = 0, N = master.length; i < N; ++i) {\\n\\n        // Create an almost-MST without the edge\\n        dsu = new DSU(n);\\n        for (let j = 0; j < N; ++j) {\\n            if (i !== j) {\\n                const [a, b] = edges[master[j]];\\n                dsu.merge(a, b);\\n            }\\n        }\\n\\n        // Check if MST can still be completed\\n        let isCrit = true;\\n        const edgeI = master[i];\\n        const weight = edges[edgeI][2];\\n        for (let j = map.get(weight); j < M && edges[j][2] === weight; ++j) {\\n            const [a, b,, k] = edges[j];\\n            if (dsu.find(a) !== dsu.find(b)) {\\n                isCrit = false;\\n                pseus.add(k);\\n            }\\n        }\\n\\n        // Mark edge as critial or pseudo-critical\\n        if (isCrit) {\\n            crits.push(edges[edgeI][3]);\\n        } else {\\n            pseus.add(edges[edgeI][3]);\\n        }\\n    }\\n\\n    return [crits, Array.from(pseus)];\\n};\\n\\nclass DSU {\\n    roots: number[];\\n    ranks: number[];\\n\\n    constructor(N: number) {\\n        const roots: number[] = [];\\n        for (let i = 0; i < N; roots.push(i++)){}\\n        this.roots = roots;\\n        this.ranks = new Array(N).fill(1);\\n    }\\n\\n    find(a: number): number {\\n        const roots = this.roots;\\n        let b = a;\\n        while (a !== roots[a]) {\\n            a = roots[a];\\n        }\\n        while (b !== a) {\\n            const c = roots[b];\\n            roots[b] = a;\\n            b = c;\\n        }\\n        return a;\\n    }\\n\\n    merge(a: number, b: number): boolean {\\n        a = this.find(a);\\n        b = this.find(b);\\n        if (a === b) {\\n            return false;\\n        }\\n        if (this.ranks[a] < this.ranks[b]) {\\n            const c = a;\\n            a = b;\\n            b = c;\\n        }\\n        this.roots[b] = a;\\n        this.ranks[a] += this.ranks[b];\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Union Find",
                    "Minimum Spanning Tree"
                ],
                "code": "```Typescript\\nfunction findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\\n    \\n    // n nodes need at least n - 1 edges\\n    const M = edges.length;\\n    if (M < n - 1) {\\n        return [[], []];\\n    }\\n\\n    // Add original index to each edge\\n    for (let i = 0; i < M; ++i) {\\n        edges[i].push(i);\\n    }\\n\\n    // Sort edges by weight ASC\\n    edges.sort((a, b) => a[2] - b[2]);\\n\\n    // Find initial MST\\n    let dsu = new DSU(n);\\n    const master: number[] = [];\\n    const map = new Map<number, number>();\\n    for (let i = 0, j = 1; j < n; ++i) {\\n        const edge = edges[i];\\n        if (!dsu.merge(edge[0], edge[1])) {\\n            continue;\\n        }\\n        ++j;\\n        const k = map.get(edge[2]) ?? i;\\n        map.set(edge[2], k + 1);\\n        edges[i] = edges[k];\\n        edges[k] = edge;\\n        master.push(k);\\n    }\\n\\n    // For each edge in the initial MST:\\n    const crits: number[] = [];\\n    const pseus = new Set<number>();\\n    for (let i = 0, N = master.length; i < N; ++i) {\\n\\n        // Create an almost-MST without the edge\\n        dsu = new DSU(n);\\n        for (let j = 0; j < N; ++j) {\\n            if (i !== j) {\\n                const [a, b] = edges[master[j]];\\n                dsu.merge(a, b);\\n            }\\n        }\\n\\n        // Check if MST can still be completed\\n        let isCrit = true;\\n        const edgeI = master[i];\\n        const weight = edges[edgeI][2];\\n        for (let j = map.get(weight); j < M && edges[j][2] === weight; ++j) {\\n            const [a, b,, k] = edges[j];\\n            if (dsu.find(a) !== dsu.find(b)) {\\n                isCrit = false;\\n                pseus.add(k);\\n            }\\n        }\\n\\n        // Mark edge as critial or pseudo-critical\\n        if (isCrit) {\\n            crits.push(edges[edgeI][3]);\\n        } else {\\n            pseus.add(edges[edgeI][3]);\\n        }\\n    }\\n\\n    return [crits, Array.from(pseus)];\\n};\\n\\nclass DSU {\\n    roots: number[];\\n    ranks: number[];\\n\\n    constructor(N: number) {\\n        const roots: number[] = [];\\n        for (let i = 0; i < N; roots.push(i++)){}\\n        this.roots = roots;\\n        this.ranks = new Array(N).fill(1);\\n    }\\n\\n    find(a: number): number {\\n        const roots = this.roots;\\n        let b = a;\\n        while (a !== roots[a]) {\\n            a = roots[a];\\n        }\\n        while (b !== a) {\\n            const c = roots[b];\\n            roots[b] = a;\\n            b = c;\\n        }\\n        return a;\\n    }\\n\\n    merge(a: number, b: number): boolean {\\n        a = this.find(a);\\n        b = this.find(b);\\n        if (a === b) {\\n            return false;\\n        }\\n        if (this.ranks[a] < this.ranks[b]) {\\n            const c = a;\\n            a = b;\\n            b = c;\\n        }\\n        this.roots[b] = a;\\n        this.ranks[a] += this.ranks[b];\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092649,
                "title": "clean-code-using-kruskal-s-algorithm-disjoint-set-union-well-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor those having difficulty in clearly understanding the question, Here is the short explanation:\\n\\nIf on excluding an edge, the minimum weight of the spanning tree is greater than the original MST weight, the edge is a critical edge.\\n\\nIf on excluding an edge, the minimum weight of the spanning tree is equal to original MST weight, then further check:\\n    a) If on including that edge, the minimum weight of the spanning tree is equal to the original MST weight, then the edge is a pseudo critical edge.\\n    b) If on including that edge, the minimum weight of the spanning tree is greater than original MST weight, then the edge is neither critical nor pseudo critical.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will traverse and check for every edge.\\nWe shall apply Kruskal\\'s algorithm.\\nFor that, first we will sort the array according to the edge weights.\\nThe code is self-explanatory.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define inf 2e9\\n    class DisjointSet\\n    {\\n        private:\\n        vector<int>parent, rank;\\n\\n        public:\\n        DisjointSet(int n)\\n        {\\n            parent.resize(n);\\n            rank.resize(n);\\n\\n            for(int i = 0; i < n; i++) parent[i] = i;\\n            for(int i = 0; i < n; i++) rank[i] = 0;\\n        }\\n\\n        int findUltimateParent(int node)\\n        {\\n            if(node != parent[node]) return parent[node] = findUltimateParent(parent[node]);\\n            else return node;\\n        }\\n\\n        void unionByRank(int u, int v)\\n        {\\n            int ultimate_parent_u = findUltimateParent(u);\\n            int ultimate_parent_v = findUltimateParent(v);\\n\\n            if(ultimate_parent_u == ultimate_parent_v) return;\\n\\n            else\\n            {\\n                if(rank[u] > rank[v])\\n                {\\n                    parent[ultimate_parent_v] = ultimate_parent_u;\\n                }\\n\\n                else if(rank[u] < rank[v])\\n                {\\n                    parent[ultimate_parent_u] = ultimate_parent_v;\\n                }\\n\\n                else\\n                {\\n                    parent[ultimate_parent_v] = ultimate_parent_u;\\n                    rank[ultimate_parent_u]++;\\n                }\\n            }\\n        }\\n    };\\n\\n    static bool cmp(vector<int> &A, vector<int> &B)\\n    {\\n        return (A[2] < B[2]);\\n    }\\n\\n    int Kruskal(int &n, vector<vector<int>> &edges, int include, int exclude)\\n    {\\n        int weight = 0;\\n        DisjointSet ds(n);\\n\\n        // Please add the weight of the edge to be included in the spanning tree and form the union of the nodes to ensure they are included.\\n        if(include != -1)\\n        {\\n            int u = edges[include][0];\\n            int v = edges[include][1];\\n            int w = edges[include][2];\\n            if(u > v) swap(u, v);\\n            weight += w;\\n            ds.unionByRank(u, v);\\n        }\\n\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(i == exclude) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int w = edges[i][2];\\n\\n            // If the edge is already a part of the spanning tree, please don\\'t include (or add) its weight again.\\n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) continue;\\n\\n            ds.unionByRank(u, v);\\n            weight += w;\\n        }\\n\\n        //If there are more than 1 components in the graph, it cannot be a spanning tree.\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ds.findUltimateParent(i) != ds.findUltimateParent(0)) return inf;\\n        }\\n        return weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n\\n        int m = edges.size();\\n\\n        // Keeping a track of the original indices of the edges so that they may not be lost after sorting.\\n        for(int i = 0; i < m; i++) edges[i].push_back(i);\\n\\n        // Sorting the edges in the increasing order of their weights in order to apply Kruskal\\'s algorithm.\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        // Finding the weight of MST.\\n        int mini = Kruskal(n, edges, -1, -1);\\n\\n        vector<int>critical, p_critical;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(Kruskal(n, edges, -1, i) > mini) critical.push_back(edges[i][3]);\\n            else if(Kruskal(n, edges, i, -1) == mini) p_critical.push_back(edges[i][3]);\\n        }\\n        return {critical, p_critical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define inf 2e9\\n    class DisjointSet\\n    {\\n        private:\\n        vector<int>parent, rank;\\n\\n        public:\\n        DisjointSet(int n)\\n        {\\n            parent.resize(n);\\n            rank.resize(n);\\n\\n            for(int i = 0; i < n; i++) parent[i] = i;\\n            for(int i = 0; i < n; i++) rank[i] = 0;\\n        }\\n\\n        int findUltimateParent(int node)\\n        {\\n            if(node != parent[node]) return parent[node] = findUltimateParent(parent[node]);\\n            else return node;\\n        }\\n\\n        void unionByRank(int u, int v)\\n        {\\n            int ultimate_parent_u = findUltimateParent(u);\\n            int ultimate_parent_v = findUltimateParent(v);\\n\\n            if(ultimate_parent_u == ultimate_parent_v) return;\\n\\n            else\\n            {\\n                if(rank[u] > rank[v])\\n                {\\n                    parent[ultimate_parent_v] = ultimate_parent_u;\\n                }\\n\\n                else if(rank[u] < rank[v])\\n                {\\n                    parent[ultimate_parent_u] = ultimate_parent_v;\\n                }\\n\\n                else\\n                {\\n                    parent[ultimate_parent_v] = ultimate_parent_u;\\n                    rank[ultimate_parent_u]++;\\n                }\\n            }\\n        }\\n    };\\n\\n    static bool cmp(vector<int> &A, vector<int> &B)\\n    {\\n        return (A[2] < B[2]);\\n    }\\n\\n    int Kruskal(int &n, vector<vector<int>> &edges, int include, int exclude)\\n    {\\n        int weight = 0;\\n        DisjointSet ds(n);\\n\\n        // Please add the weight of the edge to be included in the spanning tree and form the union of the nodes to ensure they are included.\\n        if(include != -1)\\n        {\\n            int u = edges[include][0];\\n            int v = edges[include][1];\\n            int w = edges[include][2];\\n            if(u > v) swap(u, v);\\n            weight += w;\\n            ds.unionByRank(u, v);\\n        }\\n\\n        int m = edges.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(i == exclude) continue;\\n\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int w = edges[i][2];\\n\\n            // If the edge is already a part of the spanning tree, please don\\'t include (or add) its weight again.\\n            if(ds.findUltimateParent(u) == ds.findUltimateParent(v)) continue;\\n\\n            ds.unionByRank(u, v);\\n            weight += w;\\n        }\\n\\n        //If there are more than 1 components in the graph, it cannot be a spanning tree.\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ds.findUltimateParent(i) != ds.findUltimateParent(0)) return inf;\\n        }\\n        return weight;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n\\n        int m = edges.size();\\n\\n        // Keeping a track of the original indices of the edges so that they may not be lost after sorting.\\n        for(int i = 0; i < m; i++) edges[i].push_back(i);\\n\\n        // Sorting the edges in the increasing order of their weights in order to apply Kruskal\\'s algorithm.\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        // Finding the weight of MST.\\n        int mini = Kruskal(n, edges, -1, -1);\\n\\n        vector<int>critical, p_critical;\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(Kruskal(n, edges, -1, i) > mini) critical.push_back(edges[i][3]);\\n            else if(Kruskal(n, edges, i, -1) == mini) p_critical.push_back(edges[i][3]);\\n        }\\n        return {critical, p_critical};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4077687,
                "title": "kruskal-approach",
                "content": "# Kruskal\\n```\\nint parent_[100], rank_[100];\\n\\nvoid init(int n) {\\n    for(int i=0; i<n; i++)\\n    parent_[i] = i, rank_[i] = 1;\\n}\\n\\nint find_(int x) {\\n    if(parent_[x] == x)\\n    return x;\\n\\n    return parent_[x] = find_(parent_[x]);\\n}\\n\\nvoid union_(int x, int y) {\\n    int px = find_(x), py = find_(y);\\n\\n    if(px == py)\\n    return;\\n\\n    if(rank_[px] < rank_[py])\\n    swap(px, py);\\n\\n    parent_[py] = px;\\n    rank_[px] += rank_[py];\\n}\\n\\nclass Solution {\\npublic:\\n    int kruskal(int n, vector<vector<int>>& edges, vector<int>& inds, int use = -1, int ignore = -1) {\\n        int weight = 0, num_edges = 0;\\n\\n        init(n);\\n\\n        if(use != -1)\\n        weight += edges[use][2], union_(edges[use][0], edges[use][1]), num_edges++;\\n\\n        for(auto e: inds)\\n        if(e != ignore and find_(edges[e][0]) != find_(edges[e][1]))\\n        weight += edges[e][2], union_(edges[e][0], edges[e][1]), num_edges++;\\n\\n        if(num_edges < n - 1)\\n        return -1;\\n\\n        return weight;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> inds(edges.size());\\n        iota(inds.begin(), inds.end(), 0);\\n\\n        sort(inds.begin(), inds.end(), [&edges](int x, int y) {\\n            return edges[x][2] < edges[y][2];\\n        });\\n\\n        int min_weight = kruskal(n, edges, inds);\\n\\n        vector<vector<int>> ans(2, vector<int>());\\n\\n        for(int i=0; i<edges.size(); i++)\\n        if(kruskal(n, edges, inds, i) == min_weight) {\\n            if(kruskal(n, edges, inds, -1, i) != min_weight)\\n            ans[0].push_back(i);\\n            else\\n            ans[1].push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};      \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint parent_[100], rank_[100];\\n\\nvoid init(int n) {\\n    for(int i=0; i<n; i++)\\n    parent_[i] = i, rank_[i] = 1;\\n}\\n\\nint find_(int x) {\\n    if(parent_[x] == x)\\n    return x;\\n\\n    return parent_[x] = find_(parent_[x]);\\n}\\n\\nvoid union_(int x, int y) {\\n    int px = find_(x), py = find_(y);\\n\\n    if(px == py)\\n    return;\\n\\n    if(rank_[px] < rank_[py])\\n    swap(px, py);\\n\\n    parent_[py] = px;\\n    rank_[px] += rank_[py];\\n}\\n\\nclass Solution {\\npublic:\\n    int kruskal(int n, vector<vector<int>>& edges, vector<int>& inds, int use = -1, int ignore = -1) {\\n        int weight = 0, num_edges = 0;\\n\\n        init(n);\\n\\n        if(use != -1)\\n        weight += edges[use][2], union_(edges[use][0], edges[use][1]), num_edges++;\\n\\n        for(auto e: inds)\\n        if(e != ignore and find_(edges[e][0]) != find_(edges[e][1]))\\n        weight += edges[e][2], union_(edges[e][0], edges[e][1]), num_edges++;\\n\\n        if(num_edges < n - 1)\\n        return -1;\\n\\n        return weight;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> inds(edges.size());\\n        iota(inds.begin(), inds.end(), 0);\\n\\n        sort(inds.begin(), inds.end(), [&edges](int x, int y) {\\n            return edges[x][2] < edges[y][2];\\n        });\\n\\n        int min_weight = kruskal(n, edges, inds);\\n\\n        vector<vector<int>> ans(2, vector<int>());\\n\\n        for(int i=0; i<edges.size(); i++)\\n        if(kruskal(n, edges, inds, i) == min_weight) {\\n            if(kruskal(n, edges, inds, -1, i) != min_weight)\\n            ans[0].push_back(i);\\n            else\\n            ans[1].push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060081,
                "title": "c-solution-kruskal-algo-simplified",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(E*E*logE)$$\\n\\n- Space complexity:\\n$$O(V+E)$$\\n\\n# Code\\n```\\n bool comp(const vector<int> &a, const vector<int> &b)\\n    {\\n        return a[2] < b[2];\\n    }\\n\\n    int findParent(int i, int parent[])\\n    {\\n        if (parent[i] == i)\\n            return i;\\n\\n        return parent[i] = findParent(parent[i], parent);\\n    }\\n\\n    void unionParent(int u, int v, int parent[])\\n    {\\n        parent[u] = v;\\n    }\\n\\nclass Solution {\\npublic:\\n    int MSTUtil(int n, vector<vector<int>>& edges, int exclude, int include) {\\n        int mstTemp = 0;\\n        int e = edges.size();\\n\\n        int parent[n];\\n        for (int v = 0; v < n; v++) parent[v] = v;\\n\\n        if(include != -1) {\\n          auto edge = edges[0];\\n\\n          for(int i=0;i<e;i++) {\\n            if(edges[i][3] == include) {\\n              edge = edges[i];\\n              break;\\n            }\\n          }\\n\\n          int u = edge[0];\\n          int v = edge[1];\\n\\n          int up = findParent(u,parent);\\n          int vp = findParent(v,parent);\\n\\n          unionParent(up,vp, parent);\\n          \\n          mstTemp+=edge[2];\\n        }\\n\\n        for(int j=0;j<e;j++){\\n          if(edges[j][3]==exclude || edges[j][3]==include) continue;\\n          // cout<<j<<\" \";\\n\\n          int u = edges[j][0];\\n          int v = edges[j][1];\\n\\n          int up = findParent(u,parent);\\n          int vp = findParent(v,parent);\\n\\n          if(up==vp) continue;\\n          unionParent(up,vp, parent);\\n          mstTemp+=edges[j][2];\\n        }\\n\\n        cout<<endl;\\n\\n        for (int v = 0; v < n; v++) {\\n          if(findParent(v, parent) != findParent(0, parent)) return INT_MAX;\\n        }\\n  \\n\\n        return mstTemp;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n      int e = edges.size();\\n\\n      for (int i = 0; i < e; i++)\\n            edges[i].push_back(i);\\n            \\n      sort(edges.begin(), edges.end(), comp);\\n\\n      int mst = MSTUtil(n, edges, -1, -1);\\n        // cout<<mst<<endl;\\n      vector<vector<int>> res(2);\\n\\n      for(int i=0;i<e;i++) {\\n        int mst1 = MSTUtil(n, edges, i, -1); // excluded\\n        int mst2 = MSTUtil(n, edges, -1, i); //included\\n        // cout<<mst1<<\" \"<<mst2<<endl;\\n        if(mst2 == mst && mst1 == mst) res[1].push_back(i);\\n        if(mst2 == mst && mst1 > mst) res[0].push_back(i);\\n      }\\n\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool comp(const vector<int> &a, const vector<int> &b)\\n    {\\n        return a[2] < b[2];\\n    }\\n\\n    int findParent(int i, int parent[])\\n    {\\n        if (parent[i] == i)\\n            return i;\\n\\n        return parent[i] = findParent(parent[i], parent);\\n    }\\n\\n    void unionParent(int u, int v, int parent[])\\n    {\\n        parent[u] = v;\\n    }\\n\\nclass Solution {\\npublic:\\n    int MSTUtil(int n, vector<vector<int>>& edges, int exclude, int include) {\\n        int mstTemp = 0;\\n        int e = edges.size();\\n\\n        int parent[n];\\n        for (int v = 0; v < n; v++) parent[v] = v;\\n\\n        if(include != -1) {\\n          auto edge = edges[0];\\n\\n          for(int i=0;i<e;i++) {\\n            if(edges[i][3] == include) {\\n              edge = edges[i];\\n              break;\\n            }\\n          }\\n\\n          int u = edge[0];\\n          int v = edge[1];\\n\\n          int up = findParent(u,parent);\\n          int vp = findParent(v,parent);\\n\\n          unionParent(up,vp, parent);\\n          \\n          mstTemp+=edge[2];\\n        }\\n\\n        for(int j=0;j<e;j++){\\n          if(edges[j][3]==exclude || edges[j][3]==include) continue;\\n          // cout<<j<<\" \";\\n\\n          int u = edges[j][0];\\n          int v = edges[j][1];\\n\\n          int up = findParent(u,parent);\\n          int vp = findParent(v,parent);\\n\\n          if(up==vp) continue;\\n          unionParent(up,vp, parent);\\n          mstTemp+=edges[j][2];\\n        }\\n\\n        cout<<endl;\\n\\n        for (int v = 0; v < n; v++) {\\n          if(findParent(v, parent) != findParent(0, parent)) return INT_MAX;\\n        }\\n  \\n\\n        return mstTemp;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n      int e = edges.size();\\n\\n      for (int i = 0; i < e; i++)\\n            edges[i].push_back(i);\\n            \\n      sort(edges.begin(), edges.end(), comp);\\n\\n      int mst = MSTUtil(n, edges, -1, -1);\\n        // cout<<mst<<endl;\\n      vector<vector<int>> res(2);\\n\\n      for(int i=0;i<e;i++) {\\n        int mst1 = MSTUtil(n, edges, i, -1); // excluded\\n        int mst2 = MSTUtil(n, edges, -1, i); //included\\n        // cout<<mst1<<\" \"<<mst2<<endl;\\n        if(mst2 == mst && mst1 == mst) res[1].push_back(i);\\n        if(mst2 == mst && mst1 > mst) res[0].push_back(i);\\n      }\\n\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4018139,
                "title": "c-solution-use-union-find",
                "content": "# Intuition\\n1. Sort edges by weight\\n2. Find the MST weight sum using Union Find\\n3. remove each element edge[i] and check if the rest elements MST become lager or groups number > 1, if so, edge[i] is critical edge,\\nthe other is non_critical edges\\n4. iterate non_critical edges, put in non_critical edges[j] to Union Find first, and do MST of the rest element, if MST is the same, j is psuedo critical edge \\n\\n# Code\\n```\\nbool compare(vector<int> &a, vector<int>&b)\\n{\\n    if(a[2]<b[2])return true;\\n    else return false;\\n}\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int groupsize;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        groupsize = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n            }\\n        }\\n        groupsize--;\\n        return true;\\n    }\\n    void reinitial(int n)\\n    {\\n        groupsize = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }        \\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), compare);\\n        UnionFind *uf = new UnionFind(n);\\n        int iMST = 0;\\n        for(int i=0; i<edges.size();i++)\\n        {\\n            if(uf->Union(edges[i][0], edges[i][1])) iMST+=edges[i][2];\\n        }\\n        vector<int>vCritical;\\n        vector<int>vNonCritical;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            uf->reinitial(n);\\n            int iMST_critial = 0;\\n            for(int j=0; j<edges.size(); j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(uf->Union(edges[j][0], edges[j][1])) iMST_critial+=edges[j][2];\\n                }\\n            }\\n            if(iMST_critial > iMST || uf->groupsize!=1) vCritical.push_back(i);\\n            else vNonCritical.push_back(i);\\n        }\\n        vector<int> vPseudo;\\n        for(int &i:vNonCritical)\\n        {\\n            uf->reinitial(n);\\n            int iMST_pseudo = edges[i][2];\\n            for(int &k:vCritical)\\n            {\\n                if(uf->Union(edges[k][0], edges[k][1])) iMST_pseudo+=edges[k][2];\\n            }\\n            uf->Union(edges[i][0], edges[i][1]);\\n            for(int &j:vNonCritical)\\n            {\\n                if(uf->Union(edges[j][0], edges[j][1])) iMST_pseudo+=edges[j][2];\\n            }\\n            if(iMST_pseudo == iMST && uf->groupsize==1) vPseudo.push_back(i);\\n        }\\n\\n        vector<vector<int>> vvRet;\\n        for(int i=0; i<vCritical.size(); i++)\\n            vCritical[i] = edges[vCritical[i]][3];\\n        for(int i=0; i<vPseudo.size(); i++)\\n            vPseudo[i] = edges[vPseudo[i]][3];\\n        vvRet.push_back(vCritical);\\n        vvRet.push_back(vPseudo);\\n        return vvRet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool compare(vector<int> &a, vector<int>&b)\\n{\\n    if(a[2]<b[2])return true;\\n    else return false;\\n}\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int groupsize;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        groupsize = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n            }\\n        }\\n        groupsize--;\\n        return true;\\n    }\\n    void reinitial(int n)\\n    {\\n        groupsize = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }        \\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), compare);\\n        UnionFind *uf = new UnionFind(n);\\n        int iMST = 0;\\n        for(int i=0; i<edges.size();i++)\\n        {\\n            if(uf->Union(edges[i][0], edges[i][1])) iMST+=edges[i][2];\\n        }\\n        vector<int>vCritical;\\n        vector<int>vNonCritical;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            uf->reinitial(n);\\n            int iMST_critial = 0;\\n            for(int j=0; j<edges.size(); j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(uf->Union(edges[j][0], edges[j][1])) iMST_critial+=edges[j][2];\\n                }\\n            }\\n            if(iMST_critial > iMST || uf->groupsize!=1) vCritical.push_back(i);\\n            else vNonCritical.push_back(i);\\n        }\\n        vector<int> vPseudo;\\n        for(int &i:vNonCritical)\\n        {\\n            uf->reinitial(n);\\n            int iMST_pseudo = edges[i][2];\\n            for(int &k:vCritical)\\n            {\\n                if(uf->Union(edges[k][0], edges[k][1])) iMST_pseudo+=edges[k][2];\\n            }\\n            uf->Union(edges[i][0], edges[i][1]);\\n            for(int &j:vNonCritical)\\n            {\\n                if(uf->Union(edges[j][0], edges[j][1])) iMST_pseudo+=edges[j][2];\\n            }\\n            if(iMST_pseudo == iMST && uf->groupsize==1) vPseudo.push_back(i);\\n        }\\n\\n        vector<vector<int>> vvRet;\\n        for(int i=0; i<vCritical.size(); i++)\\n            vCritical[i] = edges[vCritical[i]][3];\\n        for(int i=0; i<vPseudo.size(); i++)\\n            vPseudo[i] = edges[vPseudo[i]][3];\\n        vvRet.push_back(vCritical);\\n        vvRet.push_back(vPseudo);\\n        return vvRet;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4010617,
                "title": "navigating-the-maze-of-graphs-uncovering-critical-and-pseudo-critical-edges-with-kruskal-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem appears to be about finding critical and pseudo-critical edges in a graph. Critical edges are those that, if removed, would increase the minimum spanning tree (MST) weight, and pseudo-critical edges are those that, if included, would still result in the same MST weight. The solution seems to involve using Kruskal\\'s algorithm for finding the MST and analyzing the effects of skipping or forcing specific edges.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDisjoint Set (Union-Find): The solution begins by defining a Disjoint Set (Union-Find) data structure to keep track of connected components in the graph.\\n\\nKruskal\\'s Algorithm: The main part of the solution uses Kruskal\\'s algorithm to find the MST of the graph. It starts by sorting the edges in ascending order of weight.\\n\\nMST Construction with Optional Edges: Kruskal\\'s algorithm is used to construct the MST, and this process involves two scenarios:\\n\\nForcing an edge: If there\\'s a \"force_edge\" specified (not equal to -1), it forcefully includes that edge in the MST and updates the MST weight accordingly.\\nSkipping an edge: If an edge is skipped (specified by \"skip_edge\"), it is ignored during MST construction.\\nChecking Connectivity: After constructing the MST, the code checks if all vertices are included in the MST. If not, it returns INT_MAX, indicating that there\\'s no valid MST for the given graph.\\n\\nIdentifying Critical and Pseudo-Critical Edges: Finally, the code iterates through the sorted edges and identifies critical edges (edges that, when skipped, increase the MST weight) and pseudo-critical edges (edges that, when forced, maintain the same MST weight).\\n\\nReturning Results: The critical and pseudo-critical edge indices are collected and returned as results.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of building the Disjoint Set is O(n), where n is the number of vertices.\\nSorting the edges based on weight takes O(n log n) time.\\nRunning Kruskal\\'s algorithm with edge modifications takes O(n log n) time as well, considering that the worst-case scenario is that all edges are considered.\\nChecking vertex connectivity takes O(n) time.\\nOverall, the time complexity is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe Disjoint Set data structure uses O(n) space to store parent and size information.\\nThe space required for sorting the edges is negligible compared to the main data structure.\\nOverall, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N;\\n    class DisjointSet\\n    {\\n        vector<int> parent, size;\\n\\n    public:\\n        DisjointSet(int n)\\n        {\\n            // resize means it will shrink according to the size, otherwise it will be the same size as we declared\\n            parent.resize(n + 1);\\n            size.resize(n + 1);\\n            for (int i = 0; i <= n; i++)\\n            {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUltimateParent(int node)\\n        {\\n            if (node == parent[node])\\n            {\\n                return node;\\n            }\\n            return parent[node] = findUltimateParent(parent[node]);\\n        }\\n\\n        void unionBySize(int u, int v)\\n        {\\n            int ultimateParentU = findUltimateParent(u);\\n            int ultimateParentV = findUltimateParent(v);\\n            if (ultimateParentU == ultimateParentV)\\n            {\\n                return;\\n            }\\n\\n            if (size[ultimateParentU] < size[ultimateParentV])\\n            {\\n                parent[ultimateParentU] = ultimateParentV;\\n                size[ultimateParentV] += size[ultimateParentU];\\n            }\\n            else\\n            {\\n                parent[ultimateParentV] = ultimateParentU;\\n                size[ultimateParentU] += size[ultimateParentV];\\n            }\\n        }\\n    };\\n\\n    int Kruskal(vector<vector<int>> &adj, int skip_edge, int force_edge)\\n    {\\n        int mstWt = 0;\\n        DisjointSet ds(N);\\n        \\n        if(force_edge != -1) {\\n            ds.unionBySize(adj[force_edge][0], adj[force_edge][1]);\\n            mstWt += adj[force_edge][2];\\n        }\\n\\n        for (int i=0;i<adj.size();i++)\\n        {\\n            if(i == skip_edge){\\n                continue;\\n            }\\n\\n            int u  = adj[i][0];\\n            int v  = adj[i][1];\\n            int wt = adj[i][2];\\n            if (ds.findUltimateParent(u) != ds.findUltimateParent(v))\\n            {\\n                mstWt += wt;\\n                ds.unionBySize(u, v);\\n            }\\n        }\\n\\n\\n        //Check if all vertices are included in MST\\n        for(int i = 0; i < N; i++){\\n            if(ds.findUltimateParent(i) != ds.findUltimateParent(0)){\\n                return INT_MAX;\\n            }\\n        }\\n        return mstWt;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        N = n;\\n\\n        // since for kruskal\\'s algo, we will sort our input by edge weight but since we need to return the index in the last\\n        for(int i = 0; i < edges.size(); i++){\\n            edges[i].push_back(i);\\n        }\\n\\n        auto comparator = [&](auto &v1, auto v2){\\n            return v1[2] < v2[2];\\n        };\\n\\n        // Now sort based on weight\\n        sort(edges.begin(), edges.end(), comparator);\\n\\n        int MST_WEIGHT = Kruskal(edges, -1, -1);\\n        vector<int> critical, pseudo_critical;\\n\\n        for(int i = 0; i < edges.size(); i++){\\n            // Skipping ith edge\\n            if(Kruskal(edges, i, -1) > MST_WEIGHT){\\n                critical.push_back(edges[i][3]);\\n            }\\n            \\n            // Force add ith edge\\n            else if(Kruskal(edges, -1, i) == MST_WEIGHT){\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, pseudo_critical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N;\\n    class DisjointSet\\n    {\\n        vector<int> parent, size;\\n\\n    public:\\n        DisjointSet(int n)\\n        {\\n            // resize means it will shrink according to the size, otherwise it will be the same size as we declared\\n            parent.resize(n + 1);\\n            size.resize(n + 1);\\n            for (int i = 0; i <= n; i++)\\n            {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUltimateParent(int node)\\n        {\\n            if (node == parent[node])\\n            {\\n                return node;\\n            }\\n            return parent[node] = findUltimateParent(parent[node]);\\n        }\\n\\n        void unionBySize(int u, int v)\\n        {\\n            int ultimateParentU = findUltimateParent(u);\\n            int ultimateParentV = findUltimateParent(v);\\n            if (ultimateParentU == ultimateParentV)\\n            {\\n                return;\\n            }\\n\\n            if (size[ultimateParentU] < size[ultimateParentV])\\n            {\\n                parent[ultimateParentU] = ultimateParentV;\\n                size[ultimateParentV] += size[ultimateParentU];\\n            }\\n            else\\n            {\\n                parent[ultimateParentV] = ultimateParentU;\\n                size[ultimateParentU] += size[ultimateParentV];\\n            }\\n        }\\n    };\\n\\n    int Kruskal(vector<vector<int>> &adj, int skip_edge, int force_edge)\\n    {\\n        int mstWt = 0;\\n        DisjointSet ds(N);\\n        \\n        if(force_edge != -1) {\\n            ds.unionBySize(adj[force_edge][0], adj[force_edge][1]);\\n            mstWt += adj[force_edge][2];\\n        }\\n\\n        for (int i=0;i<adj.size();i++)\\n        {\\n            if(i == skip_edge){\\n                continue;\\n            }\\n\\n            int u  = adj[i][0];\\n            int v  = adj[i][1];\\n            int wt = adj[i][2];\\n            if (ds.findUltimateParent(u) != ds.findUltimateParent(v))\\n            {\\n                mstWt += wt;\\n                ds.unionBySize(u, v);\\n            }\\n        }\\n\\n\\n        //Check if all vertices are included in MST\\n        for(int i = 0; i < N; i++){\\n            if(ds.findUltimateParent(i) != ds.findUltimateParent(0)){\\n                return INT_MAX;\\n            }\\n        }\\n        return mstWt;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        N = n;\\n\\n        // since for kruskal\\'s algo, we will sort our input by edge weight but since we need to return the index in the last\\n        for(int i = 0; i < edges.size(); i++){\\n            edges[i].push_back(i);\\n        }\\n\\n        auto comparator = [&](auto &v1, auto v2){\\n            return v1[2] < v2[2];\\n        };\\n\\n        // Now sort based on weight\\n        sort(edges.begin(), edges.end(), comparator);\\n\\n        int MST_WEIGHT = Kruskal(edges, -1, -1);\\n        vector<int> critical, pseudo_critical;\\n\\n        for(int i = 0; i < edges.size(); i++){\\n            // Skipping ith edge\\n            if(Kruskal(edges, i, -1) > MST_WEIGHT){\\n                critical.push_back(edges[i][3]);\\n            }\\n            \\n            // Force add ith edge\\n            else if(Kruskal(edges, -1, i) == MST_WEIGHT){\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical, pseudo_critical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000756,
                "title": "dart-mst-using-union-find",
                "content": "\\n\\n# Code\\n```\\nclass UnionFind {\\n  late List<int> parent;\\n  UnionFind(int n) {\\n    parent = List.generate(n, (_) => 0);\\n    for (int i = 0; i < n; i++) {\\n      parent[i] = i;\\n    }\\n  }\\n\\n  int find(int x) {\\n    if (parent[x] != x) parent[x] = find(parent[x]);\\n    return parent[x];\\n  }\\n\\n  void union(int x, int y) {\\n    int px = find(x), py = find(y);\\n    if (px == py) return;\\n\\n    parent[px] = py;\\n  }\\n}\\n\\nclass Solution {\\n  List<List<int>> findCriticalAndPseudoCriticalEdges(\\n      int n, List<List<int>> edges) {\\n    int minWeight = 0;\\n    for (int i = 0; i < edges.length; i++) {\\n      edges[i].add(i);\\n    }\\n    edges.sort((a, b) => a[2].compareTo(b[2]));\\n    UnionFind uf = UnionFind(n);\\n    for (int i = 0; i < edges.length; i++) {\\n      int a = edges[i][0], b = edges[i][1], w = edges[i][2];\\n      if (uf.find(a) == uf.find(b)) continue;\\n      uf.union(a, b);\\n      minWeight += w;\\n    }\\n    List<int> criticalEdges = [], pseudoCriticalEdges = [];\\n    for (var i = 0; i < edges.length; i++) {\\n      UnionFind newUf = UnionFind(n);\\n      int newWeight = 0, edgesCnt = 0;\\n      for (int j = 0; j < edges.length; j++) {\\n        int a = edges[j][0], b = edges[j][1], w = edges[j][2];\\n        if (i == j || newUf.find(a) == newUf.find(b)) continue;\\n        newUf.union(a, b);\\n        edgesCnt++;\\n        newWeight += w;\\n      }\\n\\n      if (newWeight > minWeight || edgesCnt != n - 1) {\\n        criticalEdges.add(edges[i][3]);\\n      } else {\\n        UnionFind tempUf = UnionFind(n);\\n        int newWeight = edges[i][2];\\n        tempUf.union(edges[i][0], edges[i][1]);\\n        for (int j = 0; j < edges.length; j++) {\\n          int a = edges[j][0], b = edges[j][1], w = edges[j][2];\\n          if (i == j || tempUf.find(a) == tempUf.find(b)) continue;\\n          tempUf.union(a, b);\\n          newWeight += w;\\n        }\\n        if (newWeight == minWeight) {\\n          pseudoCriticalEdges.add(edges[i][3]);\\n        }\\n      }\\n    }\\n    return [\\n      [...criticalEdges],\\n      [...pseudoCriticalEdges]\\n    ];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass UnionFind {\\n  late List<int> parent;\\n  UnionFind(int n) {\\n    parent = List.generate(n, (_) => 0);\\n    for (int i = 0; i < n; i++) {\\n      parent[i] = i;\\n    }\\n  }\\n\\n  int find(int x) {\\n    if (parent[x] != x) parent[x] = find(parent[x]);\\n    return parent[x];\\n  }\\n\\n  void union(int x, int y) {\\n    int px = find(x), py = find(y);\\n    if (px == py) return;\\n\\n    parent[px] = py;\\n  }\\n}\\n\\nclass Solution {\\n  List<List<int>> findCriticalAndPseudoCriticalEdges(\\n      int n, List<List<int>> edges) {\\n    int minWeight = 0;\\n    for (int i = 0; i < edges.length; i++) {\\n      edges[i].add(i);\\n    }\\n    edges.sort((a, b) => a[2].compareTo(b[2]));\\n    UnionFind uf = UnionFind(n);\\n    for (int i = 0; i < edges.length; i++) {\\n      int a = edges[i][0], b = edges[i][1], w = edges[i][2];\\n      if (uf.find(a) == uf.find(b)) continue;\\n      uf.union(a, b);\\n      minWeight += w;\\n    }\\n    List<int> criticalEdges = [], pseudoCriticalEdges = [];\\n    for (var i = 0; i < edges.length; i++) {\\n      UnionFind newUf = UnionFind(n);\\n      int newWeight = 0, edgesCnt = 0;\\n      for (int j = 0; j < edges.length; j++) {\\n        int a = edges[j][0], b = edges[j][1], w = edges[j][2];\\n        if (i == j || newUf.find(a) == newUf.find(b)) continue;\\n        newUf.union(a, b);\\n        edgesCnt++;\\n        newWeight += w;\\n      }\\n\\n      if (newWeight > minWeight || edgesCnt != n - 1) {\\n        criticalEdges.add(edges[i][3]);\\n      } else {\\n        UnionFind tempUf = UnionFind(n);\\n        int newWeight = edges[i][2];\\n        tempUf.union(edges[i][0], edges[i][1]);\\n        for (int j = 0; j < edges.length; j++) {\\n          int a = edges[j][0], b = edges[j][1], w = edges[j][2];\\n          if (i == j || tempUf.find(a) == tempUf.find(b)) continue;\\n          tempUf.union(a, b);\\n          newWeight += w;\\n        }\\n        if (newWeight == minWeight) {\\n          pseudoCriticalEdges.add(edges[i][3]);\\n        }\\n      }\\n    }\\n    return [\\n      [...criticalEdges],\\n      [...pseudoCriticalEdges]\\n    ];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980700,
                "title": "this-is-best-and-very-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N;\\n\\n    class DSU{\\n        public:\\n        vector<int>rank;\\n        vector<int>parent;\\n\\n        DSU(int n){\\n            parent.resize(n);\\n            rank.resize(n,0);\\n\\n            for(int i=0;i<n;i++){\\n                parent[i] = i; // start khud ke parent self hoga\\n            }\\n        }\\n        int find(int x){\\n\\n            if(x == parent[x]){\\n                return x;  \\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        bool Union(int x ,int y){\\n\\n            int x_parent = find(x);\\n            int y_parent = find(y);\\n\\n            if(x_parent == y_parent){\\n                return false;\\n            }\\n            if(rank[x_parent] > rank[y_parent]){\\n                parent[y_parent] = x_parent;\\n            }\\n            else if(rank[y_parent] > rank[x_parent]){\\n                parent[x_parent] = y_parent;\\n            }\\n            else{\\n                parent[x_parent] = y_parent;\\n                rank[y_parent]++;\\n            }\\n            return true;\\n        }\\n    };\\n\\n    int kruskal(vector<vector<int>>&vec,int skip_edges,int add_edges){\\n\\n        int sum = 0;\\n\\n        DSU UF(N);\\n\\n        if(add_edges != -1){\\n\\n            UF.Union(vec[add_edges][0],vec[add_edges][1]);   \\n            sum +=vec[add_edges][2];\\n        }\\n        for(int i=0;i<vec.size();i++){\\n\\n            if(i == skip_edges)\\n                continue;\\n\\n            int u =  vec[i][0];\\n            int v =  vec[i][1];\\n            int wt = vec[i][2];\\n\\n            int parent_u = UF.find(u);\\n            int parent_v = UF.find(v);\\n\\n            if(parent_u != parent_v){\\n                UF.Union(u,v);\\n                sum +=wt;\\n            }\\n        }\\n        //check for MST ban bhi rhai hai ya nahi\\n        \\n        for(int i=0;i<N;i++){\\n                               //initial edge\\n            if(UF.find(i)!= UF.find(0)){ ///kahi component seperate to nahi hai\\n                return INT_MAX; // agr hai to INT_MAX return kr do \\n            }\\n        }\\n        return sum;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        N =n;\\n\\n        //original index push to save index\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        //sort according weight\\n        auto lamda = [&](vector<int>&v1,vector<int>&v2){\\n            return v1[2] < v2[2];\\n        };\\n        sort(begin(edges),end(edges),lamda);\\n\\n        int mst_weight =kruskal(edges ,-1,-1); //skip or add this index\\n\\n        vector<int>critical; \\n        vector<int>pseudo_critical;\\n\\n        for(int i=0;i<edges.size();i++){\\n\\n            if(kruskal(edges,i,-1) > mst_weight){\\n                critical.push_back(edges[i][3]);//{original index push}\\n            }  \\n            else if(kruskal(edges,-1,i) == mst_weight){ //add this ith edges\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical,pseudo_critical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N;\\n\\n    class DSU{\\n        public:\\n        vector<int>rank;\\n        vector<int>parent;\\n\\n        DSU(int n){\\n            parent.resize(n);\\n            rank.resize(n,0);\\n\\n            for(int i=0;i<n;i++){\\n                parent[i] = i; // start khud ke parent self hoga\\n            }\\n        }\\n        int find(int x){\\n\\n            if(x == parent[x]){\\n                return x;  \\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        bool Union(int x ,int y){\\n\\n            int x_parent = find(x);\\n            int y_parent = find(y);\\n\\n            if(x_parent == y_parent){\\n                return false;\\n            }\\n            if(rank[x_parent] > rank[y_parent]){\\n                parent[y_parent] = x_parent;\\n            }\\n            else if(rank[y_parent] > rank[x_parent]){\\n                parent[x_parent] = y_parent;\\n            }\\n            else{\\n                parent[x_parent] = y_parent;\\n                rank[y_parent]++;\\n            }\\n            return true;\\n        }\\n    };\\n\\n    int kruskal(vector<vector<int>>&vec,int skip_edges,int add_edges){\\n\\n        int sum = 0;\\n\\n        DSU UF(N);\\n\\n        if(add_edges != -1){\\n\\n            UF.Union(vec[add_edges][0],vec[add_edges][1]);   \\n            sum +=vec[add_edges][2];\\n        }\\n        for(int i=0;i<vec.size();i++){\\n\\n            if(i == skip_edges)\\n                continue;\\n\\n            int u =  vec[i][0];\\n            int v =  vec[i][1];\\n            int wt = vec[i][2];\\n\\n            int parent_u = UF.find(u);\\n            int parent_v = UF.find(v);\\n\\n            if(parent_u != parent_v){\\n                UF.Union(u,v);\\n                sum +=wt;\\n            }\\n        }\\n        //check for MST ban bhi rhai hai ya nahi\\n        \\n        for(int i=0;i<N;i++){\\n                               //initial edge\\n            if(UF.find(i)!= UF.find(0)){ ///kahi component seperate to nahi hai\\n                return INT_MAX; // agr hai to INT_MAX return kr do \\n            }\\n        }\\n        return sum;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        N =n;\\n\\n        //original index push to save index\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        //sort according weight\\n        auto lamda = [&](vector<int>&v1,vector<int>&v2){\\n            return v1[2] < v2[2];\\n        };\\n        sort(begin(edges),end(edges),lamda);\\n\\n        int mst_weight =kruskal(edges ,-1,-1); //skip or add this index\\n\\n        vector<int>critical; \\n        vector<int>pseudo_critical;\\n\\n        for(int i=0;i<edges.size();i++){\\n\\n            if(kruskal(edges,i,-1) > mst_weight){\\n                critical.push_back(edges[i][3]);//{original index push}\\n            }  \\n            else if(kruskal(edges,-1,i) == mst_weight){ //add this ith edges\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n        }\\n        return {critical,pseudo_critical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979227,
                "title": "c-java-python-kruskal-s-algorithm",
                "content": "# Intuition\\nThe question is very descriptive on what to do. Basically using Kruskal\\'s algorithm to create the mst and iteratively checking if we can or not include an edge in the mst and what that means for if its critical or pseudo is the whole approach. \\n# Approach\\nYou can check this video out for how I approach the problem: https://www.youtube.com/watch?v=NCfu0aGKwa0 \\n\\n# Complexity\\n- Time complexity: O(Nlogn + N^2*alpha) where n is the number of nodes\\n\\n- Space complexity: O(N)\\n```java []\\nclass Solution {\\n    /*\\n    1. Union find class\\n    2. build Mst using Kruskal\\'s algo\\'\\n    3. We first get the minCost // the cost of making the minimum spanning tree\\n    4. Check for each edge and see if its critical or not\\n    */\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> criticals = new ArrayList();\\n        List<Integer> pseudos = new ArrayList();\\n        List<List<Integer>> result = new ArrayList();\\n\\n        Map<int[], Integer> map = new HashMap();\\n        //filling our map with the corresponding edge values\\n        int val = 0;\\n        for(int [] edge : edges){\\n            map.put(edge, val);\\n            val++;\\n        }\\n\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]); //sorting by weight in ascending order\\n        int mincost = buildMST(edges, n , null, null);\\n\\n        for(int [] edge : edges){\\n            int index = map.get(edge);\\n            int costWithout = buildMST(edges, n, edge, null);\\n            int costWith = buildMST(edges, n, null, edge);\\n\\n            if(costWithout > mincost || costWithout == -1){\\n                //we have a critical edge\\n                criticals.add(index);\\n            }\\n            else if(costWith == mincost){\\n                pseudos.add(index);\\n            }\\n        }\\n\\n        result.add(criticals);\\n        result.add(pseudos);\\n        return result;\\n    }\\n\\n    public int buildMST(int [][] edges, int n, int [] skip, int [] keep){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0; //cost of building the mst\\n\\n        //for the keep or mandatory elements\\n        if(keep != null){\\n            int i = keep[0];\\n            int j = keep[1];\\n            uf.union(i, j);\\n            cost += keep[2];\\n        }\\n\\n        for(int [] edge : edges){\\n            if(edge != skip){\\n                boolean unite = uf.union(edge[0], edge[1]);\\n                if(unite){\\n                    cost += edge[2];\\n                }\\n            }\\n        }\\n        if(uf.components() == 1){\\n            //we have built our mst\\n            return cost;\\n        }\\n        else{\\n            return -1; // to show we have not made the mst\\n        }\\n    }\\n\\n    public class UnionFind{\\n        int [] parent;\\n        int [] rank;\\n        int components; \\n\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            rank = new int[n];\\n            components = n;\\n\\n            for(int k = 0; k < n; k++){\\n                parent[k] = k;\\n                rank[k] = 1;\\n            }\\n        }\\n\\n        public int findParent(int i){\\n            while(i != parent[i]){\\n                parent[i] = parent[parent[i]]; //path compresssion \\n                i = parent[i];\\n            }\\n            return i;\\n        }\\n\\n        public boolean union(int i, int j){\\n            int parentI = findParent(i);\\n            int parentJ = findParent(j);\\n            if(parentI == parentJ){\\n                return false; //they are already connnected\\n            }\\n            if(rank[parentI] > rank[parentJ]){\\n                parent[parentJ] = parentI;\\n                rank[parentI] += rank[parentJ];\\n            }\\n            else{\\n                parent[parentI] = parentJ;\\n                rank[parentJ] += rank[parentI];\\n            }\\n            components--;\\n            return true;\\n        }\\n\\n        public int components(){\\n            return components;\\n        }\\n    }\\n}\\n```\\n```python []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n        self.components = n\\n\\n    def findParent(self, i):\\n        while i != self.parent[i]:\\n            self.parent[i] = self.parent[self.parent[i]]\\n            i = self.parent[i]\\n        return i\\n\\n    def union(self, i, j):\\n        parentI = self.findParent(i)\\n        parentJ = self.findParent(j)\\n        if parentI == parentJ:\\n            return False\\n        if self.rank[parentI] > self.rank[parentJ]:\\n            self.parent[parentJ] = parentI\\n            self.rank[parentI] += self.rank[parentJ]\\n        else:\\n            self.parent[parentI] = parentJ\\n            self.rank[parentJ] += self.rank[parentI]\\n        self.components -= 1\\n        return True\\n\\n    def components(self):\\n        return self.components\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        criticals = []\\n        pseudos = []\\n        result = []\\n        edge_dict = {tuple(edge): idx for idx, edge in enumerate(edges)}\\n        edges.sort(key=lambda x: x[2])\\n        mincost = self.buildMST(edges, n, None, None)\\n\\n        for edge in edges:\\n            index = edge_dict[tuple(edge)]\\n            costWithout = self.buildMST(edges, n, edge, None)\\n            costWith = self.buildMST(edges, n, None, edge)\\n\\n            if costWithout > mincost or costWithout == -1:\\n                criticals.append(index)\\n            elif costWith == mincost:\\n                pseudos.append(index)\\n\\n        result.append(criticals)\\n        result.append(pseudos)\\n        return result\\n\\n    def buildMST(self, edges, n, skip, keep):\\n        uf = UnionFind(n)\\n        cost = 0\\n\\n        if keep:\\n            i, j, _ = keep\\n            uf.union(i, j)\\n            cost += keep[2]\\n\\n        for edge in edges:\\n            if edge != skip:\\n                unite = uf.union(edge[0], edge[1])\\n                if unite:\\n                    cost += edge[2]\\n\\n        if uf.components == 1:\\n            return cost\\n        else:\\n            return -1\\n\\n```\\n```c++ []\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass UnionFind {\\npublic:\\n    vector<int> parent, rank;\\n    int components;\\n    UnionFind(int n) {\\n        parent = vector<int>(n);\\n        rank = vector<int>(n, 1);\\n        components = n;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int i) {\\n        while (i != parent[i]) {\\n            parent[i] = parent[parent[i]]; // path compression\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n\\n    bool unionSets(int i, int j) {\\n        int parentI = findParent(i);\\n        int parentJ = findParent(j);\\n        if (parentI == parentJ) {\\n            return false; // they are already connected\\n        }\\n        if (rank[parentI] > rank[parentJ]) {\\n            parent[parentJ] = parentI;\\n            rank[parentI] += rank[parentJ];\\n        } else {\\n            parent[parentI] = parentJ;\\n            rank[parentJ] += rank[parentI];\\n        }\\n        components--;\\n        return true;\\n    }\\n\\n    int getComponents() {\\n        return components;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> criticals;\\n        vector<int> pseudos;\\n        vector<vector<int>> result;\\n\\n        unordered_map<vector<int>, int> map;\\n        int val = 0;\\n        for (vector<int> edge : edges) {\\n            map[edge] = val;\\n            val++;\\n        }\\n\\n        sort(edges.begin(), edges.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[2] < b[2];\\n        }); // sorting by weight in ascending order\\n        int mincost = buildMST(edges, n, NULL, NULL);\\n\\n        for (vector<int> edge : edges) {\\n            int index = map[edge];\\n            int costWithout = buildMST(edges, n, &edge, NULL);\\n            int costWith = buildMST(edges, n, NULL, &edge);\\n\\n            if (costWithout > mincost || costWithout == -1) {\\n                // we have a critical edge\\n                criticals.push_back(index);\\n            } else if (costWith == mincost) {\\n                pseudos.push_back(index);\\n            }\\n        }\\n\\n        result.push_back(criticals);\\n        result.push_back(pseudos);\\n        return result;\\n    }\\n\\n    int buildMST(vector<vector<int>>& edges, int n, vector<int>* skip, vector<int>* keep) {\\n        UnionFind uf(n);\\n        int cost = 0; // cost of building the mst\\n\\n        // for the keep or mandatory elements\\n        if (keep != NULL) {\\n            int i = (*keep)[0];\\n            int j = (*keep)[1];\\n            uf.unionSets(i, j);\\n            cost += (*keep)[2];\\n        }\\n\\n        for (vector<int> edge : edges) {\\n            if (&edge != skip) {\\n                bool unite = uf.unionSets(edge[0], edge[1]);\\n                if (unite) {\\n                    cost += edge[2];\\n                }\\n            }\\n        }\\n        if (uf.getComponents() == 1) {\\n            // we have built our mst\\n            return cost;\\n        } else {\\n            return -1; // to show we have not made the mst\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Union Find"
                ],
                "code": "```java []\\nclass Solution {\\n    /*\\n    1. Union find class\\n    2. build Mst using Kruskal\\'s algo\\'\\n    3. We first get the minCost // the cost of making the minimum spanning tree\\n    4. Check for each edge and see if its critical or not\\n    */\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        List<Integer> criticals = new ArrayList();\\n        List<Integer> pseudos = new ArrayList();\\n        List<List<Integer>> result = new ArrayList();\\n\\n        Map<int[], Integer> map = new HashMap();\\n        //filling our map with the corresponding edge values\\n        int val = 0;\\n        for(int [] edge : edges){\\n            map.put(edge, val);\\n            val++;\\n        }\\n\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]); //sorting by weight in ascending order\\n        int mincost = buildMST(edges, n , null, null);\\n\\n        for(int [] edge : edges){\\n            int index = map.get(edge);\\n            int costWithout = buildMST(edges, n, edge, null);\\n            int costWith = buildMST(edges, n, null, edge);\\n\\n            if(costWithout > mincost || costWithout == -1){\\n                //we have a critical edge\\n                criticals.add(index);\\n            }\\n            else if(costWith == mincost){\\n                pseudos.add(index);\\n            }\\n        }\\n\\n        result.add(criticals);\\n        result.add(pseudos);\\n        return result;\\n    }\\n\\n    public int buildMST(int [][] edges, int n, int [] skip, int [] keep){\\n        UnionFind uf = new UnionFind(n);\\n        int cost = 0; //cost of building the mst\\n\\n        //for the keep or mandatory elements\\n        if(keep != null){\\n            int i = keep[0];\\n            int j = keep[1];\\n            uf.union(i, j);\\n            cost += keep[2];\\n        }\\n\\n        for(int [] edge : edges){\\n            if(edge != skip){\\n                boolean unite = uf.union(edge[0], edge[1]);\\n                if(unite){\\n                    cost += edge[2];\\n                }\\n            }\\n        }\\n        if(uf.components() == 1){\\n            //we have built our mst\\n            return cost;\\n        }\\n        else{\\n            return -1; // to show we have not made the mst\\n        }\\n    }\\n\\n    public class UnionFind{\\n        int [] parent;\\n        int [] rank;\\n        int components; \\n\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            rank = new int[n];\\n            components = n;\\n\\n            for(int k = 0; k < n; k++){\\n                parent[k] = k;\\n                rank[k] = 1;\\n            }\\n        }\\n\\n        public int findParent(int i){\\n            while(i != parent[i]){\\n                parent[i] = parent[parent[i]]; //path compresssion \\n                i = parent[i];\\n            }\\n            return i;\\n        }\\n\\n        public boolean union(int i, int j){\\n            int parentI = findParent(i);\\n            int parentJ = findParent(j);\\n            if(parentI == parentJ){\\n                return false; //they are already connnected\\n            }\\n            if(rank[parentI] > rank[parentJ]){\\n                parent[parentJ] = parentI;\\n                rank[parentI] += rank[parentJ];\\n            }\\n            else{\\n                parent[parentI] = parentJ;\\n                rank[parentJ] += rank[parentI];\\n            }\\n            components--;\\n            return true;\\n        }\\n\\n        public int components(){\\n            return components;\\n        }\\n    }\\n}\\n```\n```python []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n        self.components = n\\n\\n    def findParent(self, i):\\n        while i != self.parent[i]:\\n            self.parent[i] = self.parent[self.parent[i]]\\n            i = self.parent[i]\\n        return i\\n\\n    def union(self, i, j):\\n        parentI = self.findParent(i)\\n        parentJ = self.findParent(j)\\n        if parentI == parentJ:\\n            return False\\n        if self.rank[parentI] > self.rank[parentJ]:\\n            self.parent[parentJ] = parentI\\n            self.rank[parentI] += self.rank[parentJ]\\n        else:\\n            self.parent[parentI] = parentJ\\n            self.rank[parentJ] += self.rank[parentI]\\n        self.components -= 1\\n        return True\\n\\n    def components(self):\\n        return self.components\\n\\nclass Solution:\\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n        criticals = []\\n        pseudos = []\\n        result = []\\n        edge_dict = {tuple(edge): idx for idx, edge in enumerate(edges)}\\n        edges.sort(key=lambda x: x[2])\\n        mincost = self.buildMST(edges, n, None, None)\\n\\n        for edge in edges:\\n            index = edge_dict[tuple(edge)]\\n            costWithout = self.buildMST(edges, n, edge, None)\\n            costWith = self.buildMST(edges, n, None, edge)\\n\\n            if costWithout > mincost or costWithout == -1:\\n                criticals.append(index)\\n            elif costWith == mincost:\\n                pseudos.append(index)\\n\\n        result.append(criticals)\\n        result.append(pseudos)\\n        return result\\n\\n    def buildMST(self, edges, n, skip, keep):\\n        uf = UnionFind(n)\\n        cost = 0\\n\\n        if keep:\\n            i, j, _ = keep\\n            uf.union(i, j)\\n            cost += keep[2]\\n\\n        for edge in edges:\\n            if edge != skip:\\n                unite = uf.union(edge[0], edge[1])\\n                if unite:\\n                    cost += edge[2]\\n\\n        if uf.components == 1:\\n            return cost\\n        else:\\n            return -1\\n\\n```\n```c++ []\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass UnionFind {\\npublic:\\n    vector<int> parent, rank;\\n    int components;\\n    UnionFind(int n) {\\n        parent = vector<int>(n);\\n        rank = vector<int>(n, 1);\\n        components = n;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int i) {\\n        while (i != parent[i]) {\\n            parent[i] = parent[parent[i]]; // path compression\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n\\n    bool unionSets(int i, int j) {\\n        int parentI = findParent(i);\\n        int parentJ = findParent(j);\\n        if (parentI == parentJ) {\\n            return false; // they are already connected\\n        }\\n        if (rank[parentI] > rank[parentJ]) {\\n            parent[parentJ] = parentI;\\n            rank[parentI] += rank[parentJ];\\n        } else {\\n            parent[parentI] = parentJ;\\n            rank[parentJ] += rank[parentI];\\n        }\\n        components--;\\n        return true;\\n    }\\n\\n    int getComponents() {\\n        return components;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> criticals;\\n        vector<int> pseudos;\\n        vector<vector<int>> result;\\n\\n        unordered_map<vector<int>, int> map;\\n        int val = 0;\\n        for (vector<int> edge : edges) {\\n            map[edge] = val;\\n            val++;\\n        }\\n\\n        sort(edges.begin(), edges.end(), [](vector<int>& a, vector<int>& b) {\\n            return a[2] < b[2];\\n        }); // sorting by weight in ascending order\\n        int mincost = buildMST(edges, n, NULL, NULL);\\n\\n        for (vector<int> edge : edges) {\\n            int index = map[edge];\\n            int costWithout = buildMST(edges, n, &edge, NULL);\\n            int costWith = buildMST(edges, n, NULL, &edge);\\n\\n            if (costWithout > mincost || costWithout == -1) {\\n                // we have a critical edge\\n                criticals.push_back(index);\\n            } else if (costWith == mincost) {\\n                pseudos.push_back(index);\\n            }\\n        }\\n\\n        result.push_back(criticals);\\n        result.push_back(pseudos);\\n        return result;\\n    }\\n\\n    int buildMST(vector<vector<int>>& edges, int n, vector<int>* skip, vector<int>* keep) {\\n        UnionFind uf(n);\\n        int cost = 0; // cost of building the mst\\n\\n        // for the keep or mandatory elements\\n        if (keep != NULL) {\\n            int i = (*keep)[0];\\n            int j = (*keep)[1];\\n            uf.unionSets(i, j);\\n            cost += (*keep)[2];\\n        }\\n\\n        for (vector<int> edge : edges) {\\n            if (&edge != skip) {\\n                bool unite = uf.unionSets(edge[0], edge[1]);\\n                if (unite) {\\n                    cost += edge[2];\\n                }\\n            }\\n        }\\n        if (uf.getComponents() == 1) {\\n            // we have built our mst\\n            return cost;\\n        } else {\\n            return -1; // to show we have not made the mst\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3971386,
                "title": "easy-code-hindi-hints",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //ya to edge ko lo yaa to naa lo\\n    //iss edge ko leke dekho  ki ktna aarha mst ka\\n    int parent[101]={0};\\n    int rank[101]={0};\\n    int dsu_parent(int i){\\n        if(i==parent[i])return i;\\n        else return parent[i]=dsu_parent(parent[i]);\\n    }\\n    void dsu_union(int i,int j){\\n        i=dsu_parent(i);\\n        j=dsu_parent(j);\\n        if(i!=j){\\n            if(rank[i]>=rank[j]){\\n                parent[j]=i;\\n                rank[i]+=rank[j];\\n                rank[j]=0;\\n            }\\n            else{\\n                parent[i]=j;\\n                rank[j]+=rank[i];\\n                rank[i]=0;\\n            }\\n        }\\n    }\\n    \\n    int include(int n, vector<vector<int>> &edges,vector<int>edge){\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n        int ans=edge[2];\\n        if(dsu_parent(edge[0])!=dsu_parent(edge[1]))dsu_union(edge[0],edge[1]);\\n        for(auto v:edges){\\n            if(dsu_parent(v[0])!=dsu_parent(v[1])){\\n                ans+=v[2];\\n                dsu_union(v[0],v[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int not_include(int n, vector<vector<int>> &edges,int ind){\\n       for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n       int ans=0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            vector<int>v=edges[i];\\n            if(i==ind)continue;\\n            else{\\n                if(dsu_parent(v[0])!=dsu_parent(v[1])){\\n                    ans+=v[2];\\n                    dsu_union(v[0],v[1]);\\n                }\\n            }\\n        }\\n        if( (edges.size()==0  and ind==0)  or  (rank[dsu_parent(edges[0][0])] <n))return 1e9;\\n        return ans;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        //intersection of all msts\\n        //union of all msts\\n\\n        //jinko remove karne se wt badh jaata hai wo critical\\n        //jo kuch mst me hai baaki me nhi non critical\\n\\n        //how will you find union of all msts?????\\n        //inko chodh ke mst ban jaarha hai to non critcal\\n        map<vector<int>,int>edge_ind;\\n        for(int i=0;i<edges.size();i++){\\n            edge_ind[edges[i]]=i;\\n        }\\n        sort(edges.begin(),edges.end(),[](vector<int>v1,vector<int>v2){\\n            return v1[2]<v2[2];\\n        });\\n        vector<vector<int>>ans(2);\\n        int mst=include(n,edges,{0,0,0});\\n        //includ\\n        for(int i=0;i<edges.size();i++){\\n            vector<int>v=edges[i];\\n            if(not_include(n,edges,i)>mst){\\n                ans[0].push_back(edge_ind[v]);\\n            }\\n            else if(include(n,edges,v)==mst){\\n                ans[1].push_back(edge_ind[v]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //ya to edge ko lo yaa to naa lo\\n    //iss edge ko leke dekho  ki ktna aarha mst ka\\n    int parent[101]={0};\\n    int rank[101]={0};\\n    int dsu_parent(int i){\\n        if(i==parent[i])return i;\\n        else return parent[i]=dsu_parent(parent[i]);\\n    }\\n    void dsu_union(int i,int j){\\n        i=dsu_parent(i);\\n        j=dsu_parent(j);\\n        if(i!=j){\\n            if(rank[i]>=rank[j]){\\n                parent[j]=i;\\n                rank[i]+=rank[j];\\n                rank[j]=0;\\n            }\\n            else{\\n                parent[i]=j;\\n                rank[j]+=rank[i];\\n                rank[i]=0;\\n            }\\n        }\\n    }\\n    \\n    int include(int n, vector<vector<int>> &edges,vector<int>edge){\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n        int ans=edge[2];\\n        if(dsu_parent(edge[0])!=dsu_parent(edge[1]))dsu_union(edge[0],edge[1]);\\n        for(auto v:edges){\\n            if(dsu_parent(v[0])!=dsu_parent(v[1])){\\n                ans+=v[2];\\n                dsu_union(v[0],v[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int not_include(int n, vector<vector<int>> &edges,int ind){\\n       for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n       int ans=0;\\n\\n        for(int i=0;i<edges.size();i++){\\n            vector<int>v=edges[i];\\n            if(i==ind)continue;\\n            else{\\n                if(dsu_parent(v[0])!=dsu_parent(v[1])){\\n                    ans+=v[2];\\n                    dsu_union(v[0],v[1]);\\n                }\\n            }\\n        }\\n        if( (edges.size()==0  and ind==0)  or  (rank[dsu_parent(edges[0][0])] <n))return 1e9;\\n        return ans;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        //intersection of all msts\\n        //union of all msts\\n\\n        //jinko remove karne se wt badh jaata hai wo critical\\n        //jo kuch mst me hai baaki me nhi non critical\\n\\n        //how will you find union of all msts?????\\n        //inko chodh ke mst ban jaarha hai to non critcal\\n        map<vector<int>,int>edge_ind;\\n        for(int i=0;i<edges.size();i++){\\n            edge_ind[edges[i]]=i;\\n        }\\n        sort(edges.begin(),edges.end(),[](vector<int>v1,vector<int>v2){\\n            return v1[2]<v2[2];\\n        });\\n        vector<vector<int>>ans(2);\\n        int mst=include(n,edges,{0,0,0});\\n        //includ\\n        for(int i=0;i<edges.size();i++){\\n            vector<int>v=edges[i];\\n            if(not_include(n,edges,i)>mst){\\n                ans[0].push_back(edge_ind[v]);\\n            }\\n            else if(include(n,edges,v)==mst){\\n                ans[1].push_back(edge_ind[v]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964233,
                "title": "another-solution-beats-90-time-and-space",
                "content": "# Intuition\\nI spent way too long on this, but this is a personal victory to do this problem on my own without any hints or looking at the solution.\\n\\n\\n# Code\\n```\\n\\nclass Solution:\\n  def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n    # 1. Attach indices to the edges and sort by cost\\n    edges = list(map(lambda edge: [edge[0]] + edge[1], enumerate(edges)))\\n    edges.sort(key = functools.cmp_to_key(lambda x, y: -1 if x[3] < y[3] else 1))\\n\\n    meta, root = list(map(lambda n: [n, -1, 0], range(n))), list(range(n))\\n\\n    # 2. Write a function to get pseudocritical edges\\n    def getPseudoCriticalEdges(A, B, cost):\\n      if root[A] != root[B]: return [False, []]\\n      pseudo_edge = set()\\n\\n      # Find common ancestor between A and B\\n      ancestorA = set([root[A]])\\n      \\n      node = A\\n      while node != root[A]:\\n        ancestorA.add(node)\\n        node = meta[node][0]\\n      \\n      ancestor = B\\n      while ancestor not in ancestorA: ancestor = meta[ancestor][0]\\n\\n      while A != ancestor:\\n        if meta[A][2] == cost: pseudo_edge.add(meta[A][1])\\n        A = meta[A][0]\\n\\n      while B != ancestor:\\n        if meta[B][2] == cost: pseudo_edge.add(meta[B][1])\\n        B = meta[B][0]\\n\\n      return [not pseudo_edge, pseudo_edge]\\n    \\n    # 3. Iterate over the edges and add until all edges are exhausted\\n    k = n - 1\\n    mst, pseudo = set(), set()\\n    for [idx, A, B, cost] in edges:\\n      [skip, pseudo_edges] = getPseudoCriticalEdges(A, B, cost)\\n\\n      if not pseudo_edges:\\n        if skip: continue\\n        if k == 0: break\\n        # A will be parent of B\\n\\n        # Swap the meta to ensure this is new node\\n        if root[B] != B:\\n          rootB = root[B]\\n          \\n          curr_node = B\\n          temp = meta[curr_node]\\n\\n          while curr_node != rootB:\\n            curr_parent = temp[0]\\n            temp2 = meta[curr_parent]\\n            meta[curr_parent] = [curr_node, temp[1], temp[2]]\\n            curr_node, temp = curr_parent, temp2\\n          \\n          meta[B] = [B, -1, 0]\\n            \\n          \\n          for t in range(n):\\n            if root[t] == rootB: root[t] = B\\n        \\n        # Now the actual op\\n        meta[B] = [A, idx, cost]\\n        for t in range(n):\\n          if root[t] == B: root[t] = root[A]\\n        \\n        mst.add(idx)\\n        k -= 1\\n      \\n      else:\\n        pseudo.update(pseudo_edges)\\n        pseudo.add(idx)\\n      \\n    return [list(mst.difference(pseudo)), list(pseudo)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n  def findCriticalAndPseudoCriticalEdges(self, n, edges):\\n    # 1. Attach indices to the edges and sort by cost\\n    edges = list(map(lambda edge: [edge[0]] + edge[1], enumerate(edges)))\\n    edges.sort(key = functools.cmp_to_key(lambda x, y: -1 if x[3] < y[3] else 1))\\n\\n    meta, root = list(map(lambda n: [n, -1, 0], range(n))), list(range(n))\\n\\n    # 2. Write a function to get pseudocritical edges\\n    def getPseudoCriticalEdges(A, B, cost):\\n      if root[A] != root[B]: return [False, []]\\n      pseudo_edge = set()\\n\\n      # Find common ancestor between A and B\\n      ancestorA = set([root[A]])\\n      \\n      node = A\\n      while node != root[A]:\\n        ancestorA.add(node)\\n        node = meta[node][0]\\n      \\n      ancestor = B\\n      while ancestor not in ancestorA: ancestor = meta[ancestor][0]\\n\\n      while A != ancestor:\\n        if meta[A][2] == cost: pseudo_edge.add(meta[A][1])\\n        A = meta[A][0]\\n\\n      while B != ancestor:\\n        if meta[B][2] == cost: pseudo_edge.add(meta[B][1])\\n        B = meta[B][0]\\n\\n      return [not pseudo_edge, pseudo_edge]\\n    \\n    # 3. Iterate over the edges and add until all edges are exhausted\\n    k = n - 1\\n    mst, pseudo = set(), set()\\n    for [idx, A, B, cost] in edges:\\n      [skip, pseudo_edges] = getPseudoCriticalEdges(A, B, cost)\\n\\n      if not pseudo_edges:\\n        if skip: continue\\n        if k == 0: break\\n        # A will be parent of B\\n\\n        # Swap the meta to ensure this is new node\\n        if root[B] != B:\\n          rootB = root[B]\\n          \\n          curr_node = B\\n          temp = meta[curr_node]\\n\\n          while curr_node != rootB:\\n            curr_parent = temp[0]\\n            temp2 = meta[curr_parent]\\n            meta[curr_parent] = [curr_node, temp[1], temp[2]]\\n            curr_node, temp = curr_parent, temp2\\n          \\n          meta[B] = [B, -1, 0]\\n            \\n          \\n          for t in range(n):\\n            if root[t] == rootB: root[t] = B\\n        \\n        # Now the actual op\\n        meta[B] = [A, idx, cost]\\n        for t in range(n):\\n          if root[t] == B: root[t] = root[A]\\n        \\n        mst.add(idx)\\n        k -= 1\\n      \\n      else:\\n        pseudo.update(pseudo_edges)\\n        pseudo.add(idx)\\n      \\n    return [list(mst.difference(pseudo)), list(pseudo)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951559,
                "title": "kruskal-implementation-beats-90-complete-explanation-lengthiest-leetcode-q",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int [] parent;\\n    int [] rank;\\n    int N;\\n    int count =0;\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        N=n;\\n        List<Integer> critical =  new ArrayList<>();\\n        List<Integer> pseudo =  new ArrayList<>();\\n         int [][] newEdges =  new int[edges.length][4];\\n\\n         // adding the index in the fourth column as we need to sort the edges for Kruskal \\n           for(int i=0;i<edges.length;i++)\\n        {\\n            int [] row =  edges[i];\\n            newEdges[i][0] = row[0];\\n            newEdges[i][1] = row[1];\\n            newEdges[i][2] = row[2];\\n            // so we have the index now we can put the critical and pseudo critical edgse in answer \\n            newEdges[i][3] = i;\\n        }\\n\\n        int minMstSum =0;\\n         // for Kruskals we need to sort the edges array greedily on the basis of weight\\n\\n         Arrays.sort(newEdges,(a,b)->{\\n             return a[2] - b[2];\\n         });\\n\\n          minMstSum = kruskal(newEdges, -1, -1);\\n        // we are checking for critical and pseudocritical edges here \\n        for(int k=0;k<newEdges.length;k++)\\n        {    \\n               //System.out.print(sum);\\n               int kSum = kruskal(newEdges, k ,-1);\\n\\n    //** this coondn is to check if an MST is actually being formed, because if MST is not being formed then that edge is\\n        // critical and cannot be skipped\\n        // 1.alternate check we can do is to check the parent of each vertex and compare if they have same parent or not\\n        // 2.alternate we can check if kSum is lesser than MST then definitely critical edge is missing\\n               /*\\n               if(count != N-1)\\n               {\\n                    critical.add(newEdges[k][3]);\\n                    continue;\\n               }\\n               */\\n                //System.out.println(kSum);\\n                // if sum is greater then the minMstsum thenedge that we have skipped is critical\\n               if(kSum>minMstSum)\\n               {\\n                 critical.add(newEdges[k][3]);\\n               }\\n               else if(kSum == minMstSum)//sum is equal to mst sum so it can be pseudocritical , to confirm we need to take edge and\\n               // check\\n               {\\n              // we have to check if taking this edge gives equal value to minMstSum then it can be a pseudocritical edge\\n\\n                   int sum1 = kruskal(newEdges, -1, k);\\n                   if(sum1 == minMstSum)\\n                   {\\n                      pseudo.add(newEdges[k][3]);\\n                   }\\n               }\\n\\n               else{\\n                    critical.add(newEdges[k][3]);\\n               }\\n        }\\n\\n         List<List<Integer>> result = new ArrayList<>();\\n         result.add(critical);\\n         result.add(pseudo);\\n        \\n         //System.out.print(minMstSum);\\n\\n         return result;  \\n    }\\n\\n    public int kruskal(int [][] newEdges, int skip, int take){\\n        // this count checks if edges are equal to N-1 \\n             count =0;\\n            int sum=0;\\n            parent = new int[N];\\n            rank =  new int[N];\\n\\n            // initializing parent and rank array\\n            for(int i=0;i<parent.length;i++)\\n            {\\n              parent[i] = i;\\n              rank[i]=1; \\n            }\\n\\n           // if we want to take an edge we can do so and make the connection before update the sum and count\\n           // take is when we want to check a pseudocritical edge \\n            if(take !=-1)\\n            {\\n                int row[] = newEdges[take];\\n                boolean x = unioun(row[0], row[1]);\\n                sum+=row[2];\\n                count++;\\n            }\\n        \\n            int count =0;\\n            // start to check all edges\\n            for(int i=0;i<newEdges.length;i++)\\n            {\\n                // skipping an edge \\n               if(i==skip)\\n               continue;\\n                  \\n               int row[] =  newEdges[i];\\n                 // if they are connected then ignore else add the sum for the MST \\n               boolean isConnected= unioun(row[0], row[1]);\\n\\n               if(!isConnected)\\n               {\\n                  sum += row[2];\\n               }   \\n            }\\n            \\n          return sum;\\n        \\n    }\\n    \\n    // DSU code \\n    public int find(int x)\\n    {\\n        if(parent[x]==x)\\n        return x;\\n\\n        int temp  =  find(parent[x]);\\n\\n         return parent[x] = temp;\\n    }\\n\\n    public boolean unioun(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n\\n        if(px!=py)\\n        {\\n            count++;\\n            if(rank[px]>rank[py])\\n            {\\n                parent[py] = px;\\n            }\\n\\n            else if(rank[px]<rank[py])\\n            {\\n                parent[px] = py;\\n            }\\n            else\\n            {\\n                parent[py] = px;\\n                rank[px]++;\\n            }\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int [] parent;\\n    int [] rank;\\n    int N;\\n    int count =0;\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        N=n;\\n        List<Integer> critical =  new ArrayList<>();\\n        List<Integer> pseudo =  new ArrayList<>();\\n         int [][] newEdges =  new int[edges.length][4];\\n\\n         // adding the index in the fourth column as we need to sort the edges for Kruskal \\n           for(int i=0;i<edges.length;i++)\\n        {\\n            int [] row =  edges[i];\\n            newEdges[i][0] = row[0];\\n            newEdges[i][1] = row[1];\\n            newEdges[i][2] = row[2];\\n            // so we have the index now we can put the critical and pseudo critical edgse in answer \\n            newEdges[i][3] = i;\\n        }\\n\\n        int minMstSum =0;\\n         // for Kruskals we need to sort the edges array greedily on the basis of weight\\n\\n         Arrays.sort(newEdges,(a,b)->{\\n             return a[2] - b[2];\\n         });\\n\\n          minMstSum = kruskal(newEdges, -1, -1);\\n        // we are checking for critical and pseudocritical edges here \\n        for(int k=0;k<newEdges.length;k++)\\n        {    \\n               //System.out.print(sum);\\n               int kSum = kruskal(newEdges, k ,-1);\\n\\n    //** this coondn is to check if an MST is actually being formed, because if MST is not being formed then that edge is\\n        // critical and cannot be skipped\\n        // 1.alternate check we can do is to check the parent of each vertex and compare if they have same parent or not\\n        // 2.alternate we can check if kSum is lesser than MST then definitely critical edge is missing\\n               /*\\n               if(count != N-1)\\n               {\\n                    critical.add(newEdges[k][3]);\\n                    continue;\\n               }\\n               */\\n                //System.out.println(kSum);\\n                // if sum is greater then the minMstsum thenedge that we have skipped is critical\\n               if(kSum>minMstSum)\\n               {\\n                 critical.add(newEdges[k][3]);\\n               }\\n               else if(kSum == minMstSum)//sum is equal to mst sum so it can be pseudocritical , to confirm we need to take edge and\\n               // check\\n               {\\n              // we have to check if taking this edge gives equal value to minMstSum then it can be a pseudocritical edge\\n\\n                   int sum1 = kruskal(newEdges, -1, k);\\n                   if(sum1 == minMstSum)\\n                   {\\n                      pseudo.add(newEdges[k][3]);\\n                   }\\n               }\\n\\n               else{\\n                    critical.add(newEdges[k][3]);\\n               }\\n        }\\n\\n         List<List<Integer>> result = new ArrayList<>();\\n         result.add(critical);\\n         result.add(pseudo);\\n        \\n         //System.out.print(minMstSum);\\n\\n         return result;  \\n    }\\n\\n    public int kruskal(int [][] newEdges, int skip, int take){\\n        // this count checks if edges are equal to N-1 \\n             count =0;\\n            int sum=0;\\n            parent = new int[N];\\n            rank =  new int[N];\\n\\n            // initializing parent and rank array\\n            for(int i=0;i<parent.length;i++)\\n            {\\n              parent[i] = i;\\n              rank[i]=1; \\n            }\\n\\n           // if we want to take an edge we can do so and make the connection before update the sum and count\\n           // take is when we want to check a pseudocritical edge \\n            if(take !=-1)\\n            {\\n                int row[] = newEdges[take];\\n                boolean x = unioun(row[0], row[1]);\\n                sum+=row[2];\\n                count++;\\n            }\\n        \\n            int count =0;\\n            // start to check all edges\\n            for(int i=0;i<newEdges.length;i++)\\n            {\\n                // skipping an edge \\n               if(i==skip)\\n               continue;\\n                  \\n               int row[] =  newEdges[i];\\n                 // if they are connected then ignore else add the sum for the MST \\n               boolean isConnected= unioun(row[0], row[1]);\\n\\n               if(!isConnected)\\n               {\\n                  sum += row[2];\\n               }   \\n            }\\n            \\n          return sum;\\n        \\n    }\\n    \\n    // DSU code \\n    public int find(int x)\\n    {\\n        if(parent[x]==x)\\n        return x;\\n\\n        int temp  =  find(parent[x]);\\n\\n         return parent[x] = temp;\\n    }\\n\\n    public boolean unioun(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n\\n        if(px!=py)\\n        {\\n            count++;\\n            if(rank[px]>rank[py])\\n            {\\n                parent[py] = px;\\n            }\\n\\n            else if(rank[px]<rank[py])\\n            {\\n                parent[px] = py;\\n            }\\n            else\\n            {\\n                parent[py] = px;\\n                rank[px]++;\\n            }\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951029,
                "title": "using-kruskal-s-algorithm-graph-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int n){\\n        parent.resize(n);\\n        rank.resize(n, 0);\\n        for(int i = 0; i<n; i++) parent[i] = i;\\n    }\\n    int findParent(int node){\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    void unionRank(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(rank[pv] < rank[pu]) parent[pv] = pu;\\n        else if(rank[pu] < rank[pv]) parent[pu] = pv;\\n        else {\\n            parent[pu] = pv;\\n            rank[pv]++;\\n        }\\n    }\\n};\\nstruct compare{\\n    bool operator()(const vector<int> &a, const vector<int> &b){\\n        return a[2] < b[2];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        DSU ds(n);\\n        for(int i = 0; i<edges.size(); i++) edges[i].push_back(i);\\n        sort(edges.begin(), edges.end(), compare());\\n        vector<int> critical;\\n        vector<int> pseudo;\\n        int sum = 0;\\n        for(int i = 0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int wt = edges[i][2];\\n            if(ds.findParent(u) != ds.findParent(v)){\\n                ds.unionRank(u, v);\\n                sum += wt; \\n            }\\n        }\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            DSU ds1(n);\\n            int newwt = 0;\\n            for(int j = 0; j < edges.size(); j++){\\n                if(ds1.findParent(edges[j][0]) != ds1.findParent(edges[j][1]) && i != j){\\n                    ds1.unionRank(edges[j][0], edges[j][1]);\\n                    newwt += edges[j][2];\\n                }\\n            }\\n            int comp = 0;\\n            vector<int> parent = ds1.parent;\\n            for(int x = 0; x< parent.size(); x++) if(parent[x] == x) comp++;\\n            if(newwt > sum || comp > 1){\\n                critical.push_back(edges[i][3]);\\n            }\\n            else {\\n                DSU ds2(n);\\n                ds2.unionRank(edges[i][0], edges[i][1]);\\n                newwt = edges[i][2];\\n                for(int j = 0; j < edges.size(); j++){\\n                    if(ds2.findParent(edges[j][0]) != ds2.findParent(edges[j][1])){\\n                        ds2.unionRank(edges[j][0], edges[j][1]);\\n                        newwt += edges[j][2];\\n                    }\\n                }\\n                if(newwt == sum) pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pseudo);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int n){\\n        parent.resize(n);\\n        rank.resize(n, 0);\\n        for(int i = 0; i<n; i++) parent[i] = i;\\n    }\\n    int findParent(int node){\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    void unionRank(int u, int v){\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n        if(pu == pv) return;\\n        if(rank[pv] < rank[pu]) parent[pv] = pu;\\n        else if(rank[pu] < rank[pv]) parent[pu] = pv;\\n        else {\\n            parent[pu] = pv;\\n            rank[pv]++;\\n        }\\n    }\\n};\\nstruct compare{\\n    bool operator()(const vector<int> &a, const vector<int> &b){\\n        return a[2] < b[2];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans;\\n        DSU ds(n);\\n        for(int i = 0; i<edges.size(); i++) edges[i].push_back(i);\\n        sort(edges.begin(), edges.end(), compare());\\n        vector<int> critical;\\n        vector<int> pseudo;\\n        int sum = 0;\\n        for(int i = 0; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int wt = edges[i][2];\\n            if(ds.findParent(u) != ds.findParent(v)){\\n                ds.unionRank(u, v);\\n                sum += wt; \\n            }\\n        }\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            DSU ds1(n);\\n            int newwt = 0;\\n            for(int j = 0; j < edges.size(); j++){\\n                if(ds1.findParent(edges[j][0]) != ds1.findParent(edges[j][1]) && i != j){\\n                    ds1.unionRank(edges[j][0], edges[j][1]);\\n                    newwt += edges[j][2];\\n                }\\n            }\\n            int comp = 0;\\n            vector<int> parent = ds1.parent;\\n            for(int x = 0; x< parent.size(); x++) if(parent[x] == x) comp++;\\n            if(newwt > sum || comp > 1){\\n                critical.push_back(edges[i][3]);\\n            }\\n            else {\\n                DSU ds2(n);\\n                ds2.unionRank(edges[i][0], edges[i][1]);\\n                newwt = edges[i][2];\\n                for(int j = 0; j < edges.size(); j++){\\n                    if(ds2.findParent(edges[j][0]) != ds2.findParent(edges[j][1])){\\n                        ds2.unionRank(edges[j][0], edges[j][1]);\\n                        newwt += edges[j][2];\\n                    }\\n                }\\n                if(newwt == sum) pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pseudo);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947784,
                "title": "easy-intuitive-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    public:\\n    vector<int>rank,size,parent;\\n\\n    DSU(int n)\\n    {\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        rank.resize(n+1,0);\\n\\n        for(int i=0;i<=n;i++)\\n        parent[i]=i;\\n    }\\n\\n    int findPar(int node)\\n    {\\n        if(node==parent[node])\\n        return node;\\n\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u,int v)\\n    {\\n        int ult_u = findPar(u);\\n        int ult_v = findPar(v);\\n\\n        if(ult_u==ult_v)\\n        return;\\n\\n        if(size[ult_v] < size[ult_u])\\n        {\\n            parent[ult_v] = ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        else\\n        {\\n            parent[ult_u] = ult_v;\\n            size[ult_v]+=size[ult_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int>&a,vector<int>&b)\\n{\\n    return a[2]<b[2];\\n}\\nint kruskal(int n,vector<vector<int>>&edges,int skipEdge,int addEdge)\\n{\\n    int minSum=0;\\n    DSU dsu(n);\\n\\n    if(addEdge!=-1)\\n    {\\n        minSum+=edges[addEdge][2];\\n        dsu.unionBySize(edges[addEdge][0],edges[addEdge][1]);\\n    }\\n    \\n \\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(i==skipEdge)continue;\\n\\n            int wt = edges[i][2];\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(dsu.findPar(u)!=dsu.findPar(v))\\n            {\\n                minSum+=wt;\\n                dsu.unionBySize(u,v);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dsu.findPar(0)!=dsu.findPar(i))\\n            return INT_MAX;\\n        }\\n        return minSum;\\n    \\n}\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // sort(begin(edges),end(edges),cmp);\\n        // DSU dsu(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n              sort(begin(edges),end(edges),cmp);\\n        int minSum=kruskal(n,edges,-1,-1);\\n        cout<<minSum;\\n        vector<int>critical,pseudo;\\n\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(minSum < kruskal(n,edges,i,-1))\\n            {\\n                critical.push_back(edges[i][3]);//critical edge\\n            }\\n            else if(minSum == kruskal(n,edges,-1,i))\\n            {\\n                pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n        \\n        return {critical,pseudo};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\n    public:\\n    vector<int>rank,size,parent;\\n\\n    DSU(int n)\\n    {\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n        rank.resize(n+1,0);\\n\\n        for(int i=0;i<=n;i++)\\n        parent[i]=i;\\n    }\\n\\n    int findPar(int node)\\n    {\\n        if(node==parent[node])\\n        return node;\\n\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionBySize(int u,int v)\\n    {\\n        int ult_u = findPar(u);\\n        int ult_v = findPar(v);\\n\\n        if(ult_u==ult_v)\\n        return;\\n\\n        if(size[ult_v] < size[ult_u])\\n        {\\n            parent[ult_v] = ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        else\\n        {\\n            parent[ult_u] = ult_v;\\n            size[ult_v]+=size[ult_u];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int>&a,vector<int>&b)\\n{\\n    return a[2]<b[2];\\n}\\nint kruskal(int n,vector<vector<int>>&edges,int skipEdge,int addEdge)\\n{\\n    int minSum=0;\\n    DSU dsu(n);\\n\\n    if(addEdge!=-1)\\n    {\\n        minSum+=edges[addEdge][2];\\n        dsu.unionBySize(edges[addEdge][0],edges[addEdge][1]);\\n    }\\n    \\n \\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(i==skipEdge)continue;\\n\\n            int wt = edges[i][2];\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n\\n            if(dsu.findPar(u)!=dsu.findPar(v))\\n            {\\n                minSum+=wt;\\n                dsu.unionBySize(u,v);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dsu.findPar(0)!=dsu.findPar(i))\\n            return INT_MAX;\\n        }\\n        return minSum;\\n    \\n}\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        // sort(begin(edges),end(edges),cmp);\\n        // DSU dsu(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n              sort(begin(edges),end(edges),cmp);\\n        int minSum=kruskal(n,edges,-1,-1);\\n        cout<<minSum;\\n        vector<int>critical,pseudo;\\n\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(minSum < kruskal(n,edges,i,-1))\\n            {\\n                critical.push_back(edges[i][3]);//critical edge\\n            }\\n            else if(minSum == kruskal(n,edges,-1,i))\\n            {\\n                pseudo.push_back(edges[i][3]);\\n            }\\n        }\\n        \\n        return {critical,pseudo};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3942930,
                "title": "rust-python-union-find-for-mst-ignore-and-force-the-edge",
                "content": "# Intuition\\n\\nThe solution relies on knowledge about MST and union find. The best explanation [about UF is here](https://cp-algorithms.com/data_structures/disjoint_set_union.html) and how to [apply it to finding MST is here](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm).\\n\\nNow based on definition:\\n - **critical edge**. Without this edge the MST will have weight higher than original weight. So we can just ignore each edge and check the weight\\n - **pseudo critical edge**. It can appear in one MST but it is not required. This is slightly harder to reason about. First it is clear that if the edge is critical, it can\\'t be pseudo critical as well. So we can force MST to use a specific edge (by adding it first ignorig our order and then add everything else). Then if the weight is equal to our original weight, then it is pseudo-critical.\\n\\n\\nThis gives us an algorithm.\\n - sort all the edges according to their weight. This is needed to find MST and because we will do this many times, lets preprocess it only once. \\n - find a weight of MST. Let it be `w`\\n - Iterate over all possible edges and for each of them:\\n   - calculate MST ignoring this edge. If `MST(ignore=edge) != w` then this edge is critical. \\n   - if not, force this edge. And if `MST(force=edge) != w`, then it is pseudo critical\\n\\n# Complexity\\n\\nLet the graph has $E$ edges and $V$ vertices, then \\n\\n- Time complexity: $O(E^2)$. Because for each edge we do at most 2 MST construction which take `O(E)`\\n- Space complexity: $(E + V)$\\n\\n# Code\\n\\n\\n```Rust []\\nstruct UnionFind {\\n  parent: Vec<usize>,\\n  size: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n  fn new(n: usize) -> UnionFind {\\n    return UnionFind {\\n      parent: (0..n).collect(),\\n      size: vec![1; n],\\n    }\\n  }\\n\\n  fn find(&mut self, p: usize) -> usize {\\n    if p == self.parent[p] {\\n      return p;\\n    }\\n\\n    self.parent[p] = self.find(self.parent[p]);\\n    return self.parent[p];\\n  }\\n\\n  fn union(&mut self, mut p: usize, mut q: usize) {\\n    p = self.find(p);\\n    q = self.find(q);\\n\\n    if p != q {\\n      let (size_p, size_q) = (self.size[p], self.size[q]);\\n      if size_p > size_q {\\n        self.size[p] += size_q;\\n        self.parent[q] = p;\\n      } else {\\n        self.size[q] += size_p;\\n        self.parent[p] = q;\\n      }\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n\\n  fn build_mst(n: usize, edges: &Vec<(usize, usize, usize, usize)>, ignore: usize, is_force: bool) -> usize {\\n    let mut uf = UnionFind::new(n);\\n    let mut res = 0;\\n\\n    if is_force {\\n      for v in edges {\\n        if v.3 == ignore {\\n          uf.union(v.1, v.2);\\n          res += v.0;\\n          break;\\n        }\\n      }\\n    }\\n\\n    for v in edges {\\n      if v.3 != ignore && uf.find(v.1) != uf.find(v.2) {\\n        uf.union(v.1, v.2);\\n        res += v.0;\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n  pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n    let mut ext_edges = Vec::with_capacity(edges.len());\\n    for i in 0 .. edges.len() {\\n      ext_edges.push((edges[i][2] as usize, edges[i][0] as usize, edges[i][1] as usize, i));\\n    }\\n    ext_edges.sort_unstable();\\n    let w = Self::build_mst(n as usize, &ext_edges, usize::MAX, false);\\n\\n    let mut res = vec![Vec::new(), Vec::new()];\\n    for i in 0 .. ext_edges.len() {\\n      if w != Self::build_mst(n as usize, &ext_edges, i, false) {\\n        res[0].push(i as i32);\\n      } else if w == Self::build_mst(n as usize, &ext_edges, i, true) {\\n        res[1].push(i as i32);\\n      }\\n    }\\n\\n    return res;  \\n  }\\n}\\n```\\n```python []\\nclass UnionFind:\\n  def __init__(self, n: int) -> None:\\n    self._parent = list(range(n))  # tells which element belongs to which component\\n    self._size = [1] * n           # size of each component\\n\\n  def find(self, p: int) -> int:\\n    root = p\\n    while root != self._parent[root]:\\n      root = self._parent[root]\\n\\n    while p != root:\\n      p, self._parent[p] = self._parent[p], root\\n\\n    return root\\n\\n  def union(self, p: int, q: int) -> None:\\n    p, q = self.find(p), self.find(q)\\n    if p != q:\\n      size_p, size_q = self._size[p], self._size[q]\\n      if size_p > size_q:\\n        self._size[p] += size_q\\n        self._parent[q] = p\\n      else:\\n        self._size[q] += size_p\\n        self._parent[p] = q\\n\\n\\nclass Solution:\\n\\n  def build_mst(self, n, edges, ignore: int, is_force: bool):\\n    uf, res = UnionFind(n), 0\\n    if is_force:\\n      for w, v1, v2, i in edges:\\n        if i == ignore: \\n          res += w\\n          uf.union(v1, v2)\\n\\n    for w, v1, v2, i in edges:\\n      if i != ignore and uf.find(v1) != uf.find(v2):\\n        res += w\\n        uf.union(v1, v2)\\n    \\n    return res\\n\\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    edges = sorted([(w, v1, v2, i) for i, (v1, v2, w) in enumerate(edges)])\\n    w = self.build_mst(n, edges, -1, False)\\n    \\n    res = [[], []]\\n    for i in range(len(edges)):\\n      if w != self.build_mst(n, edges, i, False):\\n        res[0].append(i)\\n      elif self.build_mst(n, edges, i, True) == w:\\n        res[1].append(i)\\n      \\n    return res\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Union Find"
                ],
                "code": "```Rust []\\nstruct UnionFind {\\n  parent: Vec<usize>,\\n  size: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n  fn new(n: usize) -> UnionFind {\\n    return UnionFind {\\n      parent: (0..n).collect(),\\n      size: vec![1; n],\\n    }\\n  }\\n\\n  fn find(&mut self, p: usize) -> usize {\\n    if p == self.parent[p] {\\n      return p;\\n    }\\n\\n    self.parent[p] = self.find(self.parent[p]);\\n    return self.parent[p];\\n  }\\n\\n  fn union(&mut self, mut p: usize, mut q: usize) {\\n    p = self.find(p);\\n    q = self.find(q);\\n\\n    if p != q {\\n      let (size_p, size_q) = (self.size[p], self.size[q]);\\n      if size_p > size_q {\\n        self.size[p] += size_q;\\n        self.parent[q] = p;\\n      } else {\\n        self.size[q] += size_p;\\n        self.parent[p] = q;\\n      }\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n\\n  fn build_mst(n: usize, edges: &Vec<(usize, usize, usize, usize)>, ignore: usize, is_force: bool) -> usize {\\n    let mut uf = UnionFind::new(n);\\n    let mut res = 0;\\n\\n    if is_force {\\n      for v in edges {\\n        if v.3 == ignore {\\n          uf.union(v.1, v.2);\\n          res += v.0;\\n          break;\\n        }\\n      }\\n    }\\n\\n    for v in edges {\\n      if v.3 != ignore && uf.find(v.1) != uf.find(v.2) {\\n        uf.union(v.1, v.2);\\n        res += v.0;\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n  pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n    let mut ext_edges = Vec::with_capacity(edges.len());\\n    for i in 0 .. edges.len() {\\n      ext_edges.push((edges[i][2] as usize, edges[i][0] as usize, edges[i][1] as usize, i));\\n    }\\n    ext_edges.sort_unstable();\\n    let w = Self::build_mst(n as usize, &ext_edges, usize::MAX, false);\\n\\n    let mut res = vec![Vec::new(), Vec::new()];\\n    for i in 0 .. ext_edges.len() {\\n      if w != Self::build_mst(n as usize, &ext_edges, i, false) {\\n        res[0].push(i as i32);\\n      } else if w == Self::build_mst(n as usize, &ext_edges, i, true) {\\n        res[1].push(i as i32);\\n      }\\n    }\\n\\n    return res;  \\n  }\\n}\\n```\n```python []\\nclass UnionFind:\\n  def __init__(self, n: int) -> None:\\n    self._parent = list(range(n))  # tells which element belongs to which component\\n    self._size = [1] * n           # size of each component\\n\\n  def find(self, p: int) -> int:\\n    root = p\\n    while root != self._parent[root]:\\n      root = self._parent[root]\\n\\n    while p != root:\\n      p, self._parent[p] = self._parent[p], root\\n\\n    return root\\n\\n  def union(self, p: int, q: int) -> None:\\n    p, q = self.find(p), self.find(q)\\n    if p != q:\\n      size_p, size_q = self._size[p], self._size[q]\\n      if size_p > size_q:\\n        self._size[p] += size_q\\n        self._parent[q] = p\\n      else:\\n        self._size[q] += size_p\\n        self._parent[p] = q\\n\\n\\nclass Solution:\\n\\n  def build_mst(self, n, edges, ignore: int, is_force: bool):\\n    uf, res = UnionFind(n), 0\\n    if is_force:\\n      for w, v1, v2, i in edges:\\n        if i == ignore: \\n          res += w\\n          uf.union(v1, v2)\\n\\n    for w, v1, v2, i in edges:\\n      if i != ignore and uf.find(v1) != uf.find(v2):\\n        res += w\\n        uf.union(v1, v2)\\n    \\n    return res\\n\\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n    edges = sorted([(w, v1, v2, i) for i, (v1, v2, w) in enumerate(edges)])\\n    w = self.build_mst(n, edges, -1, False)\\n    \\n    res = [[], []]\\n    for i in range(len(edges)):\\n      if w != self.build_mst(n, edges, i, False):\\n        res[0].append(i)\\n      elif self.build_mst(n, edges, i, True) == w:\\n        res[1].append(i)\\n      \\n    return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942709,
                "title": "easy-dfs-c-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E^2 + VE))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V + E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> used;\\n    vector<vector<array<int, 3>>> g;\\n\\n    void dfs(int v, int max_w, int not_used) { \\n        used[v] = true;\\n\\n        for (auto& [to, w, i] : g[v]) { \\n\\n            if (w <= max_w && (not_used != i) && !used[to]) { \\n                dfs(to, max_w, not_used);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n\\n        int m = edges.size();\\n\\n        for (int i = 0; i < m; ++i) { \\n            g[edges[i][0]].push_back({edges[i][1], edges[i][2], i});\\n            g[edges[i][1]].push_back({edges[i][0], edges[i][2], i});\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        int i = 0; \\n\\n        for (auto& e : edges) { \\n            int a = e[0];\\n            int b = e[1];\\n            int w = e[2];\\n\\n            used.assign(n, false);  \\n            dfs(a, w, i);\\n            \\n            if (!used[b]) { \\n                ans[0].push_back(i); \\n            } else {    \\n                used.assign(n, false); \\n                dfs(a, w - 1, i);\\n                if (!used[b]) ans[1].push_back(i);\\n            }\\n\\n            ++i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> used;\\n    vector<vector<array<int, 3>>> g;\\n\\n    void dfs(int v, int max_w, int not_used) { \\n        used[v] = true;\\n\\n        for (auto& [to, w, i] : g[v]) { \\n\\n            if (w <= max_w && (not_used != i) && !used[to]) { \\n                dfs(to, max_w, not_used);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        g.resize(n);\\n\\n        int m = edges.size();\\n\\n        for (int i = 0; i < m; ++i) { \\n            g[edges[i][0]].push_back({edges[i][1], edges[i][2], i});\\n            g[edges[i][1]].push_back({edges[i][0], edges[i][2], i});\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        int i = 0; \\n\\n        for (auto& e : edges) { \\n            int a = e[0];\\n            int b = e[1];\\n            int w = e[2];\\n\\n            used.assign(n, false);  \\n            dfs(a, w, i);\\n            \\n            if (!used[b]) { \\n                ans[0].push_back(i); \\n            } else {    \\n                used.assign(n, false); \\n                dfs(a, w - 1, i);\\n                if (!used[b]) ans[1].push_back(i);\\n            }\\n\\n            ++i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938655,
                "title": "java-kruskal-and-union-find-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKruskal\\'s Algorithm (greedy) and Union-Find to find an MST.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* To find MST, we need to sort the edges but also maintain their original index for the result, so first encapsulated edges with their edges, then sort them bby weight\\n* Find the weight of the MST (say W). This will be unique for a graph (say G)\\n* Find the spanning tree (say T) for G by ignoring each edge one by one. Let the current edge be E\\n    * If weight(T) > W, then E is critical\\n    * Else find another spanning (say R) tree but this time instead of ignoring E, force it in R. If weight(R) = W, then E is pseudo critical\\n\\n# Complexity\\n- Time complexity: O(m\\xB2), where m = size(edges)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nprivate record Edge(int v1, int v2, int weight, int index) {}\\n\\npublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n    var uf = new UnionFind(n);\\n    var critical = new ArrayList<Integer>();\\n    var pseudoCritical = new ArrayList<Integer>();\\n    var sorted = sortByWeight(edges);\\n    var mstWeight = spanningTreeWeight(uf, sorted);\\n\\n    for (var edge : sorted) {\\n        var ignoredWeight = ignoredSpanningTreeWeight(n, sorted, edge.index);\\n\\n        for (var e : sorted)\\n            if (e.index != edge.index && uf.union(e.v1, e.v2))\\n                ignoredWeight += e.weight;\\n\\n        if (ignoredWeight > mstWeight || uf.maxRank < n) {\\n            critical.add(edge.index);\\n        } else {\\n            uf = new UnionFind(n);\\n            uf.union(edge.v1, edge.v2);\\n            var forcedWeight = edge.weight + spanningTreeWeight(uf, sorted);\\n\\n            if (forcedWeight == mstWeight)\\n                pseudoCritical.add(edge.index);\\n        }\\n    }\\n\\n    return List.of(critical, pseudoCritical);\\n}\\n\\nprivate Edge[] sortByWeight(int[][] edges) {\\n    return IntStream.range(0, edges.length)\\n                    .mapToObj(i -> new Edge(edges[i][0], edges[i][1], edges[i][2], i))\\n                    .sorted(Comparator.comparing(edge -> edge.weight))\\n                    .toArray(Edge[]::new);\\n}\\n\\nprivate int ignoredSpanningTreeWeight(int n, Edge[] sorted, int ignore) {\\n    var uf = new UnionFind(n);\\n    return Arrays.stream(sorted)\\n                 .filter(e -> e.index != ignore && uf.union(e.v1, e.v2))\\n                 .mapToInt(e -> e.weight)\\n                 .sum();\\n}\\n\\nprivate int spanningTreeWeight(UnionFind uf, Edge[] edges) {\\n    return Arrays.stream(edges)\\n                 .filter(edge -> uf.union(edge.v1, edge.v2))\\n                 .mapToInt(edge -> edge.weight)\\n                 .sum();\\n}\\n\\nprivate static class UnionFind {\\n    private final int[] parent;\\n    private final int[] rank;\\n    private int maxRank;\\n\\n    private UnionFind(int n) {\\n        rank = new int[n];\\n        parent = new int[n];\\n\\n        for (var i = 0; i < n; i++) {\\n            rank[i] = 1;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    private boolean union(int x, int y) {\\n        var parentX = find(x);\\n        var parentY = find(y);\\n\\n        if (parentX == parentY)\\n            return false;\\n        if (rank[parentX] > rank[parentY]) \\n            rankCompress(parentX, parentY);\\n        else \\n            rankCompress(parentY, parentX);\\n        return true;\\n    }\\n\\n    private void rankCompress(int parentX, int parentY) {\\n        parent[parentY] = parentX;\\n        rank[parentX] += rank[parentY];\\n        maxRank = Math.max(maxRank, rank[parentX]);\\n    }\\n\\n    private int find(int x) {\\n        if (x != parent[x])\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate record Edge(int v1, int v2, int weight, int index) {}\\n\\npublic List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n    var uf = new UnionFind(n);\\n    var critical = new ArrayList<Integer>();\\n    var pseudoCritical = new ArrayList<Integer>();\\n    var sorted = sortByWeight(edges);\\n    var mstWeight = spanningTreeWeight(uf, sorted);\\n\\n    for (var edge : sorted) {\\n        var ignoredWeight = ignoredSpanningTreeWeight(n, sorted, edge.index);\\n\\n        for (var e : sorted)\\n            if (e.index != edge.index && uf.union(e.v1, e.v2))\\n                ignoredWeight += e.weight;\\n\\n        if (ignoredWeight > mstWeight || uf.maxRank < n) {\\n            critical.add(edge.index);\\n        } else {\\n            uf = new UnionFind(n);\\n            uf.union(edge.v1, edge.v2);\\n            var forcedWeight = edge.weight + spanningTreeWeight(uf, sorted);\\n\\n            if (forcedWeight == mstWeight)\\n                pseudoCritical.add(edge.index);\\n        }\\n    }\\n\\n    return List.of(critical, pseudoCritical);\\n}\\n\\nprivate Edge[] sortByWeight(int[][] edges) {\\n    return IntStream.range(0, edges.length)\\n                    .mapToObj(i -> new Edge(edges[i][0], edges[i][1], edges[i][2], i))\\n                    .sorted(Comparator.comparing(edge -> edge.weight))\\n                    .toArray(Edge[]::new);\\n}\\n\\nprivate int ignoredSpanningTreeWeight(int n, Edge[] sorted, int ignore) {\\n    var uf = new UnionFind(n);\\n    return Arrays.stream(sorted)\\n                 .filter(e -> e.index != ignore && uf.union(e.v1, e.v2))\\n                 .mapToInt(e -> e.weight)\\n                 .sum();\\n}\\n\\nprivate int spanningTreeWeight(UnionFind uf, Edge[] edges) {\\n    return Arrays.stream(edges)\\n                 .filter(edge -> uf.union(edge.v1, edge.v2))\\n                 .mapToInt(edge -> edge.weight)\\n                 .sum();\\n}\\n\\nprivate static class UnionFind {\\n    private final int[] parent;\\n    private final int[] rank;\\n    private int maxRank;\\n\\n    private UnionFind(int n) {\\n        rank = new int[n];\\n        parent = new int[n];\\n\\n        for (var i = 0; i < n; i++) {\\n            rank[i] = 1;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    private boolean union(int x, int y) {\\n        var parentX = find(x);\\n        var parentY = find(y);\\n\\n        if (parentX == parentY)\\n            return false;\\n        if (rank[parentX] > rank[parentY]) \\n            rankCompress(parentX, parentY);\\n        else \\n            rankCompress(parentY, parentX);\\n        return true;\\n    }\\n\\n    private void rankCompress(int parentX, int parentY) {\\n        parent[parentY] = parentX;\\n        rank[parentX] += rank[parentY];\\n        maxRank = Math.max(maxRank, rank[parentX]);\\n    }\\n\\n    private int find(int x) {\\n        if (x != parent[x])\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938265,
                "title": "easy-c-kruskal-s-algorithm-union-find",
                "content": "# Code\\n```\\nclass UnionFind{\\n    public:\\n    int parent[105];\\n    int rank[105];\\n    UnionFind(int size)\\n    {\\n        for(int i=0; i<size;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n    }\\n    int findParent(int x)\\n    {\\n        if(parent[x]!=x)\\n        parent[x]= findParent(parent[x]);\\n\\n        return parent[x];\\n    }\\n    bool Union(int x, int y)\\n    {\\n        int u= findParent(x);\\n        int v= findParent(y);\\n        if(u==v)\\n        return false;\\n\\n        if(rank[u]<rank[v])\\n        parent[u]=v;\\n        else if(rank[v]<rank[u])\\n        parent[v]=u;\\n        else if(rank[u]==rank[v])\\n        {\\n            parent[u]=v;\\n            rank[v]=rank[v]+1;\\n        }\\n        return true;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMST(int n, vector<vector<int>>& edges, int block, int force)\\n    {\\n        UnionFind uf(n);\\n        int res=0;\\n\\n        if(force!=-1)\\n        {\\n            uf.Union(edges[force][0], edges[force][1]);\\n            res+= edges[force][2];\\n        }\\n        \\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(i==block)\\n            continue;\\n\\n            if(uf.Union(edges[i][0], edges[i][1]))\\n            res+= edges[i][2];\\n\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(uf.findParent(i)!=uf.findParent(0))\\n            return INT_MAX;\\n        }\\n\\n        return res;\\n        \\n    }\\n    static bool compare(vector<int>& a, vector<int>& b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> critical; vector<int> pseudo_critical;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), compare);\\n        int mst= findMST(n, edges, -1, -1);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(findMST(n, edges, i, -1)>mst)\\n            {\\n                critical.push_back(edges[i][3]);\\n                \\n            }\\n            else if(findMST(n, edges, -1, i)==mst)\\n            {\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n \\n        }\\n        return {critical, pseudo_critical};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind{\\n    public:\\n    int parent[105];\\n    int rank[105];\\n    UnionFind(int size)\\n    {\\n        for(int i=0; i<size;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n    }\\n    int findParent(int x)\\n    {\\n        if(parent[x]!=x)\\n        parent[x]= findParent(parent[x]);\\n\\n        return parent[x];\\n    }\\n    bool Union(int x, int y)\\n    {\\n        int u= findParent(x);\\n        int v= findParent(y);\\n        if(u==v)\\n        return false;\\n\\n        if(rank[u]<rank[v])\\n        parent[u]=v;\\n        else if(rank[v]<rank[u])\\n        parent[v]=u;\\n        else if(rank[u]==rank[v])\\n        {\\n            parent[u]=v;\\n            rank[v]=rank[v]+1;\\n        }\\n        return true;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findMST(int n, vector<vector<int>>& edges, int block, int force)\\n    {\\n        UnionFind uf(n);\\n        int res=0;\\n\\n        if(force!=-1)\\n        {\\n            uf.Union(edges[force][0], edges[force][1]);\\n            res+= edges[force][2];\\n        }\\n        \\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(i==block)\\n            continue;\\n\\n            if(uf.Union(edges[i][0], edges[i][1]))\\n            res+= edges[i][2];\\n\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(uf.findParent(i)!=uf.findParent(0))\\n            return INT_MAX;\\n        }\\n\\n        return res;\\n        \\n    }\\n    static bool compare(vector<int>& a, vector<int>& b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> critical; vector<int> pseudo_critical;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(), edges.end(), compare);\\n        int mst= findMST(n, edges, -1, -1);\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(findMST(n, edges, i, -1)>mst)\\n            {\\n                critical.push_back(edges[i][3]);\\n                \\n            }\\n            else if(findMST(n, edges, -1, i)==mst)\\n            {\\n                pseudo_critical.push_back(edges[i][3]);\\n            }\\n \\n        }\\n        return {critical, pseudo_critical};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938109,
                "title": "o-eloge-e-e-kruskal-dsu-based-on-every-edge-exclusion-inclusion",
                "content": "# TIME COMPLEXITY EXPLAINED\\n- Sort Once all edges = O(ELogE)\\n- Kruskal is O(E*4alpha) [4alpha is dsu time which is as good as O(1)]\\n- Thereby kruskal is O(E)\\n- We run 2 kruskal [exclude + include] for every edge - E times\\n- O(E* 2E) is the time complexity\\n- O(ElogE + E*E) is final (excluding all constants)\\n\\n# Code\\n```\\nclass DSU{\\n\\nprivate:\\n    vector<int> parent, size;\\n\\npublic:\\n    DSU(int n){\\n        size.resize(n+1, 1);\\n        parent.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v){\\n        int ultU = findUPar(u);\\n        int ultV = findUPar(v);\\n\\n        if(ultU == ultV) return;\\n\\n        if(size[ultU] < size[ultV]){\\n            parent[ultU] = ultV;\\n            size[ultV] += size[ultU];\\n        }\\n        else{\\n            parent[ultV] = ultU;\\n            size[ultU] += size[ultV];\\n        }\\n\\n    }\\n\\n    int findUPar(int node){\\n        if(parent[node] == node) return node;\\n\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n};\\n\\nclass Solution {\\n\\nprivate:\\n    //Kruskal Algo\\n    int getMST(int n, vector<vector<int>>& edges, int exc, int inc){\\n        DSU dsu(n);\\n\\n        int mstW = 0;\\n        if(inc != -1){\\n            //must include that first\\n            mstW += edges[inc][2];\\n            dsu.unionBySize(edges[inc][0], edges[inc][1]);\\n        }\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            if(i == exc) continue;\\n\\n            //its asc sorted - so take it as such\\n            //useless edge\\n            if(dsu.findUPar(edges[i][0]) == dsu.findUPar(edges[i][1])) continue;\\n\\n            mstW += edges[i][2];\\n            dsu.unionBySize(edges[i][0], edges[i][1]);\\n\\n        }\\n\\n        //is MST FORMED\\n        for(int i=0; i<n; i++){\\n            if(dsu.findUPar(i) != dsu.findUPar(0)) return 1e9;\\n        }\\n        //all nodes are connected to a single ULT PAR - therfore all nodes are connected\\n\\n        return mstW;\\n    }\\n\\n    bool static comp(vector<int>& a, vector<int>& b){\\n        return a[2] < b[2];\\n    }\\n\\npublic:    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pCritical;\\n        //while sorting the idx gets changed, so keep it in edges itself orgIDX\\n        for(int i=0; i<edges.size(); i++){\\n            edges[i].push_back(i);\\n            //[u, v, wt, ordIdx]\\n        }\\n\\n        //sort the edges based on Wt once for KRUSKAL to work \\n        sort(edges.begin(), edges.end(), comp);\\n\\n        int orgMSTWt = getMST(n, edges, -1, -1); // org mst wt\\n\\n        for(int i=0; i<edges.size(); i++){\\n            //try excluding i th edge\\n            int excWt = getMST(n, edges, i, -1);\\n            //try including ith edge for sure\\n            int incWt = getMST(n, edges, -1, i);\\n\\n            if(orgMSTWt < excWt){\\n                //its a critical edge - as it impacted our MST\\n                critical.push_back(edges[i][3]);\\n            }\\n            else if(incWt == orgMSTWt){\\n                //its a pseudo cri edge\\n                //its an edge from which MST can be made \\n                pCritical.push_back(edges[i][3]);\\n            }\\n\\n            //its not at all an edge that helps in creation of MST\\n        }\\n\\n        return {critical, pCritical};\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\n\\nprivate:\\n    vector<int> parent, size;\\n\\npublic:\\n    DSU(int n){\\n        size.resize(n+1, 1);\\n        parent.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v){\\n        int ultU = findUPar(u);\\n        int ultV = findUPar(v);\\n\\n        if(ultU == ultV) return;\\n\\n        if(size[ultU] < size[ultV]){\\n            parent[ultU] = ultV;\\n            size[ultV] += size[ultU];\\n        }\\n        else{\\n            parent[ultV] = ultU;\\n            size[ultU] += size[ultV];\\n        }\\n\\n    }\\n\\n    int findUPar(int node){\\n        if(parent[node] == node) return node;\\n\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n};\\n\\nclass Solution {\\n\\nprivate:\\n    //Kruskal Algo\\n    int getMST(int n, vector<vector<int>>& edges, int exc, int inc){\\n        DSU dsu(n);\\n\\n        int mstW = 0;\\n        if(inc != -1){\\n            //must include that first\\n            mstW += edges[inc][2];\\n            dsu.unionBySize(edges[inc][0], edges[inc][1]);\\n        }\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            if(i == exc) continue;\\n\\n            //its asc sorted - so take it as such\\n            //useless edge\\n            if(dsu.findUPar(edges[i][0]) == dsu.findUPar(edges[i][1])) continue;\\n\\n            mstW += edges[i][2];\\n            dsu.unionBySize(edges[i][0], edges[i][1]);\\n\\n        }\\n\\n        //is MST FORMED\\n        for(int i=0; i<n; i++){\\n            if(dsu.findUPar(i) != dsu.findUPar(0)) return 1e9;\\n        }\\n        //all nodes are connected to a single ULT PAR - therfore all nodes are connected\\n\\n        return mstW;\\n    }\\n\\n    bool static comp(vector<int>& a, vector<int>& b){\\n        return a[2] < b[2];\\n    }\\n\\npublic:    \\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pCritical;\\n        //while sorting the idx gets changed, so keep it in edges itself orgIDX\\n        for(int i=0; i<edges.size(); i++){\\n            edges[i].push_back(i);\\n            //[u, v, wt, ordIdx]\\n        }\\n\\n        //sort the edges based on Wt once for KRUSKAL to work \\n        sort(edges.begin(), edges.end(), comp);\\n\\n        int orgMSTWt = getMST(n, edges, -1, -1); // org mst wt\\n\\n        for(int i=0; i<edges.size(); i++){\\n            //try excluding i th edge\\n            int excWt = getMST(n, edges, i, -1);\\n            //try including ith edge for sure\\n            int incWt = getMST(n, edges, -1, i);\\n\\n            if(orgMSTWt < excWt){\\n                //its a critical edge - as it impacted our MST\\n                critical.push_back(edges[i][3]);\\n            }\\n            else if(incWt == orgMSTWt){\\n                //its a pseudo cri edge\\n                //its an edge from which MST can be made \\n                pCritical.push_back(edges[i][3]);\\n            }\\n\\n            //its not at all an edge that helps in creation of MST\\n        }\\n\\n        return {critical, pCritical};\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937814,
                "title": "well-commented-code-and-steps-to-solve-this-problem-kruskal-dsu-easy-implementation",
                "content": "\\n# Approach\\nApproach/steps are commented well in the code itself.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n\\n    /*\\n        Steps:\\n            1. Firstly, As we need to apply Kruskal, the edges must be SORTED.\\n               But, we need to keep track of their indices AS We need to return indices of EDGES in ANSWER!\\n            2. Find the MST weight using (MODIFIED)KRUSKAL(See why only KRUSKAL?)\\n            3. Now, iterate over each EDGE.\\n                > To find the CRITICAL EDGE: Try to Skip it and call KRUSKAL.\\n                    ~ If, thisMSTwt > mstWT  -> means, the current skipped edge is CRITICAL.\\n                    ~ Also, if graph gets disconnected after removing this edge, it is also CRITICAL\\n                > To find the P.Critical Edge:\\n                    ~ Take iTH edge NECESSARILY in the mst, and see if \"newMSTwt == mstWt\" then it is PCritical edge\\n\\n            4. Write a slightly modified Kruskal to do this task\\n     */\\n    int nodes;\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\n//------------------------------------------------------- Step 1 -------------------------------------------------------\\n        nodes = n;\\n        int[][] sortedEdges = new int[edges.length][4];\\n        for (int i = 0; i < edges.length; i++) {\\n            sortedEdges[i][0] = edges[i][0];//u\\n            sortedEdges[i][1] = edges[i][1];//v\\n            sortedEdges[i][2] = edges[i][2];//wt\\n            sortedEdges[i][3] = i;//original index\\n        }\\n        Arrays.sort(sortedEdges, Comparator.comparing(o -> o[2]));//sort wrt wt.\\n\\n//------------------------------------------------------- Step 2 -------------------------------------------------------\\n        int mstWt = kruskalModified(sortedEdges, -1, -1);\\n\\n//------------------------------------------------------- Step 3 -------------------------------------------------------\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        int criticalMstWt, pCriticalMstWt;\\n        for (int i = 0; i < sortedEdges.length; i++) {\\n            int[] edge = sortedEdges[i];\\n            //Critical Edge: Check by SKIPPING current edge\\n            criticalMstWt = kruskalModified(sortedEdges, i, -1);\\n            if (criticalMstWt > mstWt) {\\n                critical.add(edge[3]);\\n                continue;//if an edge is critical It CANT BE PSEUDO_CRITICAL\\n            }\\n\\n            //Pseudo-Critical Edge: Compulsorily add this edge\\n            pCriticalMstWt = kruskalModified(sortedEdges, -1, i);\\n            if (pCriticalMstWt == mstWt)\\n                pseudoCritical.add(edge[3]);\\n        }\\n\\n//------------------------------------------------------- Returning answer -------------------------------------------------------\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ans.add(critical);//Just doing SHALLOW COPY, as these inner lists don\\'t change at this point. so no need of deep copy\\n        ans.add(pseudoCritical);\\n\\n        return ans;\\n    }\\n\\n//------------------------------------------------------- Step 4 -------------------------------------------------------\\n    private int kruskalModified(int[][] sortedEdges, int skipEdge, int addEdge) {\\n        DSU dsu = new DSU(nodes);\\n        int mstWt = 0;\\n\\n        //modification1 : for pseudo critical edges.\\n        if (addEdge != -1) {\\n            dsu.union(sortedEdges[addEdge][0], sortedEdges[addEdge][1]);\\n            mstWt += sortedEdges[addEdge][2];\\n        }\\n\\n        for (int i = 0; i < sortedEdges.length; i++) {\\n            //modification2: for critical edges\\n            if (skipEdge == i)\\n                continue;\\n\\n            int u = sortedEdges[i][0];\\n            int v = sortedEdges[i][1];\\n            int wt = sortedEdges[i][2];\\n\\n            //if cycle forms, skip the edge\\n            if (dsu.findParent(u) == dsu.findParent(v))\\n                continue;\\n\\n            //else join this edge.\\n            dsu.union(u, v);\\n            mstWt += wt;\\n        }\\n\\n        //BROKEN GRAPH: it might happen that because of skipping an edge, we end up forming BROKEN GRAPH. so check this\\n        for (int i = 0; i < nodes; i++) {\\n            if (dsu.findParent(i) != dsu.findParent(0))//check with any random node. Every ones parent must be same\\n                return Integer.MAX_VALUE;//that is skipped edge was critical\\n        }\\n\\n        return mstWt;\\n    }\\n}\\n\\n\\nclass DSU{\\n    int[] rank, parent;\\n    DSU(int nodes){\\n        rank = new int[nodes];\\n        parent = new int[nodes];\\n        //IMP: every node is parent of itself at the starting\\n        for (int i = 0; i < nodes; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int findParent(int node) {//this finds the ultimate parent\\n        if (node == parent[node])\\n            return node;\\n\\n        int parentOfNode = findParent(parent[node]);\\n        return parent[node] = parentOfNode;\\n    }\\n\\n    public void union(int u, int v) {\\n        //Step1 : Find parents of both\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n\\n        //Step2: Connected: if both u, v have same parent already -> Means they are already connected\\n        if (pu == pv)\\n            return;\\n\\n        //Step3: Disconnected: Find ranks of parents and compare\\n        int rankPU = rank[pu];\\n        int rankPV = rank[pv];\\n\\n        //Step4: Find Union/Join the 2 components. Smaller rank joins the Larger rank\\n        if (rankPU < rankPV){\\n            parent[pu] = pv;\\n        }\\n        else if (rankPU > rankPV)\\n            parent[pv] = pu;\\n        else {//equal\\n            parent[pu] = pv;\\n            rank[pv] = rank[pu]+1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\n    /*\\n        Steps:\\n            1. Firstly, As we need to apply Kruskal, the edges must be SORTED.\\n               But, we need to keep track of their indices AS We need to return indices of EDGES in ANSWER!\\n            2. Find the MST weight using (MODIFIED)KRUSKAL(See why only KRUSKAL?)\\n            3. Now, iterate over each EDGE.\\n                > To find the CRITICAL EDGE: Try to Skip it and call KRUSKAL.\\n                    ~ If, thisMSTwt > mstWT  -> means, the current skipped edge is CRITICAL.\\n                    ~ Also, if graph gets disconnected after removing this edge, it is also CRITICAL\\n                > To find the P.Critical Edge:\\n                    ~ Take iTH edge NECESSARILY in the mst, and see if \"newMSTwt == mstWt\" then it is PCritical edge\\n\\n            4. Write a slightly modified Kruskal to do this task\\n     */\\n    int nodes;\\n\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n\\n//------------------------------------------------------- Step 1 -------------------------------------------------------\\n        nodes = n;\\n        int[][] sortedEdges = new int[edges.length][4];\\n        for (int i = 0; i < edges.length; i++) {\\n            sortedEdges[i][0] = edges[i][0];//u\\n            sortedEdges[i][1] = edges[i][1];//v\\n            sortedEdges[i][2] = edges[i][2];//wt\\n            sortedEdges[i][3] = i;//original index\\n        }\\n        Arrays.sort(sortedEdges, Comparator.comparing(o -> o[2]));//sort wrt wt.\\n\\n//------------------------------------------------------- Step 2 -------------------------------------------------------\\n        int mstWt = kruskalModified(sortedEdges, -1, -1);\\n\\n//------------------------------------------------------- Step 3 -------------------------------------------------------\\n        List<Integer> critical = new ArrayList<>();\\n        List<Integer> pseudoCritical = new ArrayList<>();\\n        int criticalMstWt, pCriticalMstWt;\\n        for (int i = 0; i < sortedEdges.length; i++) {\\n            int[] edge = sortedEdges[i];\\n            //Critical Edge: Check by SKIPPING current edge\\n            criticalMstWt = kruskalModified(sortedEdges, i, -1);\\n            if (criticalMstWt > mstWt) {\\n                critical.add(edge[3]);\\n                continue;//if an edge is critical It CANT BE PSEUDO_CRITICAL\\n            }\\n\\n            //Pseudo-Critical Edge: Compulsorily add this edge\\n            pCriticalMstWt = kruskalModified(sortedEdges, -1, i);\\n            if (pCriticalMstWt == mstWt)\\n                pseudoCritical.add(edge[3]);\\n        }\\n\\n//------------------------------------------------------- Returning answer -------------------------------------------------------\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ans.add(critical);//Just doing SHALLOW COPY, as these inner lists don\\'t change at this point. so no need of deep copy\\n        ans.add(pseudoCritical);\\n\\n        return ans;\\n    }\\n\\n//------------------------------------------------------- Step 4 -------------------------------------------------------\\n    private int kruskalModified(int[][] sortedEdges, int skipEdge, int addEdge) {\\n        DSU dsu = new DSU(nodes);\\n        int mstWt = 0;\\n\\n        //modification1 : for pseudo critical edges.\\n        if (addEdge != -1) {\\n            dsu.union(sortedEdges[addEdge][0], sortedEdges[addEdge][1]);\\n            mstWt += sortedEdges[addEdge][2];\\n        }\\n\\n        for (int i = 0; i < sortedEdges.length; i++) {\\n            //modification2: for critical edges\\n            if (skipEdge == i)\\n                continue;\\n\\n            int u = sortedEdges[i][0];\\n            int v = sortedEdges[i][1];\\n            int wt = sortedEdges[i][2];\\n\\n            //if cycle forms, skip the edge\\n            if (dsu.findParent(u) == dsu.findParent(v))\\n                continue;\\n\\n            //else join this edge.\\n            dsu.union(u, v);\\n            mstWt += wt;\\n        }\\n\\n        //BROKEN GRAPH: it might happen that because of skipping an edge, we end up forming BROKEN GRAPH. so check this\\n        for (int i = 0; i < nodes; i++) {\\n            if (dsu.findParent(i) != dsu.findParent(0))//check with any random node. Every ones parent must be same\\n                return Integer.MAX_VALUE;//that is skipped edge was critical\\n        }\\n\\n        return mstWt;\\n    }\\n}\\n\\n\\nclass DSU{\\n    int[] rank, parent;\\n    DSU(int nodes){\\n        rank = new int[nodes];\\n        parent = new int[nodes];\\n        //IMP: every node is parent of itself at the starting\\n        for (int i = 0; i < nodes; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int findParent(int node) {//this finds the ultimate parent\\n        if (node == parent[node])\\n            return node;\\n\\n        int parentOfNode = findParent(parent[node]);\\n        return parent[node] = parentOfNode;\\n    }\\n\\n    public void union(int u, int v) {\\n        //Step1 : Find parents of both\\n        int pu = findParent(u);\\n        int pv = findParent(v);\\n\\n        //Step2: Connected: if both u, v have same parent already -> Means they are already connected\\n        if (pu == pv)\\n            return;\\n\\n        //Step3: Disconnected: Find ranks of parents and compare\\n        int rankPU = rank[pu];\\n        int rankPV = rank[pv];\\n\\n        //Step4: Find Union/Join the 2 components. Smaller rank joins the Larger rank\\n        if (rankPU < rankPV){\\n            parent[pu] = pv;\\n        }\\n        else if (rankPU > rankPV)\\n            parent[pv] = pu;\\n        else {//equal\\n            parent[pu] = pv;\\n            rank[pv] = rank[pu]+1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936999,
                "title": "c-code-easy-to-understand",
                "content": "```\\nclass UnionFind{\\npublic:\\n    int n,maxelm = 0;\\n    vector<int> par, rank;\\n    \\n    UnionFind(int n){\\n        this->n = n;\\n        par.resize(n);\\n        iota(par.begin(),par.end(),0);\\n        rank.resize(n,1);\\n    }\\n    \\n    int findPar(int v){\\n        if(par[v]==v) return v;\\n        return par[v] = findPar(par[v]);\\n    }\\n    \\n    bool Union(int a, int b){\\n        a = findPar(a);\\n        b = findPar(b);\\n        \\n        if(a!=b){\\n            if(rank[a] < rank[b]) swap(a,b);\\n            par[b] = a;\\n            rank[a] += rank[b];\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maxUnionSet(){\\n        for(auto it: rank) maxelm = max(maxelm,it);\\n        return maxelm;\\n    }\\n    \\n};\\n\\nclass Solution {\\n    typedef vector<vector<int>> vvi;\\n    vector<int> ce, psce;\\npublic:\\n    vvi findCriticalAndPseudoCriticalEdges(int n, vvi& e) {\\n        for(int i = 0 ;i<e.size();i++) e[i].push_back(i);\\n        \\n        sort(begin(e), end(e), [](vector<int> &a, vector<int> &b){\\n            return a[2]< b[2]; \\n        });\\n        \\n        int mstW = 0, tmastW = 0;\\n        \\n        UnionFind uf = UnionFind(n);\\n        \\n        for(auto it: e) if(uf.Union(it[0],it[1])) mstW += it[2];\\n        \\n        for(auto e1: e) {\\n            \\n            tmastW = 0;\\n            UnionFind tuf = UnionFind(n);   // for critical edge \\n            \\n            for(auto e2: e) {\\n                if(e1[3] != e2[3]  and tuf.Union(e2[0],e2[1])) tmastW += e2[2];\\n            }\\n            \\n            if(tuf.maxUnionSet() != n or tmastW > mstW) {\\n                ce.push_back(e1[3]);\\n                continue;  // if an edge is a criticel edge it can never be a pseudo critical edge so we continue\\n            }\\n            \\n            \\n            UnionFind stuf = UnionFind(n);  // for pseudo-critical edge \\n            stuf.Union(e1[0],e1[1]);\\n            tmastW = e1[2];\\n            \\n            for(auto e2: e) {\\n                if(stuf.Union(e2[0],e2[1])) tmastW += e2[2];\\n            }\\n            \\n            if(tmastW == mstW) psce.push_back(e1[3]);\\n\\n        } \\n        return {ce,psce};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind{\\npublic:\\n    int n,maxelm = 0;\\n    vector<int> par, rank;\\n    \\n    UnionFind(int n){\\n        this->n = n;\\n        par.resize(n);\\n        iota(par.begin(),par.end(),0);\\n        rank.resize(n,1);\\n    }\\n    \\n    int findPar(int v){\\n        if(par[v]==v) return v;\\n        return par[v] = findPar(par[v]);\\n    }\\n    \\n    bool Union(int a, int b){\\n        a = findPar(a);\\n        b = findPar(b);\\n        \\n        if(a!=b){\\n            if(rank[a] < rank[b]) swap(a,b);\\n            par[b] = a;\\n            rank[a] += rank[b];\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maxUnionSet(){\\n        for(auto it: rank) maxelm = max(maxelm,it);\\n        return maxelm;\\n    }\\n    \\n};\\n\\nclass Solution {\\n    typedef vector<vector<int>> vvi;\\n    vector<int> ce, psce;\\npublic:\\n    vvi findCriticalAndPseudoCriticalEdges(int n, vvi& e) {\\n        for(int i = 0 ;i<e.size();i++) e[i].push_back(i);\\n        \\n        sort(begin(e), end(e), [](vector<int> &a, vector<int> &b){\\n            return a[2]< b[2]; \\n        });\\n        \\n        int mstW = 0, tmastW = 0;\\n        \\n        UnionFind uf = UnionFind(n);\\n        \\n        for(auto it: e) if(uf.Union(it[0],it[1])) mstW += it[2];\\n        \\n        for(auto e1: e) {\\n            \\n            tmastW = 0;\\n            UnionFind tuf = UnionFind(n);   // for critical edge \\n            \\n            for(auto e2: e) {\\n                if(e1[3] != e2[3]  and tuf.Union(e2[0],e2[1])) tmastW += e2[2];\\n            }\\n            \\n            if(tuf.maxUnionSet() != n or tmastW > mstW) {\\n                ce.push_back(e1[3]);\\n                continue;  // if an edge is a criticel edge it can never be a pseudo critical edge so we continue\\n            }\\n            \\n            \\n            UnionFind stuf = UnionFind(n);  // for pseudo-critical edge \\n            stuf.Union(e1[0],e1[1]);\\n            tmastW = e1[2];\\n            \\n            for(auto e2: e) {\\n                if(stuf.Union(e2[0],e2[1])) tmastW += e2[2];\\n            }\\n            \\n            if(tmastW == mstW) psce.push_back(e1[3]);\\n\\n        } \\n        return {ce,psce};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936724,
                "title": "java-dsu-kruskal-better-than-81-submissions",
                "content": "# Intuition: Generate All Spanning Trees & Check (TLE \\u274C)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Minimum Spanning Tree, so Prim\\'s or Kruskal\\'s Algorithm.\\n    /**\\n     1. Find all the MSTs possible\\n     2. Find the common edges\\n     3. Other edges of all the MSTs\\n     */\\n    static List<List<Edge>> allMST = new ArrayList<>();\\n    public static List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Edge Case: Check if all the weights are equal. If yes, all the edges will be pseudo-critical edge\\n        Edge edge[] = new Edge[edges.length];\\n        for(int i = 0; i < edges.length; i++){\\n            edge[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i);\\n        }\\n\\n        Arrays.sort(edge, (a, b) -> (a.weight - b.weight));\\n\\n        int MSTWeight = 0;\\n        DisjointSet DJ = new DisjointSet(n);\\n        for(int i = 0; i < edges.length; i++){\\n            int u = edge[i].src;\\n            int v = edge[i].dest;\\n            int w = edge[i].weight;\\n\\n            if(DJ.find(u) != DJ.find(v)){\\n                MSTWeight += w;\\n                DJ.union(u, v);\\n            }\\n        }\\n\\n        allPossibleMST(0, MSTWeight, n, edge, new ArrayList<>());\\n\\n        HashMap<Integer, Integer> edgeFreq = new HashMap<>();\\n        for(List<Edge> MST : allMST){\\n            for(Edge e : MST){\\n                if(!edgeFreq.containsKey(e.edgeNo)){\\n                    edgeFreq.put(e.edgeNo, 1);\\n                } else {\\n                    edgeFreq.put(e.edgeNo, edgeFreq.get(e.edgeNo) + 1);\\n                }\\n\\n            }\\n        }\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for(Map.Entry<Integer, Integer> it : edgeFreq.entrySet()){\\n            if(it.getValue() == allMST.size()){\\n                criticalEdges.add(it.getKey());\\n            } else {\\n                pseudoCriticalEdges.add(it.getKey());\\n            }\\n        }\\n\\n        return new ArrayList<>(\\n            Arrays.asList(criticalEdges, pseudoCriticalEdges)\\n        );\\n    }\\n\\n    public static void allPossibleMST(int idx, int MSTWeight, int n, Edge edge[], List<Edge> graph){\\n        if(graph.size() == n - 1){\\n            //check for cycle, connected and MST\\n            if(checkIfValidMST(MSTWeight, n, graph)){\\n                //storeItInSomeDataStructure\\n                allMST.add(new ArrayList<Edge>(graph));\\n            }\\n            return;\\n        }\\n\\n        if(idx >= edge.length){\\n            return;\\n        }\\n\\n        // don\\'t take the current edge\\n        allPossibleMST(idx + 1, MSTWeight, n, edge, graph);\\n\\n        graph.add(new Edge(edge[idx].src, edge[idx].dest, edge[idx].weight, edge[idx].edgeNo));\\n        allPossibleMST(idx + 1, MSTWeight, n, edge, graph);\\n        graph.remove(graph.size() - 1);\\n    }\\n\\n    public static  boolean checkIfValidMST(int MSTWeight, int n, List<Edge> graph){\\n        int noOfEdgesSelected = 0;\\n        DisjointSet DJ = new DisjointSet(n);\\n        int currentMSTWeight = 0;\\n        for(Edge edge : graph){\\n            int u = edge.src;\\n            int v = edge.dest;\\n            int w = edge.weight;\\n\\n            if(DJ.find(u) != DJ.find(v)){\\n                currentMSTWeight += w;\\n                DJ.union(u, v);\\n                noOfEdgesSelected++;\\n            }\\n        }\\n\\n        if(noOfEdgesSelected != n - 1){\\n            return false;\\n        }\\n\\n        return currentMSTWeight == MSTWeight;\\n    }\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        int edgeNo;\\n\\n        public Edge(int src, int dest, int weight, int edgeNo){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n            this.edgeNo = edgeNo;\\n        }\\n    }\\n\\n    // Union By Size\\n    public class DisjointSet{\\n        int parent[];\\n        int size[];\\n        \\n        public DisjointSet(int n){\\n            this.parent = new int[n];\\n            this.size = new int[n];\\n\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int node){\\n            if(parent[node] == node){\\n                return node;\\n            }\\n\\n            return parent[node] = find(parent[node]);\\n        }\\n\\n        public void union(int i, int j){\\n            int representativeI = find(i);\\n            int representativeJ = find(j);\\n\\n            if(representativeI == representativeJ){\\n                return;\\n            }\\n\\n            if(size[representativeI] < size[representativeJ]){\\n                parent[representativeI] = representativeJ;\\n                size[representativeJ] += size[representativeI];\\n            } else {\\n                parent[representativeJ] = representativeI;\\n                size[representativeI] += size[representativeJ];\\n            }\\n        }\\n    }\\n}\\n\\n```\\n---\\n# Intuition: Include & Exclude Edges\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E + ElogV)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E*4)\\\\ for\\\\ newEdges,\\\\ O(2*V)\\\\ for\\\\ DSU$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Minimum Spanning Tree, so Prim\\'s or Kruskal\\'s Algorithm.\\n    /**\\n     1. Find all the MSTs possible\\n     2. Find the common edges\\n     3. Other edges of all the MSTs\\n     */\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Edge Case: Check if all the weights are equal. If yes, all the edges will be pseudo-critical edge\\n        Edge newEdges[] = new Edge[edges.length];\\n        for(int i = 0; i < edges.length; i++){\\n            newEdges[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i); \\n        }\\n\\n        Arrays.sort(newEdges, (a, b) -> (a.weight - b.weight));\\n\\n        int MSTWeight = runKruskal(n, newEdges, -1, -1);\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for(int i = 0; i < newEdges.length; i++){\\n            // if I exclude the current edge and the MST that I am getting has weight greater than original MST, then the edge is critical\\n            if(MSTWeight < runKruskal(n, newEdges, -1, i)){\\n                criticalEdges.add(newEdges[i].edgeNo);\\n            } else if(MSTWeight == runKruskal(n, newEdges, i, -1)){\\n                pseudoCriticalEdges.add(newEdges[i].edgeNo);\\n            }\\n        }\\n\\n        return new ArrayList<>(\\n            Arrays.asList(criticalEdges, pseudoCriticalEdges)\\n        );\\n    }\\n\\n    public int runKruskal(int n, Edge[] newEdges, int includeEdge, int excludeEdge){\\n        DisjointSet DSU = new DisjointSet(n);\\n\\n        int MSTWeight = 0;\\n        if(includeEdge != -1){\\n            MSTWeight += newEdges[includeEdge].weight;\\n            DSU.union(newEdges[includeEdge].src, newEdges[includeEdge].dest);\\n        }\\n\\n        for(int i = 0; i < newEdges.length; i++){\\n            if(i == excludeEdge){\\n                continue;\\n            }\\n\\n            int src = newEdges[i].src;\\n            int dest = newEdges[i].dest;\\n            int weight = newEdges[i].weight;\\n            if(DSU.find(src) != DSU.find(dest)){\\n                MSTWeight += weight;\\n                DSU.union(src, dest);\\n            }\\n        }\\n\\n        // Checking for connected component\\n        for (int i = 0; i < n; i++) {\\n            if (DSU.find(i) != DSU.find(0))\\n                return Integer.MAX_VALUE;\\n        }\\n        return MSTWeight;\\n    }\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        int edgeNo;\\n\\n        public Edge(int src, int dest, int weight, int edgeNo){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n            this.edgeNo = edgeNo;\\n        }\\n    }\\n\\n    // Union By Size\\n    public class DisjointSet{\\n        int parent[];\\n        int size[];\\n        \\n        public DisjointSet(int n){\\n            this.parent = new int[n];\\n            this.size = new int[n];\\n\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int node){\\n            if(parent[node] == node){\\n                return node;\\n            }\\n\\n            return parent[node] = find(parent[node]);\\n        }\\n\\n        public void union(int i, int j){\\n            int representativeI = find(i);\\n            int representativeJ = find(j);\\n\\n            if(representativeI == representativeJ){\\n                return;\\n            }\\n\\n            if(size[representativeI] < size[representativeJ]){\\n                parent[representativeI] = representativeJ;\\n                size[representativeJ] += size[representativeI];\\n            } else {\\n                parent[representativeJ] = representativeI;\\n                size[representativeI] += size[representativeJ];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n    // Minimum Spanning Tree, so Prim\\'s or Kruskal\\'s Algorithm.\\n    /**\\n     1. Find all the MSTs possible\\n     2. Find the common edges\\n     3. Other edges of all the MSTs\\n     */\\n    static List<List<Edge>> allMST = new ArrayList<>();\\n    public static List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Edge Case: Check if all the weights are equal. If yes, all the edges will be pseudo-critical edge\\n        Edge edge[] = new Edge[edges.length];\\n        for(int i = 0; i < edges.length; i++){\\n            edge[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i);\\n        }\\n\\n        Arrays.sort(edge, (a, b) -> (a.weight - b.weight));\\n\\n        int MSTWeight = 0;\\n        DisjointSet DJ = new DisjointSet(n);\\n        for(int i = 0; i < edges.length; i++){\\n            int u = edge[i].src;\\n            int v = edge[i].dest;\\n            int w = edge[i].weight;\\n\\n            if(DJ.find(u) != DJ.find(v)){\\n                MSTWeight += w;\\n                DJ.union(u, v);\\n            }\\n        }\\n\\n        allPossibleMST(0, MSTWeight, n, edge, new ArrayList<>());\\n\\n        HashMap<Integer, Integer> edgeFreq = new HashMap<>();\\n        for(List<Edge> MST : allMST){\\n            for(Edge e : MST){\\n                if(!edgeFreq.containsKey(e.edgeNo)){\\n                    edgeFreq.put(e.edgeNo, 1);\\n                } else {\\n                    edgeFreq.put(e.edgeNo, edgeFreq.get(e.edgeNo) + 1);\\n                }\\n\\n            }\\n        }\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for(Map.Entry<Integer, Integer> it : edgeFreq.entrySet()){\\n            if(it.getValue() == allMST.size()){\\n                criticalEdges.add(it.getKey());\\n            } else {\\n                pseudoCriticalEdges.add(it.getKey());\\n            }\\n        }\\n\\n        return new ArrayList<>(\\n            Arrays.asList(criticalEdges, pseudoCriticalEdges)\\n        );\\n    }\\n\\n    public static void allPossibleMST(int idx, int MSTWeight, int n, Edge edge[], List<Edge> graph){\\n        if(graph.size() == n - 1){\\n            //check for cycle, connected and MST\\n            if(checkIfValidMST(MSTWeight, n, graph)){\\n                //storeItInSomeDataStructure\\n                allMST.add(new ArrayList<Edge>(graph));\\n            }\\n            return;\\n        }\\n\\n        if(idx >= edge.length){\\n            return;\\n        }\\n\\n        // don\\'t take the current edge\\n        allPossibleMST(idx + 1, MSTWeight, n, edge, graph);\\n\\n        graph.add(new Edge(edge[idx].src, edge[idx].dest, edge[idx].weight, edge[idx].edgeNo));\\n        allPossibleMST(idx + 1, MSTWeight, n, edge, graph);\\n        graph.remove(graph.size() - 1);\\n    }\\n\\n    public static  boolean checkIfValidMST(int MSTWeight, int n, List<Edge> graph){\\n        int noOfEdgesSelected = 0;\\n        DisjointSet DJ = new DisjointSet(n);\\n        int currentMSTWeight = 0;\\n        for(Edge edge : graph){\\n            int u = edge.src;\\n            int v = edge.dest;\\n            int w = edge.weight;\\n\\n            if(DJ.find(u) != DJ.find(v)){\\n                currentMSTWeight += w;\\n                DJ.union(u, v);\\n                noOfEdgesSelected++;\\n            }\\n        }\\n\\n        if(noOfEdgesSelected != n - 1){\\n            return false;\\n        }\\n\\n        return currentMSTWeight == MSTWeight;\\n    }\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        int edgeNo;\\n\\n        public Edge(int src, int dest, int weight, int edgeNo){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n            this.edgeNo = edgeNo;\\n        }\\n    }\\n\\n    // Union By Size\\n    public class DisjointSet{\\n        int parent[];\\n        int size[];\\n        \\n        public DisjointSet(int n){\\n            this.parent = new int[n];\\n            this.size = new int[n];\\n\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int node){\\n            if(parent[node] == node){\\n                return node;\\n            }\\n\\n            return parent[node] = find(parent[node]);\\n        }\\n\\n        public void union(int i, int j){\\n            int representativeI = find(i);\\n            int representativeJ = find(j);\\n\\n            if(representativeI == representativeJ){\\n                return;\\n            }\\n\\n            if(size[representativeI] < size[representativeJ]){\\n                parent[representativeI] = representativeJ;\\n                size[representativeJ] += size[representativeI];\\n            } else {\\n                parent[representativeJ] = representativeI;\\n                size[representativeI] += size[representativeJ];\\n            }\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    // Minimum Spanning Tree, so Prim\\'s or Kruskal\\'s Algorithm.\\n    /**\\n     1. Find all the MSTs possible\\n     2. Find the common edges\\n     3. Other edges of all the MSTs\\n     */\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n        // Edge Case: Check if all the weights are equal. If yes, all the edges will be pseudo-critical edge\\n        Edge newEdges[] = new Edge[edges.length];\\n        for(int i = 0; i < edges.length; i++){\\n            newEdges[i] = new Edge(edges[i][0], edges[i][1], edges[i][2], i); \\n        }\\n\\n        Arrays.sort(newEdges, (a, b) -> (a.weight - b.weight));\\n\\n        int MSTWeight = runKruskal(n, newEdges, -1, -1);\\n\\n        List<Integer> criticalEdges = new ArrayList<>();\\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\\n        for(int i = 0; i < newEdges.length; i++){\\n            // if I exclude the current edge and the MST that I am getting has weight greater than original MST, then the edge is critical\\n            if(MSTWeight < runKruskal(n, newEdges, -1, i)){\\n                criticalEdges.add(newEdges[i].edgeNo);\\n            } else if(MSTWeight == runKruskal(n, newEdges, i, -1)){\\n                pseudoCriticalEdges.add(newEdges[i].edgeNo);\\n            }\\n        }\\n\\n        return new ArrayList<>(\\n            Arrays.asList(criticalEdges, pseudoCriticalEdges)\\n        );\\n    }\\n\\n    public int runKruskal(int n, Edge[] newEdges, int includeEdge, int excludeEdge){\\n        DisjointSet DSU = new DisjointSet(n);\\n\\n        int MSTWeight = 0;\\n        if(includeEdge != -1){\\n            MSTWeight += newEdges[includeEdge].weight;\\n            DSU.union(newEdges[includeEdge].src, newEdges[includeEdge].dest);\\n        }\\n\\n        for(int i = 0; i < newEdges.length; i++){\\n            if(i == excludeEdge){\\n                continue;\\n            }\\n\\n            int src = newEdges[i].src;\\n            int dest = newEdges[i].dest;\\n            int weight = newEdges[i].weight;\\n            if(DSU.find(src) != DSU.find(dest)){\\n                MSTWeight += weight;\\n                DSU.union(src, dest);\\n            }\\n        }\\n\\n        // Checking for connected component\\n        for (int i = 0; i < n; i++) {\\n            if (DSU.find(i) != DSU.find(0))\\n                return Integer.MAX_VALUE;\\n        }\\n        return MSTWeight;\\n    }\\n\\n    public class Edge{\\n        int src;\\n        int dest;\\n        int weight;\\n        int edgeNo;\\n\\n        public Edge(int src, int dest, int weight, int edgeNo){\\n            this.src = src;\\n            this.dest = dest;\\n            this.weight = weight;\\n            this.edgeNo = edgeNo;\\n        }\\n    }\\n\\n    // Union By Size\\n    public class DisjointSet{\\n        int parent[];\\n        int size[];\\n        \\n        public DisjointSet(int n){\\n            this.parent = new int[n];\\n            this.size = new int[n];\\n\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int node){\\n            if(parent[node] == node){\\n                return node;\\n            }\\n\\n            return parent[node] = find(parent[node]);\\n        }\\n\\n        public void union(int i, int j){\\n            int representativeI = find(i);\\n            int representativeJ = find(j);\\n\\n            if(representativeI == representativeJ){\\n                return;\\n            }\\n\\n            if(size[representativeI] < size[representativeJ]){\\n                parent[representativeI] = representativeJ;\\n                size[representativeJ] += size[representativeI];\\n            } else {\\n                parent[representativeJ] = representativeI;\\n                size[representativeI] += size[representativeJ];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936321,
                "title": "very-easy-c-solution-with-explanation-dsu-kruskal-s-algo-bridges-in-graph-mst-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*It is a mixed problem of Disjoint Set Union, Bridges in Graph and Minimum Spanning tree using Kruskal\\'s Algorithm. At first time read of the problem you will be able to think it as a MST Problem but it is not sufficient.*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- *To find the critical edges you have first consider the bridges of graph because if we go with finding them with kruskal algo then it will fail so after that we will find the minimum weight of the MST formed using Kruskal\\'s Algorithm.After that if we want to find the critical edges then we have to check if we delete one edge and then form the mst then if the minimum weight increases then it will be absolutely the critical edge.*\\n\\n- *After that if we want to find the pseudo critical edges then we can say that will be all rest edges excluding the edges that does not appear in any mst configuration.To find that edges we have fix one edge in the mst and then calculate the mst weight , if the mst weight increases then it will lie in that category so we have to exclude that edges and rest is fine.*\\n\\n# Complexity\\n- Time complexity: $$O(E^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\n    vector<int> parent,size;\\npublic:\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findP(int i){\\n        if(parent[i]==i){\\n            return i;\\n        }\\n        return parent[i] = findP(parent[i]);\\n    }\\n    bool unionBySize(int u,int v){\\n        int ulp_u = findP(u);\\n        int ulp_v = findP(v);\\n        if(ulp_u == ulp_v)return false;\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(int node,int parent,int timer,vector<int> &discTime,vector<int> &lowTime,\\n    unordered_map<int,list<pair<int,int>>> &adj,unordered_map<int,bool> &vis,vector<int> &result){\\n        vis[node] = 1;\\n        discTime[node] = lowTime[node] = timer++;\\n        for(auto [adjNode,index]:adj[node]){\\n            if(adjNode==parent)continue;\\n            if(vis[adjNode]){\\n                lowTime[node] = min(lowTime[node],discTime[adjNode]);\\n            }\\n            else{\\n                dfs(adjNode,node,timer,discTime,lowTime,adj,vis,result);\\n                lowTime[node] = min(lowTime[node],lowTime[adjNode]);\\n                if(lowTime[adjNode] > discTime[node]){\\n                    result.push_back(index);\\n                }\\n            }\\n        }\\n\\n    }\\n    vector<int> criticalConnections(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,list<pair<int,int>>> adj;\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back({v,i});\\n            adj[v].push_back({u,i});\\n        }\\n        int timer = 0;\\n        vector<int> discTime(n,-1);\\n        vector<int> lowTime(n,-1);\\n        int parent = -1;\\n        unordered_map<int,bool> vis;\\n        vector<int> result;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,parent,timer,discTime,lowTime,adj,vis,result);\\n            }\\n        }\\n        return result;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        vector<int> tm = criticalConnections(n,edges);\\n        unordered_map<int,bool> um;\\n        for(auto &it:tm){\\n            ans[0].push_back(it);\\n            um[it]=1;\\n        }\\n        DisjointSet ds(n);\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<edges.size();i++){\\n            temp.push_back({edges[i][2],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int weight = 0;\\n        for(int i=0;i<temp.size();i++){\\n            if(ds.unionBySize(edges[temp[i].second][0],edges[temp[i].second][1])){\\n                weight += temp[i].first;\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(um[i])continue;\\n            DisjointSet sample(n);\\n            int w = 0;\\n            for(int j=0;j<temp.size();j++){\\n                if(temp[j].second==i)continue;\\n                if(sample.unionBySize(edges[temp[j].second][0],edges[temp[j].second][1])){\\n                    w += temp[j].first;\\n                }\\n            }\\n            if(w>weight){\\n                ans[0].push_back(i);\\n                um[i]=1;\\n            }\\n            else{\\n                DisjointSet sample2(n);\\n                w = edges[i][2];\\n                bool pp = sample2.unionBySize(edges[i][0],edges[i][1]);\\n                for(int j=0;j<temp.size();j++){\\n                    if(sample2.unionBySize(edges[temp[j].second][0],edges[temp[j].second][1])){\\n                        w += temp[j].first;\\n                    }\\n                }\\n                if(w>weight){\\n                    um[i]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(!um[i])ans[1].push_back(i);\\n        }\\n        sort(ans[0].begin(),ans[0].end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting",
                    "Minimum Spanning Tree",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int> parent,size;\\npublic:\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findP(int i){\\n        if(parent[i]==i){\\n            return i;\\n        }\\n        return parent[i] = findP(parent[i]);\\n    }\\n    bool unionBySize(int u,int v){\\n        int ulp_u = findP(u);\\n        int ulp_v = findP(v);\\n        if(ulp_u == ulp_v)return false;\\n        if(size[ulp_u] < size[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void dfs(int node,int parent,int timer,vector<int> &discTime,vector<int> &lowTime,\\n    unordered_map<int,list<pair<int,int>>> &adj,unordered_map<int,bool> &vis,vector<int> &result){\\n        vis[node] = 1;\\n        discTime[node] = lowTime[node] = timer++;\\n        for(auto [adjNode,index]:adj[node]){\\n            if(adjNode==parent)continue;\\n            if(vis[adjNode]){\\n                lowTime[node] = min(lowTime[node],discTime[adjNode]);\\n            }\\n            else{\\n                dfs(adjNode,node,timer,discTime,lowTime,adj,vis,result);\\n                lowTime[node] = min(lowTime[node],lowTime[adjNode]);\\n                if(lowTime[adjNode] > discTime[node]){\\n                    result.push_back(index);\\n                }\\n            }\\n        }\\n\\n    }\\n    vector<int> criticalConnections(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,list<pair<int,int>>> adj;\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back({v,i});\\n            adj[v].push_back({u,i});\\n        }\\n        int timer = 0;\\n        vector<int> discTime(n,-1);\\n        vector<int> lowTime(n,-1);\\n        int parent = -1;\\n        unordered_map<int,bool> vis;\\n        vector<int> result;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,parent,timer,discTime,lowTime,adj,vis,result);\\n            }\\n        }\\n        return result;\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> ans(2);\\n        vector<int> tm = criticalConnections(n,edges);\\n        unordered_map<int,bool> um;\\n        for(auto &it:tm){\\n            ans[0].push_back(it);\\n            um[it]=1;\\n        }\\n        DisjointSet ds(n);\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<edges.size();i++){\\n            temp.push_back({edges[i][2],i});\\n        }\\n        sort(temp.begin(),temp.end());\\n        int weight = 0;\\n        for(int i=0;i<temp.size();i++){\\n            if(ds.unionBySize(edges[temp[i].second][0],edges[temp[i].second][1])){\\n                weight += temp[i].first;\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(um[i])continue;\\n            DisjointSet sample(n);\\n            int w = 0;\\n            for(int j=0;j<temp.size();j++){\\n                if(temp[j].second==i)continue;\\n                if(sample.unionBySize(edges[temp[j].second][0],edges[temp[j].second][1])){\\n                    w += temp[j].first;\\n                }\\n            }\\n            if(w>weight){\\n                ans[0].push_back(i);\\n                um[i]=1;\\n            }\\n            else{\\n                DisjointSet sample2(n);\\n                w = edges[i][2];\\n                bool pp = sample2.unionBySize(edges[i][0],edges[i][1]);\\n                for(int j=0;j<temp.size();j++){\\n                    if(sample2.unionBySize(edges[temp[j].second][0],edges[temp[j].second][1])){\\n                        w += temp[j].first;\\n                    }\\n                }\\n                if(w>weight){\\n                    um[i]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<edges.size();i++){\\n            if(!um[i])ans[1].push_back(i);\\n        }\\n        sort(ans[0].begin(),ans[0].end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936084,
                "title": "near-linear-beats-100-16ms",
                "content": "# Intuition\\nRun Kruskal. On each step consider a subgraph formed by the edges of  the same weight. Ignore the edges of the same connectivity component. Find cycles in this subgraph via DFS. The edges in cycles are pseudo critical, all the other - critical.\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(edges.length * log(edges.length) + alpha(n)). edges.length * log(edges.length) - from sorting, could be made linear by radix sort, alpha - Ackermann function, from UF.\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\nclass Solution {\\n    class UF {\\n        vector<int> Data;\\n    public:\\n        explicit UF(int size)\\n            : Data(size + 1, -1)\\n        {\\n        }\\n        int getRep(int i) {\\n            return Data[i] < 0 ? i : (Data[i] = getRep(Data[i]));\\n        }\\n        void unionNodes(int i, int j) {\\n            if (Data[i] > Data[i]) {\\n                swap(i, j);\\n            }\\n            if (Data[i] == Data[j]) {\\n                --Data[i];\\n            }\\n            Data[j] = i;\\n        }\\n    };\\n    unordered_map<int, vector<pair<int, int>>> Adjacent;\\n    unordered_set<int> Pseudo;\\n    unordered_map<int, pair<int, int>> Prev;\\n    void dfs(int p, int pp, int pe) {\\n        if (Prev.insert({p, {pp, pe}}).second) {\\n            if (const auto it = Adjacent.find(p); it != Adjacent.end()) {\\n                auto next = std::move(it->second);\\n                Adjacent.erase(it);\\n                for (const auto [v, e]: next) {\\n                    if (e != pe) {\\n                        dfs(v, p, e);\\n                    }\\n                }\\n            }\\n            Prev.erase(p);\\n        } else {\\n            Pseudo.insert(pe);\\n            while (pp != p) {\\n                const auto [v, e] = Prev[pp];\\n                Pseudo.insert(e);\\n                pp = v;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pseudoCritical;\\n\\n        // edges with smallest weight are at the beginning\\n        const int eSize = edges.size();\\n        vector<int> sortedEdges(eSize);\\n        iota(begin(sortedEdges), end(sortedEdges), 0);\\n        sort(begin(sortedEdges), end(sortedEdges), [&](int a, int b) {\\n            return edges[a][2] < edges[b][2];\\n        });\\n\\n        UF uf(n);\\n        int count = 0, i = 0;\\n        while (count < n - 1) {\\n            // build the subgraph by the edges of the same weight\\n            Adjacent.clear();\\n            Pseudo.clear();\\n            Prev.clear();\\n            const int start = i;\\n            const auto weight = edges[sortedEdges[start]][2];\\n            for (; i < eSize; ++i) {\\n                const auto edgeIndex = sortedEdges[i];\\n                auto& e = edges[edgeIndex];\\n                if (e[2] > weight) {\\n                    break;\\n                }\\n                const auto v0 = uf.getRep(e[0]);\\n                const auto v1 = uf.getRep(e[1]);\\n                if (v0 != v1) {\\n                    Adjacent[v0].push_back({v1, edgeIndex});\\n                    Adjacent[v1].push_back({v0, edgeIndex});\\n                } else {\\n                    // ignore edges of the same connectivity component\\n                    sortedEdges[i] = -1;\\n                }\\n            }\\n\\n            // find cycles in the subgraph  \\n            while (!Adjacent.empty()) {\\n                dfs(Adjacent.begin()->first, -1, -1);\\n            }\\n\\n            // distribute edges to critical or pseudoCritical\\n            // based on the DFS result,\\n            // merge uf components\\n            for (int j = start; j < i; ++j) {\\n                const auto edgeIndex = sortedEdges[j];\\n                if (edgeIndex < 0) {\\n                    continue;\\n                }\\n                auto& e = edges[edgeIndex];\\n                const auto v0 = uf.getRep(e[0]);\\n                const auto v1 = uf.getRep(e[1]);\\n                if (v0 != v1) {\\n                    uf.unionNodes(v0, v1);\\n                    ++count;\\n                }\\n                if (Pseudo.find(edgeIndex) != Pseudo.end()) {\\n                    pseudoCritical.push_back(edgeIndex);\\n                } else {\\n                    critical.push_back(edgeIndex);\\n                }\\n            }\\n        }\\n        return {std::move(critical), std::move(pseudoCritical)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    class UF {\\n        vector<int> Data;\\n    public:\\n        explicit UF(int size)\\n            : Data(size + 1, -1)\\n        {\\n        }\\n        int getRep(int i) {\\n            return Data[i] < 0 ? i : (Data[i] = getRep(Data[i]));\\n        }\\n        void unionNodes(int i, int j) {\\n            if (Data[i] > Data[i]) {\\n                swap(i, j);\\n            }\\n            if (Data[i] == Data[j]) {\\n                --Data[i];\\n            }\\n            Data[j] = i;\\n        }\\n    };\\n    unordered_map<int, vector<pair<int, int>>> Adjacent;\\n    unordered_set<int> Pseudo;\\n    unordered_map<int, pair<int, int>> Prev;\\n    void dfs(int p, int pp, int pe) {\\n        if (Prev.insert({p, {pp, pe}}).second) {\\n            if (const auto it = Adjacent.find(p); it != Adjacent.end()) {\\n                auto next = std::move(it->second);\\n                Adjacent.erase(it);\\n                for (const auto [v, e]: next) {\\n                    if (e != pe) {\\n                        dfs(v, p, e);\\n                    }\\n                }\\n            }\\n            Prev.erase(p);\\n        } else {\\n            Pseudo.insert(pe);\\n            while (pp != p) {\\n                const auto [v, e] = Prev[pp];\\n                Pseudo.insert(e);\\n                pp = v;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<int> critical, pseudoCritical;\\n\\n        // edges with smallest weight are at the beginning\\n        const int eSize = edges.size();\\n        vector<int> sortedEdges(eSize);\\n        iota(begin(sortedEdges), end(sortedEdges), 0);\\n        sort(begin(sortedEdges), end(sortedEdges), [&](int a, int b) {\\n            return edges[a][2] < edges[b][2];\\n        });\\n\\n        UF uf(n);\\n        int count = 0, i = 0;\\n        while (count < n - 1) {\\n            // build the subgraph by the edges of the same weight\\n            Adjacent.clear();\\n            Pseudo.clear();\\n            Prev.clear();\\n            const int start = i;\\n            const auto weight = edges[sortedEdges[start]][2];\\n            for (; i < eSize; ++i) {\\n                const auto edgeIndex = sortedEdges[i];\\n                auto& e = edges[edgeIndex];\\n                if (e[2] > weight) {\\n                    break;\\n                }\\n                const auto v0 = uf.getRep(e[0]);\\n                const auto v1 = uf.getRep(e[1]);\\n                if (v0 != v1) {\\n                    Adjacent[v0].push_back({v1, edgeIndex});\\n                    Adjacent[v1].push_back({v0, edgeIndex});\\n                } else {\\n                    // ignore edges of the same connectivity component\\n                    sortedEdges[i] = -1;\\n                }\\n            }\\n\\n            // find cycles in the subgraph  \\n            while (!Adjacent.empty()) {\\n                dfs(Adjacent.begin()->first, -1, -1);\\n            }\\n\\n            // distribute edges to critical or pseudoCritical\\n            // based on the DFS result,\\n            // merge uf components\\n            for (int j = start; j < i; ++j) {\\n                const auto edgeIndex = sortedEdges[j];\\n                if (edgeIndex < 0) {\\n                    continue;\\n                }\\n                auto& e = edges[edgeIndex];\\n                const auto v0 = uf.getRep(e[0]);\\n                const auto v1 = uf.getRep(e[1]);\\n                if (v0 != v1) {\\n                    uf.unionNodes(v0, v1);\\n                    ++count;\\n                }\\n                if (Pseudo.find(edgeIndex) != Pseudo.end()) {\\n                    pseudoCritical.push_back(edgeIndex);\\n                } else {\\n                    critical.push_back(edgeIndex);\\n                }\\n            }\\n        }\\n        return {std::move(critical), std::move(pseudoCritical)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935953,
                "title": "krushkal-algo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_parent(int node,vector<int>& parent){\\n    if(parent[node]==node)\\n        return(node);\\n    return(parent[node]=find_parent(parent[node],parent));\\n}\\n    int make_union(vector<int>edgex,vector<int>& parent,vector<int>&sze){\\n        int u,v,w,up1,up2;\\n        //w = edgex.first;\\n        //u = edgex.second.first;\\n        //v = edgex.second.second;\\n        w = edgex[0];\\n        u = edgex[1];\\n        v = edgex[2];\\n        up1 = find_parent(u,parent);\\n        up2 = find_parent(v,parent);\\n        //cout<<up1<<\" \"<<up2<<\" \"<<u<<\" \"<<v<<endl;\\n        if(up1!=up2){\\n            if(sze[up1]>=sze[up2]){\\n                parent[up2] = up1;\\n                sze[up1]+=sze[up2];\\n            }\\n            else{\\n                parent[up1]=up2;\\n                sze[up2]+=sze[up1];\\n            } \\n            //cout<<u<<\" \"<<find_parent(u,parent)<<\" \"<<v<<\" \"<<find_parent(v,parent)<<endl;\\n            return(w);\\n        }\\n        return(0);\\n    }\\n    bool is_mst(int n,vector<int>& parent){\\n        int i ;\\n        int par = find_parent(0,parent);\\n        //cout<<par<<endl;\\n        for(i=1;i<n;i++){\\n            //cout<<i<<\" \"<<find_parent(i,parent)<<endl;\\n            if(find_parent(i,parent)!=par)\\n                return(false);\\n        }\\n        return(true);\\n    }\\n    int mst_weight(int n,int remind,vector<vector<int>>&edges2,vector<int>& parent,vector<int>& sze){\\n        int i;\\n        int c=0;\\n        for(i=0;i<edges2.size();i++){\\n            if(i!=remind){\\n                c+=make_union(edges2[i],parent,sze);\\n            }\\n        }\\n        if(is_mst(n,parent)==true) \\n            return(c);\\n        else\\n            return(-1);\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>edges2;\\n        int i;\\n        for(i=0;i<edges.size();i++){\\n            edges2.push_back({edges[i][2],edges[i][0],edges[i][1],i});\\n        }\\n        sort(edges2.begin(),edges2.end());\\n        vector<int>parent(n,-1);\\n        vector<int>sze(n,1);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        int u,v,w,up1,up2;\\n        int cri=0,pcri=0;\\n        int lastcri=0,lastpcri=0;\\n        int mstw = mst_weight(n,-1,edges2,parent,sze);\\n        vector<int>critical;\\n        vector<int>pcritical;\\n        vector<vector<int>>ans;\\n        //cout<<mstw<<endl;\\n        if(mstw==-1){\\n            ans.push_back(critical);\\n            ans.push_back(pcritical);\\n            return(ans);\\n        }\\n        int new_wt;\\n        for(i=0;i<edges2.size();i++){\\n            for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                sze[j]=1;\\n            }\\n            new_wt = mst_weight(n,i,edges2,parent,sze);\\n            if(new_wt>mstw || new_wt==-1){\\n                critical.push_back(edges2[i][3]);\\n            }\\n            else if(new_wt==mstw){\\n                for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                sze[j]=1;\\n                }\\n                int x = make_union(edges2[i],parent,sze);\\n                new_wt = x+mst_weight(n,i,edges2,parent,sze);\\n                if(new_wt==mstw)\\n                    pcritical.push_back(edges2[i][3]);\\n            }            \\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pcritical);\\n    return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_parent(int node,vector<int>& parent){\\n    if(parent[node]==node)\\n        return(node);\\n    return(parent[node]=find_parent(parent[node],parent));\\n}\\n    int make_union(vector<int>edgex,vector<int>& parent,vector<int>&sze){\\n        int u,v,w,up1,up2;\\n        //w = edgex.first;\\n        //u = edgex.second.first;\\n        //v = edgex.second.second;\\n        w = edgex[0];\\n        u = edgex[1];\\n        v = edgex[2];\\n        up1 = find_parent(u,parent);\\n        up2 = find_parent(v,parent);\\n        //cout<<up1<<\" \"<<up2<<\" \"<<u<<\" \"<<v<<endl;\\n        if(up1!=up2){\\n            if(sze[up1]>=sze[up2]){\\n                parent[up2] = up1;\\n                sze[up1]+=sze[up2];\\n            }\\n            else{\\n                parent[up1]=up2;\\n                sze[up2]+=sze[up1];\\n            } \\n            //cout<<u<<\" \"<<find_parent(u,parent)<<\" \"<<v<<\" \"<<find_parent(v,parent)<<endl;\\n            return(w);\\n        }\\n        return(0);\\n    }\\n    bool is_mst(int n,vector<int>& parent){\\n        int i ;\\n        int par = find_parent(0,parent);\\n        //cout<<par<<endl;\\n        for(i=1;i<n;i++){\\n            //cout<<i<<\" \"<<find_parent(i,parent)<<endl;\\n            if(find_parent(i,parent)!=par)\\n                return(false);\\n        }\\n        return(true);\\n    }\\n    int mst_weight(int n,int remind,vector<vector<int>>&edges2,vector<int>& parent,vector<int>& sze){\\n        int i;\\n        int c=0;\\n        for(i=0;i<edges2.size();i++){\\n            if(i!=remind){\\n                c+=make_union(edges2[i],parent,sze);\\n            }\\n        }\\n        if(is_mst(n,parent)==true) \\n            return(c);\\n        else\\n            return(-1);\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>edges2;\\n        int i;\\n        for(i=0;i<edges.size();i++){\\n            edges2.push_back({edges[i][2],edges[i][0],edges[i][1],i});\\n        }\\n        sort(edges2.begin(),edges2.end());\\n        vector<int>parent(n,-1);\\n        vector<int>sze(n,1);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        int u,v,w,up1,up2;\\n        int cri=0,pcri=0;\\n        int lastcri=0,lastpcri=0;\\n        int mstw = mst_weight(n,-1,edges2,parent,sze);\\n        vector<int>critical;\\n        vector<int>pcritical;\\n        vector<vector<int>>ans;\\n        //cout<<mstw<<endl;\\n        if(mstw==-1){\\n            ans.push_back(critical);\\n            ans.push_back(pcritical);\\n            return(ans);\\n        }\\n        int new_wt;\\n        for(i=0;i<edges2.size();i++){\\n            for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                sze[j]=1;\\n            }\\n            new_wt = mst_weight(n,i,edges2,parent,sze);\\n            if(new_wt>mstw || new_wt==-1){\\n                critical.push_back(edges2[i][3]);\\n            }\\n            else if(new_wt==mstw){\\n                for(int j=0;j<n;j++){\\n                parent[j]=j;\\n                sze[j]=1;\\n                }\\n                int x = make_union(edges2[i],parent,sze);\\n                new_wt = x+mst_weight(n,i,edges2,parent,sze);\\n                if(new_wt==mstw)\\n                    pcritical.push_back(edges2[i][3]);\\n            }            \\n        }\\n        ans.push_back(critical);\\n        ans.push_back(pcritical);\\n    return(ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3935587,
                "title": "java-kruskal",
                "content": "```\\nclass Edge{\\n    int src;\\n    int dest;\\n    int weight;\\n    int index;\\n    public Edge(int src,int dest,int weight,int index){\\n        this.src = src;\\n        this.dest = dest;\\n        this.weight = weight;\\n        this.index = index;\\n    }\\n}\\n\\nclass DisjointSet{\\n    \\n    int parent[];\\n    int rank[];\\n    \\n    public DisjointSet(int size){\\n        parent = new int[size];\\n        rank = new int[size];\\n        for(int i=0;i<size;i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int findParent(int index){\\n        if(index == parent[index])\\n             return index;\\n        \\n        return parent[index]  = findParent(parent[index]);\\n    }\\n    \\n    public void unionByRank(int i, int j){\\n        int ulitmateParentI = findParent(i);\\n        int ulitmateParentJ = findParent(j);\\n        \\n        if(rank[ulitmateParentI] < rank[ulitmateParentJ]){\\n            parent[ulitmateParentI] = ulitmateParentJ;\\n        }\\n        else{\\n            parent[ulitmateParentI] = ulitmateParentJ;\\n           rank[ulitmateParentJ]++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n       \\n        List<List<Integer>> list = new ArrayList<>();\\n        if(edges == null || edges.length == 0)\\n           return list;\\n        \\n        for(int i=0;i<2;i++)\\n             list.add(new ArrayList<>());\\n        \\n        \\n       List<Edge> edgeList = new ArrayList<>();\\n        for(int i=0;i < edges.length;i++){\\n            Edge edge = new Edge(edges[i][0],edges[i][1],edges[i][2],i);\\n            edgeList.add(edge);\\n        }\\n        Collections.sort(edgeList,(e1,e2) -> e1.weight - e2.weight);\\n        int minimumMstWeight = findMst(edgeList,-1,-1,n);\\n        for(int i=0;i<edgeList.size();i++){\\n            if(findMst(edgeList,i,-1,n) > minimumMstWeight){ //critical edge\\n                list.get(0).add(edgeList.get(i).index);\\n            }\\n            else if(findMst(edgeList,-1,i,n) == minimumMstWeight){ // psuedo critical edge\\n                list.get(1).add(edgeList.get(i).index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public int findMst(List<Edge> edge , int skip,int add,int n) // skip for  critical and add is for psuedo edge\\n    {\\n        DisjointSet dsu = new DisjointSet(n);\\n         int mstWeight = 0;\\n         int edgesRequired = 0;\\n        //1.simply find MST\\n        if(add != -1){\\n             dsu.unionByRank(edge.get(add).src,edge.get(add).dest);\\n             edgesRequired++;\\n             mstWeight += edge.get(add).weight;\\n        }\\n       \\n        for(int i=0;i<edge.size();i++){\\n            \\n            if(i == skip)\\n                continue;\\n            \\n            int src = edge.get(i).src;\\n            int dest = edge.get(i).dest;\\n            int weight = edge.get(i).weight;\\n            \\n            int parentSrc = dsu.findParent(src);\\n            int parentDest = dsu.findParent(dest);\\n            \\n            if(parentSrc != parentDest){\\n                mstWeight += weight;\\n                edgesRequired++;\\n                dsu.unionByRank(parentSrc,parentDest);\\n            }  \\n        }\\n        if(edgesRequired != n-1){ //skipping the edge might not form mst , hence that edge was not to be skipped so critical edge\\n            return Integer.MAX_VALUE;\\n        }\\n        return mstWeight;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Edge{\\n    int src;\\n    int dest;\\n    int weight;\\n    int index;\\n    public Edge(int src,int dest,int weight,int index){\\n        this.src = src;\\n        this.dest = dest;\\n        this.weight = weight;\\n        this.index = index;\\n    }\\n}\\n\\nclass DisjointSet{\\n    \\n    int parent[];\\n    int rank[];\\n    \\n    public DisjointSet(int size){\\n        parent = new int[size];\\n        rank = new int[size];\\n        for(int i=0;i<size;i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int findParent(int index){\\n        if(index == parent[index])\\n             return index;\\n        \\n        return parent[index]  = findParent(parent[index]);\\n    }\\n    \\n    public void unionByRank(int i, int j){\\n        int ulitmateParentI = findParent(i);\\n        int ulitmateParentJ = findParent(j);\\n        \\n        if(rank[ulitmateParentI] < rank[ulitmateParentJ]){\\n            parent[ulitmateParentI] = ulitmateParentJ;\\n        }\\n        else{\\n            parent[ulitmateParentI] = ulitmateParentJ;\\n           rank[ulitmateParentJ]++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\\n       \\n        List<List<Integer>> list = new ArrayList<>();\\n        if(edges == null || edges.length == 0)\\n           return list;\\n        \\n        for(int i=0;i<2;i++)\\n             list.add(new ArrayList<>());\\n        \\n        \\n       List<Edge> edgeList = new ArrayList<>();\\n        for(int i=0;i < edges.length;i++){\\n            Edge edge = new Edge(edges[i][0],edges[i][1],edges[i][2],i);\\n            edgeList.add(edge);\\n        }\\n        Collections.sort(edgeList,(e1,e2) -> e1.weight - e2.weight);\\n        int minimumMstWeight = findMst(edgeList,-1,-1,n);\\n        for(int i=0;i<edgeList.size();i++){\\n            if(findMst(edgeList,i,-1,n) > minimumMstWeight){ //critical edge\\n                list.get(0).add(edgeList.get(i).index);\\n            }\\n            else if(findMst(edgeList,-1,i,n) == minimumMstWeight){ // psuedo critical edge\\n                list.get(1).add(edgeList.get(i).index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public int findMst(List<Edge> edge , int skip,int add,int n) // skip for  critical and add is for psuedo edge\\n    {\\n        DisjointSet dsu = new DisjointSet(n);\\n         int mstWeight = 0;\\n         int edgesRequired = 0;\\n        //1.simply find MST\\n        if(add != -1){\\n             dsu.unionByRank(edge.get(add).src,edge.get(add).dest);\\n             edgesRequired++;\\n             mstWeight += edge.get(add).weight;\\n        }\\n       \\n        for(int i=0;i<edge.size();i++){\\n            \\n            if(i == skip)\\n                continue;\\n            \\n            int src = edge.get(i).src;\\n            int dest = edge.get(i).dest;\\n            int weight = edge.get(i).weight;\\n            \\n            int parentSrc = dsu.findParent(src);\\n            int parentDest = dsu.findParent(dest);\\n            \\n            if(parentSrc != parentDest){\\n                mstWeight += weight;\\n                edgesRequired++;\\n                dsu.unionByRank(parentSrc,parentDest);\\n            }  \\n        }\\n        if(edgesRequired != n-1){ //skipping the edge might not form mst , hence that edge was not to be skipped so critical edge\\n            return Integer.MAX_VALUE;\\n        }\\n        return mstWeight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2020020,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020028,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020041,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020084,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020015,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 1749655,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020086,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020004,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020012,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020063,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020020,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020028,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020041,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020084,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020015,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 1749655,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020086,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020004,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020012,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2020063,
                "content": [
                    {
                        "username": "Braderbell",
                        "content": "I understood one word from that description: \"Hard\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "that\\'s what she said"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I got hard reading that"
                    },
                    {
                        "username": "algoacer",
                        "content": "**__When one question is sufficient to help you revisit all concepts of Graphs.__**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "user6567lX",
                        "content": "if someone asks this question during an interview -- they don\\'t want you"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not for interviews but for learning, this is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This is the type of question they know no one can solve so that they can assess your behevior doing an impossible task. \nThey don't really want to fail you, but you know they are mean, disrespectful, and follows outdated brainteaser interview practices, so you know you don't wnat them. Remember in an interview, you are also interviewing the company."
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Not necessarily.  This looks like a textbook Amazon bar-raiser question.  You\\'re not supposed to be able to solve it in time.  "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I usually don\\'t say this but yeah, this question is cool to solve but dumb to ask in an interview"
                    },
                    {
                        "username": "shresthaaa",
                        "content": "Hey I was going to write that.."
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "# Time to touch grass"
                    },
                    {
                        "username": "adityarev",
                        "content": "This kind of problem is that usually break my streak"
                    },
                    {
                        "username": "sanchi03",
                        "content": "same :/"
                    },
                    {
                        "username": "WagdySamih",
                        "content": "12 days strike and will be broke today"
                    },
                    {
                        "username": "yihuic",
                        "content": "Who ask this question in 45min interview???"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is a beautiful problem! Not suited for interviews because of time constraints but it leads to clarity in doing easier problems. Included good Concepts like Kruskal\\'s, Union Find, Including/Excluding edges, Returning original indexes of edges (before sorting)."
                    },
                    {
                        "username": "Overmachine",
                        "content": "they ask this question when the position is filled and you have an interview already scheduled."
                    },
                    {
                        "username": "hail-cali",
                        "content": "I did last year, and I was sitting on the other side :("
                    },
                    {
                        "username": "realones",
                        "content": "just learned how to ruin my weekend "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem is not even understandable for me :) "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "`1 <= edges.length <= min(200, n * (n - 1) / 2)` Look at this closely.\\nIt say that E ( number of edges ) can be at max 200 and we\\'re told that V can be max 100.\\n\\nKruskal\\'s MST with Union Find runs in O( E logV ) ~ O( 200 log 100 ) in worst case, Now you can do brute force for every edge to check if it\\'s critical or not by creating a MST without that edge i.e. O( E * E logV )."
                    },
                    {
                        "username": "Jaiff",
                        "content": "[@Karilli](/Karilli) We are checking the criticality of edges."
                    },
                    {
                        "username": "Karilli",
                        "content": "i havent solved it yet, so i am just speculating, but if you find minimum spanning tree first and check only those vertices for criticality you could do O(V*ElogV), couldnt you?"
                    }
                ]
            },
            {
                "id": 2019996,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2019986,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2019997,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020101,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020186,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020458,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020240,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020243,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020221,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2020431,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Graph Theory Problem for Master's Degree Study. One hint:\nIt's possible to modify the code with some Optimizations by reducing the times of applying Kruskal's algorithm. Both of critical edges and pseudo-critical edges have the following relation with  minimal spanning trees:\n$$\n\\{Critical\\}\\subset \\cap MST, \\{Pseudo Critical \\}\\subset \\cup MST\n$$"
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "DP has successfully handed over to graphs"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "I wish I had enough focus span to read and understand the whole problem...."
                    },
                    {
                        "username": "Aditya_vig",
                        "content": "lmfao same \\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/nd9HpEb\"><img src=\"https://i.imgur.com/nd9HpEb.jpg\" title=\"source: imgur.com\"  width=\"450px\"/></a>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "[@codeMonarch](/codeMonarch) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: baassss, nikal gayi hawa????"
                    },
                    {
                        "username": "dumb_me",
                        "content": "all the points  I can understand  from this questions \\n1.\\n2.\\n3.\\n4.\\n5.\\nthank you \\n\\uD83D\\uDE2D"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "There should be a separate category for this..very Hard."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "It will rain frog with twinkle little stars as its eyes if I can solve this on a real interview."
                    },
                    {
                        "username": "eashan455",
                        "content": "If they ask you this question during an interview, they don\\'t want to hire you "
                    },
                    {
                        "username": "c4tdog",
                        "content": "some tests:\\n4\\n[[0,1,1],[0,3,1],[0,2,1],[1,2,1],[1,3,1],[2,3,1]]\\n6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Thanks a lot"
                    },
                    {
                        "username": "aitachii",
                        "content": "Can someone explain it slowly...\nWhat's a minimum spanning tree and how do you get one? \nDo you need to generate all possible MSTs per testcase?\nHow do you get the weight of an MST? \nWhat does it mean when removing an edge increases the weight? \nHow do you determine if an edge exists in all MSTs? "
                    },
                    {
                        "username": "AndreiZherder",
                        "content": "[@c4tdog](/c4tdog) Many thanks to your tip for finding pseudo edges. \"Add the edge you want to check to Disjoint Set first\" - it is brilliant idea! Thank you."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@c4tdog](/c4tdog) Thank you bro.\n\n\nSeems like Kruskal's algorithm works like this:\n1. Sort the edges by weight.\n2. Iterate through the sorted edges.\n3. If edges[0] and edges[1] are not already connected(indirectly or directly), connect them using a Disjoint Set, then add the weight to the total weight.\n4. The total weight should be the MST weight.\n\nThen getting the critical weight and pseudo-critical weight requires some modifications to the original algorithm."
                    },
                    {
                        "username": "c4tdog",
                        "content": "- to find a MST use Kruskal algorithm\n- no need to generate all of them\n- to get weight sum all the edges of MST\n- to find critical edges: ignore the edge and try to find MST again w/o it: if found MST has lower or higher weight then it is a critical edge\n- to find pseudo edges: add the edge you want to check to Disjoint Set first, then try to find MST: if found MST has the same weight as initial one - it is the pseudo edge."
                    },
                    {
                        "username": "aitachii",
                        "content": "Also, there's only 5 minimum spanning tree problems....\nhttps://leetcode.com/tag/minimum-spanning-tree/"
                    }
                ]
            },
            {
                "id": 2021324,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020847,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020369,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020355,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020172,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020154,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020096,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2021569,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020730,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020625,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "If LeetCode wanted to ruin Saturday, he succeeded :)))"
                    },
                    {
                        "username": "s3stan",
                        "content": "[@MrBeverage](/MrBeverage) That\\'s for sure. And I thought about it myself. We\\'ll see tomorrow ;)))"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "If this is a Saturday question, we can only dread tomorrow."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Cool problem. I really liked it\\nAccepted rate surprised me a bit, this problem is very hard and can\\'t have such good AR, imo"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "A great problem. The way of checking each edge if its critical or pseudo-critical was not easy for me to think of"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/CBhUdhC\"><img src=\"https://i.imgur.com/CBhUdhC.jpg\" title=\"source: imgur.com\" width=\"340px\" /></a>"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "these kinda problems only compelled you to cheat"
                    },
                    {
                        "username": "psionl0",
                        "content": "Only if you want to keep your streak running. You will probably have to do some research to answer the question but that isn\\'t necessarily cheating."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Light weight, baby! (no)"
                    },
                    {
                        "username": "ronlek",
                        "content": "Needs applying Kruskal number of edges times and if it\\'s not critical then apply Kruskal again for number of edges times. Crazy!"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now I can die un-peacefully \\uD83D\\uDC80. "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Best use case of this problem is to **Revise** all concept related to the **Graph**.\nThanks LeetCode !"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "I sincerely tried to come up with some sort of algorithm to solve that, but then decided to look at a hint\n\nI guess, now I know what Kruskal's algorithm is :idk:\n(I've never heard of it. It was never mentioned by anyone I talked to. Problems that rely on <b>some sort of random algorithm you can't solve it without</b> are irritating.)\n\n<h5>Also it's a greedy algorithm. I hate greedy, as I alias it with \"well, I tried and it worked. Have no idea why\"</h5>"
                    }
                ]
            },
            {
                "id": 2020623,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2020388,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2020248,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2020127,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 1922192,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2075575,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2038018,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2022250,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2021547,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2021514,
                "content": [
                    {
                        "username": "JianZheSu",
                        "content": "<i>An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.</i>\\n\\n<b>And if we can\\'t find MST without an edge, it also a critical edge.</b>\\n\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "mtfk, never heard something like Kruskal b4 hell nah"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Seeing this question, now I will enjoy my weekend"
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge.\\n\\nWTH is this? MST weight to increase? Can someone explain?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sandeep_pasula](/sandeep_pasula) if removing an edge breaks the graph then the edge is a critical one. The weight is inconsequential in that case. I have my ``mstWeight()`` function return INT_MAX if the graph is broken."
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Hey thanks, what if deletion results in disconnected graph, deletion of critical node resulting in 2 disconnected sub graphs, in that case there is no other MST scenario. Is increase in weight still valid?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The MST weight is the sum of the weights of all the edges contained in the MST. If an edge is deleted from the MST then the MST will have to be made from other edges in the graph. If the sum of those weights exceeds the original weight then the edge you deleted was a critical one."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "There can be more than 1 MST for a given graph and all of them will be of equal weight W. Let those MST be in a set called MST_SET.\\nIt\\'s possible that an Edge E1 can be part of some or all of those MST\\'s.\\n\\nThe statement that OP posted means if you remove an edge E1 and recompute MST of the remaining Graph, and observe the weight of MST then the new MST weight can:\\n\\n1. Be Equal to W\\nWhich means that there exists a MST in MST_SET which doesn\\'t contain edge E1.\\n2. Be more than W\\nWhich means that all MSTs in MST_SET contain edge E1 so when you remove that edge, the graph will now choose a different edge to form MST which wasn\\'t there before in any of the MST\\'s from MST_SET.\\n3. Be less than W.\\nNot Possible otherwise you computed the wrong MST at the beginning because it\\'s the min possible weight so you cannot go below min, right?"
                    },
                    {
                        "username": "__Shinigami__",
                        "content": "should bridges include in critical or pseudo-critical edges or in none"
                    },
                    {
                        "username": "devilsblast",
                        "content": "Can someone explain me how this comes under strongly connected components? Please!!"
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "6\\n[[0,1,1],[1,2,1],[0,2,1],[2,3,4],[3,4,2],[3,5,2],[4,5,2]]\\n\\nIn this case 3 is considered as a critical edges i.e on its removal the weight of the MST must increase but actually on its removal the weight is increased."
                    },
                    {
                        "username": "Zefick",
                        "content": "Everyone mention Kruslal's algorithm but nobody remember the Prim's algorithm. As for me it looks easier."
                    },
                    {
                        "username": "Husoski",
                        "content": "It depends on what you\\'ve done before, I guess.  Kruskal\\'s algorithm is so much like building a Huffman code tree that (to me) it feels like an old friend.  I\\'m still struggling with how to use *any* algorithm to build a single MST to somehow find *all* MSTs.\\n\\n"
                    },
                    {
                        "username": "aye-aye34",
                        "content": "how could we make sure if an edge was used once in a MST as removing that would give same ans?"
                    },
                    {
                        "username": "Zxun2",
                        "content": "You can \"force\" the MST to use the edge by initializing the MST with that edge. When you encounter the same edge later on, you can simply skip it"
                    },
                    {
                        "username": "adityaparab",
                        "content": "When you realize you should revise your graph notes."
                    }
                ]
            },
            {
                "id": 2021480,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2021341,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2021308,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2021181,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2021117,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020849,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020812,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020761,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020756,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020744,
                "content": [
                    {
                        "username": "roman-mc",
                        "content": "When an interviewer didn\\'t like you and gave this challenge "
                    },
                    {
                        "username": "czjnbb",
                        "content": "After seeing the hint, it is pretty straightforward."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not able to find out what is wrong in this implementation. Can someone please help?\\n\\n```\\n// start\\nclass Solution {\\npublic:\\n\\n    struct Edge {\\n        int ind;\\n        int s;\\n        int e;\\n        int w;\\n    };\\n\\n    int parent[105];\\n\\n    int find(int x) {\\n        if (x == parent[x]) return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    void unionn(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        if (a == b) return;\\n        if (a < b) {\\n            parent[b] = a;\\n        } else {\\n            parent[a] = b;\\n        }\\n    }\\n\\n    static bool cop(Edge& a, Edge& b) {\\n        return a.w < b.w;\\n    }\\n\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n,\\n        vector<vector<int>>& edges) {\\n        \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n\\n        vector<Edge> v;\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            Edge x;\\n            x.ind = i;\\n            x.s = edges[i][0];\\n            x.e = edges[i][1];\\n            x.w = edges[i][2];\\n            v.push_back(x);\\n        }\\n\\n        sort(v.begin(), v.end(), cop);\\n\\n        int wt = 0;\\n// find initial mst weight\\n        for (int i = 0; i < edges.size(); i++) {\\n            int x = v[i].s;\\n            int y = v[i].e;\\n            x = find(x);\\n            y = find(y);\\n            if (x == y) continue;\\n            unionn(x, y);\\n            wt += v[i].w;\\n        }\\n\\n        unordered_set<int> crit;\\n\\n        \\n// check for critical\\n        for (int i = 0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) {\\n                continue;\\n            }\\n\\n            int curw = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                parent[k] = k;\\n            }\\n\\n            for (int j = 0; j < v.size(); j++) {\\n                if (j == i) continue;\\n                int x = find(v[j].s);\\n                int y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    crit.insert(v[i].ind);\\n                    break;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            bool app = true;\\n\\n            for (int k = 0; k < n; k++) {\\n                if (parent[k] != 0) {\\n                    app = false;\\n                    break;\\n                }\\n            }\\n\\n            if (!app) {\\n                crit.insert(v[i].ind);\\n            }\\n           \\n        }\\n\\n\\n// check for pseudo-critical\\n        unordered_set<int> pscrit;\\n        \\n        for (int i =0; i < v.size(); i++) {\\n            if (crit.find(v[i].ind) != crit.end()) continue;\\n            if (pscrit.find(v[i].ind) != pscrit.end()) continue;\\n\\n            for (int j = 0; j < n; j++) {\\n                parent[j] = j;\\n            }\\n\\n            bool app = true;\\n\\n            int curw = 0;\\n\\n            int x = find(v[i].s);\\n            int y = find(v[i].e);\\n\\n            unionn(x, y);\\n            curw += v[i].w;\\n\\n            if (curw > wt) {\\n                app = false;\\n            }\\n\\n            for (int j =0; j < v.size(); j++) {\\n                if (!app) break;\\n                if (j == i) continue;\\n                x = find(v[j].s);\\n                y = find(v[j].e);\\n                if (x == y) continue;\\n                curw += v[j].w;\\n                if (curw > wt) {\\n                    app = false;\\n                }\\n                unionn(x, y);\\n            }\\n\\n            if (app) {\\n                pscrit.insert(v[i].ind);\\n            }\\n        }\\n\\n        vector<vector<int>> ans(2);\\n\\n        for (auto& it : crit) {\\n            ans[0].push_back(it);\\n        }\\n\\n        for (auto& it: pscrit) {\\n            ans[1].push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "archerfx",
                        "content": "found it guys I was checking `parent[k] != 0`, instead i needed to use `find(k) != 0`"
                    },
                    {
                        "username": "anusha00000",
                        "content": "Leetcode want to play games with us "
                    },
                    {
                        "username": "ProtoDot",
                        "content": "so this is how my streak dies"
                    },
                    {
                        "username": "sameer89",
                        "content": "We at leetcode are always striving to bring you the hardest and the most unsolvable questions for interviewers to copy and ruin your interview. In this sequence we present you the new category of problems \"Impossible\". Please stay tuned for more such problems \\uD83D\\uDE07. Hope you have a lovely weekend."
                    },
                    {
                        "username": "rdex99",
                        "content": "Question: Can an edge be neither critical nor pseudo-critical? From what I understand, the answer is no. An edge has to be either of the two unless, of course, I am too far into the weeds."
                    },
                    {
                        "username": "rdex99",
                        "content": "[@c4tdog](/c4tdog) Ah (needed coffee early morning). An edge may not be in _any_ spanning tree at all. Makes \"yes\" as the obvious answer. Many thanks."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Yes, it can. See example #1"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "haonan"
                    },
                    {
                        "username": "aniketmukherjee001",
                        "content": "This seems like a Catastrophe class question"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Question seemed so hard but look at the accepted rate, ohmygod!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Doing Ctrl + C -> Ctrl + V without trying at first leads to high acceptance rate."
                    }
                ]
            },
            {
                "id": 2020698,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020628,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020613,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020606,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020572,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020557,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020540,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020510,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020504,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020500,
                "content": [
                    {
                        "username": "Leaderboard",
                        "content": "How do you get the intuition for finding pseudo-critical edges? The hint says this:\\n\\n> To find if one edge is non-critical (in any MST), include that edge to the accepted edge list and continue the MST algorithm, then see if the resulting MST has the same weight of the initial MST of the entire graph.\\n\\nHow does that work though? Do I create the MST and then add edges? But then that doesn\\'t make sense.\\n\\nMy difficulty is that it *looks* as if I need to find all MSTs first..."
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "You don\\'t need to find ALL MST\\'s, you need to determine if the edge lies in all MST\\'s or at least in one of them (but not in all)\\nBtw, in my solution the check if the edge is pseudo-critical, a little bit different from that hint. You can decrease the weight of checked edge and run finding MST, if the new value is less than MST weight for original graph then this edge is pseudo-critical (if it\\'s not a critical in the first case)."
                    },
                    {
                        "username": "c4tdog",
                        "content": "Add an edge you want to check to disjoint set first. After that try to find an mst. If the weight is the same as initial mst this is a pseudo"
                    },
                    {
                        "username": "looser8271",
                        "content": "Aisa question tab he aata hai jab interviewer ko lagta hai bete ye position tere liye ni hai (:"
                    },
                    {
                        "username": "julkar9",
                        "content": "Graph question exists\\nDSU: \"Now this looks like a job for me\""
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "I cheated \\uD83D\\uDE11"
                    },
                    {
                        "username": "prototye",
                        "content": "That\\'s what she said bro \\n"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nThis is the first test case and how is this even possible, I mean if I have n=5 and we have edges 0,1,2,3,4 then in my ans how can I have 5 as an edge.\\nHow can my output have 6 distinct edges if my graph only has 5 edges.\\nbruhhhhhhhhh!!!!!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "[@psionl0](/psionl0) Thank you, I misread the question."
                    },
                    {
                        "username": "psionl0",
                        "content": "n = 5 NODES - not edges. You are returning lists of edges."
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "lightweight baby"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "class DSU{\\n    public:\\n    vector<int>parent,size;\\n    DSU(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    int findpar(int node){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void UnionSize(int u,int v){\\n        int x=findpar(u);\\n        int y=findpar(v);\\n        if(x==y) return;\\n        if(size[x]>=size[y]){\\n            size[x]+=size[y];\\n            parent[y]=x;\\n        }\\n        else{\\n            size[y]+=size[x];\\n            parent[x]=y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        return b[2]>a[2];\\n    }\\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\\n        for(int i=0;i<edges.size();i++){\\n            edges[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),comp);\\n        DSU ds(n);\\n        int sum=0,ct=0;\\n        vector<bool>visi(n,false);\\n        for(int i=0;i<edges.size();i++){\\n            if(ct==n-1) break;\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            int wt=edges[i][2];\\n            int ind=edges[i][3];\\n            if(ds.findpar(a)!=ds.findpar(b)){\\n                sum+=wt;\\n                ds.UnionSize(a,b);\\n                ct++;\\n                visi[ind]=true;\\n            }\\n        }\\n        vector<int>cri,psu;\\n        vector<vector<int>>v;\\n        for(int i=0;i<edges.size();i++){\\n            int cost=0;\\n            DSU xd(n);\\n            int ct=0;\\n            vector<bool>temp(edges.size(),0);\\n            for(int j=0;j<edges.size();j++){\\n                if(ct==n-1) break;\\n                if(i!=j){\\n                    int a=edges[j][0];\\n                    int b=edges[j][1];\\n                    int wt=edges[j][2];\\n                    int ind=edges[j][3];\\n                    if(xd.findpar(a)!=xd.findpar(b)){\\n                        cost+=wt;\\n                        xd.UnionSize(a,b);\\n                        temp[ind]=true;\\n                        ct++;\\n                    }\\n                }\\n            }\\n            if(cost>sum){\\n                cri.push_back(edges[i][3]);\\n            }\\n            else if(cost==sum){\\n                psu.push_back(edges[i][3]);\\n            }\\n        }\\n        v.push_back(cri);\\n        v.push_back(psu);\\n        return v;\\n    }\\n};\\n\\ncan anyone debug this code....i am getting wrong ans"
                    },
                    {
                        "username": "aalmos",
                        "content": "It\\'s not necessarily a bad problem to practice, but why would anyone ask this on a real interview?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Interviewer : We can\\'t say direct no, but yes this question will do that task for us."
                    },
                    {
                        "username": "psionl0",
                        "content": "When you sort the edges list, the index position of each edge changes. However, the answer must be based on the <i>original</i> index positions of the edges. (That oversight doubled the time it took me to solve this problem)."
                    }
                ]
            },
            {
                "id": 2020475,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020445,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020436,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020430,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020396,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020393,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020377,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020353,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020352,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            },
            {
                "id": 2020310,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\\nOutput: [[0,1],[2,3,4,5]]\\n\\nWhere the 5 in output is coming from?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "5th edge - one of MSTs has it"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "\"What are you doing on your weekend?\"\\nMe asf:"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Looks like my streak is gonna break today. :)"
                    },
                    {
                        "username": "leetcancode",
                        "content": "[@codeMonarch](/codeMonarch)  ooh my bad, thanks brother! "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "streak**"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "I have seen the problem, now i am going, ta ta bye bye."
                    },
                    {
                        "username": "minokazman",
                        "content": "Rip my 18 day streak :/"
                    },
                    {
                        "username": "So_mnm",
                        "content": "[ Streak Gone! ]"
                    },
                    {
                        "username": "reassurance",
                        "content": "ig this is where i break my streak "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "why example 1 of Edge 6 no in pseudo edge list? "
                    },
                    {
                        "username": "PanJianTing",
                        "content": "[@c4tdog](/c4tdog) thanks!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "b/c there is no MST which contains that edge"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "No. Thank You.\\nI\\'ll pass."
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "yeah,im not even trying to open editorial on this one"
                    }
                ]
            }
        ]
    }
]